htColor, selectForeground,
        disabledForeground, insertBackground, troughColor."""
        self.tk.call(('tk_setPalette',)
              + _flatten(args) + _flatten(kw.items()))
    def tk_menuBar(self, *args):
        """Do not use. Needed in Tk 3.6 and earlier."""
        # obsolete since Tk 4.0
        import warnings
        warnings.warn('tk_menuBar() does nothing and will be removed in 3.6',
                      DeprecationWarning, stacklevel=2)
    def wait_variable(self, name='PY_VAR'):
        """Wait until the variable is modified.

        A parameter of type IntVar, StringVar, DoubleVar or
        BooleanVar must be given."""
        self.tk.call('tkwait', 'variable', name)
    waitvar = wait_variable # XXX b/w compat
    def wait_window(self, window=None):
        """Wait until a WIDGET is destroyed.

        If no parameter is given self is used."""
        if window is None:
            window = self
        self.tk.call('tkwait', 'window', window._w)
    def wait_visibility(self, window=None):
        """Wait until the visibility of a WIDGET changes
        (e.g. it appears).

        If no parameter is given self is used."""
        if window is None:
            window = self
        self.tk.call('tkwait', 'visibility', window._w)
    def setvar(self, name='PY_VAR', value='1'):
        """Set Tcl variable NAME to VALUE."""
        self.tk.setvar(name, value)
    def getvar(self, name='PY_VAR'):
        """Return value of Tcl variable NAME."""
        return self.tk.getvar(name)
    getint = int
    getdouble = float
    def getboolean(self, s):
        """Return a boolean value for Tcl boolean values true and false given as parameter."""
        return self.tk.getboolean(s)
    def focus_set(self):
        """Direct input focus to this widget.

        If the application currently does not have the focus
        this widget will get the focus if the application gets
        the focus through the window manager."""
        self.tk.call('focus', self._w)
    focus = focus_set # XXX b/w compat?
    def focus_force(self):
        """Direct input focus to this widget even if the
        application does not have the focus. Use with
        caution!"""
        self.tk.call('focus', '-force', self._w)
    def focus_get(self):
        """Return the widget which has currently the focus in the
        application.

        Use focus_displayof to allow working with several
        displays. Return None if application does not have
        the focus."""
        name = self.tk.call('focus')
        if name == 'none' or not name: return None
        return self._nametowidget(name)
    def focus_displayof(self):
        """Return the widget which has currently the focus on the
        display where this widget is located.

        Return None if the application does not have the focus."""
        name = self.tk.call('focus', '-displayof', self._w)
        if name == 'none' or not name: return None
        return self._nametowidget(name)
    def focus_lastfor(self):
        """Return the widget which would have the focus if top level
        for this widget gets the focus from the window manager."""
        name = self.tk.call('focus', '-lastfor', self._w)
        if name == 'none' or not name: return None
        return self._nametowidget(name)
    def tk_focusFollowsMouse(self):
        """The widget under mouse will get automatically focus. Can not
        be disabled easily."""
        self.tk.call('tk_focusFollowsMouse')
    def tk_focusNext(self):
        """Return the next widget in the focus order which follows
        widget which has currently the focus.

        The focus order first goes to the next child, then to
        the children of the child recursively and then to the
        next sibling which is higher in the stacking order.  A
        widget is omitted if it has the takefocus resource set
        to 0."""
        name = self.tk.call('tk_focusNext', self._w)
        if not name: return None
        return self._nametowidget(name)
    def tk_focusPrev(self):
        """Return previous widget in the focus order. See tk_focusNext for details."""
        name = self.tk.call('tk_focusPrev', self._w)
        if not name: return None
        return self._nametowidget(name)
    def after(self, ms, func=None, *args):
        """Call function once after given time.

        MS specifies the time in milliseconds. FUNC gives the
        function which shall be called. Additional parameters
        are given as parameters to the function call.  Return
        identifier to cancel scheduling with after_cancel."""
        if not func:
            # I'd rather use time.sleep(ms*0.001)
            self.tk.call('after', ms)
        else:
            def callit():
                try:
                    func(*args)
                finally:
                    try:
                        self.deletecommand(name)
                    except TclError:
                        pass
            callit.__name__ = func.__name__
            name = self._register(callit)
            return self.tk.call('after', ms, name)
    def after_idle(self, func, *args):
        """Call FUNC once if the Tcl main loop has no event to
        process.

        Return an identifier to cancel the scheduling with
        after_cancel."""
        return self.after('idle', func, *args)
    def after_cancel(self, id):
        """Cancel scheduling of function identified with ID.

        Identifier returned by after or after_idle must be
        given as first parameter."""
        try:
            data = self.tk.call('after', 'info', id)
            # In Tk 8.3, splitlist returns: (script, type)
            # In Tk 8.4, splitlist may return (script, type) or (script,)
            script = self.tk.splitlist(data)[0]
            self.deletecommand(script)
        except TclError:
            pass
        self.tk.call('after', 'cancel', id)
    def bell(self, displayof=0):
        """Ring a display's bell."""
        self.tk.call(('bell',) + self._displayof(displayof))

    # Clipboard handling:
    def clipboard_get(self, **kw):
        """Retrieve data from the clipboard on window's display.

        The window keyword defaults to the root window of the Tkinter
        application.

        The type keyword specifies the form in which the data is
        to be returned and should be an atom name such as STRING
        or FILE_NAME.  Type defaults to STRING, except on X11, where the default
        is to try UTF8_STRING and fall back to STRING.

        This command is equivalent to:

        selection_get(CLIPBOARD)
        """
        if 'type' not in kw and self._windowingsystem == 'x11':
            try:
                kw['type'] = 'UTF8_STRING'
                return self.tk.call(('clipboard', 'get') + self._options(kw))
            except TclError:
                del kw['type']
        return self.tk.call(('clipboard', 'get') + self._options(kw))

    def clipboard_clear(self, **kw):
        """Clear the data in the Tk clipboard.

        A widget specified for the optional displayof keyword
        argument specifies the target display."""
        if 'displayof' not in kw: kw['displayof'] = self._w
        self.tk.call(('clipboard', 'clear') + self._options(kw))
    def clipboard_append(self, string, **kw):
        """Append STRING to the Tk clipboard.

        A widget specified at the optional displayof keyword
        argument specifies the target display. The clipboard
        can be retrieved with selection_get."""
        if 'displayof' not in kw: kw['displayof'] = self._w
        self.tk.call(('clipboard', 'append') + self._options(kw)
              + ('--', string))
    # XXX grab current w/o window argument
    def grab_current(self):
        """Return widget which has currently the grab in this application
        or None."""
        name = self.tk.call('grab', 'current', self._w)
        if not name: return None
        return self._nametowidget(name)
    def grab_release(self):
        """Release grab for this widget if currently set."""
        self.tk.call('grab', 'release', self._w)
    def grab_set(self):
        """Set grab for this widget.

        A grab directs all events to this and descendant
        widgets in the application."""
        self.tk.call('grab', 'set', self._w)
    def grab_set_global(self):
        """Set global grab for this widget.

        A global grab directs all events to this and
        descendant widgets on the display. Use with caution -
        other applications do not get events anymore."""
        self.tk.call('grab', 'set', '-global', self._w)
    def grab_status(self):
        """Return None, "local" or "global" if this widget has
        no, a local or a global grab."""
        status = self.tk.call('grab', 'status', self._w)
        if status == 'none': status = None
        return status
    def option_add(self, pattern, value, priority = None):
        """Set a VALUE (second parameter) for an option
        PATTERN (first parameter).

        An optional third parameter gives the numeric priority
        (defaults to 80)."""
        self.tk.call('option', 'add', pattern, value, priority)
    def option_clear(self):
        """Clear the option database.

        It will be reloaded if option_add is called."""
        self.tk.call('option', 'clear')
    def option_get(self, name, className):
        """Return the value for an option NAME for this widget
        with CLASSNAME.

        Values with higher priority override lower values."""
        return self.tk.call('option', 'get', self._w, name, className)
    def option_readfile(self, fileName, priority = None):
        """Read file FILENAME into the option database.

        An optional second parameter gives the numeric
        priority."""
        self.tk.call('option', 'readfile', fileName, priority)
    def selection_clear(self, **kw):
        """Clear the current X selection."""
        if 'displayof' not in kw: kw['displayof'] = self._w
        self.tk.call(('selection', 'clear') + self._options(kw))
    def selection_get(self, **kw):
        """Return the contents of the current X selection.

        A keyword parameter selection specifies the name of
        the selection and defaults to PRIMARY.  A keyword
        parameter displayof specifies a widget on the display
        to use. A keyword parameter type specifies the form of data to be
        fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
        before STRING."""
        if 'displayof' not in kw: kw['displayof'] = self._w
        if 'type' not in kw and self._windowingsystem == 'x11':
            try:
                kw['type'] = 'UTF8_STRING'
                return self.tk.call(('selection', 'get') + self._options(kw))
            except TclError:
                del kw['type']
        return self.tk.call(('selection', 'get') + self._options(kw))
    def selection_handle(self, command, **kw):
        """Specify a function COMMAND to call if the X
        selection owned by this widget is queried by another
        application.

        This function must return the contents of the
        selection. The function will be called with the
        arguments OFFSET and LENGTH which allows the chunking
        of very long selections. The following keyword
        parameters can be provided:
        selection - name of the selection (default PRIMARY),
        type - type of the selection (e.g. STRING, FILE_NAME)."""
        name = self._register(command)
        self.tk.call(('selection', 'handle') + self._options(kw)
              + (self._w, name))
    def selection_own(self, **kw):
        """Become owner of X selection.

        A keyword parameter selection specifies the name of
        the selection (default PRIMARY)."""
        self.tk.call(('selection', 'own') +
                 self._options(kw) + (self._w,))
    def selection_own_get(self, **kw):
        """Return owner of X selection.

        The following keyword parameter can
        be provided:
        selection - name of the selection (default PRIMARY),
        type - type of the selection (e.g. STRING, FILE_NAME)."""
        if 'displayof' not in kw: kw['displayof'] = self._w
        name = self.tk.call(('selection', 'own') + self._options(kw))
        if not name: return None
        return self._nametowidget(name)
    def send(self, interp, cmd, *args):
        """Send Tcl command CMD to different interpreter INTERP to be executed."""
        return self.tk.call(('send', interp, cmd) + args)
    def lower(self, belowThis=None):
        """Lower this widget in the stacking order."""
        self.tk.call('lower', self._w, belowThis)
    def tkraise(self, aboveThis=None):
        """Raise this widget in the stacking order."""
        self.tk.call('raise', self._w, aboveThis)
    lift = tkraise
    def colormodel(self, value=None):
        """Useless. Not implemented in Tk."""
        return self.tk.call('tk', 'colormodel', self._w, value)
    def winfo_atom(self, name, displayof=0):
        """Return integer which represents atom NAME."""
        args = ('winfo', 'atom') + self._displayof(displayof) + (name,)
        return getint(self.tk.call(args))
    def winfo_atomname(self, id, displayof=0):
        """Return name of atom with identifier ID."""
        args = ('winfo', 'atomname') \
               + self._displayof(displayof) + (id,)
        return self.tk.call(args)
    def winfo_cells(self):
        """Return number of cells in the colormap for this widget."""
        return getint(
            self.tk.call('winfo', 'cells', self._w))
    def winfo_children(self):
        """Return a list of all widgets which are children of this widget."""
        result = []
        for child in self.tk.splitlist(
            self.tk.call('winfo', 'children', self._w)):
            try:
                # Tcl sometimes returns extra windows, e.g. for
                # menus; those need to be skipped
                result.append(self._nametowidget(child))
            except KeyError:
                pass
        return result

    def winfo_class(self):
        """Return window class name of this widget."""
        return self.tk.call('winfo', 'class', self._w)
    def winfo_colormapfull(self):
        """Return true if at the last color request the colormap was full."""
        return self.tk.getboolean(
            self.tk.call('winfo', 'colormapfull', self._w))
    def winfo_containing(self, rootX, rootY, displayof=0):
        """Return the widget which is at the root coordinates ROOTX, ROOTY."""
        args = ('winfo', 'containing') \
               + self._displayof(displayof) + (rootX, rootY)
        name = self.tk.call(args)
        if not name: return None
        return self._nametowidget(name)
    def winfo_depth(self):
        """Return the number of bits per pixel."""
        return getint(self.tk.call('winfo', 'depth', self._w))
    def winfo_exists(self):
        """Return true if this widget exists."""
        return getint(
            self.tk.call('winfo', 'exists', self._w))
    def winfo_fpixels(self, number):
        """Return the number of pixels for the given distance NUMBER
        (e.g. "3c") as float."""
        return getdouble(self.tk.call(
            'winfo', 'fpixels', self._w, number))
    def winfo_geometry(self):
        """Return geometry string for this widget in the form "widthxheight+X+Y"."""
        return self.tk.call('winfo', 'geometry', self._w)
    def winfo_height(self):
        """Return height of this widget."""
        return getint(
            self.tk.call('winfo', 'height', self._w))
    def winfo_id(self):
        """Return identifier ID for this widget."""
        return self.tk.getint(
            self.tk.call('winfo', 'id', self._w))
    def winfo_interps(self, displayof=0):
        """Return the name of all Tcl interpreters for this display."""
        args = ('winfo', 'interps') + self._displayof(displayof)
        return self.tk.splitlist(self.tk.call(args))
    def winfo_ismapped(self):
        """Return true if this widget is mapped."""
        return getint(
            self.tk.call('winfo', 'ismapped', self._w))
    def winfo_manager(self):
        """Return the window mananger name for this widget."""
        return self.tk.call('winfo', 'manager', self._w)
    def winfo_name(self):
        """Return the name of this widget."""
        return self.tk.call('winfo', 'name', self._w)
    def winfo_parent(self):
        """Return the name of the parent of this widget."""
        return self.tk.call('winfo', 'parent', self._w)
    def winfo_pathname(self, id, displayof=0):
        """Return the pathname of the widget given by ID."""
        args = ('winfo', 'pathname') \
               + self._displayof(displayof) + (id,)
        return self.tk.call(args)
    def winfo_pixels(self, number):
        """Rounded integer value of winfo_fpixels."""
        return getint(
            self.tk.call('winfo', 'pixels', self._w, number))
    def winfo_pointerx(self):
        """Return the x coordinate of the pointer on the root window."""
        return getint(
            self.tk.call('winfo', 'pointerx', self._w))
    def winfo_pointerxy(self):
        """Return a tuple of x and y coordinates of the pointer on the root window."""
        return self._getints(
            self.tk.call('winfo', 'pointerxy', self._w))
    def winfo_pointery(self):
        """Return the y coordinate of the pointer on the root window."""
        return getint(
            self.tk.call('winfo', 'pointery', self._w))
    def winfo_reqheight(self):
        """Return requested height of this widget."""
        return getint(
            self.tk.call('winfo', 'reqheight', self._w))
    def winfo_reqwidth(self):
        """Return requested width of this widget."""
        return getint(
            self.tk.call('winfo', 'reqwidth', self._w))
    def winfo_rgb(self, color):
        """Return tuple of decimal values for red, green, blue for
        COLOR in this widget."""
        return self._getints(
            self.tk.call('winfo', 'rgb', self._w, color))
    def winfo_rootx(self):
        """Return x coordinate of upper left corner of this widget on the
        root window."""
        return getint(
            self.tk.call('winfo', 'rootx', self._w))
    def winfo_rooty(self):
        """Return y coordinate of upper left corner of this widget on the
        root window."""
        return getint(
            self.tk.call('winfo', 'rooty', self._w))
    def winfo_screen(self):
        """Return the screen name of this widget."""
        return self.tk.call('winfo', 'screen', self._w)
    def winfo_screencells(self):
        """Return the number of the cells in the colormap of the screen
        of this widget."""
        return getint(
            self.tk.call('winfo', 'screencells', self._w))
    def winfo_screendepth(self):
        """Return the number of bits per pixel of the root window of the
        screen of this widget."""
        return getint(
            self.tk.call('winfo', 'screendepth', self._w))
    def winfo_screenheight(self):
        """Return the number of pixels of the height of the screen of this widget
        in pixel."""
        return getint(
            self.tk.call('winfo', 'screenheight', self._w))
    def winfo_screenmmheight(self):
        """Return the number of pixels of the height of the screen of
        this widget in mm."""
        return getint(
            self.tk.call('winfo', 'screenmmheight', self._w))
    def winfo_screenmmwidth(self):
        """Return the number of pixels of the width of the screen of
        this widget in mm."""
        return getint(
            self.tk.call('winfo', 'screenmmwidth', self._w))
    def winfo_screenvisual(self):
        """Return one of the strings directcolor, grayscale, pseudocolor,
        staticcolor, staticgray, or truecolor for the default
        colormodel of this screen."""
        return self.tk.call('winfo', 'screenvisual', self._w)
    def winfo_screenwidth(self):
        """Return the number of pixels of the width of the screen of
        this widget in pixel."""
        return getint(
            self.tk.call('winfo', 'screenwidth', self._w))
    def winfo_server(self):
        """Return information of the X-Server of the screen of this widget in
        the form "XmajorRminor vendor vendorVersion"."""
        return self.tk.call('winfo', 'server', self._w)
    def winfo_toplevel(self):
        """Return the toplevel widget of this widget."""
        return self._nametowidget(self.tk.call(
            'winfo', 'toplevel', self._w))
    def winfo_viewable(self):
        """Return true if the widget and all its higher ancestors are mapped."""
        return getint(
            self.tk.call('winfo', 'viewable', self._w))
    def winfo_visual(self):
        """Return one of the strings directcolor, grayscale, pseudocolor,
        staticcolor, staticgray, or truecolor for the
        colormodel of this widget."""
        return self.tk.call('winfo', 'visual', self._w)
    def winfo_visualid(self):
        """Return the X identifier for the visual for this widget."""
        return self.tk.call('winfo', 'visualid', self._w)
    def winfo_visualsavailable(self, includeids=0):
        """Return a list of all visuals available for the screen
        of this widget.

        Each item in the list consists of a visual name (see winfo_visual), a
        depth and if INCLUDEIDS=1 is given also the X identifier."""
        data = self.tk.split(
            self.tk.call('winfo', 'visualsavailable', self._w,
                     includeids and 'includeids' or None))
        if type(data) is StringType:
            data = [self.tk.split(data)]
        return map(self.__winfo_parseitem, data)
    def __winfo_parseitem(self, t):
        """Internal function."""
        return t[:1] + tuple(map(self.__winfo_getint, t[1:]))
    def __winfo_getint(self, x):
        """Internal function."""
        return int(x, 0)
    def winfo_vrootheight(self):
        """Return the height of the virtual root window associated with this
        widget in pixels. If there is no virtual root window return the
        height of the screen."""
        return getint(
            self.tk.call('winfo', 'vrootheight', self._w))
    def winfo_vrootwidth(self):
        """Return the width of the virtual root window associated with this
        widget in pixel. If there is no virtual root window return the
        width of the screen."""
        return getint(
            self.tk.call('winfo', 'vrootwidth', self._w))
    def winfo_vrootx(self):
        """Return the x offset of the virtual root relative to the root
        window of the screen of this widget."""
        return getint(
            self.tk.call('winfo', 'vrootx', self._w))
    def winfo_vrooty(self):
        """Return the y offset of the virtual root relative to the root
        window of the screen of this widget."""
        return getint(
            self.tk.call('winfo', 'vrooty', self._w))
    def winfo_width(self):
        """Return the width of this widget."""
        return getint(
            self.tk.call('winfo', 'width', self._w))
    def winfo_x(self):
        """Return the x coordinate of the upper left corner of this widget
        in the parent."""
        return getint(
            self.tk.call('winfo', 'x', self._w))
    def winfo_y(self):
        """Return the y coordinate of the upper left corner of this widget
        in the parent."""
        return getint(
            self.tk.call('winfo', 'y', self._w))
    def update(self):
        """Enter event loop until all pending events have been processed by Tcl."""
        self.tk.call('update')
    def update_idletasks(self):
        """Enter event loop until all idle callbacks have been called. This
        will update the display of windows but not process events caused by
        the user."""
        self.tk.call('update', 'idletasks')
    def bindtags(self, tagList=None):
        """Set or get the list of bindtags for this widget.

        With no argument return the list of all bindtags associated with
        this widget. With a list of strings as argument the bindtags are
        set to this list. The bindtags determine in which order events are
        processed (see bind)."""
        if tagList is None:
            return self.tk.splitlist(
                self.tk.call('bindtags', self._w))
        else:
            self.tk.call('bindtags', self._w, tagList)
    def _bind(self, what, sequence, func, add, needcleanup=1):
        """Internal function."""
        if type(func) is StringType:
            self.tk.call(what + (sequence, func))
        elif func:
            funcid = self._register(func, self._substitute,
                        needcleanup)
            cmd = ('%sif {"[%s %s]" == "break"} break\n'
                   %
                   (add and '+' or '',
                funcid, self._subst_format_str))
            self.tk.call(what + (sequence, cmd))
            return funcid
        elif sequence:
            return self.tk.call(what + (sequence,))
        else:
            return self.tk.splitlist(self.tk.call(what))
    def bind(self, sequence=None, func=None, add=None):
        """Bind to this widget at event SEQUENCE a call to function FUNC.

        SEQUENCE is a string of concatenated event
        patterns. An event pattern is of the form
        <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
        of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
        Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
        B3, Alt, Button4, B4, Double, Button5, B5 Triple,
        Mod1, M1. TYPE is one of Activate, Enter, Map,
        ButtonPress, Button, Expose, Motion, ButtonRelease
        FocusIn, MouseWheel, Circulate, FocusOut, Property,
        Colormap, Gravity Reparent, Configure, KeyPress, Key,
        Unmap, Deactivate, KeyRelease Visibility, Destroy,
        Leave and DETAIL is the button number for ButtonPress,
        ButtonRelease and DETAIL is the Keysym for KeyPress and
        KeyRelease. Examples are
        <Control-Button-1> for pressing Control and mouse button 1 or
        <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
        An event pattern can also be a virtual event of the form
        <<AString>> where AString can be arbitrary. This
        event can be generated by event_generate.
        If events are concatenated they must appear shortly
        after each other.

        FUNC will be called if the event sequence occurs with an
        instance of Event as argument. If the return value of FUNC is
        "break" no further bound function is invoked.

        An additional boolean parameter ADD specifies whether FUNC will
        be called additionally to the other bound function or whether
        it will replace the previous function.

        Bind will return an identifier to allow deletion of the bound function with
        unbind without memory leak.

        If FUNC or SEQUENCE is omitted the bound function or list
        of bound events are returned."""

        return self._bind(('bind', self._w), sequence, func, add)
    def unbind(self, sequence, funcid=None):
        """Unbind for this widget for event SEQUENCE  the
        function identified with FUNCID."""
        self.tk.call('bind', self._w, sequence, '')
        if funcid:
            self.deletecommand(funcid)
    def bind_all(self, sequence=None, func=None, add=None):
        """Bind to all widgets at an event SEQUENCE a call to function FUNC.
        An additional boolean parameter ADD specifies whether FUNC will
        be called additionally to the other bound function or whether
        it will replace the previous function. See bind for the return value."""
        return self._bind(('bind', 'all'), sequence, func, add, 0)
    def unbind_all(self, sequence):
        """Unbind for all widgets for event SEQUENCE all functions."""
        self.tk.call('bind', 'all' , sequence, '')
    def bind_class(self, className, sequence=None, func=None, add=None):

        """Bind to widgets with bindtag CLASSNAME at event
        SEQUENCE a call of function FUNC. An additional
        boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or
        whether it will replace the previous function. See bind for
        the return value."""

        return self._bind(('bind', className), sequence, func, add, 0)
    def unbind_class(self, className, sequence):
        """Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
        all functions."""
        self.tk.call('bind', className , sequence, '')
    def mainloop(self, n=0):
        """Call the mainloop of Tk."""
        self.tk.mainloop(n)
    def quit(self):
        """Quit the Tcl interpreter. All widgets will be destroyed."""
        self.tk.quit()
    def _getints(self, string):
        """Internal function."""
        if string:
            return tuple(map(getint, self.tk.splitlist(string)))
    def _getdoubles(self, string):
        """Internal function."""
        if string:
            return tuple(map(getdouble, self.tk.splitlist(string)))
    def _getboolean(self, string):
        """Internal function."""
        if string:
            return self.tk.getboolean(string)
    def _displayof(self, displayof):
        """Internal function."""
        if displayof:
            return ('-displayof', displayof)
        if displayof is None:
            return ('-displayof', self._w)
        return ()
    @property
    def _windowingsystem(self):
        """Internal function."""
        try:
            return self._root()._windowingsystem_cached
        except AttributeError:
            ws = self._root()._windowingsystem_cached = \
                        self.tk.call('tk', 'windowingsystem')
            return ws
    def _options(self, cnf, kw = None):
        """Internal function."""
        if kw:
            cnf = _cnfmerge((cnf, kw))
        else:
            cnf = _cnfmerge(cnf)
        res = ()
        for k, v in cnf.items():
            if v is not None:
                if k[-1] == '_': k = k[:-1]
                if hasattr(v, '__call__'):
                    v = self._register(v)
                elif isinstance(v, (tuple, list)):
                    nv = []
                    for item in v:
                        if not isinstance(item, (basestring, int)):
                            break
                        elif isinstance(item, int):
                            nv.append('%d' % item)
                        else:
                            # format it to proper Tcl code if it contains space
                            nv.append(_stringify(item))
                    else:
                        v = ' '.join(nv)
                res = res + ('-'+k, v)
        return res
    def nametowidget(self, name):
        """Return the Tkinter instance of a widget identified by
        its Tcl name NAME."""
        name = str(name).split('.')
        w = self

        if not name[0]:
            w = w._root()
            name = name[1:]

        for n in name:
            if not n:
                break
            w = w.children[n]

        return w
    _nametowidget = nametowidget
    def _register(self, func, subst=None, needcleanup=1):
        """Return a newly created Tcl function. If this
        function is called, the Python function FUNC will
        be executed. An optional function SUBST can
        be given which will be executed before FUNC."""
        f = CallWrapper(func, subst, self).__call__
        name = repr(id(f))
        try:
            func = func.im_func
        except AttributeError:
            pass
        try:
            name = name + func.__name__
        except AttributeError:
            pass
        self.tk.createcommand(name, f)
        if needcleanup:
            if self._tclCommands is None:
                self._tclCommands = []
            self._tclCommands.append(name)
        return name
    register = _register
    def _root(self):
        """Internal function."""
        w = self
        while w.master: w = w.master
        return w
    _subst_format = ('%#', '%b', '%f', '%h', '%k',
             '%s', '%t', '%w', '%x', '%y',
             '%A', '%E', '%K', '%N', '%W', '%T', '%X', '%Y', '%D')
    _subst_format_str = " ".join(_subst_format)
    def _substitute(self, *args):
        """Internal function."""
        if len(args) != len(self._subst_format): return args
        getboolean = self.tk.getboolean

        getint = int
        def getint_event(s):
            """Tk changed behavior in 8.4.2, returning "??" rather more often."""
            try:
                return int(s)
            except ValueError:
                return s

        nsign, b, f, h, k, s, t, w, x, y, A, E, K, N, W, T, X, Y, D = args
        # Missing: (a, c, d, m, o, v, B, R)
        e = Event()
        # serial field: valid for all events
        # number of button: ButtonPress and ButtonRelease events only
        # height field: Configure, ConfigureRequest, Create,
        # ResizeRequest, and Expose events only
        # keycode field: KeyPress and KeyRelease events only
        # time field: "valid for events that contain a time field"
        # width field: Configure, ConfigureRequest, Create, ResizeRequest,
        # and Expose events only
        # x field: "valid for events that contain an x field"
        # y field: "valid for events that contain a y field"
        # keysym as decimal: KeyPress and KeyRelease events only
        # x_root, y_root fields: ButtonPress, ButtonRelease, KeyPress,
        # KeyRelease, and Motion events
        e.serial = getint(nsign)
        e.num = getint_event(b)
        try: e.focus = getboolean(f)
        except TclError: pass
        e.height = getint_event(h)
        e.keycode = getint_event(k)
        e.state = getint_event(s)
        e.time = getint_event(t)
        e.width = getint_event(w)
        e.x = getint_event(x)
        e.y = getint_event(y)
        e.char = A
        try: e.send_event = getboolean(E)
        except TclError: pass
        e.keysym = K
        e.keysym_num = getint_event(N)
        e.type = T
        try:
            e.widget = self._nametowidget(W)
        except KeyError:
            e.widget = W
        e.x_root = getint_event(X)
        e.y_root = getint_event(Y)
        try:
            e.delta = getint(D)
        except ValueError:
            e.delta = 0
        return (e,)
    def _report_exception(self):
        """Internal function."""
        import sys
        exc, val, tb = sys.exc_type, sys.exc_value, sys.exc_traceback
        root = self._root()
        root.report_callback_exception(exc, val, tb)

    def _getconfigure(self, *args):
        """Call Tcl configure command and return the result as a dict."""
        cnf = {}
        for x in self.tk.splitlist(self.tk.call(*args)):
            x = self.tk.splitlist(x)
            cnf[x[0][1:]] = (x[0][1:],) + x[1:]
        return cnf

    def _getconfigure1(self, *args):
        x = self.tk.splitlist(self.tk.call(*args))
        return (x[0][1:],) + x[1:]

    def _configure(self, cmd, cnf, kw):
        """Internal function."""
        if kw:
            cnf = _cnfmerge((cnf, kw))
        elif cnf:
            cnf = _cnfmerge(cnf)
        if cnf is None:
            return self._getconfigure(_flatten((self._w, cmd)))
        if type(cnf) is StringType:
            return self._getconfigure1(_flatten((self._w, cmd, '-'+cnf)))
        self.tk.call(_flatten((self._w, cmd)) + self._options(cnf))
    # These used to be defined in Widget:
    def configure(self, cnf=None, **kw):
        """Configure resources of a widget.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method keys.
        """
        return self._configure('configure', cnf, kw)
    config = configure
    def cget(self, key):
        """Return the resource value for a KEY given as string."""
        return self.tk.call(self._w, 'cget', '-' + key)
    __getitem__ = cget
    def __setitem__(self, key, value):
        self.configure({key: value})
    def __contains__(self, key):
        raise TypeError("Tkinter objects don't support 'in' tests.")
    def keys(self):
        """Return a list of all resource names of this widget."""
        splitlist = self.tk.splitlist
        return [splitlist(x)[0][1:] for x in
                splitlist(self.tk.call(self._w, 'configure'))]
    def __str__(self):
        """Return the window path name of this widget."""
        return self._w
    # Pack methods that apply to the master
    _noarg_ = ['_noarg_']
    def pack_propagate(self, flag=_noarg_):
        """Set or get the status for propagation of geometry information.

        A boolean argument specifies whether the geometry information
        of the slaves will determine the size of this widget. If no argument
        is given the current setting will be returned.
        """
        if flag is Misc._noarg_:
            return self._getboolean(self.tk.call(
                'pack', 'propagate', self._w))
        else:
            self.tk.call('pack', 'propagate', self._w, flag)
    propagate = pack_propagate
    def pack_slaves(self):
        """Return a list of all slaves of this widget
        in its packing order."""
        return map(self._nametowidget,
               self.tk.splitlist(
                   self.tk.call('pack', 'slaves', self._w)))
    slaves = pack_slaves
    # Place method that applies to the master
    def place_slaves(self):
        """Return a list of all slaves of this widget
        in its packing order."""
        return map(self._nametowidget,
               self.tk.splitlist(
                   self.tk.call(
                       'place', 'slaves', self._w)))
    # Grid methods that apply to the master
    def grid_bbox(self, column=None, row=None, col2=None, row2=None):
        """Return a tuple of integer coordinates for the bounding
        box of this widget controlled by the geometry manager grid.

        If COLUMN, ROW is given the bounding box applies from
        the cell with row and column 0 to the specified
        cell. If COL2 and ROW2 are given the bounding box
        starts at that cell.

        The returned integers specify the offset of the upper left
        corner in the master widget and the width and height.
        """
        args = ('grid', 'bbox', self._w)
        if column is not None and row is not None:
            args = args + (column, row)
        if col2 is not None and row2 is not None:
            args = args + (col2, row2)
        return self._getints(self.tk.call(*args)) or None

    bbox = grid_bbox

    def _gridconvvalue(self, value):
        if isinstance(value, (str, _tkinter.Tcl_Obj)):
            try:
                svalue = str(value)
                if not svalue:
                    return None
                elif '.' in svalue:
                    return getdouble(svalue)
                else:
                    return getint(svalue)
            except ValueError:
                pass
        return value

    def _grid_configure(self, command, index, cnf, kw):
        """Internal function."""
        if type(cnf) is StringType and not kw:
            if cnf[-1:] == '_':
                cnf = cnf[:-1]
            if cnf[:1] != '-':
                cnf = '-'+cnf
            options = (cnf,)
        else:
            options = self._options(cnf, kw)
        if not options:
            return _splitdict(
                self.tk,
                self.tk.call('grid', command, self._w, index),
                conv=self._gridconvvalue)
        res = self.tk.call(
                  ('grid', command, self._w, index)
                  + options)
        if len(options) == 1:
            return self._gridconvvalue(res)

    def grid_columnconfigure(self, index, cnf={}, **kw):
        """Configure column INDEX of a grid.

        Valid resources are minsize (minimum size of the column),
        weight (how much does additional space propagate to this column)
        and pad (how much space to let additionally)."""
        return self._grid_configure('columnconfigure', index, cnf, kw)
    columnconfigure = grid_columnconfigure
    def grid_location(self, x, y):
        """Return a tuple of column and row which identify the cell
        at which the pixel at position X and Y inside the master
        widget is located."""
        return self._getints(
            self.tk.call(
                'grid', 'location', self._w, x, y)) or None
    def grid_propagate(self, flag=_noarg_):
        """Set or get the status for propagation of geometry information.

        A boolean argument specifies whether the geometry information
        of the slaves will determine the size of this widget. If no argument
        is given, the current setting will be returned.
        """
        if flag is Misc._noarg_:
            return self._getboolean(self.tk.call(
                'grid', 'propagate', self._w))
        else:
            self.tk.call('grid', 'propagate', self._w, flag)
    def grid_rowconfigure(self, index, cnf={}, **kw):
        """Configure row INDEX of a grid.

        Valid resources are minsize (minimum size of the row),
        weight (how much does additional space propagate to this row)
        and pad (how much space to let additionally)."""
        return self._grid_configure('rowconfigure', index, cnf, kw)
    rowconfigure = grid_rowconfigure
    def grid_size(self):
        """Return a tuple of the number of column and rows in the grid."""
        return self._getints(
            self.tk.call('grid', 'size', self._w)) or None
    size = grid_size
    def grid_slaves(self, row=None, column=None):
        """Return a list of all slaves of this widget
        in its packing order."""
        args = ()
        if row is not None:
            args = args + ('-row', row)
        if column is not None:
            args = args + ('-column', column)
        return map(self._nametowidget,
               self.tk.splitlist(self.tk.call(
                   ('grid', 'slaves', self._w) + args)))

    # Support for the "event" command, new in Tk 4.2.
    # By Case Roole.

    def event_add(self, virtual, *sequences):
        """Bind a virtual event VIRTUAL (of the form <<Name>>)
        to an event SEQUENCE such that the virtual event is triggered
        whenever SEQUENCE occurs."""
        args = ('event', 'add', virtual) + sequences
        self.tk.call(args)

    def event_delete(self, virtual, *sequences):
        """Unbind a virtual event VIRTUAL from SEQUENCE."""
        args = ('event', 'delete', virtual) + sequences
        self.tk.call(args)

    def event_generate(self, sequence, **kw):
        """Generate an event SEQUENCE. Additional
        keyword arguments specify parameter of the event
        (e.g. x, y, rootx, rooty)."""
        args = ('event', 'generate', self._w, sequence)
        for k, v in kw.items():
            args = args + ('-%s' % k, str(v))
        self.tk.call(args)

    def event_info(self, virtual=None):
        """Return a list of all virtual events or the information
        about the SEQUENCE bound to the virtual event VIRTUAL."""
        return self.tk.splitlist(
            self.tk.call('event', 'info', virtual))

    # Image related commands

    def image_names(self):
        """Return a list of all existing image names."""
        return self.tk.splitlist(self.tk.call('image', 'names'))

    def image_types(self):
        """Return a list of all available image types (e.g. phote bitmap)."""
        return self.tk.splitlist(self.tk.call('image', 'types'))


class CallWrapper:
    """Internal class. Stores function to call when some user
    defined Tcl function is called e.g. after an event occurred."""
    def __init__(self, func, subst, widget):
        """Store FUNC, SUBST and WIDGET as members."""
        self.func = func
        self.subst = subst
        self.widget = widget
    def __call__(self, *args):
        """Apply first function SUBST to arguments, than FUNC."""
        try:
            if self.subst:
                args = self.subst(*args)
            return self.func(*args)
        except SystemExit, msg:
            raise SystemExit, msg
        except:
            self.widget._report_exception()


class XView:
    """Mix-in class for querying and changing the horizontal position
    of a widget's window."""

    def xview(self, *args):
        """Query and change the horizontal position of the view."""
        res = self.tk.call(self._w, 'xview', *args)
        if not args:
            return self._getdoubles(res)

    def xview_moveto(self, fraction):
        """Adjusts the view in the window so that FRACTION of the
        total width of the canvas is off-screen to the left."""
        self.tk.call(self._w, 'xview', 'moveto', fraction)

    def xview_scroll(self, number, what):
        """Shift the x-view according to NUMBER which is measured in "units"
        or "pages" (WHAT)."""
        self.tk.call(self._w, 'xview', 'scroll', number, what)


class YView:
    """Mix-in class for querying and changing the vertical position
    of a widget's window."""

    def yview(self, *args):
        """Query and change the vertical position of the view."""
        res = self.tk.call(self._w, 'yview', *args)
        if not args:
            return self._getdoubles(res)

    def yview_moveto(self, fraction):
        """Adjusts the view in the window so that FRACTION of the
        total height of the canvas is off-screen to the top."""
        self.tk.call(self._w, 'yview', 'moveto', fraction)

    def yview_scroll(self, number, what):
        """Shift the y-view according to NUMBER which is measured in
        "units" or "pages" (WHAT)."""
        self.tk.call(self._w, 'yview', 'scroll', number, what)


class Wm:
    """Provides functions for the communication with the window manager."""

    def wm_aspect(self,
              minNumer=None, minDenom=None,
              maxNumer=None, maxDenom=None):
        """Instruct the window manager to set the aspect ratio (width/height)
        of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
        of the actual values if no argument is given."""
        return self._getints(
            self.tk.call('wm', 'aspect', self._w,
                     minNumer, minDenom,
                     maxNumer, maxDenom))
    aspect = wm_aspect

    def wm_attributes(self, *args):
        """This subcommand returns or sets platform specific attributes

        The first form returns a list of the platform specific flags and
        their values. The second form returns the value for the specific
        option. The third form sets one or more of the values. The values
        are as follows:

        On Windows, -disabled gets or sets whether the window is in a
        disabled state. -toolwindow gets or sets the style of the window
        to toolwindow (as defined in the MSDN). -topmost gets or sets
        whether this is a topmost window (displays above all other
        windows).

        On Macintosh, XXXXX

        On Unix, there are currently no special attribute values.
        """
        args = ('wm', 'attributes', self._w) + args
        return self.tk.call(args)
    attributes=wm_attributes

    def wm_client(self, name=None):
        """Store NAME in WM_CLIENT_MACHINE property of this widget. Return
        current value."""
        return self.tk.call('wm', 'client', self._w, name)
    client = wm_client
    def wm_colormapwindows(self, *wlist):
        """Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
        of this widget. This list contains windows whose colormaps differ from their
        parents. Return current list of widgets if WLIST is empty."""
        if len(wlist) > 1:
            wlist = (wlist,) # Tk needs a list of windows here
        args = ('wm', 'colormapwindows', self._w) + wlist
        if wlist:
            self.tk.call(args)
        else:
            return map(self._nametowidget, self.tk.splitlist(self.tk.call(args)))
    colormapwindows = wm_colormapwindows
    def wm_command(self, value=None):
        """Store VALUE in WM_COMMAND property. It is the command
        which shall be used to invoke the application. Return current
        command if VALUE is None."""
        return self.tk.call('wm', 'command', self._w, value)
    command = wm_command
    def wm_deiconify(self):
        """Deiconify this widget. If it was never mapped it will not be mapped.
        On Windows it will raise this widget and give it the focus."""
        return self.tk.call('wm', 'deiconify', self._w)
    deiconify = wm_deiconify
    def wm_focusmodel(self, model=None):
        """Set focus model to MODEL. "active" means that this widget will claim
        the focus itself, "passive" means that the window manager shall give
        the focus. Return current focus model if MODEL is None."""
        return self.tk.call('wm', 'focusmodel', self._w, model)
    focusmodel = wm_focusmodel
    def wm_frame(self):
        """Return identifier for decorative frame of this widget if present."""
        return self.tk.call('wm', 'frame', self._w)
    frame = wm_frame
    def wm_geometry(self, newGeometry=None):
        """Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
        current value if None is given."""
        return self.tk.call('wm', 'geometry', self._w, newGeometry)
    geometry = wm_geometry
    def wm_grid(self,
         baseWidth=None, baseHeight=None,
         widthInc=None, heightInc=None):
        """Instruct the window manager that this widget shall only be
        resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
        height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
        number of grid units requested in Tk_GeometryRequest."""
        return self._getints(self.tk.call(
            'wm', 'grid', self._w,
            baseWidth, baseHeight, widthInc, heightInc))
    grid = wm_grid
    def wm_group(self, pathName=None):
        """Set the group leader widgets for related widgets to PATHNAME. Return
        the group leader of this widget if None is given."""
        return self.tk.call('wm', 'group', self._w, pathName)
    group = wm_group
    def wm_iconbitmap(self, bitmap=None, default=None):
        """Set bitmap for the iconified widget to BITMAP. Return
        the bitmap if None is given.

        Under Windows, the DEFAULT parameter can be used to set the icon
        for the widget and any descendents that don't have an icon set
        explicitly.  DEFAULT can be the relative path to a .ico file
        (example: root.iconbitmap(default='myicon.ico') ).  See Tk
        documentation for more information."""
        if default:
            return self.tk.call('wm', 'iconbitmap', self._w, '-default', default)
        else:
            return self.tk.call('wm', 'iconbitmap', self._w, bitmap)
    iconbitmap = wm_iconbitmap
    def wm_iconify(self):
        """Display widget as icon."""
        return self.tk.call('wm', 'iconify', self._w)
    iconify = wm_iconify
    def wm_iconmask(self, bitmap=None):
        """Set mask for the icon bitmap of this widget. Return the
        mask if None is given."""
        return self.tk.call('wm', 'iconmask', self._w, bitmap)
    iconmask = wm_iconmask
    def wm_iconname(self, newName=None):
        """Set the name of the icon for this widget. Return the name if
        None is given."""
        return self.tk.call('wm', 'iconname', self._w, newName)
    iconname = wm_iconname
    def wm_iconposition(self, x=None, y=None):
        """Set the position of the icon of this widget to X and Y. Return
        a tuple of the current values of X and X if None is given."""
        return self._getints(self.tk.call(
            'wm', 'iconposition', self._w, x, y))
    iconposition = wm_iconposition
    def wm_iconwindow(self, pathName=None):
        """Set widget PATHNAME to be displayed instead of icon. Return the current
        value if None is given."""
        return self.tk.call('wm', 'iconwindow', self._w, pathName)
    iconwindow = wm_iconwindow
    def wm_maxsize(self, width=None, height=None):
        """Set max WIDTH and HEIGHT for this widget. If the window is gridded
        the values are given in grid units. Return the current values if None
        is given."""
        return self._getints(self.tk.call(
            'wm', 'maxsize', self._w, width, height))
    maxsize = wm_maxsize
    def wm_minsize(self, width=None, height=None):
        """Set min WIDTH and HEIGHT for this widget. If the window is gridded
        the values are given in grid units. Return the current values if None
        is given."""
        return self._getints(self.tk.call(
            'wm', 'minsize', self._w, width, height))
    minsize = wm_minsize
    def wm_overrideredirect(self, boolean=None):
        """Instruct the window manager to ignore this widget
        if BOOLEAN is given with 1. Return the current value if None
        is given."""
        return self._getboolean(self.tk.call(
            'wm', 'overrideredirect', self._w, boolean))
    overrideredirect = wm_overrideredirect
    def wm_positionfrom(self, who=None):
        """Instruct the window manager that the position of this widget shall
        be defined by the user if WHO is "user", and by its own policy if WHO is
        "program"."""
        return self.tk.call('wm', 'positionfrom', self._w, who)
    positionfrom = wm_positionfrom
    def wm_protocol(self, name=None, func=None):
        """Bind function FUNC to command NAME for this widget.
        Return the function bound to NAME if None is given. NAME could be
        e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
        if hasattr(func, '__call__'):
            command = self._register(func)
        else:
            command = func
        return self.tk.call(
            'wm', 'protocol', self._w, name, command)
    protocol = wm_protocol
    def wm_resizable(self, width=None, height=None):
        """Instruct the window manager whether this width can be resized
        in WIDTH or HEIGHT. Both values are boolean values."""
        return self.tk.call('wm', 'resizable', self._w, width, height)
    resizable = wm_resizable
    def wm_sizefrom(self, who=None):
        """Instruct the window manager that the size of this widget shall
        be defined by the user if WHO is "user", and by its own policy if WHO is
        "program"."""
        return self.tk.call('wm', 'sizefrom', self._w, who)
    sizefrom = wm_sizefrom
    def wm_state(self, newstate=None):
        """Query or set the state of this widget as one of normal, icon,
        iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
        return self.tk.call('wm', 'state', self._w, newstate)
    state = wm_state
    def wm_title(self, string=None):
        """Set the title of this widget."""
        return self.tk.call('wm', 'title', self._w, string)
    title = wm_title
    def wm_transient(self, master=None):
        """Instruct the window manager that this widget is transient
        with regard to widget MASTER."""
        return self.tk.call('wm', 'transient', self._w, master)
    transient = wm_transient
    def wm_withdraw(self):
        """Withdraw this widget from the screen such that it is unmapped
        and forgotten by the window manager. Re-draw it with wm_deiconify."""
        return self.tk.call('wm', 'withdraw', self._w)
    withdraw = wm_withdraw


class Tk(Misc, Wm):
    """Toplevel widget of Tk which represents mostly the main window
    of an application. It has an associated Tcl interpreter."""
    _w = '.'
    def __init__(self, screenName=None, baseName=None, className='Tk',
                 useTk=1, sync=0, use=None):
        """Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will
        be created. BASENAME will be used for the identification of the profile file (see
        readprofile).
        It is constructed from sys.argv[0] without extensions if None is given. CLASSNAME
        is the name of the widget class."""
        self.master = None
        self.children = {}
        self._tkloaded = 0
        # to avoid recursions in the getattr code in case of failure, we
        # ensure that self.tk is always _something_.
        self.tk = None
        if baseName is None:
            import os
            baseName = os.path.basename(sys.argv[0])
            baseName, ext = os.path.splitext(baseName)
            if ext not in ('.py', '.pyc', '.pyo'):
                baseName = baseName + ext
        interactive = 0
        self.tk = _tkinter.create(screenName, baseName, className, interactive, wantobjects, useTk, sync, use)
        if useTk:
            self._loadtk()
        if not sys.flags.ignore_environment:
            # Issue #16248: Honor the -E flag to avoid code injection.
            self.readprofile(baseName, className)
    def loadtk(self):
        if not self._tkloaded:
            self.tk.loadtk()
            self._loadtk()
    def _loadtk(self):
        self._tkloaded = 1
        global _default_root
        # Version sanity checks
        tk_version = self.tk.getvar('tk_version')
        if tk_version != _tkinter.TK_VERSION:
            raise RuntimeError, \
            "tk.h version (%s) doesn't match libtk.a version (%s)" \
            % (_tkinter.TK_VERSION, tk_version)
        # Under unknown circumstances, tcl_version gets coerced to float
        tcl_version = str(self.tk.getvar('tcl_version'))
        if tcl_version != _tkinter.TCL_VERSION:
            raise RuntimeError, \
            "tcl.h version (%s) doesn't match libtcl.a version (%s)" \
            % (_tkinter.TCL_VERSION, tcl_version)
        if TkVersion < 4.0:
            raise RuntimeError, \
            "Tk 4.0 or higher is required; found Tk %s" \
            % str(TkVersion)
        # Create and register the tkerror and exit commands
        # We need to inline parts of _register here, _ register
        # would register differently-named commands.
        if self._tclCommands is None:
            self._tclCommands = []
        self.tk.createcommand('tkerror', _tkerror)
        self.tk.createcommand('exit', _exit)
        self._tclCommands.append('tkerror')
        self._tclCommands.append('exit')
        if _support_default_root and not _default_root:
            _default_root = self
        self.protocol("WM_DELETE_WINDOW", self.destroy)
    def destroy(self):
        """Destroy this and all descendants widgets. This will
        end the application of this Tcl interpreter."""
        for c in self.children.values(): c.destroy()
        self.tk.call('destroy', self._w)
        Misc.destroy(self)
        global _default_root
        if _support_default_root and _default_root is self:
            _default_root = None
    def readprofile(self, baseName, className):
        """Internal function. It reads BASENAME.tcl and CLASSNAME.tcl into
        the Tcl Interpreter and calls execfile on BASENAME.py and CLASSNAME.py if
        such a file exists in the home directory."""
        import os
        if 'HOME' in os.environ: home = os.environ['HOME']
        else: home = os.curdir
        class_tcl = os.path.join(home, '.%s.tcl' % className)
        class_py = os.path.join(home, '.%s.py' % className)
        base_tcl = os.path.join(home, '.%s.tcl' % baseName)
        base_py = os.path.join(home, '.%s.py' % baseName)
        dir = {'self': self}
        exec 'from Tkinter import *' in dir
        if os.path.isfile(class_tcl):
            self.tk.call('source', class_tcl)
        if os.path.isfile(class_py):
            execfile(class_py, dir)
        if os.path.isfile(base_tcl):
            self.tk.call('source', base_tcl)
        if os.path.isfile(base_py):
            execfile(base_py, dir)
    def report_callback_exception(self, exc, val, tb):
        """Report callback exception on sys.stderr.

        Applications may want to override this internal function, and
        should when sys.stderr is None."""
        import traceback, sys
        print >>sys.stderr, "Exception in Tkinter callback"
        sys.last_type = exc
        sys.last_value = val
        sys.last_traceback = tb
        traceback.print_exception(exc, val, tb)
    def __getattr__(self, attr):
        "Delegate attribute access to the interpreter object"
        return getattr(self.tk, attr)

# Ideally, the classes Pack, Place and Grid disappear, the
# pack/place/grid methods are defined on the Widget class, and
# everybody uses w.pack_whatever(...) instead of Pack.whatever(w,
# ...), with pack(), place() and grid() being short for
# pack_configure(), place_configure() and grid_columnconfigure(), and
# forget() being short for pack_forget().  As a practical matter, I'm
# afraid that there is too much code out there that may be using the
# Pack, Place or Grid class, so I leave them intact -- but only as
# backwards compatibility features.  Also note that those methods that
# take a master as argument (e.g. pack_propagate) have been moved to
# the Misc class (which now incorporates all methods common between
# toplevel and interior widgets).  Again, for compatibility, these are
# copied into the Pack, Place or Grid class.


def Tcl(screenName=None, baseName=None, className='Tk', useTk=0):
    return Tk(screenName, baseName, className, useTk)

class Pack:
    """Geometry manager Pack.

    Base class to use the methods pack_* in every widget."""
    def pack_configure(self, cnf={}, **kw):
        """Pack a widget in the parent widget. Use as options:
        after=widget - pack it after you have packed widget
        anchor=NSEW (or subset) - position widget according to
                                  given direction
        before=widget - pack it before you will pack widget
        expand=bool - expand widget if parent size grows
        fill=NONE or X or Y or BOTH - fill widget if widget grows
        in=master - use master to contain this widget
        in_=master - see 'in' option description
        ipadx=amount - add internal padding in x direction
        ipady=amount - add internal padding in y direction
        padx=amount - add padding in x direction
        pady=amount - add padding in y direction
        side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
        """
        self.tk.call(
              ('pack', 'configure', self._w)
              + self._options(cnf, kw))
    pack = configure = config = pack_configure
    def pack_forget(self):
        """Unmap this widget and do not use it for the packing order."""
        self.tk.call('pack', 'forget', self._w)
    forget = pack_forget
    def pack_info(self):
        """Return information about the packing options
        for this widget."""
        d = _splitdict(self.tk, self.tk.call('pack', 'info', self._w))
        if 'in' in d:
            d['in'] = self.nametowidget(d['in'])
        return d
    info = pack_info
    propagate = pack_propagate = Misc.pack_propagate
    slaves = pack_slaves = Misc.pack_slaves

class Place:
    """Geometry manager Place.

    Base class to use the methods place_* in every widget."""
    def place_configure(self, cnf={}, **kw):
        """Place a widget in the parent widget. Use as options:
        in=master - master relative to which the widget is placed
        in_=master - see 'in' option description
        x=amount - locate anchor of this widget at position x of master
        y=amount - locate anchor of this widget at position y of master
        relx=amount - locate anchor of this widget between 0.0 and 1.0
                      relative to width of master (1.0 is right edge)
        rely=amount - locate anchor of this widget between 0.0 and 1.0
                      relative to height of master (1.0 is bottom edge)
        anchor=NSEW (or subset) - position anchor according to given direction
        width=amount - width of this widget in pixel
        height=amount - height of this widget in pixel
        relwidth=amount - width of this widget between 0.0 and 1.0
                          relative to width of master (1.0 is the same width
                          as the master)
        relheight=amount - height of this widget between 0.0 and 1.0
                           relative to height of master (1.0 is the same
                           height as the master)
        bordermode="inside" or "outside" - whether to take border width of
                                           master widget into account
        """
        self.tk.call(
              ('place', 'configure', self._w)
              + self._options(cnf, kw))
    place = configure = config = place_configure
    def place_forget(self):
        """Unmap this widget."""
        self.tk.call('place', 'forget', self._w)
    forget = place_forget
    def place_info(self):
        """Return information about the placing options
        for this widget."""
        d = _splitdict(self.tk, self.tk.call('place', 'info', self._w))
        if 'in' in d:
            d['in'] = self.nametowidget(d['in'])
        return d
    info = place_info
    slaves = place_slaves = Misc.place_slaves

class Grid:
    """Geometry manager Grid.

    Base class to use the methods grid_* in every widget."""
    # Thanks to Masazumi Yoshikawa (yosikawa@isi.edu)
    def grid_configure(self, cnf={}, **kw):
        """Position a widget in the parent widget in a grid. Use as options:
        column=number - use cell identified with given column (starting with 0)
        columnspan=number - this widget will span several columns
        in=master - use master to contain this widget
        in_=master - see 'in' option description
        ipadx=amount - add internal padding in x direction
        ipady=amount - add internal padding in y direction
        padx=amount - add padding in x direction
        pady=amount - add padding in y direction
        row=number - use cell identified with given row (starting with 0)
        rowspan=number - this widget will span several rows
        sticky=NSEW - if cell is larger on which sides will this
                      widget stick to the cell boundary
        """
        self.tk.call(
              ('grid', 'configure', self._w)
              + self._options(cnf, kw))
    grid = configure = config = grid_configure
    bbox = grid_bbox = Misc.grid_bbox
    columnconfigure = grid_columnconfigure = Misc.grid_columnconfigure
    def grid_forget(self):
        """Unmap this widget."""
        self.tk.call('grid', 'forget', self._w)
    forget = grid_forget
    def grid_remove(self):
        """Unmap this widget but remember the grid options."""
        self.tk.call('grid', 'remove', self._w)
    def grid_info(self):
        """Return information about the options
        for positioning this widget in a grid."""
        d = _splitdict(self.tk, self.tk.call('grid', 'info', self._w))
        if 'in' in d:
            d['in'] = self.nametowidget(d['in'])
        return d
    info = grid_info
    location = grid_location = Misc.grid_location
    propagate = grid_propagate = Misc.grid_propagate
    rowconfigure = grid_rowconfigure = Misc.grid_rowconfigure
    size = grid_size = Misc.grid_size
    slaves = grid_slaves = Misc.grid_slaves

class BaseWidget(Misc):
    """Internal class."""
    def _setup(self, master, cnf):
        """Internal function. Sets up information about children."""
        if _support_default_root:
            global _default_root
            if not master:
                if not _default_root:
                    _default_root = Tk()
                master = _default_root
        self.master = master
        self.tk = master.tk
        name = None
        if 'name' in cnf:
            name = cnf['name']
            del cnf['name']
        if not name:
            name = repr(id(self))
        self._name = name
        if master._w=='.':
            self._w = '.' + name
        else:
            self._w = master._w + '.' + name
        self.children = {}
        if self._name in self.master.children:
            self.master.children[self._name].destroy()
        self.master.children[self._name] = self
    def __init__(self, master, widgetName, cnf={}, kw={}, extra=()):
        """Construct a widget with the parent widget MASTER, a name WIDGETNAME
        and appropriate options."""
        if kw:
            cnf = _cnfmerge((cnf, kw))
        self.widgetName = widgetName
        BaseWidget._setup(self, master, cnf)
        if self._tclCommands is None:
            self._tclCommands = []
        classes = []
        for k in cnf.keys():
            if type(k) is ClassType:
                classes.append((k, cnf[k]))
                del cnf[k]
        self.tk.call(
            (widgetName, self._w) + extra + self._options(cnf))
        for k, v in classes:
            k.configure(self, v)
    def destroy(self):
        """Destroy this and all descendants widgets."""
        for c in self.children.values(): c.destroy()
        self.tk.call('destroy', self._w)
        if self._name in self.master.children:
            del self.master.children[self._name]
        Misc.destroy(self)
    def _do(self, name, args=()):
        # XXX Obsolete -- better use self.tk.call directly!
        return self.tk.call((self._w, name) + args)

class Widget(BaseWidget, Pack, Place, Grid):
    """Internal class.

    Base class for a widget which can be positioned with the geometry managers
    Pack, Place or Grid."""
    pass

class Toplevel(BaseWidget, Wm):
    """Toplevel widget, e.g. for dialogs."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a toplevel widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, class,
        colormap, container, cursor, height, highlightbackground,
        highlightcolor, highlightthickness, menu, relief, screen, takefocus,
        use, visual, width."""
        if kw:
            cnf = _cnfmerge((cnf, kw))
        extra = ()
        for wmkey in ['screen', 'class_', 'class', 'visual',
                  'colormap']:
            if wmkey in cnf:
                val = cnf[wmkey]
                # TBD: a hack needed because some keys
                # are not valid as keyword arguments
                if wmkey[-1] == '_': opt = '-'+wmkey[:-1]
                else: opt = '-'+wmkey
                extra = extra + (opt, val)
                del cnf[wmkey]
        BaseWidget.__init__(self, master, 'toplevel', cnf, {}, extra)
        root = self._root()
        self.iconname(root.iconname())
        self.title(root.title())
        self.protocol("WM_DELETE_WINDOW", self.destroy)

class Button(Widget):
    """Button widget."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a button widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, activeforeground, anchor,
            background, bitmap, borderwidth, cursor,
            disabledforeground, font, foreground
            highlightbackground, highlightcolor,
            highlightthickness, image, justify,
            padx, pady, relief, repeatdelay,
            repeatinterval, takefocus, text,
            textvariable, underline, wraplength

        WIDGET-SPECIFIC OPTIONS

            command, compound, default, height,
            overrelief, state, width
        """
        Widget.__init__(self, master, 'button', cnf, kw)

    def tkButtonEnter(self, *dummy):
        self.tk.call('tkButtonEnter', self._w)

    def tkButtonLeave(self, *dummy):
        self.tk.call('tkButtonLeave', self._w)

    def tkButtonDown(self, *dummy):
        self.tk.call('tkButtonDown', self._w)

    def tkButtonUp(self, *dummy):
        self.tk.call('tkButtonUp', self._w)

    def tkButtonInvoke(self, *dummy):
        self.tk.call('tkButtonInvoke', self._w)

    def flash(self):
        """Flash the button.

        This is accomplished by redisplaying
        the button several times, alternating between active and
        normal colors. At the end of the flash the button is left
        in the same normal/active state as when the command was
        invoked. This command is ignored if the button's state is
        disabled.
        """
        self.tk.call(self._w, 'flash')

    def invoke(self):
        """Invoke the command associated with the button.

        The return value is the return value from the command,
        or an empty string if there is no command associated with
        the button. This command is ignored if the button's state
        is disabled.
        """
        return self.tk.call(self._w, 'invoke')

# Indices:
# XXX I don't like these -- take them away
def AtEnd():
    return 'end'
def AtInsert(*args):
    s = 'insert'
    for a in args:
        if a: s = s + (' ' + a)
    return s
def AtSelFirst():
    return 'sel.first'
def AtSelLast():
    return 'sel.last'
def At(x, y=None):
    if y is None:
        return '@%r' % (x,)
    else:
        return '@%r,%r' % (x, y)

class Canvas(Widget, XView, YView):
    """Canvas widget to display graphical elements like lines or text."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a canvas widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, closeenough,
        confine, cursor, height, highlightbackground, highlightcolor,
        highlightthickness, insertbackground, insertborderwidth,
        insertofftime, insertontime, insertwidth, offset, relief,
        scrollregion, selectbackground, selectborderwidth, selectforeground,
        state, takefocus, width, xscrollcommand, xscrollincrement,
        yscrollcommand, yscrollincrement."""
        Widget.__init__(self, master, 'canvas', cnf, kw)
    def addtag(self, *args):
        """Internal function."""
        self.tk.call((self._w, 'addtag') + args)
    def addtag_above(self, newtag, tagOrId):
        """Add tag NEWTAG to all items above TAGORID."""
        self.addtag(newtag, 'above', tagOrId)
    def addtag_all(self, newtag):
        """Add tag NEWTAG to all items."""
        self.addtag(newtag, 'all')
    def addtag_below(self, newtag, tagOrId):
        """Add tag NEWTAG to all items below TAGORID."""
        self.addtag(newtag, 'below', tagOrId)
    def addtag_closest(self, newtag, x, y, halo=None, start=None):
        """Add tag NEWTAG to item which is closest to pixel at X, Y.
        If several match take the top-most.
        All items closer than HALO are considered overlapping (all are
        closests). If START is specified the next below this tag is taken."""
        self.addtag(newtag, 'closest', x, y, halo, start)
    def addtag_enclosed(self, newtag, x1, y1, x2, y2):
        """Add tag NEWTAG to all items in the rectangle defined
        by X1,Y1,X2,Y2."""
        self.addtag(newtag, 'enclosed', x1, y1, x2, y2)
    def addtag_overlapping(self, newtag, x1, y1, x2, y2):
        """Add tag NEWTAG to all items which overlap the rectangle
        defined by X1,Y1,X2,Y2."""
        self.addtag(newtag, 'overlapping', x1, y1, x2, y2)
    def addtag_withtag(self, newtag, tagOrId):
        """Add tag NEWTAG to all items with TAGORID."""
        self.addtag(newtag, 'withtag', tagOrId)
    def bbox(self, *args):
        """Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
        which encloses all items with tags specified as arguments."""
        return self._getints(
            self.tk.call((self._w, 'bbox') + args)) or None
    def tag_unbind(self, tagOrId, sequence, funcid=None):
        """Unbind for all items with TAGORID for event SEQUENCE  the
        function identified with FUNCID."""
        self.tk.call(self._w, 'bind', tagOrId, sequence, '')
        if funcid:
            self.deletecommand(funcid)
    def tag_bind(self, tagOrId, sequence=None, func=None, add=None):
        """Bind to all items with TAGORID at event SEQUENCE a call to function FUNC.

        An additional boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or whether it will
        replace the previous function. See bind for the return value."""
        return self._bind((self._w, 'bind', tagOrId),
                  sequence, func, add)
    def canvasx(self, screenx, gridspacing=None):
        """Return the canvas x coordinate of pixel position SCREENX rounded
        to nearest multiple of GRIDSPACING units."""
        return getdouble(self.tk.call(
            self._w, 'canvasx', screenx, gridspacing))
    def canvasy(self, screeny, gridspacing=None):
        """Return the canvas y coordinate of pixel position SCREENY rounded
        to nearest multiple of GRIDSPACING units."""
        return getdouble(self.tk.call(
            self._w, 'canvasy', screeny, gridspacing))
    def coords(self, *args):
        """Return a list of coordinates for the item given in ARGS."""
        # XXX Should use _flatten on args
        return map(getdouble,
                           self.tk.splitlist(
                   self.tk.call((self._w, 'coords') + args)))
    def _create(self, itemType, args, kw): # Args: (val, val, ..., cnf={})
        """Internal function."""
        args = _flatten(args)
        cnf = args[-1]
        if type(cnf) in (DictionaryType, TupleType):
            args = args[:-1]
        else:
            cnf = {}
        return getint(self.tk.call(
            self._w, 'create', itemType,
            *(args + self._options(cnf, kw))))
    def create_arc(self, *args, **kw):
        """Create arc shaped region with coordinates x1,y1,x2,y2."""
        return self._create('arc', args, kw)
    def create_bitmap(self, *args, **kw):
        """Create bitmap with coordinates x1,y1."""
        return self._create('bitmap', args, kw)
    def create_image(self, *args, **kw):
        """Create image item with coordinates x1,y1."""
        return self._create('image', args, kw)
    def create_line(self, *args, **kw):
        """Create line with coordinates x1,y1,...,xn,yn."""
        return self._create('line', args, kw)
    def create_oval(self, *args, **kw):
        """Create oval with coordinates x1,y1,x2,y2."""
        return self._create('oval', args, kw)
    def create_polygon(self, *args, **kw):
        """Create polygon with coordinates x1,y1,...,xn,yn."""
        return self._create('polygon', args, kw)
    def create_rectangle(self, *args, **kw):
        """Create rectangle with coordinates x1,y1,x2,y2."""
        return self._create('rectangle', args, kw)
    def create_text(self, *args, **kw):
        """Create text with coordinates x1,y1."""
        return self._create('text', args, kw)
    def create_window(self, *args, **kw):
        """Create window with coordinates x1,y1,x2,y2."""
        return self._create('window', args, kw)
    def dchars(self, *args):
        """Delete characters of text items identified by tag or id in ARGS (possibly
        several times) from FIRST to LAST character (including)."""
        self.tk.call((self._w, 'dchars') + args)
    def delete(self, *args):
        """Delete items identified by all tag or ids contained in ARGS."""
        self.tk.call((self._w, 'delete') + args)
    def dtag(self, *args):
        """Delete tag or id given as last arguments in ARGS from items
        identified by first argument in ARGS."""
        self.tk.call((self._w, 'dtag') + args)
    def find(self, *args):
        """Internal function."""
        return self._getints(
            self.tk.call((self._w, 'find') + args)) or ()
    def find_above(self, tagOrId):
        """Return items above TAGORID."""
        return self.find('above', tagOrId)
    def find_all(self):
        """Return all items."""
        return self.find('all')
    def find_below(self, tagOrId):
        """Return all items below TAGORID."""
        return self.find('below', tagOrId)
    def find_closest(self, x, y, halo=None, start=None):
        """Return item which is closest to pixel at X, Y.
        If several match take the top-most.
        All items closer than HALO are considered overlapping (all are
        closests). If START is specified the next below this tag is taken."""
        return self.find('closest', x, y, halo, start)
    def find_enclosed(self, x1, y1, x2, y2):
        """Return all items in rectangle defined
        by X1,Y1,X2,Y2."""
        return self.find('enclosed', x1, y1, x2, y2)
    def find_overlapping(self, x1, y1, x2, y2):
        """Return all items which overlap the rectangle
        defined by X1,Y1,X2,Y2."""
        return self.find('overlapping', x1, y1, x2, y2)
    def find_withtag(self, tagOrId):
        """Return all items with TAGORID."""
        return self.find('withtag', tagOrId)
    def focus(self, *args):
        """Set focus to the first item specified in ARGS."""
        return self.tk.call((self._w, 'focus') + args)
    def gettags(self, *args):
        """Return tags associated with the first item specified in ARGS."""
        return self.tk.splitlist(
            self.tk.call((self._w, 'gettags') + args))
    def icursor(self, *args):
        """Set cursor at position POS in the item identified by TAGORID.
        In ARGS TAGORID must be first."""
        self.tk.call((self._w, 'icursor') + args)
    def index(self, *args):
        """Return position of cursor as integer in item specified in ARGS."""
        return getint(self.tk.call((self._w, 'index') + args))
    def insert(self, *args):
        """Insert TEXT in item TAGORID at position POS. ARGS must
        be TAGORID POS TEXT."""
        self.tk.call((self._w, 'insert') + args)
    def itemcget(self, tagOrId, option):
        """Return the resource value for an OPTION for item TAGORID."""
        return self.tk.call(
            (self._w, 'itemcget') + (tagOrId, '-'+option))
    def itemconfigure(self, tagOrId, cnf=None, **kw):
        """Configure resources of an item TAGORID.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method without arguments.
        """
        return self._configure(('itemconfigure', tagOrId), cnf, kw)
    itemconfig = itemconfigure
    # lower, tkraise/lift hide Misc.lower, Misc.tkraise/lift,
    # so the preferred name for them is tag_lower, tag_raise
    # (similar to tag_bind, and similar to the Text widget);
    # unfortunately can't delete the old ones yet (maybe in 1.6)
    def tag_lower(self, *args):
        """Lower an item TAGORID given in ARGS
        (optional below another item)."""
        self.tk.call((self._w, 'lower') + args)
    lower = tag_lower
    def move(self, *args):
        """Move an item TAGORID given in ARGS."""
        self.tk.call((self._w, 'move') + args)
    def postscript(self, cnf={}, **kw):
        """Print the contents of the canvas to a postscript
        file. Valid options: colormap, colormode, file, fontmap,
        height, pageanchor, pageheight, pagewidth, pagex, pagey,
        rotate, witdh, x, y."""
        return self.tk.call((self._w, 'postscript') +
                    self._options(cnf, kw))
    def tag_raise(self, *args):
        """Raise an item TAGORID given in ARGS
        (optional above another item)."""
        self.tk.call((self._w, 'raise') + args)
    lift = tkraise = tag_raise
    def scale(self, *args):
        """Scale item TAGORID with XORIGIN, YORIGIN, XSCALE, YSCALE."""
        self.tk.call((self._w, 'scale') + args)
    def scan_mark(self, x, y):
        """Remember the current X, Y coordinates."""
        self.tk.call(self._w, 'scan', 'mark', x, y)
    def scan_dragto(self, x, y, gain=10):
        """Adjust the view of the canvas to GAIN times the
        difference between X and Y and the coordinates given in
        scan_mark."""
        self.tk.call(self._w, 'scan', 'dragto', x, y, gain)
    def select_adjust(self, tagOrId, index):
        """Adjust the end of the selection near the cursor of an item TAGORID to index."""
        self.tk.call(self._w, 'select', 'adjust', tagOrId, index)
    def select_clear(self):
        """Clear the selection if it is in this widget."""
        self.tk.call(self._w, 'select', 'clear')
    def select_from(self, tagOrId, index):
        """Set the fixed end of a selection in item TAGORID to INDEX."""
        self.tk.call(self._w, 'select', 'from', tagOrId, index)
    def select_item(self):
        """Return the item which has the selection."""
        return self.tk.call(self._w, 'select', 'item') or None
    def select_to(self, tagOrId, index):
        """Set the variable end of a selection in item TAGORID to INDEX."""
        self.tk.call(self._w, 'select', 'to', tagOrId, index)
    def type(self, tagOrId):
        """Return the type of the item TAGORID."""
        return self.tk.call(self._w, 'type', tagOrId) or None

class Checkbutton(Widget):
    """Checkbutton widget which is either in on- or off-state."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a checkbutton widget with the parent MASTER.

        Valid resource names: activebackground, activeforeground, anchor,
        background, bd, bg, bitmap, borderwidth, command, cursor,
        disabledforeground, fg, font, foreground, height,
        highlightbackground, highlightcolor, highlightthickness, image,
        indicatoron, justify, offvalue, onvalue, padx, pady, relief,
        selectcolor, selectimage, state, takefocus, text, textvariable,
        underline, variable, width, wraplength."""
        Widget.__init__(self, master, 'checkbutton', cnf, kw)
    def deselect(self):
        """Put the button in off-state."""
        self.tk.call(self._w, 'deselect')
    def flash(self):
        """Flash the button."""
        self.tk.call(self._w, 'flash')
    def invoke(self):
        """Toggle the button and invoke a command if given as resource."""
        return self.tk.call(self._w, 'invoke')
    def select(self):
        """Put the button in on-state."""
        self.tk.call(self._w, 'select')
    def toggle(self):
        """Toggle the button."""
        self.tk.call(self._w, 'toggle')

class Entry(Widget, XView):
    """Entry widget which allows displaying simple text."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct an entry widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, cursor,
        exportselection, fg, font, foreground, highlightbackground,
        highlightcolor, highlightthickness, insertbackground,
        insertborderwidth, insertofftime, insertontime, insertwidth,
        invalidcommand, invcmd, justify, relief, selectbackground,
        selectborderwidth, selectforeground, show, state, takefocus,
        textvariable, validate, validatecommand, vcmd, width,
        xscrollcommand."""
        Widget.__init__(self, master, 'entry', cnf, kw)
    def delete(self, first, last=None):
        """Delete text from FIRST to LAST (not included)."""
        self.tk.call(self._w, 'delete', first, last)
    def get(self):
        """Return the text."""
        return self.tk.call(self._w, 'get')
    def icursor(self, index):
        """Insert cursor at INDEX."""
        self.tk.call(self._w, 'icursor', index)
    def index(self, index):
        """Return position of cursor."""
        return getint(self.tk.call(
            self._w, 'index', index))
    def insert(self, index, string):
        """Insert STRING at INDEX."""
        self.tk.call(self._w, 'insert', index, string)
    def scan_mark(self, x):
        """Remember the current X, Y coordinates."""
        self.tk.call(self._w, 'scan', 'mark', x)
    def scan_dragto(self, x):
        """Adjust the view of the canvas to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark."""
        self.tk.call(self._w, 'scan', 'dragto', x)
    def selection_adjust(self, index):
        """Adjust the end of the selection near the cursor to INDEX."""
        self.tk.call(self._w, 'selection', 'adjust', index)
    select_adjust = selection_adjust
    def selection_clear(self):
        """Clear the selection if it is in this widget."""
        self.tk.call(self._w, 'selection', 'clear')
    select_clear = selection_clear
    def selection_from(self, index):
        """Set the fixed end of a selection to INDEX."""
        self.tk.call(self._w, 'selection', 'from', index)
    select_from = selection_from
    def selection_present(self):
        """Return True if there are characters selected in the entry, False
        otherwise."""
        return self.tk.getboolean(
            self.tk.call(self._w, 'selection', 'present'))
    select_present = selection_present
    def selection_range(self, start, end):
        """Set the selection from START to END (not included)."""
        self.tk.call(self._w, 'selection', 'range', start, end)
    select_range = selection_range
    def selection_to(self, index):
        """Set the variable end of a selection to INDEX."""
        self.tk.call(self._w, 'selection', 'to', index)
    select_to = selection_to

class Frame(Widget):
    """Frame widget which may contain other widgets and can have a 3D border."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a frame widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, class,
        colormap, container, cursor, height, highlightbackground,
        highlightcolor, highlightthickness, relief, takefocus, visual, width."""
        cnf = _cnfmerge((cnf, kw))
        extra = ()
        if 'class_' in cnf:
            extra = ('-class', cnf['class_'])
            del cnf['class_']
        elif 'class' in cnf:
            extra = ('-class', cnf['class'])
            del cnf['class']
        Widget.__init__(self, master, 'frame', cnf, {}, extra)

class Label(Widget):
    """Label widget which can display text and bitmaps."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a label widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, activeforeground, anchor,
            background, bitmap, borderwidth, cursor,
            disabledforeground, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, image, justify,
            padx, pady, relief, takefocus, text,
            textvariable, underline, wraplength

        WIDGET-SPECIFIC OPTIONS

            height, state, width

        """
        Widget.__init__(self, master, 'label', cnf, kw)

class Listbox(Widget, XView, YView):
    """Listbox widget which can display a list of strings."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a listbox widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, cursor,
        exportselection, fg, font, foreground, height, highlightbackground,
        highlightcolor, highlightthickness, relief, selectbackground,
        selectborderwidth, selectforeground, selectmode, setgrid, takefocus,
        width, xscrollcommand, yscrollcommand, listvariable."""
        Widget.__init__(self, master, 'listbox', cnf, kw)
    def activate(self, index):
        """Activate item identified by INDEX."""
        self.tk.call(self._w, 'activate', index)
    def bbox(self, index):
        """Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
        which encloses the item identified by the given index."""
        return self._getints(self.tk.call(self._w, 'bbox', index)) or None
    def curselection(self):
        """Return the indices of currently selected item."""
        return self._getints(self.tk.call(self._w, 'curselection')) or ()
    def delete(self, first, last=None):
        """Delete items from FIRST to LAST (included)."""
        self.tk.call(self._w, 'delete', first, last)
    def get(self, first, last=None):
        """Get list of items from FIRST to LAST (included)."""
        if last is not None:
            return self.tk.splitlist(self.tk.call(
                self._w, 'get', first, last))
        else:
            return self.tk.call(self._w, 'get', first)
    def index(self, index):
        """Return index of item identified with INDEX."""
        i = self.tk.call(self._w, 'index', index)
        if i == 'none': return None
        return getint(i)
    def insert(self, index, *elements):
        """Insert ELEMENTS at INDEX."""
        self.tk.call((self._w, 'insert', index) + elements)
    def nearest(self, y):
        """Get index of item which is nearest to y coordinate Y."""
        return getint(self.tk.call(
            self._w, 'nearest', y))
    def scan_mark(self, x, y):
        """Remember the current X, Y coordinates."""
        self.tk.call(self._w, 'scan', 'mark', x, y)
    def scan_dragto(self, x, y):
        """Adjust the view of the listbox to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark."""
        self.tk.call(self._w, 'scan', 'dragto', x, y)
    def see(self, index):
        """Scroll such that INDEX is visible."""
        self.tk.call(self._w, 'see', index)
    def selection_anchor(self, index):
        """Set the fixed end oft the selection to INDEX."""
        self.tk.call(self._w, 'selection', 'anchor', index)
    select_anchor = selection_anchor
    def selection_clear(self, first, last=None):
        """Clear the selection from FIRST to LAST (included)."""
        self.tk.call(self._w,
                 'selection', 'clear', first, last)
    select_clear = selection_clear
    def selection_includes(self, index):
        """Return 1 if INDEX is part of the selection."""
        return self.tk.getboolean(self.tk.call(
            self._w, 'selection', 'includes', index))
    select_includes = selection_includes
    def selection_set(self, first, last=None):
        """Set the selection from FIRST to LAST (included) without
        changing the currently selected elements."""
        self.tk.call(self._w, 'selection', 'set', first, last)
    select_set = selection_set
    def size(self):
        """Return the number of elements in the listbox."""
        return getint(self.tk.call(self._w, 'size'))
    def itemcget(self, index, option):
        """Return the resource value for an ITEM and an OPTION."""
        return self.tk.call(
            (self._w, 'itemcget') + (index, '-'+option))
    def itemconfigure(self, index, cnf=None, **kw):
        """Configure resources of an ITEM.

        The values for resources are specified as keyword arguments.
        To get an overview about the allowed keyword arguments
        call the method without arguments.
        Valid resource names: background, bg, foreground, fg,
        selectbackground, selectforeground."""
        return self._configure(('itemconfigure', index), cnf, kw)
    itemconfig = itemconfigure

class Menu(Widget):
    """Menu widget which allows displaying menu bars, pull-down menus and pop-up menus."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct menu widget with the parent MASTER.

        Valid resource names: activebackground, activeborderwidth,
        activeforeground, background, bd, bg, borderwidth, cursor,
        disabledforeground, fg, font, foreground, postcommand, relief,
        selectcolor, takefocus, tearoff, tearoffcommand, title, type."""
        Widget.__init__(self, master, 'menu', cnf, kw)
    def tk_bindForTraversal(self):
        # obsolete since Tk 4.0
        import warnings
        warnings.warn('tk_bindForTraversal() does nothing and '
                      'will be removed in 3.6',
                      DeprecationWarning, stacklevel=2)
    def tk_mbPost(self):
        self.tk.call('tk_mbPost', self._w)
    def tk_mbUnpost(self):
        self.tk.call('tk_mbUnpost')
    def tk_traverseToMenu(self, char):
        self.tk.call('tk_traverseToMenu', self._w, char)
    def tk_traverseWithinMenu(self, char):
        self.tk.call('tk_traverseWithinMenu', self._w, char)
    def tk_getMenuButtons(self):
        return self.tk.call('tk_getMenuButtons', self._w)
    def tk_nextMenu(self, count):
        self.tk.call('tk_nextMenu', count)
    def tk_nextMenuEntry(self, count):
        self.tk.call('tk_nextMenuEntry', count)
    def tk_invokeMenu(self):
        self.tk.call('tk_invokeMenu', self._w)
    def tk_firstMenu(self):
        self.tk.call('tk_firstMenu', self._w)
    def tk_mbButtonDown(self):
        self.tk.call('tk_mbButtonDown', self._w)
    def tk_popup(self, x, y, entry=""):
        """Post the menu at position X,Y with entry ENTRY."""
        self.tk.call('tk_popup', self._w, x, y, entry)
    def activate(self, index):
        """Activate entry at INDEX."""
        self.tk.call(self._w, 'activate', index)
    def add(self, itemType, cnf={}, **kw):
        """Internal function."""
        self.tk.call((self._w, 'add', itemType) +
                 self._options(cnf, kw))
    def add_cascade(self, cnf={}, **kw):
        """Add hierarchical menu item."""
        self.add('cascade', cnf or kw)
    def add_checkbutton(self, cnf={}, **kw):
        """Add checkbutton menu item."""
        self.add('checkbutton', cnf or kw)
    def add_command(self, cnf={}, **kw):
        """Add command menu item."""
        self.add('command', cnf or kw)
    def add_radiobutton(self, cnf={}, **kw):
        """Addd radio menu item."""
        self.add('radiobutton', cnf or kw)
    def add_separator(self, cnf={}, **kw):
        """Add separator."""
        self.add('separator', cnf or kw)
    def insert(self, index, itemType, cnf={}, **kw):
        """Internal function."""
        self.tk.call((self._w, 'insert', index, itemType) +
                 self._options(cnf, kw))
    def insert_cascade(self, index, cnf={}, **kw):
        """Add hierarchical menu item at INDEX."""
        self.insert(index, 'cascade', cnf or kw)
    def insert_checkbutton(self, index, cnf={}, **kw):
        """Add checkbutton menu item at INDEX."""
        self.insert(index, 'checkbutton', cnf or kw)
    def insert_command(self, index, cnf={}, **kw):
        """Add command menu item at INDEX."""
        self.insert(index, 'command', cnf or kw)
    def insert_radiobutton(self, index, cnf={}, **kw):
        """Addd radio menu item at INDEX."""
        self.insert(index, 'radiobutton', cnf or kw)
    def insert_separator(self, index, cnf={}, **kw):
        """Add separator at INDEX."""
        self.insert(index, 'separator', cnf or kw)
    def delete(self, index1, index2=None):
        """Delete menu items between INDEX1 and INDEX2 (included)."""
        if index2 is None:
            index2 = index1

        num_index1, num_index2 = self.index(index1), self.index(index2)
        if (num_index1 is None) or (num_index2 is None):
            num_index1, num_index2 = 0, -1

        for i in range(num_index1, num_index2 + 1):
            if 'command' in self.entryconfig(i):
                c = str(self.entrycget(i, 'command'))
                if c:
                    self.deletecommand(c)
        self.tk.call(self._w, 'delete', index1, index2)
    def entrycget(self, index, option):
        """Return the resource value of a menu item for OPTION at INDEX."""
        return self.tk.call(self._w, 'entrycget', index, '-' + option)
    def entryconfigure(self, index, cnf=None, **kw):
        """Configure a menu item at INDEX."""
        return self._configure(('entryconfigure', index), cnf, kw)
    entryconfig = entryconfigure
    def index(self, index):
        """Return the index of a menu item identified by INDEX."""
        i = self.tk.call(self._w, 'index', index)
        if i == 'none': return None
        return getint(i)
    def invoke(self, index):
        """Invoke a menu item identified by INDEX and execute
        the associated command."""
        return self.tk.call(self._w, 'invoke', index)
    def post(self, x, y):
        """Display a menu at position X,Y."""
        self.tk.call(self._w, 'post', x, y)
    def type(self, index):
        """Return the type of the menu item at INDEX."""
        return self.tk.call(self._w, 'type', index)
    def unpost(self):
        """Unmap a menu."""
        self.tk.call(self._w, 'unpost')
    def yposition(self, index):
        """Return the y-position of the topmost pixel of the menu item at INDEX."""
        return getint(self.tk.call(
            self._w, 'yposition', index))

class Menubutton(Widget):
    """Menubutton widget, obsolete since Tk8.0."""
    def __init__(self, master=None, cnf={}, **kw):
        Widget.__init__(self, master, 'menubutton', cnf, kw)

class Message(Widget):
    """Message widget to display multiline text. Obsolete since Label does it too."""
    def __init__(self, master=None, cnf={}, **kw):
        Widget.__init__(self, master, 'message', cnf, kw)

class Radiobutton(Widget):
    """Radiobutton widget which shows only one of several buttons in on-state."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a radiobutton widget with the parent MASTER.

        Valid resource names: activebackground, activeforeground, anchor,
        background, bd, bg, bitmap, borderwidth, command, cursor,
        disabledforeground, fg, font, foreground, height,
        highlightbackground, highlightcolor, highlightthickness, image,
        indicatoron, justify, padx, pady, relief, selectcolor, selectimage,
        state, takefocus, text, textvariable, underline, value, variable,
        width, wraplength."""
        Widget.__init__(self, master, 'radiobutton', cnf, kw)
    def deselect(self):
        """Put the button in off-state."""

        self.tk.call(self._w, 'deselect')
    def flash(self):
        """Flash the button."""
        self.tk.call(self._w, 'flash')
    def invoke(self):
        """Toggle the button and invoke a command if given as resource."""
        return self.tk.call(self._w, 'invoke')
    def select(self):
        """Put the button in on-state."""
        self.tk.call(self._w, 'select')

class Scale(Widget):
    """Scale widget which can display a numerical scale."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a scale widget with the parent MASTER.

        Valid resource names: activebackground, background, bigincrement, bd,
        bg, borderwidth, command, cursor, digits, fg, font, foreground, from,
        highlightbackground, highlightcolor, highlightthickness, label,
        length, orient, relief, repeatdelay, repeatinterval, resolution,
        showvalue, sliderlength, sliderrelief, state, takefocus,
        tickinterval, to, troughcolor, variable, width."""
        Widget.__init__(self, master, 'scale', cnf, kw)
    def get(self):
        """Get the current value as integer or float."""
        value = self.tk.call(self._w, 'get')
        try:
            return getint(value)
        except ValueError:
            return getdouble(value)
    def set(self, value):
        """Set the value to VALUE."""
        self.tk.call(self._w, 'set', value)
    def coords(self, value=None):
        """Return a tuple (X,Y) of the point along the centerline of the
        trough that corresponds to VALUE or the current value if None is
        given."""

        return self._getints(self.tk.call(self._w, 'coords', value))
    def identify(self, x, y):
        """Return where the point X,Y lies. Valid return values are "slider",
        "though1" and "though2"."""
        return self.tk.call(self._w, 'identify', x, y)

class Scrollbar(Widget):
    """Scrollbar widget which displays a slider at a certain position."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a scrollbar widget with the parent MASTER.

        Valid resource names: activebackground, activerelief,
        background, bd, bg, borderwidth, command, cursor,
        elementborderwidth, highlightbackground,
        highlightcolor, highlightthickness, jump, orient,
        relief, repeatdelay, repeatinterval, takefocus,
        troughcolor, width."""
        Widget.__init__(self, master, 'scrollbar', cnf, kw)
    def activate(self, index):
        """Display the element at INDEX with activebackground and activerelief.
        INDEX can be "arrow1","slider" or "arrow2"."""
        self.tk.call(self._w, 'activate', index)
    def delta(self, deltax, deltay):
        """Return the fractional change of the scrollbar setting if it
        would be moved by DELTAX or DELTAY pixels."""
        return getdouble(
            self.tk.call(self._w, 'delta', deltax, deltay))
    def fraction(self, x, y):
        """Return the fractional value which corresponds to a slider
        position of X,Y."""
        return getdouble(self.tk.call(self._w, 'fraction', x, y))
    def identify(self, x, y):
        """Return the element under position X,Y as one of
        "arrow1","slider","arrow2" or ""."""
        return self.tk.call(self._w, 'identify', x, y)
    def get(self):
        """Return the current fractional values (upper and lower end)
        of the slider position."""
        return self._getdoubles(self.tk.call(self._w, 'get'))
    def set(self, *args):
        """Set the fractional values of the slider position (upper and
        lower ends as value between 0 and 1)."""
        self.tk.call((self._w, 'set') + args)



class Text(Widget, XView, YView):
    """Text widget which can display text in various forms."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a text widget with the parent MASTER.

        STANDARD OPTIONS

            background, borderwidth, cursor,
            exportselection, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, insertbackground,
            insertborderwidth, insertofftime,
            insertontime, insertwidth, padx, pady,
            relief, selectbackground,
            selectborderwidth, selectforeground,
            setgrid, takefocus,
            xscrollcommand, yscrollcommand,

        WIDGET-SPECIFIC OPTIONS

            autoseparators, height, maxundo,
            spacing1, spacing2, spacing3,
            state, tabs, undo, width, wrap,

        """
        Widget.__init__(self, master, 'text', cnf, kw)
    def bbox(self, *args):
        """Return a tuple of (x,y,width,height) which gives the bounding
        box of the visible part of the character at the index in ARGS."""
        return self._getints(
            self.tk.call((self._w, 'bbox') + args)) or None
    def tk_textSelectTo(self, index):
        self.tk.call('tk_textSelectTo', self._w, index)
    def tk_textBackspace(self):
        self.tk.call('tk_textBackspace', self._w)
    def tk_textIndexCloser(self, a, b, c):
        self.tk.call('tk_textIndexCloser', self._w, a, b, c)
    def tk_textResetAnchor(self, index):
        self.tk.call('tk_textResetAnchor', self._w, index)
    def compare(self, index1, op, index2):
        """Return whether between index INDEX1 and index INDEX2 the
        relation OP is satisfied. OP is one of <, <=, ==, >=, >, or !=."""
        return self.tk.getboolean(self.tk.call(
            self._w, 'compare', index1, op, index2))
    def debug(self, boolean=None):
        """Turn on the internal consistency checks of the B-Tree inside the text
        widget according to BOOLEAN."""
        if boolean is None:
            return self.tk.getboolean(self.tk.call(self._w, 'debug'))
        self.tk.call(self._w, 'debug', boolean)
    def delete(self, index1, index2=None):
        """Delete the characters between INDEX1 and INDEX2 (not included)."""
        self.tk.call(self._w, 'delete', index1, index2)
    def dlineinfo(self, index):
        """Return tuple (x,y,width,height,baseline) giving the bounding box
        and baseline position of the visible part of the line containing
        the character at INDEX."""
        return self._getints(self.tk.call(self._w, 'dlineinfo', index))
    def dump(self, index1, index2=None, command=None, **kw):
        """Return the contents of the widget between index1 and index2.

        The type of contents returned in filtered based on the keyword
        parameters; if 'all', 'image', 'mark', 'tag', 'text', or 'window' are
        given and true, then the corresponding items are returned. The result
        is a list of triples of the form (key, value, index). If none of the
        keywords are true then 'all' is used by default.

        If the 'command' argument is given, it is called once for each element
        of the list of triples, with the values of each triple serving as the
        arguments to the function. In this case the list is not returned."""
        args = []
        func_name = None
        result = None
        if not command:
            # Never call the dump command without the -command flag, since the
            # output could involve Tcl quoting and would be a pain to parse
            # right. Instead just set the command to build a list of triples
            # as if we had done the parsing.
            result = []
            def append_triple(key, value, index, result=result):
                result.append((key, value, index))
            command = append_triple
        try:
            if not isinstance(command, str):
                func_name = command = self._register(command)
            args += ["-command", command]
            for key in kw:
                if kw[key]: args.append("-" + key)
            args.append(index1)
            if index2:
                args.append(index2)
            self.tk.call(self._w, "dump", *args)
            return result
        finally:
            if func_name:
                self.deletecommand(func_name)

    ## new in tk8.4
    def edit(self, *args):
        """Internal method

        This method controls the undo mechanism and
        the modified flag. The exact behavior of the
        command depends on the option argument that
        follows the edit argument. The following forms
        of the command are currently supported:

        edit_modified, edit_redo, edit_reset, edit_separator
        and edit_undo

        """
        return self.tk.call(self._w, 'edit', *args)

    def edit_modified(self, arg=None):
        """Get or Set the modified flag

        If arg is not specified, returns the modified
        flag of the widget. The insert, delete, edit undo and
        edit redo commands or the user can set or clear the
        modified flag. If boolean is specified, sets the
        modified flag of the widget to arg.
        """
        return self.edit("modified", arg)

    def edit_redo(self):
        """Redo the last undone edit

        When the undo option is true, reapplies the last
        undone edits provided no other edits were done since
        then. Generates an error when the redo stack is empty.
        Does nothing when the undo option is false.
        """
        return self.edit("redo")

    def edit_reset(self):
        """Clears the undo and redo stacks
        """
        return self.edit("reset")

    def edit_separator(self):
        """Inserts a separator (boundary) on the undo stack.

        Does nothing when the undo option is false
        """
        return self.edit("separator")

    def edit_undo(self):
        """Undoes the last edit action

        If the undo option is true. An edit action is defined
        as all the insert and delete commands that are recorded
        on the undo stack in between two separators. Generates
        an error when the undo stack is empty. Does nothing
        when the undo option is false
        """
        return self.edit("undo")

    def get(self, index1, index2=None):
        """Return the text from INDEX1 to INDEX2 (not included)."""
        return self.tk.call(self._w, 'get', index1, index2)
    # (Image commands are new in 8.0)
    def image_cget(self, index, option):
        """Return the value of OPTION of an embedded image at INDEX."""
        if option[:1] != "-":
            option = "-" + option
        if option[-1:] == "_":
            option = option[:-1]
        return self.tk.call(self._w, "image", "cget", index, option)
    def image_configure(self, index, cnf=None, **kw):
        """Configure an embedded image at INDEX."""
        return self._configure(('image', 'configure', index), cnf, kw)
    def image_create(self, index, cnf={}, **kw):
        """Create an embedded image at INDEX."""
        return self.tk.call(
                 self._w, "image", "create", index,
                 *self._options(cnf, kw))
    def image_names(self):
        """Return all names of embedded images in this widget."""
        return self.tk.call(self._w, "image", "names")
    def index(self, index):
        """Return the index in the form line.char for INDEX."""
        return str(self.tk.call(self._w, 'index', index))
    def insert(self, index, chars, *args):
        """Insert CHARS before the characters at INDEX. An additional
        tag can be given in ARGS. Additional CHARS and tags can follow in ARGS."""
        self.tk.call((self._w, 'insert', index, chars) + args)
    def mark_gravity(self, markName, direction=None):
        """Change the gravity of a mark MARKNAME to DIRECTION (LEFT or RIGHT).
        Return the current value if None is given for DIRECTION."""
        return self.tk.call(
            (self._w, 'mark', 'gravity', markName, direction))
    def mark_names(self):
        """Return all mark names."""
        return self.tk.splitlist(self.tk.call(
            self._w, 'mark', 'names'))
    def mark_set(self, markName, index):
        """Set mark MARKNAME before the character at INDEX."""
        self.tk.call(self._w, 'mark', 'set', markName, index)
    def mark_unset(self, *markNames):
        """Delete all marks in MARKNAMES."""
        self.tk.call((self._w, 'mark', 'unset') + markNames)
    def mark_next(self, index):
        """Return the name of the next mark after INDEX."""
        return self.tk.call(self._w, 'mark', 'next', index) or None
    def mark_previous(self, index):
        """Return the name of the previous mark before INDEX."""
        return self.tk.call(self._w, 'mark', 'previous', index) or None
    def scan_mark(self, x, y):
        """Remember the current X, Y coordinates."""
        self.tk.call(self._w, 'scan', 'mark', x, y)
    def scan_dragto(self, x, y):
        """Adjust the view of the text to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark."""
        self.tk.call(self._w, 'scan', 'dragto', x, y)
    def search(self, pattern, index, stopindex=None,
           forwards=None, backwards=None, exact=None,
           regexp=None, nocase=None, count=None, elide=None):
        """Search PATTERN beginning from INDEX until STOPINDEX.
        Return the index of the first character of a match or an
        empty string."""
        args = [self._w, 'search']
        if forwards: args.append('-forwards')
        if backwards: args.append('-backwards')
        if exact: args.append('-exact')
        if regexp: args.append('-regexp')
        if nocase: args.append('-nocase')
        if elide: args.append('-elide')
        if count: args.append('-count'); args.append(count)
        if pattern and pattern[0] == '-': args.append('--')
        args.append(pattern)
        args.append(index)
        if stopindex: args.append(stopindex)
        return str(self.tk.call(tuple(args)))
    def see(self, index):
        """Scroll such that the character at INDEX is visible."""
        self.tk.call(self._w, 'see', index)
    def tag_add(self, tagName, index1, *args):
        """Add tag TAGNAME to all characters between INDEX1 and index2 in ARGS.
        Additional pairs of indices may follow in ARGS."""
        self.tk.call(
            (self._w, 'tag', 'add', tagName, index1) + args)
    def tag_unbind(self, tagName, sequence, funcid=None):
        """Unbind for all characters with TAGNAME for event SEQUENCE  the
        function identified with FUNCID."""
        self.tk.call(self._w, 'tag', 'bind', tagName, sequence, '')
        if funcid:
            self.deletecommand(funcid)
    def tag_bind(self, tagName, sequence, func, add=None):
        """Bind to all characters with TAGNAME at event SEQUENCE a call to function FUNC.

        An additional boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or whether it will
        replace the previous function. See bind for the return value."""
        return self._bind((self._w, 'tag', 'bind', tagName),
                  sequence, func, add)
    def tag_cget(self, tagName, option):
        """Return the value of OPTION for tag TAGNAME."""
        if option[:1] != '-':
            option = '-' + option
        if option[-1:] == '_':
            option = option[:-1]
        return self.tk.call(self._w, 'tag', 'cget', tagName, option)
    def tag_configure(self, tagName, cnf=None, **kw):
        """Configure a tag TAGNAME."""
        return self._configure(('tag', 'configure', tagName), cnf, kw)
    tag_config = tag_configure
    def tag_delete(self, *tagNames):
        """Delete all tags in TAGNAMES."""
        self.tk.call((self._w, 'tag', 'delete') + tagNames)
    def tag_lower(self, tagName, belowThis=None):
        """Change the priority of tag TAGNAME such that it is lower
        than the priority of BELOWTHIS."""
        self.tk.call(self._w, 'tag', 'lower', tagName, belowThis)
    def tag_names(self, index=None):
        """Return a list of all tag names."""
        return self.tk.splitlist(
            self.tk.call(self._w, 'tag', 'names', index))
    def tag_nextrange(self, tagName, index1, index2=None):
        """Return a list of start and end index for the first sequence of
        characters between INDEX1 and INDEX2 which all have tag TAGNAME.
        The text is searched forward from INDEX1."""
        return self.tk.splitlist(self.tk.call(
            self._w, 'tag', 'nextrange', tagName, index1, index2))
    def tag_prevrange(self, tagName, index1, index2=None):
        """Return a list of start and end index for the first sequence of
        characters between INDEX1 and INDEX2 which all have tag TAGNAME.
        The text is searched backwards from INDEX1."""
        return self.tk.splitlist(self.tk.call(
            self._w, 'tag', 'prevrange', tagName, index1, index2))
    def tag_raise(self, tagName, aboveThis=None):
        """Change the priority of tag TAGNAME such that it is higher
        than the priority of ABOVETHIS."""
        self.tk.call(
            self._w, 'tag', 'raise', tagName, aboveThis)
    def tag_ranges(self, tagName):
        """Return a list of ranges of text which have tag TAGNAME."""
        return self.tk.splitlist(self.tk.call(
            self._w, 'tag', 'ranges', tagName))
    def tag_remove(self, tagName, index1, index2=None):
        """Remove tag TAGNAME from all characters between INDEX1 and INDEX2."""
        self.tk.call(
            self._w, 'tag', 'remove', tagName, index1, index2)
    def window_cget(self, index, option):
        """Return the value of OPTION of an embedded window at INDEX."""
        if option[:1] != '-':
            option = '-' + option
        if option[-1:] == '_':
            option = option[:-1]
        return self.tk.call(self._w, 'window', 'cget', index, option)
    def window_configure(self, index, cnf=None, **kw):
        """Configure an embedded window at INDEX."""
        return self._configure(('window', 'configure', index), cnf, kw)
    window_config = window_configure
    def window_create(self, index, cnf={}, **kw):
        """Create a window at INDEX."""
        self.tk.call(
              (self._w, 'window', 'create', index)
              + self._options(cnf, kw))
    def window_names(self):
        """Return all names of embedded windows in this widget."""
        return self.tk.splitlist(
            self.tk.call(self._w, 'window', 'names'))
    def yview_pickplace(self, *what):
        """Obsolete function, use see."""
        self.tk.call((self._w, 'yview', '-pickplace') + what)


class _setit:
    """Internal class. It wraps the command in the widget OptionMenu."""
    def __init__(self, var, value, callback=None):
        self.__value = value
        self.__var = var
        self.__callback = callback
    def __call__(self, *args):
        self.__var.set(self.__value)
        if self.__callback:
            self.__callback(self.__value, *args)

class OptionMenu(Menubutton):
    """OptionMenu which allows the user to select a value from a menu."""
    def __init__(self, master, variable, value, *values, **kwargs):
        """Construct an optionmenu widget with the parent MASTER, with
        the resource textvariable set to VARIABLE, the initially selected
        value VALUE, the other menu values VALUES and an additional
        keyword argument command."""
        kw = {"borderwidth": 2, "textvariable": variable,
              "indicatoron": 1, "relief": RAISED, "anchor": "c",
              "highlightthickness": 2}
        Widget.__init__(self, master, "menubutton", kw)
        self.widgetName = 'tk_optionMenu'
        menu = self.__menu = Menu(self, name="menu", tearoff=0)
        self.menuname = menu._w
        # 'command' is the only supported keyword
        callback = kwargs.get('command')
        if 'command' in kwargs:
            del kwargs['command']
        if kwargs:
            raise TclError, 'unknown option -'+kwargs.keys()[0]
        menu.add_command(label=value,
                 command=_setit(variable, value, callback))
        for v in values:
            menu.add_command(label=v,
                     command=_setit(variable, v, callback))
        self["menu"] = menu

    def __getitem__(self, name):
        if name == 'menu':
            return self.__menu
        return Widget.__getitem__(self, name)

    def destroy(self):
        """Destroy this widget and the associated menu."""
        Menubutton.destroy(self)
        self.__menu = None

class Image:
    """Base class for images."""
    _last_id = 0
    def __init__(self, imgtype, name=None, cnf={}, master=None, **kw):
        self.name = None
        if not master:
            master = _default_root
            if not master:
                raise RuntimeError, 'Too early to create image'
        self.tk = getattr(master, 'tk', master)
        if not name:
            Image._last_id += 1
            name = "pyimage%r" % (Image._last_id,) # tk itself would use image<x>
            # The following is needed for systems where id(x)
            # can return a negative number, such as Linux/m68k:
            if name[0] == '-': name = '_' + name[1:]
        if kw and cnf: cnf = _cnfmerge((cnf, kw))
        elif kw: cnf = kw
        options = ()
        for k, v in cnf.items():
            if hasattr(v, '__call__'):
                v = self._register(v)
            elif k in ('data', 'maskdata'):
                v = self.tk._createbytearray(v)
            options = options + ('-'+k, v)
        self.tk.call(('image', 'create', imgtype, name,) + options)
        self.name = name
    def __str__(self): return self.name
    def __del__(self):
        if self.name:
            try:
                self.tk.call('image', 'delete', self.name)
            except TclError:
                # May happen if the root was destroyed
                pass
    def __setitem__(self, key, value):
        self.tk.call(self.name, 'configure', '-'+key, value)
    def __getitem__(self, key):
        return self.tk.call(self.name, 'configure', '-'+key)
    def configure(self, **kw):
        """Configure the image."""
        res = ()
        for k, v in _cnfmerge(kw).items():
            if v is not None:
                if k[-1] == '_': k = k[:-1]
                if hasattr(v, '__call__'):
                    v = self._register(v)
                elif k in ('data', 'maskdata'):
                    v = self.tk._createbytearray(v)
                res = res + ('-'+k, v)
        self.tk.call((self.name, 'config') + res)
    config = configure
    def height(self):
        """Return the height of the image."""
        return getint(
            self.tk.call('image', 'height', self.name))
    def type(self):
        """Return the type of the imgage, e.g. "photo" or "bitmap"."""
        return self.tk.call('image', 'type', self.name)
    def width(self):
        """Return the width of the image."""
        return getint(
            self.tk.call('image', 'width', self.name))

class PhotoImage(Image):
    """Widget which can display colored images in GIF, PPM/PGM format."""
    def __init__(self, name=None, cnf={}, master=None, **kw):
        """Create an image with NAME.

        Valid resource names: data, format, file, gamma, height, palette,
        width."""
        Image.__init__(self, 'photo', name, cnf, master, **kw)
    def blank(self):
        """Display a transparent image."""
        self.tk.call(self.name, 'blank')
    def cget(self, option):
        """Return the value of OPTION."""
        return self.tk.call(self.name, 'cget', '-' + option)
    # XXX config
    def __getitem__(self, key):
        return self.tk.call(self.name, 'cget', '-' + key)
    # XXX copy -from, -to, ...?
    def copy(self):
        """Return a new PhotoImage with the same image as this widget."""
        destImage = PhotoImage(master=self.tk)
        self.tk.call(destImage, 'copy', self.name)
        return destImage
    def zoom(self, x, y=''):
        """Return a new PhotoImage with the same image as this widget
        but zoom it with a factor of x in the X direction and y in the Y
        direction.  If y is not given, the default value is the same as x.
        """
        destImage = PhotoImage(master=self.tk)
        if y=='': y=x
        self.tk.call(destImage, 'copy', self.name, '-zoom',x,y)
        return destImage
    def subsample(self, x, y=''):
        """Return a new PhotoImage based on the same image as this widget
        but use only every Xth or Yth pixel.  If y is not given, the
        default value is the same as x.
        """
        destImage = PhotoImage(master=self.tk)
        if y=='': y=x
        self.tk.call(destImage, 'copy', self.name, '-subsample',x,y)
        return destImage
    def get(self, x, y):
        """Return the color (red, green, blue) of the pixel at X,Y."""
        return self.tk.call(self.name, 'get', x, y)
    def put(self, data, to=None):
        """Put row formatted colors to image starting from
        position TO, e.g. image.put("{red green} {blue yellow}", to=(4,6))"""
        args = (self.name, 'put', data)
        if to:
            if to[0] == '-to':
                to = to[1:]
            args = args + ('-to',) + tuple(to)
        self.tk.call(args)
    # XXX read
    def write(self, filename, format=None, from_coords=None):
        """Write image to file FILENAME in FORMAT starting from
        position FROM_COORDS."""
        args = (self.name, 'write', filename)
        if format:
            args = args + ('-format', format)
        if from_coords:
            args = args + ('-from',) + tuple(from_coords)
        self.tk.call(args)

class BitmapImage(Image):
    """Widget which can display a bitmap."""
    def __init__(self, name=None, cnf={}, master=None, **kw):
        """Create a bitmap with NAME.

        Valid resource names: background, data, file, foreground, maskdata, maskfile."""
        Image.__init__(self, 'bitmap', name, cnf, master, **kw)

def image_names():
    return _default_root.tk.splitlist(_default_root.tk.call('image', 'names'))

def image_types():
    return _default_root.tk.splitlist(_default_root.tk.call('image', 'types'))


class Spinbox(Widget, XView):
    """spinbox widget."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a spinbox widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, background, borderwidth,
            cursor, exportselection, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, insertbackground,
            insertborderwidth, insertofftime,
            insertontime, insertwidth, justify, relief,
            repeatdelay, repeatinterval,
            selectbackground, selectborderwidth
            selectforeground, takefocus, textvariable
            xscrollcommand.

        WIDGET-SPECIFIC OPTIONS

            buttonbackground, buttoncursor,
            buttondownrelief, buttonuprelief,
            command, disabledbackground,
            disabledforeground, format, from,
            invalidcommand, increment,
            readonlybackground, state, to,
            validate, validatecommand values,
            width, wrap,
        """
        Widget.__init__(self, master, 'spinbox', cnf, kw)

    def bbox(self, index):
        """Return a tuple of X1,Y1,X2,Y2 coordinates for a
        rectangle which encloses the character given by index.

        The first two elements of the list give the x and y
        coordinates of the upper-left corner of the screen
        area covered by the character (in pixels relative
        to the widget) and the last two elements give the
        width and height of the character, in pixels. The
        bounding box may refer to a region outside the
        visible area of the window.
        """
        return self._getints(self.tk.call(self._w, 'bbox', index)) or None

    def delete(self, first, last=None):
        """Delete one or more elements of the spinbox.

        First is the index of the first character to delete,
        and last is the index of the character just after
        the last one to delete. If last isn't specified it
        defaults to first+1, i.e. a single character is
        deleted.  This command returns an empty string.
        """
        return self.tk.call(self._w, 'delete', first, last)

    def get(self):
        """Returns the spinbox's string"""
        return self.tk.call(self._w, 'get')

    def icursor(self, index):
        """Alter the position of the insertion cursor.

        The insertion cursor will be displayed just before
        the character given by index. Returns an empty string
        """
        return self.tk.call(self._w, 'icursor', index)

    def identify(self, x, y):
        """Returns the name of the widget at position x, y

        Return value is one of: none, buttondown, buttonup, entry
        """
        return self.tk.call(self._w, 'identify', x, y)

    def index(self, index):
        """Returns the numerical index corresponding to index
        """
        return self.tk.call(self._w, 'index', index)

    def insert(self, index, s):
        """Insert string s at index

         Returns an empty string.
        """
        return self.tk.call(self._w, 'insert', index, s)

    def invoke(self, element):
        """Causes the specified element to be invoked

        The element could be buttondown or buttonup
        triggering the action associated with it.
        """
        return self.tk.call(self._w, 'invoke', element)

    def scan(self, *args):
        """Internal function."""
        return self._getints(
            self.tk.call((self._w, 'scan') + args)) or ()

    def scan_mark(self, x):
        """Records x and the current view in the spinbox window;

        used in conjunction with later scan dragto commands.
        Typically this command is associated with a mouse button
        press in the widget. It returns an empty string.
        """
        return self.scan("mark", x)

    def scan_dragto(self, x):
        """Compute the difference between the given x argument
        and the x argument to the last scan mark command

        It then adjusts the view left or right by 10 times the
        difference in x-coordinates. This command is typically
        associated with mouse motion events in the widget, to
        produce the effect of dragging the spinbox at high speed
        through the window. The return value is an empty string.
        """
        return self.scan("dragto", x)

    def selection(self, *args):
        """Internal function."""
        return self._getints(
            self.tk.call((self._w, 'selection') + args)) or ()

    def selection_adjust(self, index):
        """Locate the end of the selection nearest to the character
        given by index,

        Then adjust that end of the selection to be at index
        (i.e including but not going beyond index). The other
        end of the selection is made the anchor point for future
        select to commands. If the selection isn't currently in
        the spinbox, then a new selection is created to include
        the characters between index and the most recent selection
        anchor point, inclusive. Returns an empty string.
        """
        return self.selection("adjust", index)

    def selection_clear(self):
        """Clear the selection

        If the selection isn't in this widget then the
        command has no effect. Returns an empty string.
        """
        return self.selection("clear")

    def selection_element(self, element=None):
        """Sets or gets the currently selected element.

        If a spinbutton element is specified, it will be
        displayed depressed
        """
        return self.selection("element", element)

###########################################################################

class LabelFrame(Widget):
    """labelframe widget."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a labelframe widget with the parent MASTER.

        STANDARD OPTIONS

            borderwidth, cursor, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, padx, pady, relief,
            takefocus, text

        WIDGET-SPECIFIC OPTIONS

            background, class, colormap, container,
            height, labelanchor, labelwidget,
            visual, width
        """
        Widget.__init__(self, master, 'labelframe', cnf, kw)

########################################################################

class PanedWindow(Widget):
    """panedwindow widget."""
    def __init__(self, master=None, cnf={}, **kw):
        """Construct a panedwindow widget with the parent MASTER.

        STANDARD OPTIONS

            background, borderwidth, cursor, height,
            orient, relief, width

        WIDGET-SPECIFIC OPTIONS

            handlepad, handlesize, opaqueresize,
            sashcursor, sashpad, sashrelief,
            sashwidth, showhandle,
        """
        Widget.__init__(self, master, 'panedwindow', cnf, kw)

    def add(self, child, **kw):
        """Add a child widget to the panedwindow in a new pane.

        The child argument is the name of the child widget
        followed by pairs of arguments that specify how to
        manage the windows. The possible options and values
        are the ones accepted by the paneconfigure method.
        """
        self.tk.call((self._w, 'add', child) + self._options(kw))

    def remove(self, child):
        """Remove the pane containing child from the panedwindow

        All geometry management options for child will be forgotten.
        """
        self.tk.call(self._w, 'forget', child)
    forget=remove

    def identify(self, x, y):
        """Identify the panedwindow component at point x, y

        If the point is over a sash or a sash handle, the result
        is a two element list containing the index of the sash or
        handle, and a word indicating whether it is over a sash
        or a handle, such as {0 sash} or {2 handle}. If the point
        is over any other part of the panedwindow, the result is
        an empty list.
        """
        return self.tk.call(self._w, 'identify', x, y)

    def proxy(self, *args):
        """Internal function."""
        return self._getints(
            self.tk.call((self._w, 'proxy') + args)) or ()

    def proxy_coord(self):
        """Return the x and y pair of the most recent proxy location
        """
        return self.proxy("coord")

    def proxy_forget(self):
        """Remove the proxy from the display.
        """
        return self.proxy("forget")

    def proxy_place(self, x, y):
        """Place the proxy at the given x and y coordinates.
        """
        return self.proxy("place", x, y)

    def sash(self, *args):
        """Internal function."""
        return self._getints(
            self.tk.call((self._w, 'sash') + args)) or ()

    def sash_coord(self, index):
        """Return the current x and y pair for the sash given by index.

        Index must be an integer between 0 and 1 less than the
        number of panes in the panedwindow. The coordinates given are
        those of the top left corner of the region containing the sash.
        pathName sash dragto index x y This command computes the
        difference between the given coordinates and the coordinates
        given to the last sash coord command for the given sash. It then
        moves that sash the computed difference. The return value is the
        empty string.
        """
        return self.sash("coord", index)

    def sash_mark(self, index):
        """Records x and y for the sash given by index;

        Used in conjunction with later dragto commands to move the sash.
        """
        return self.sash("mark", index)

    def sash_place(self, index, x, y):
        """Place the sash given by index at the given coordinates
        """
        return self.sash("place", index, x, y)

    def panecget(self, child, option):
        """Query a management option for window.

        Option may be any value allowed by the paneconfigure subcommand
        """
        return self.tk.call(
            (self._w, 'panecget') + (child, '-'+option))

    def paneconfigure(self, tagOrId, cnf=None, **kw):
        """Query or modify the management options for window.

        If no option is specified, returns a list describing all
        of the available options for pathName.  If option is
        specified with no value, then the command returns a list
        describing the one named option (this list will be identical
        to the corresponding sublist of the value returned if no
        option is specified). If one or more option-value pairs are
        specified, then the command modifies the given widget
        option(s) to have the given value(s); in this case the
        command returns an empty string. The following options
        are supported:

        after window
            Insert the window after the window specified. window
            should be the name of a window already managed by pathName.
        before window
            Insert the window before the window specified. window
            should be the name of a window already managed by pathName.
        height size
            Specify a height for the window. The height will be the
            outer dimension of the window including its border, if
            any. If size is an empty string, or if -height is not
            specified, then the height requested internally by the
            window will be used initially; the height may later be
            adjusted by the movement of sashes in the panedwindow.
            Size may be any value accepted by Tk_GetPixels.
        minsize n
            Specifies that the size of the window cannot be made
            less than n. This constraint only affects the size of
            the widget in the paned dimension -- the x dimension
            for horizontal panedwindows, the y dimension for
            vertical panedwindows. May be any value accepted by
            Tk_GetPixels.
        padx n
            Specifies a non-negative value indicating how much
            extra space to leave on each side of the window in
            the X-direction. The value may have any of the forms
            accepted by Tk_GetPixels.
        pady n
            Specifies a non-negative value indicating how much
            extra space to leave on each side of the window in
            the Y-direction. The value may have any of the forms
            accepted by Tk_GetPixels.
        sticky style
            If a window's pane is larger than the requested
            dimensions of the window, this option may be used
            to position (or stretch) the window within its pane.
            Style is a string that contains zero or more of the
            characters n, s, e or w. The string can optionally
            contains spaces or commas, but they are ignored. Each
            letter refers to a side (north, south, east, or west)
            that the window will "stick" to. If both n and s
            (or e and w) are specified, the window will be
            stretched to fill the entire height (or width) of
            its cavity.
        width size
            Specify a width for the window. The width will be
            the outer dimension of the window including its
            border, if any. If size is an empty string, or
            if -width is not specified, then the width requested
            internally by the window will be used initially; the
            width may later be adjusted by the movement of sashes
            in the panedwindow. Size may be any value accepted by
            Tk_GetPixels.

        """
        if cnf is None and not kw:
            return self._getconfigure(self._w, 'paneconfigure', tagOrId)
        if type(cnf) == StringType and not kw:
            return self._getconfigure1(
                self._w, 'paneconfigure', tagOrId, '-'+cnf)
        self.tk.call((self._w, 'paneconfigure', tagOrId) +
                 self._options(cnf, kw))
    paneconfig = paneconfigure

    def panes(self):
        """Returns an ordered list of the child panes."""
        return self.tk.splitlist(self.tk.call(self._w, 'panes'))

######################################################################
# Extensions:

class Studbutton(Button):
    def __init__(self, master=None, cnf={}, **kw):
        Widget.__init__(self, master, 'studbutton', cnf, kw)
        self.bind('<Any-Enter>',       self.tkButtonEnter)
        self.bind('<Any-Leave>',       self.tkButtonLeave)
        self.bind('<1>',               self.tkButtonDown)
        self.bind('<ButtonRelease-1>', self.tkButtonUp)

class Tributton(Button):
    def __init__(self, master=None, cnf={}, **kw):
        Widget.__init__(self, master, 'tributton', cnf, kw)
        self.bind('<Any-Enter>',       self.tkButtonEnter)
        self.bind('<Any-Leave>',       self.tkButtonLeave)
        self.bind('<1>',               self.tkButtonDown)
        self.bind('<ButtonRelease-1>', self.tkButtonUp)
        self['fg']               = self['bg']
        self['activebackground'] = self['bg']

######################################################################
# Test:

def _test():
    root = Tk()
    text = "This is Tcl/Tk version %s" % TclVersion
    if TclVersion >= 8.1:
        try:
            text = text + unicode("\nThis should be a cedilla: \347",
                                  "iso-8859-1")
        except NameError:
            pass # no unicode support
    label = Label(root, text=text)
    label.pack()
    test = Button(root, text="Click me!",
              command=lambda root=root: root.test.configure(
                  text="[%s]" % root.test['text']))
    test.pack()
    root.test = test
    quit = Button(root, text="QUIT", command=root.destroy)
    quit.pack()
    # The following three commands are needed so the window pops
    # up on top on Windows...
    root.iconify()
    root.update()
    root.deiconify()
    root.mainloop()

if __name__ == '__main__':
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
[c           @   s*  d  Z  d Z d d l Z e j d k r6 d d l Z n  y d d l Z Wn& e k
 rn Z e e e  d  n Xe Z	 e j
 Z
 d d l Td d l Td d l Z d Z e e j  Z e e j  Z e j Z e j Z e j Z y e j Wn e k
 re e _ n Xy e j Wn e k
 r,e e _ n Xe j d  Z e j d	  Z d
   Z d   Z d   Z  y e j  Z  Wn e k
 rn Xd   Z! y e j! Z! Wn e k
 rn Xe" e d  Z# d f  d     YZ$ d a% e a& d   Z' d   Z( d d  Z) d a* d f  d     YZ+ d e+ f d     YZ, d e+ f d     YZ- d e+ f d     YZ. d e+ f d     YZ/ d d  Z0 e1 Z2 e Z3 d    Z4 d! f  d"     YZ5 d# f  d$     YZ6 d% f  d&     YZ7 d' f  d(     YZ8 d) f  d*     YZ9 d+ e5 e9 f d,     YZ: e e d+ d d-  Z; d. f  d/     YZ< d0 f  d1     YZ= d2 f  d3     YZ> d4 e5 f d5     YZ? d6 e? e< e= e> f d7     YZ@ d8 e? e9 f d9     YZA d: e@ f d;     YZB d<   ZC d=   ZD d>   ZE d?   ZF e d@  ZG dA e@ e7 e8 f dB     YZH dC e@ f dD     YZI dE e@ e7 f dF     YZJ dG e@ f dH     YZK dI e@ f dJ     YZL dK e@ e7 e8 f dL     YZM dM e@ f dN     YZN dO e@ f dP     YZO dQ e@ f dR     YZP dS e@ f dT     YZQ dU e@ f dV     YZR dW e@ f dX     YZS dY e@ e7 e8 f dZ     YZT d[ f  d\     YZU d] eO f d^     YZV d_ f  d`     YZW da eW f db     YZX dc eW f dd     YZY de   ZZ df   Z[ dg e@ e7 f dh     YZ\ di e@ f dj     YZ] dk e@ f dl     YZ^ dm eB f dn     YZ_ do eB f dp     YZ` dq   Za eb dr k r&ea   n  d S(s   s2  Wrapper functions for Tcl/Tk.

Tkinter provides classes which allow the display, positioning and
control of widgets. Toplevel widgets are Tk and Toplevel. Other
widgets are Frame, Label, Entry, Text, Canvas, Button, Radiobutton,
Checkbutton, Scale, Listbox, Scrollbar, OptionMenu, Spinbox
LabelFrame and PanedWindow.

Properties of the widgets are specified with keyword arguments.
Keyword arguments have the same name as the corresponding resource
under Tk.

Widgets are positioned with one of the geometry managers Place, Pack
or Grid. These managers can be called with methods place, pack, grid
available in every Widget.

Actions are bound to events by resources (e.g. keyword argument
command) or with the method bind.

Example (Hello, World):
import Tkinter
from Tkconstants import *
tk = Tkinter.Tk()
frame = Tkinter.Frame(tk, relief=RIDGE, borderwidth=2)
frame.pack(fill=BOTH,expand=1)
label = Tkinter.Label(frame, text="Hello, World")
label.pack(fill=X, expand=1)
button = Tkinter.Button(frame,text="Exit",command=tk.destroy)
button.pack(side=BOTTOM)
tk.mainloop()
s   $Revision: 81008 $iNt   win32s&   , please install the python-tk package(   t   *i   s   ([\\{}])s   ([\s])c         C   s   d j  t t |    S(   s   Internal function.t    (   t   joint   mapt
   _stringify(   t   value(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _joinD   s    c         C   s  t  |  t t f  rj t |   d k rW t |  d  }  |  d d k rg d |  }  qg qd t |   }  n t  |  t  r t |  d  }  n t  |  t  s t |   }  n  |  s d }  nb t j	 |   r t j
 d |   }  t j
 d |   }  n, |  d d k st j	 |   rd |  }  n  |  S(	   s   Internal function.i   i    t   {s   {%s}s   utf-8s   {}s   \\\1t   "(   t
   isinstancet   listt   tuplet   lenR   R   t   strt   unicodet	   _magic_ret   searcht   subt	   _space_re(   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   H   s$    	c         C   sb   d } xU |  D]M } t  |  t t f k r> | t |  } q | d k	 r | | f } q q W| S(   s   Internal function.(    N(   t   typet	   TupleTypet   ListTypet   _flattent   None(   R   t   rest   item(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   `   s    c         C   s   t  |   t k r |  St  |   t t f k r2 |  Si  } xq t |   D]c } y | j |  WqE t t f k
 r } d G| GHx( | j   D] \ } } | | | <q WqE XqE W| Sd S(   s   Internal function.s   _cnfmerge: fallback due to:N(	   R   t   DictionaryTypet   NoneTypet
   StringTypeR   t   updatet   AttributeErrort	   TypeErrort   items(   t   cnfst   cnft   ct   msgt   kt   v(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   _cnfmergem   s    	c   	      C   s   |  j  |  } t |  d r. t d   n  t |  } i  } xk t | |  D]Z \ } } t |  } | r | d d k r | d } n  | r | |  } n  | | | <qP W| S(   s  Return a properly formatted dict built from Tcl list pairs.

    If cut_minus is True, the supposed '-' prefix will be removed from
    keys. If conv is specified, it is used to convert values.

    Tcl list is expected to contain an even number of elements.
    i   sN   Tcl list representing a dict is expected to contain an even number of elementsi    t   -i   (   t	   splitlistR   t   RuntimeErrort   itert   zipR   (	   t   tkR'   t	   cut_minust   convt   tt   itt   dictt   keyR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   _splitdict   s    t   Eventc           B   s   e  Z d  Z RS(   s  Container for the properties of an event.

    Instances of this type are generated if one of the following events occurs:

    KeyPress, KeyRelease - for keyboard events
    ButtonPress, ButtonRelease, Motion, Enter, Leave, MouseWheel - for mouse events
    Visibility, Unmap, Map, Expose, FocusIn, FocusOut, Circulate,
    Colormap, Gravity, Reparent, Property, Destroy, Activate,
    Deactivate - for window events.

    If a callback function for one of these events is registered
    using bind, bind_all, bind_class, or tag_bind, the callback is
    called with an Event as first argument. It will have the
    following attributes (in braces are the event types for which
    the attribute is valid):

        serial - serial number of event
    num - mouse button pressed (ButtonPress, ButtonRelease)
    focus - whether the window has the focus (Enter, Leave)
    height - height of the exposed window (Configure, Expose)
    width - width of the exposed window (Configure, Expose)
    keycode - keycode of the pressed key (KeyPress, KeyRelease)
    state - state of the event as a number (ButtonPress, ButtonRelease,
                            Enter, KeyPress, KeyRelease,
                            Leave, Motion)
    state - state as a string (Visibility)
    time - when the event occurred
    x - x-position of the mouse
    y - y-position of the mouse
    x_root - x-position of the mouse on the screen
             (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
    y_root - y-position of the mouse on the screen
             (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
    char - pressed character (KeyPress, KeyRelease)
    send_event - see X/Windows documentation
    keysym - keysym of the event as a string (KeyPress, KeyRelease)
    keysym_num - keysym of the event as a number (KeyPress, KeyRelease)
    type - type of the event as a number
    widget - widget in which the event occurred
    delta - delta of wheel movement (MouseWheel)
    (   t   __name__t
   __module__t   __doc__(    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR6      s   )c           C   s   d a  d a b d S(   s   Inhibit setting of default root window.

    Call this function to inhibit that the first instance of
    Tk is used for windows without an explicit parent window.
    i    N(   t   _support_default_rootR   t   _default_root(    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   NoDefaultRoot   s    c         C   s   d S(   s   Internal function.N(    (   t   err(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _tkerror   s    i    c         C   s1   y t  |   }  Wn t k
 r# n Xt |   d S(   sB   Internal function. Calling it will raise the exception SystemExit.N(   t   intt
   ValueErrort
   SystemExit(   t   code(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _exit   s
    t   Variablec           B   sz   e  Z d  Z d Z d Z d d d d  Z d   Z d   Z d   Z	 d   Z
 d   Z e Z d   Z d	   Z d
   Z RS(   s   Class to define value holders for e.g. buttons.

    Subclasses StringVar, IntVar, DoubleVar, BooleanVar are specializations
    that constrain the type of the value returned from get().t    c         C   s   | s t  } n  | j   |  _ | j |  _ | r< | |  _ n d t t  |  _ t d 7a | d k	 ru |  j |  n: |  j j	 |  j j
 d d |  j   s |  j |  j  n  d S(   s.  Construct a variable

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to "")
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        t   PY_VARi   t   infot   existsN(   R;   t   _rootR.   t   _tkt   _namet   reprt   _varnumR   t   sett
   getbooleant   callt   _default(   t   selft   masterR   t   name(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __init__   s    	
'c         C   s   |  j  d k r d S|  j  j |  j  j d d |  j   rP |  j  j |  j  n  |  j d k	 r x! |  j D] } |  j  j |  qi Wd |  _ n  d S(   s   Unset the variable in Tcl.NRG   RH   (   RJ   R   RO   RP   RK   t   globalunsetvart   _tclCommandst   deletecommand(   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __del__   s    'c         C   s   |  j  S(   s'   Return the name of the variable in Tcl.(   RK   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __str__
  s    c         C   s   |  j  j |  j |  S(   s   Set the variable to VALUE.(   RJ   t   globalsetvarRK   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRN     s    c         C   s   |  j  j |  j  S(   s   Return value of variable.(   RJ   t   globalgetvarRK   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   get  s    c         C   s   t  | d |  j  j } t t |   } y | j } Wn t k
 rJ n Xy | | j } Wn t k
 ro n X|  j	 j
 | |  |  j d k r g  |  _ n  |  j j |  |  j	 j d d |  j | |  | S(   s
  Define a trace callback for the variable.

        MODE is one of "r", "w", "u" for read, write, undefine.
        CALLBACK must be a function which is called when
        the variable is read, written or undefined.

        Return the name of the callback.
        t   tracet   variableN(   t   CallWrapperR   RI   t   __call__RL   t   idt   im_funcR   R7   RJ   t   createcommandRW   t   appendRP   RK   (   RR   t   modet   callbackt   ft   cbname(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   trace_variable  s     	c         C   s   |  j  j d d |  j | |  |  j  j |  d } xr |  j   D], \ } } |  j  j |  d | k rB PqB qB W|  j  j |  y |  j j |  Wn t k
 r n Xd S(   s   Delete the trace callback for a variable.

        MODE is one of "r", "w", "u" for read, write, undefine.
        CBNAME is the name of the callback returned from trace_variable or trace.
        R^   t   vdeletei    N(	   RJ   RP   RK   R*   t   trace_vinfoRX   RW   t   removeR@   (   RR   Rf   Ri   t   mt   ca(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   trace_vdelete-  s    c         C   s4   t  |  j j |  j j |  j j d d |  j    S(   s&   Return all trace callback information.R^   t   vinfo(   R   RJ   R*   RP   RK   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRl   >  s    c         C   s(   |  j  j | j  j k o' |  j | j k S(   s   Comparison for equality (==).

        Note: if the Variable's master matters to behavior
        also compare self._master == other._master
        (   t	   __class__R7   RK   (   RR   t   other(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __eq__B  s    N(   R7   R8   R9   RQ   R   RW   RU   RY   RZ   RN   R]   Rj   R^   Rp   Rl   Rt   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRD      s   							t	   StringVarc           B   s/   e  Z d  Z d Z d d d d  Z d   Z RS(   s#   Value holder for strings variables.RE   c         C   s   t  j |  | | |  d S(   s6  Construct a string variable.

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to "")
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        N(   RD   RU   (   RR   RS   R   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   N  s    
c         C   s2   |  j  j |  j  } t | t  r( | St |  S(   s#   Return value of variable as string.(   RJ   R\   RK   R
   t
   basestringR   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]   Z  s    N(   R7   R8   R9   RQ   R   RU   R]   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRu   K  s   t   IntVarc           B   s8   e  Z d  Z d Z d d d d  Z d   Z d   Z RS(   s#   Value holder for integer variables.i    c         C   s   t  j |  | | |  d S(   s7  Construct an integer variable.

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to 0)
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        N(   RD   RU   (   RR   RS   R   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   d  s    
c         C   s.   t  | t  r t |  } n  t j |  |  S(   s;   Set the variable to value, converting booleans to integers.(   R
   t   boolR?   RD   RN   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRN   p  s    c         C   s   t  |  j j |  j   S(   s/   Return the value of the variable as an integer.(   t   getintRJ   R\   RK   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]   v  s    N(   R7   R8   R9   RQ   R   RU   RN   R]   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRw   a  s
   	t	   DoubleVarc           B   s/   e  Z d  Z d Z d d d d  Z d   Z RS(   s!   Value holder for float variables.g        c         C   s   t  j |  | | |  d S(   s6  Construct a float variable.

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to 0.0)
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        N(   RD   RU   (   RR   RS   R   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   }  s    
c         C   s   t  |  j j |  j   S(   s,   Return the value of the variable as a float.(   t	   getdoubleRJ   R\   RK   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]     s    N(   R7   R8   R9   RQ   R   RU   R]   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRz   z  s   t
   BooleanVarc           B   s8   e  Z d  Z e Z d d d d  Z d   Z d   Z RS(   s#   Value holder for boolean variables.c         C   s   t  j |  | | |  d S(   s:  Construct a boolean variable.

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to False)
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        N(   RD   RU   (   RR   RS   R   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s    
c         C   s"   |  j  j |  j |  j  j |   S(   s   Set the variable to VALUE.(   RJ   R[   RK   RO   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRN     s    c         C   s   |  j  j |  j  j |  j   S(   s+   Return the value of the variable as a bool.(   RJ   RO   R\   RK   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]     s    N(	   R7   R8   R9   t   FalseRQ   R   RU   RN   R]   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR|     s
   	c         C   s   t  j j |   d S(   s   Run the main loop of Tcl.N(   R;   R.   t   mainloop(   t   n(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR~     s    c         C   s   t  j j |   S(   s1   Convert true and false to integer values 1 and 0.(   R;   R.   RO   (   t   s(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRO     s    t   Miscc           B   sD  e  Z d  Z d Z d   Z d   Z d d  Z d   Z d   Z	 d   Z
 d d  Z e Z d d	  Z d d
  Z d d d  Z d d  Z e Z e Z d   Z d   Z e Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d d  Z d   Z  d   Z! d d  Z" d   Z# d   Z$ d   Z% d   Z& d    Z' d!   Z( d"   Z) d#   Z* d d$  Z+ d%   Z, d&   Z- d d'  Z. d(   Z/ d)   Z0 d*   Z1 d+   Z2 d,   Z3 d-   Z4 d d.  Z5 d d/  Z6 e6 Z7 d d0  Z8 d d1  Z9 d d2  Z: d3   Z; d4   Z< d5   Z= d6   Z> d d7  Z? d8   Z@ d9   ZA d:   ZB d;   ZC d<   ZD d=   ZE d d>  ZF d?   ZG d@   ZH dA   ZI dB   ZJ d dC  ZK dD   ZL dE   ZM dF   ZN dG   ZO dH   ZP dI   ZQ dJ   ZR dK   ZS dL   ZT dM   ZU dN   ZV dO   ZW dP   ZX dQ   ZY dR   ZZ dS   Z[ dT   Z\ dU   Z] dV   Z^ dW   Z_ dX   Z` dY   Za d dZ  Zb d[   Zc d\   Zd d]   Ze d^   Zf d_   Zg d`   Zh da   Zi db   Zj dc   Zk dd   Zl de   Zm d df  Zn dg dh  Zo d d d di  Zp d dj  Zq d d d dk  Zr dl   Zs d d d dm  Zt dn   Zu d do  Zv dp   Zw dq   Zx dr   Zy ds   Zz dt   Z{ e| du    Z} d dv  Z~ dw   Z e Z d dg dx  Z e Z dy   Z d Z d j e  Z d   Z d   Z d   Z d   Z d   Z d d  Z e Z d   Z e Z d   Z d   Z d   Z d   Z d g Z e d  Z e Z d   Z e Z d   Z d d d d d  Z e Z d   Z d   Z i  d  Z e Z d   Z e d  Z i  d  Z e Z d   Z e Z d d d  Z d   Z d   Z d   Z d d  Z d   Z d   Z RS(   sR   Internal class.

    Base class which defines methods common for interior widgets.c         C   sC   |  j  d k	 r? x! |  j  D] } |  j j |  q Wd |  _  n  d S(   sk   Internal function.

        Delete all Tcl commands created for
        this widget in the Tcl interpreter.N(   RW   R   R.   RX   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   destroy  s    c         C   s<   |  j  j |  y |  j j |  Wn t k
 r7 n Xd S(   sD   Internal function.

        Delete the Tcl command provided in NAME.N(   R.   RX   RW   Rm   R@   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRX     s
    c         C   s"   |  j  j |  j  j d d |   S(   s   Set Tcl internal variable, whether the look and feel
        should adhere to Motif.

        A parameter of 1 means adhere to Motif (e.g. no color
        change if mouse passes over slider).
        Returns the set value.RN   t   tk_strictMotif(   R.   RO   RP   (   RR   t   boolean(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  j d  d S(   sD   Change the color scheme to light brown as used in Tk 3.6 and before.t	   tk_bisqueN(   R.   RP   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         O   s.   |  j  j d t |  t | j     d S(   s  Set a new color scheme for all widget elements.

        A single color as argument will cause that all colors of Tk
        widget elements are derived from this.
        Alternatively several keyword parameters and its associated
        colors can be given. The following keywords are valid:
        activeBackground, foreground, selectColor,
        activeForeground, highlightBackground, selectBackground,
        background, highlightColor, selectForeground,
        disabledForeground, insertBackground, troughColor.t   tk_setPaletteN(   R   (   R.   RP   R   R!   (   RR   t   argst   kw(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    	c         G   s&   d d l  } | j d t d d d S(   s)   Do not use. Needed in Tk 3.6 and earlier.iNs4   tk_menuBar() does nothing and will be removed in 3.6t
   stackleveli   (   t   warningst   warnt   DeprecationWarning(   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   tk_menuBar  s    	RF   c         C   s   |  j  j d d |  d S(   s   Wait until the variable is modified.

        A parameter of type IntVar, StringVar, DoubleVar or
        BooleanVar must be given.t   tkwaitR_   N(   R.   RP   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wait_variable  s    c         C   s2   | d k r |  } n  |  j j d d | j  d S(   sQ   Wait until a WIDGET is destroyed.

        If no parameter is given self is used.R   t   windowN(   R   R.   RP   t   _w(   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wait_window  s    	c         C   s2   | d k r |  } n  |  j j d d | j  d S(   sx   Wait until the visibility of a WIDGET changes
        (e.g. it appears).

        If no parameter is given self is used.R   t
   visibilityN(   R   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wait_visibility  s    	t   1c         C   s   |  j  j | |  d S(   s   Set Tcl variable NAME to VALUE.N(   R.   t   setvar(   RR   RT   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  j |  S(   s"   Return value of Tcl variable NAME.(   R.   t   getvar(   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  j |  S(   sP   Return a boolean value for Tcl boolean values true and false given as parameter.(   R.   RO   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRO   	  s    c         C   s   |  j  j d |  j  d S(   s   Direct input focus to this widget.

        If the application currently does not have the focus
        this widget will get the focus if the application gets
        the focus through the window manager.t   focusN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   focus_set  s    c         C   s   |  j  j d d |  j  d S(   st   Direct input focus to this widget even if the
        application does not have the focus. Use with
        caution!R   s   -forceN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   focus_force  s    c         C   s6   |  j  j d  } | d k s% | r) d S|  j |  S(   s   Return the widget which has currently the focus in the
        application.

        Use focus_displayof to allow working with several
        displays. Return None if application does not have
        the focus.R   t   noneN(   R.   RP   R   t   _nametowidget(   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   focus_get  s     c         C   s?   |  j  j d d |  j  } | d k s. | r2 d S|  j |  S(   s   Return the widget which has currently the focus on the
        display where this widget is located.

        Return None if the application does not have the focus.R   s
   -displayofR   N(   R.   RP   R   R   R   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   focus_displayof#  s     c         C   s?   |  j  j d d |  j  } | d k s. | r2 d S|  j |  S(   sy   Return the widget which would have the focus if top level
        for this widget gets the focus from the window manager.R   s   -lastforR   N(   R.   RP   R   R   R   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   focus_lastfor+  s     c         C   s   |  j  j d  d S(   sX   The widget under mouse will get automatically focus. Can not
        be disabled easily.t   tk_focusFollowsMouseN(   R.   RP   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   1  s    c         C   s/   |  j  j d |  j  } | s" d S|  j |  S(   sn  Return the next widget in the focus order which follows
        widget which has currently the focus.

        The focus order first goes to the next child, then to
        the children of the child recursively and then to the
        next sibling which is higher in the stacking order.  A
        widget is omitted if it has the takefocus resource set
        to 0.t   tk_focusNextN(   R.   RP   R   R   R   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   5  s    	 c         C   s/   |  j  j d |  j  } | s" d S|  j |  S(   sH   Return previous widget in the focus order. See tk_focusNext for details.t   tk_focusPrevN(   R.   RP   R   R   R   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   A  s     c            si    s  j  j d |  nI      f d   }  j | _  j |    j  j d |   Sd S(   s  Call function once after given time.

        MS specifies the time in milliseconds. FUNC gives the
        function which shall be called. Additional parameters
        are given as parameters to the function call.  Return
        identifier to cancel scheduling with after_cancel.t   afterc              s;   z      Wd  y  j    Wn t k
 r5 n XXd  S(   N(   RX   t   TclError(    (   R   t   funcRT   RR   (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   callitQ  s    N(   R.   RP   R7   t	   _register(   RR   t   msR   R   R   (    (   R   R   RT   RR   s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   F  s    c         G   s   |  j  d | |  S(   s   Call FUNC once if the Tcl main loop has no event to
        process.

        Return an identifier to cancel the scheduling with
        after_cancel.t   idle(   R   (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   after_idle\  s    c         C   sm   y? |  j  j d d |  } |  j  j |  d } |  j |  Wn t k
 rR n X|  j  j d d |  d S(   s   Cancel scheduling of function identified with ID.

        Identifier returned by after or after_idle must be
        given as first parameter.R   RG   i    t   cancelN(   R.   RP   R*   RX   R   (   RR   Rb   t   datat   script(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   after_cancelc  s    i    c         C   s!   |  j  j d |  j |   d S(   s   Ring a display's bell.t   bellN(   R   (   R.   RP   t
   _displayof(   RR   t	   displayof(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   q  s    c         K   s   d | k rd |  j  d k rd y+ d | d <|  j j d |  j |   SWqd t k
 r` | d =qd Xn  |  j j d |  j |   S(   s  Retrieve data from the clipboard on window's display.

        The window keyword defaults to the root window of the Tkinter
        application.

        The type keyword specifies the form in which the data is
        to be returned and should be an atom name such as STRING
        or FILE_NAME.  Type defaults to STRING, except on X11, where the default
        is to try UTF8_STRING and fall back to STRING.

        This command is equivalent to:

        selection_get(CLIPBOARD)
        R   t   x11t   UTF8_STRINGt	   clipboardR]   (   R   R]   (   R   R]   (   t   _windowingsystemR.   RP   t   _optionsR   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   clipboard_getv  s    
!c         K   s=   d | k r |  j  | d <n  |  j j d |  j |   d S(   s   Clear the data in the Tk clipboard.

        A widget specified for the optional displayof keyword
        argument specifies the target display.R   R   t   clearN(   R   R   (   R   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   clipboard_clear  s     c         K   sG   d | k r |  j  | d <n  |  j j d |  j |  d | f  d S(   s   Append STRING to the Tk clipboard.

        A widget specified at the optional displayof keyword
        argument specifies the target display. The clipboard
        can be retrieved with selection_get.R   R   Re   s   --N(   R   Re   (   R   R.   RP   R   (   RR   t   stringR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   clipboard_append  s     	c         C   s2   |  j  j d d |  j  } | s% d S|  j |  S(   sO   Return widget which has currently the grab in this application
        or None.t   grabt   currentN(   R.   RP   R   R   R   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grab_current  s     c         C   s   |  j  j d d |  j  d S(   s.   Release grab for this widget if currently set.R   t   releaseN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grab_release  s    c         C   s   |  j  j d d |  j  d S(   sw   Set grab for this widget.

        A grab directs all events to this and descendant
        widgets in the application.R   RN   N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grab_set  s    c         C   s    |  j  j d d d |  j  d S(   s   Set global grab for this widget.

        A global grab directs all events to this and
        descendant widgets on the display. Use with caution -
        other applications do not get events anymore.R   RN   s   -globalN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grab_set_global  s    c         C   s4   |  j  j d d |  j  } | d k r0 d } n  | S(   sY   Return None, "local" or "global" if this widget has
        no, a local or a global grab.R   t   statusR   N(   R.   RP   R   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grab_status  s     	c         C   s    |  j  j d d | | |  d S(   s   Set a VALUE (second parameter) for an option
        PATTERN (first parameter).

        An optional third parameter gives the numeric priority
        (defaults to 80).t   optiont   addN(   R.   RP   (   RR   t   patternR   t   priority(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   option_add  s    c         C   s   |  j  j d d  d S(   sP   Clear the option database.

        It will be reloaded if option_add is called.R   R   N(   R.   RP   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   option_clear  s    c         C   s   |  j  j d d |  j | |  S(   s   Return the value for an option NAME for this widget
        with CLASSNAME.

        Values with higher priority override lower values.R   R]   (   R.   RP   R   (   RR   RT   t	   className(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   option_get  s    c         C   s   |  j  j d d | |  d S(   sv   Read file FILENAME into the option database.

        An optional second parameter gives the numeric
        priority.R   t   readfileN(   R.   RP   (   RR   t   fileNameR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   option_readfile  s    c         K   s=   d | k r |  j  | d <n  |  j j d |  j |   d S(   s   Clear the current X selection.R   t	   selectionR   N(   R   R   (   R   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_clear  s     c         K   s   d | k r |  j  | d <n  d | k r |  j d k r y+ d | d <|  j j d |  j |   SWq t k
 r| | d =q Xn  |  j j d |  j |   S(	   s  Return the contents of the current X selection.

        A keyword parameter selection specifies the name of
        the selection and defaults to PRIMARY.  A keyword
        parameter displayof specifies a widget on the display
        to use. A keyword parameter type specifies the form of data to be
        fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
        before STRING.R   R   R   R   R   R]   (   R   R]   (   R   R]   (   R   R   R.   RP   R   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_get  s    	 
!c         K   s=   |  j  |  } |  j j d |  j |  |  j | f  d S(   s  Specify a function COMMAND to call if the X
        selection owned by this widget is queried by another
        application.

        This function must return the contents of the
        selection. The function will be called with the
        arguments OFFSET and LENGTH which allows the chunking
        of very long selections. The following keyword
        parameters can be provided:
        selection - name of the selection (default PRIMARY),
        type - type of the selection (e.g. STRING, FILE_NAME).R   t   handleN(   R   R   (   R   R.   RP   R   R   (   RR   t   commandR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_handle  s    	c         K   s+   |  j  j d |  j |  |  j f  d S(   s   Become owner of X selection.

        A keyword parameter selection specifies the name of
        the selection (default PRIMARY).R   t   ownN(   R   R   (   R.   RP   R   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_own  s    	c         K   sR   d | k r |  j  | d <n  |  j j d |  j |   } | sE d S|  j |  S(   s   Return owner of X selection.

        The following keyword parameter can
        be provided:
        selection - name of the selection (default PRIMARY),
        type - type of the selection (e.g. STRING, FILE_NAME).R   R   R   (   R   R   N(   R   R.   RP   R   R   R   (   RR   R   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_own_get  s      c         G   s   |  j  j d | | f |  S(   sD   Send Tcl command CMD to different interpreter INTERP to be executed.t   send(   R.   RP   (   RR   t   interpt   cmdR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  j d |  j |  d S(   s(   Lower this widget in the stacking order.t   lowerN(   R.   RP   R   (   RR   t	   belowThis(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  j d |  j |  d S(   s(   Raise this widget in the stacking order.t   raiseN(   R.   RP   R   (   RR   t	   aboveThis(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   tkraise  s    c         C   s   |  j  j d d |  j |  S(   s   Useless. Not implemented in Tk.R.   t
   colormodel(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s0   d |  j  |  | f } t |  j j |   S(   s*   Return integer which represents atom NAME.t   winfot   atom(   R   R   (   R   Ry   R.   RP   (   RR   RT   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   winfo_atom  s    c         C   s*   d |  j  |  | f } |  j j |  S(   s'   Return name of atom with identifier ID.R   t   atomname(   R   R   (   R   R.   RP   (   RR   Rb   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_atomname  s    c         C   s   t  |  j j d d |  j   S(   s7   Return number of cells in the colormap for this widget.R   t   cells(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_cells  s    c         C   sj   g  } x] |  j  j |  j  j d d |  j   D]4 } y | j |  j |   Wq. t k
 ra q. Xq. W| S(   s?   Return a list of all widgets which are children of this widget.R   t   children(   R.   R*   RP   R   Re   R   t   KeyError(   RR   t   resultt   child(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_children"  s    "c         C   s   |  j  j d d |  j  S(   s(   Return window class name of this widget.R   t   class(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_class/  s    c         C   s%   |  j  j |  j  j d d |  j   S(   s?   Return true if at the last color request the colormap was full.R   t   colormapfull(   R.   RO   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_colormapfull2  s    	c         C   sF   d |  j  |  | | f } |  j j |  } | s9 d S|  j |  S(   s@   Return the widget which is at the root coordinates ROOTX, ROOTY.R   t
   containing(   R   R   N(   R   R.   RP   R   R   (   RR   t   rootXt   rootYR   R   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_containing6  s
     c         C   s   t  |  j j d d |  j   S(   s$   Return the number of bits per pixel.R   t   depth(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_depth=  s    c         C   s   t  |  j j d d |  j   S(   s"   Return true if this widget exists.R   RH   (   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_exists@  s    c         C   s"   t  |  j j d d |  j |   S(   sW   Return the number of pixels for the given distance NUMBER
        (e.g. "3c") as float.R   t   fpixels(   R{   R.   RP   R   (   RR   t   number(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_fpixelsD  s    c         C   s   |  j  j d d |  j  S(   sF   Return geometry string for this widget in the form "widthxheight+X+Y".R   t   geometry(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_geometryI  s    c         C   s   t  |  j j d d |  j   S(   s   Return height of this widget.R   t   height(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_heightL  s    c         C   s%   |  j  j |  j  j d d |  j   S(   s%   Return identifier ID for this widget.R   Rb   (   R.   Ry   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_idP  s    	c         C   s/   d |  j  |  } |  j j |  j j |   S(   s9   Return the name of all Tcl interpreters for this display.R   t   interps(   R   R  (   R   R.   R*   RP   (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_interpsT  s    c         C   s   t  |  j j d d |  j   S(   s%   Return true if this widget is mapped.R   t   ismapped(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_ismappedX  s    c         C   s   |  j  j d d |  j  S(   s0   Return the window mananger name for this widget.R   t   manager(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_manager\  s    c         C   s   |  j  j d d |  j  S(   s   Return the name of this widget.R   RT   (   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   winfo_name_  s    c         C   s   |  j  j d d |  j  S(   s-   Return the name of the parent of this widget.R   t   parent(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_parentb  s    c         C   s*   d |  j  |  | f } |  j j |  S(   s.   Return the pathname of the widget given by ID.R   t   pathname(   R   R
  (   R   R.   RP   (   RR   Rb   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_pathnamee  s    c         C   s"   t  |  j j d d |  j |   S(   s'   Rounded integer value of winfo_fpixels.R   t   pixels(   Ry   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_pixelsj  s    c         C   s   t  |  j j d d |  j   S(   s:   Return the x coordinate of the pointer on the root window.R   t   pointerx(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_pointerxn  s    c         C   s"   |  j  |  j j d d |  j   S(   sH   Return a tuple of x and y coordinates of the pointer on the root window.R   t	   pointerxy(   t   _getintsR.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_pointerxyr  s    c         C   s   t  |  j j d d |  j   S(   s:   Return the y coordinate of the pointer on the root window.R   t   pointery(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_pointeryv  s    c         C   s   t  |  j j d d |  j   S(   s'   Return requested height of this widget.R   t	   reqheight(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_reqheightz  s    c         C   s   t  |  j j d d |  j   S(   s&   Return requested width of this widget.R   t   reqwidth(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_reqwidth~  s    c         C   s%   |  j  |  j j d d |  j |   S(   sU   Return tuple of decimal values for red, green, blue for
        COLOR in this widget.R   t   rgb(   R  R.   RP   R   (   RR   t   color(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   winfo_rgb  s    c         C   s   t  |  j j d d |  j   S(   sS   Return x coordinate of upper left corner of this widget on the
        root window.R   t   rootx(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_rootx  s    c         C   s   t  |  j j d d |  j   S(   sS   Return y coordinate of upper left corner of this widget on the
        root window.R   t   rooty(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_rooty  s    c         C   s   |  j  j d d |  j  S(   s&   Return the screen name of this widget.R   t   screen(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_screen  s    c         C   s   t  |  j j d d |  j   S(   sT   Return the number of the cells in the colormap of the screen
        of this widget.R   t   screencells(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_screencells  s    c         C   s   t  |  j j d d |  j   S(   s\   Return the number of bits per pixel of the root window of the
        screen of this widget.R   t   screendepth(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_screendepth  s    c         C   s   t  |  j j d d |  j   S(   sX   Return the number of pixels of the height of the screen of this widget
        in pixel.R   t   screenheight(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_screenheight  s    c         C   s   t  |  j j d d |  j   S(   sU   Return the number of pixels of the height of the screen of
        this widget in mm.R   t   screenmmheight(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_screenmmheight  s    c         C   s   t  |  j j d d |  j   S(   sT   Return the number of pixels of the width of the screen of
        this widget in mm.R   t   screenmmwidth(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_screenmmwidth  s    c         C   s   |  j  j d d |  j  S(   s   Return one of the strings directcolor, grayscale, pseudocolor,
        staticcolor, staticgray, or truecolor for the default
        colormodel of this screen.R   t   screenvisual(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_screenvisual  s    c         C   s   t  |  j j d d |  j   S(   sW   Return the number of pixels of the width of the screen of
        this widget in pixel.R   t   screenwidth(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_screenwidth  s    c         C   s   |  j  j d d |  j  S(   sx   Return information of the X-Server of the screen of this widget in
        the form "XmajorRminor vendor vendorVersion".R   t   server(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_server  s    c         C   s"   |  j  |  j j d d |  j   S(   s*   Return the toplevel widget of this widget.R   t   toplevel(   R   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_toplevel  s    c         C   s   t  |  j j d d |  j   S(   sB   Return true if the widget and all its higher ancestors are mapped.R   t   viewable(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_viewable  s    c         C   s   |  j  j d d |  j  S(   s   Return one of the strings directcolor, grayscale, pseudocolor,
        staticcolor, staticgray, or truecolor for the
        colormodel of this widget.R   t   visual(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_visual  s    c         C   s   |  j  j d d |  j  S(   s7   Return the X identifier for the visual for this widget.R   t   visualid(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_visualid  s    c         C   sp   |  j  j |  j  j d d |  j | r* d p- d   } t |  t k r` |  j  j |  g } n  t |  j |  S(   s   Return a list of all visuals available for the screen
        of this widget.

        Each item in the list consists of a visual name (see winfo_visual), a
        depth and if INCLUDEIDS=1 is given also the X identifier.R   t   visualsavailablet
   includeidsN(	   R.   t   splitRP   R   R   R   R   R   t   _Misc__winfo_parseitem(   RR   R;  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_visualsavailable  s    	c         C   s"   | d  t  t |  j | d   S(   s   Internal function.i   (   R   R   t   _Misc__winfo_getint(   RR   R1   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __winfo_parseitem  s    c         C   s   t  | d  S(   s   Internal function.i    (   R?   (   RR   t   x(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __winfo_getint  s    c         C   s   t  |  j j d d |  j   S(   s   Return the height of the virtual root window associated with this
        widget in pixels. If there is no virtual root window return the
        height of the screen.R   t   vrootheight(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_vrootheight  s    c         C   s   t  |  j j d d |  j   S(   s   Return the width of the virtual root window associated with this
        widget in pixel. If there is no virtual root window return the
        width of the screen.R   t
   vrootwidth(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_vrootwidth  s    c         C   s   t  |  j j d d |  j   S(   si   Return the x offset of the virtual root relative to the root
        window of the screen of this widget.R   t   vrootx(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_vrootx  s    c         C   s   t  |  j j d d |  j   S(   si   Return the y offset of the virtual root relative to the root
        window of the screen of this widget.R   t   vrooty(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_vrooty  s    c         C   s   t  |  j j d d |  j   S(   s    Return the width of this widget.R   t   width(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_width  s    c         C   s   t  |  j j d d |  j   S(   sV   Return the x coordinate of the upper left corner of this widget
        in the parent.R   RA  (   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_x  s    c         C   s   t  |  j j d d |  j   S(   sV   Return the y coordinate of the upper left corner of this widget
        in the parent.R   t   y(   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   winfo_y  s    c         C   s   |  j  j d  d S(   sE   Enter event loop until all pending events have been processed by Tcl.R   N(   R.   RP   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  j d d  d S(   s   Enter event loop until all idle callbacks have been called. This
        will update the display of windows but not process events caused by
        the user.R   t	   idletasksN(   R.   RP   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   update_idletasks  s    c         C   sK   | d k r. |  j j |  j j d |  j   S|  j j d |  j |  d S(   s,  Set or get the list of bindtags for this widget.

        With no argument return the list of all bindtags associated with
        this widget. With a list of strings as argument the bindtags are
        set to this list. The bindtags determine in which order events are
        processed (see bind).t   bindtagsN(   R   R.   R*   RP   R   (   RR   t   tagList(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRR  	  s    	i   c         C   s   t  |  t k r/ |  j j | | | f  n | r |  j | |  j |  } d | r\ d p_ d | |  j f } |  j j | | | f  | S| r |  j j | | f  S|  j j |  j j |   Sd S(   s   Internal function.s"   %sif {"[%s %s]" == "break"} break
t   +RE   N(   R   R   R.   RP   R   t   _substitutet   _subst_format_strR*   (   RR   t   whatt   sequenceR   R   t   needcleanupt   funcidR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _bind  s    	c         C   s   |  j  d |  j f | | |  S(   sO  Bind to this widget at event SEQUENCE a call to function FUNC.

        SEQUENCE is a string of concatenated event
        patterns. An event pattern is of the form
        <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
        of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
        Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
        B3, Alt, Button4, B4, Double, Button5, B5 Triple,
        Mod1, M1. TYPE is one of Activate, Enter, Map,
        ButtonPress, Button, Expose, Motion, ButtonRelease
        FocusIn, MouseWheel, Circulate, FocusOut, Property,
        Colormap, Gravity Reparent, Configure, KeyPress, Key,
        Unmap, Deactivate, KeyRelease Visibility, Destroy,
        Leave and DETAIL is the button number for ButtonPress,
        ButtonRelease and DETAIL is the Keysym for KeyPress and
        KeyRelease. Examples are
        <Control-Button-1> for pressing Control and mouse button 1 or
        <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
        An event pattern can also be a virtual event of the form
        <<AString>> where AString can be arbitrary. This
        event can be generated by event_generate.
        If events are concatenated they must appear shortly
        after each other.

        FUNC will be called if the event sequence occurs with an
        instance of Event as argument. If the return value of FUNC is
        "break" no further bound function is invoked.

        An additional boolean parameter ADD specifies whether FUNC will
        be called additionally to the other bound function or whether
        it will replace the previous function.

        Bind will return an identifier to allow deletion of the bound function with
        unbind without memory leak.

        If FUNC or SEQUENCE is omitted the bound function or list
        of bound events are returned.t   bind(   R[  R   (   RR   RX  R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR\  &  s    'c         C   s6   |  j  j d |  j | d  | r2 |  j |  n  d S(   sW   Unbind for this widget for event SEQUENCE  the
        function identified with FUNCID.R\  RE   N(   R.   RP   R   RX   (   RR   RX  RZ  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   unbindN  s    c         C   s   |  j  d | | | d  S(   s  Bind to all widgets at an event SEQUENCE a call to function FUNC.
        An additional boolean parameter ADD specifies whether FUNC will
        be called additionally to the other bound function or whether
        it will replace the previous function. See bind for the return value.R\  t   alli    (   R\  R^  (   R[  (   RR   RX  R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   bind_allT  s    c         C   s   |  j  j d d | d  d S(   s8   Unbind for all widgets for event SEQUENCE all functions.R\  R^  RE   N(   R.   RP   (   RR   RX  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   unbind_allZ  s    c         C   s   |  j  d | f | | | d  S(   s=  Bind to widgets with bindtag CLASSNAME at event
        SEQUENCE a call of function FUNC. An additional
        boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or
        whether it will replace the previous function. See bind for
        the return value.R\  i    (   R[  (   RR   R   RX  R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   bind_class]  s    	c         C   s   |  j  j d | | d  d S(   sW   Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
        all functions.R\  RE   N(   R.   RP   (   RR   R   RX  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   unbind_classg  s    c         C   s   |  j  j |  d S(   s   Call the mainloop of Tk.N(   R.   R~   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR~   k  s    c         C   s   |  j  j   d S(   s8   Quit the Tcl interpreter. All widgets will be destroyed.N(   R.   t   quit(   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRc  n  s    c         C   s)   | r% t  t t |  j j |    Sd S(   s   Internal function.N(   R   R   Ry   R.   R*   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  q  s    c         C   s)   | r% t  t t |  j j |    Sd S(   s   Internal function.N(   R   R   R{   R.   R*   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _getdoublesu  s    c         C   s   | r |  j  j |  Sd S(   s   Internal function.N(   R.   RO   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _getbooleany  s    c         C   s-   | r d | f S| d k r) d |  j f Sd S(   s   Internal function.s
   -displayofN(    (   R   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   }  s
    
c         C   sL   y |  j    j SWn4 t k
 rG |  j j d d  } |  j    _ | SXd S(   s   Internal function.R.   t   windowingsystemN(   RI   t   _windowingsystem_cachedR   R.   RP   (   RR   t   ws(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s
    "c         C   s<  | r t  | | f  } n t  |  } d } x| j   D] \ } } | d k	 r: | d d k ro | d  } n  t | d  r |  j |  } n t | t t f  rg  } xo | D]U } t | t t	 f  s Pq t | t	  r | j
 d |  q | j
 t |   q Wd j |  } n  | d | | f } q: q: W| S(	   s   Internal function.it   _Ra   s   %dR   R)   (    N(   R(   R!   R   t   hasattrR   R
   R   R   Rv   R?   Re   R   R   (   RR   R#   R   R   R&   R'   t   nvR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s*     c         C   sj   t  |  j d  } |  } | d s> | j   } | d } n  x% | D] } | sU Pn  | j | } qE W| S(   sP   Return the Tkinter instance of a widget identified by
        its Tcl name NAME.t   .i    i   (   R   R<  RI   R   (   RR   RT   t   wR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   nametowidget  s    
c         C   s   t  | | |   j } t t |   } y | j } Wn t k
 rG n Xy | | j } Wn t k
 rl n X|  j j | |  | r |  j	 d k r g  |  _	 n  |  j	 j |  n  | S(   s   Return a newly created Tcl function. If this
        function is called, the Python function FUNC will
        be executed. An optional function SUBST can
        be given which will be executed before FUNC.N(   R`   Ra   RL   Rb   Rc   R   R7   R.   Rd   RW   R   Re   (   RR   R   t   substRY  Rh   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s     c         C   s#   |  } x | j  r | j  } q	 W| S(   s   Internal function.(   RS   (   RR   Rm  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRI     s     s   %#s   %bs   %fs   %hs   %ks   %ss   %ts   %ws   %xs   %ys   %As   %Es   %Ks   %Ns   %Ws   %Ts   %Xs   %Ys   %DR   c         G   s	  t  |  t  |  j  k r | S|  j j } t } d   } | \ } } } } }	 }
 } } } } } } } } } } } } } t   } | |  | _ | |  | _ y | |  | _ Wn t	 k
 r n X| |  | _
 | |	  | _ | |
  | _ | |  | _ | |  | _ | |  | _ | |  | _ | | _ y | |  | _ Wn t	 k
 r_n X| | _ | |  | _ | | _ y |  j |  | _ Wn t k
 r| | _ n X| |  | _ | |  | _ y | |  | _ Wn t k
 rd | _ n X| f S(   s   Internal function.c         S   s'   y t  |   SWn t k
 r" |  SXd S(   s?   Tk changed behavior in 8.4.2, returning "??" rather more often.N(   R?   R@   (   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   getint_event  s    i    (   R   t   _subst_formatR.   RO   R?   R6   t   serialt   numR   R   R   t   keycodet   statet   timeRK  RA  RN  t   chart
   send_eventt   keysymt
   keysym_numR   R   t   widgetR   t   x_roott   y_roott   deltaR@   (   RR   R   RO   Ry   Rp  t   nsignt   bRh   t   hR&   R   R1   Rm  RA  RN  t   At   Et   Kt   Nt   Wt   Tt   Xt   Yt   Dt   e(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU    sN     	?	  	  		c         C   sL   d d l  } | j | j | j } } } |  j   } | j | | |  d S(   s   Internal function.iN(   t   syst   exc_typet	   exc_valuet   exc_tracebackRI   t   report_callback_exception(   RR   R  t   exct   valt   tbt   root(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _report_exception  s    c         G   sj   i  } x] |  j  j |  j  j |    D]= } |  j  j |  } | d d f | d | | d d <q% W| S(   s;   Call Tcl configure command and return the result as a dict.i    i   (   R.   R*   RP   (   RR   R   R#   RA  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _getconfigure  s
    %)c         G   s5   |  j  j |  j  j |    } | d d f | d S(   Ni    i   (   R.   R*   RP   (   RR   R   RA  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _getconfigure1  s    c         C   s   | r t  | | f  } n | r0 t  |  } n  | d k rX |  j t |  j | f   St |  t k r |  j t |  j | d | f   S|  j j	 t |  j | f  |  j
 |   d S(   s   Internal function.R)   N(   R(   R   R  R   R   R   R   R  R.   RP   R   (   RR   R   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   _configure#  s    #c         K   s   |  j  d | |  S(   s   Configure resources of a widget.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method keys.
        t	   configure(   R  (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  /  s    c         C   s   |  j  j |  j d d |  S(   s4   Return the resource value for a KEY given as string.t   cgetR)   (   R.   RP   R   (   RR   R4   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  8  s    c         C   s   |  j  i | | 6 d  S(   N(   R  (   RR   R4   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __setitem__<  s    c         C   s   t  d   d  S(   Ns)   Tkinter objects don't support 'in' tests.(   R    (   RR   R4   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __contains__>  s    c         C   sI   |  j  j } g  | |  j  j |  j d   D] } | |  d d ^ q+ S(   s3   Return a list of all resource names of this widget.R  i    i   (   R.   R*   RP   R   (   RR   R*   RA  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   keys@  s    c         C   s   |  j  S(   s+   Return the window path name of this widget.(   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRZ   E  s    t   _noarg_c         C   sQ   | t  j k r1 |  j |  j j d d |  j   S|  j j d d |  j |  d S(   s  Set or get the status for propagation of geometry information.

        A boolean argument specifies whether the geometry information
        of the slaves will determine the size of this widget. If no argument
        is given the current setting will be returned.
        t   packt	   propagateN(   R   R  Re  R.   RP   R   (   RR   t   flag(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   pack_propagateJ  s    c         C   s1   t  |  j |  j j |  j j d d |  j    S(   sH   Return a list of all slaves of this widget
        in its packing order.R  t   slaves(   R   R   R.   R*   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   pack_slavesW  s    		c         C   s1   t  |  j |  j j |  j j d d |  j    S(   sH   Return a list of all slaves of this widget
        in its packing order.t   placeR  (   R   R   R.   R*   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   place_slaves_  s    			c         C   s   d d |  j  f } | d k	 r= | d k	 r= | | | f } n  | d k	 rh | d k	 rh | | | f } n  |  j |  j j |    p d S(   s  Return a tuple of integer coordinates for the bounding
        box of this widget controlled by the geometry manager grid.

        If COLUMN, ROW is given the bounding box applies from
        the cell with row and column 0 to the specified
        cell. If COL2 and ROW2 are given the bounding box
        starts at that cell.

        The returned integers specify the offset of the upper left
        corner in the master widget and the width and height.
        t   gridt   bboxN(   R   R   R  R.   RP   (   RR   t   columnt   rowt   col2t   row2R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   grid_bboxg  s    c         C   sm   t  | t t j f  ri y: t |  } | s1 d  Sd | k rG t |  St |  SWqi t k
 re qi Xn  | S(   NRl  (   R
   R   t   _tkintert   Tcl_ObjR   R{   Ry   R@   (   RR   R   t   svalue(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _gridconvvalue|  s    
c         C   s   t  |  t k r_ | r_ | d d k r6 | d  } n  | d  d k rS d | } n  | f } n |  j | |  } | s t |  j |  j j d | |  j |  d |  j S|  j j d | |  j | f |  } t |  d k r |  j |  Sd S(   s   Internal function.iRi  i   R)   R  R0   N(	   R   R   R   R5   R.   RP   R   R  R   (   RR   R   t   indexR#   R   t   optionsR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _grid_configure  s"    
	
c         K   s   |  j  d | | |  S(   s   Configure column INDEX of a grid.

        Valid resources are minsize (minimum size of the column),
        weight (how much does additional space propagate to this column)
        and pad (how much space to let additionally).t   columnconfigure(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grid_columnconfigure  s    c         C   s.   |  j  |  j j d d |  j | |   p- d S(   s   Return a tuple of column and row which identify the cell
        at which the pixel at position X and Y inside the master
        widget is located.R  t   locationN(   R  R.   RP   R   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grid_location  s    	c         C   sQ   | t  j k r1 |  j |  j j d d |  j   S|  j j d d |  j |  d S(   s  Set or get the status for propagation of geometry information.

        A boolean argument specifies whether the geometry information
        of the slaves will determine the size of this widget. If no argument
        is given, the current setting will be returned.
        R  R  N(   R   R  Re  R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grid_propagate  s    c         K   s   |  j  d | | |  S(   s   Configure row INDEX of a grid.

        Valid resources are minsize (minimum size of the row),
        weight (how much does additional space propagate to this row)
        and pad (how much space to let additionally).t   rowconfigure(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grid_rowconfigure  s    c         C   s(   |  j  |  j j d d |  j   p' d S(   s<   Return a tuple of the number of column and rows in the grid.R  t   sizeN(   R  R.   RP   R   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   grid_size  s    c         C   s|   d } | d k	 r% | d | f } n  | d k	 rD | d | f } n  t |  j |  j j |  j j d d |  j f |    S(   sH   Return a list of all slaves of this widget
        in its packing order.s   -rows   -columnR  R  (    N(   R   R   R   R.   R*   RP   R   (   RR   R  R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grid_slaves  s    	c         G   s'   d d | f | } |  j  j |  d S(   s   Bind a virtual event VIRTUAL (of the form <<Name>>)
        to an event SEQUENCE such that the virtual event is triggered
        whenever SEQUENCE occurs.t   eventR   N(   R.   RP   (   RR   t   virtualt	   sequencesR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   event_add  s    c         G   s'   d d | f | } |  j  j |  d S(   s-   Unbind a virtual event VIRTUAL from SEQUENCE.R  t   deleteN(   R.   RP   (   RR   R  R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   event_delete  s    c         K   s`   d d |  j  | f } x4 | j   D]& \ } } | d | t |  f } q" W|  j j |  d S(   s   Generate an event SEQUENCE. Additional
        keyword arguments specify parameter of the event
        (e.g. x, y, rootx, rooty).R  t   generates   -%sN(   R   R!   R   R.   RP   (   RR   RX  R   R   R&   R'   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   event_generate  s    c         C   s"   |  j  j |  j  j d d |   S(   su   Return a list of all virtual events or the information
        about the SEQUENCE bound to the virtual event VIRTUAL.R  RG   (   R.   R*   RP   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   event_info  s    	c         C   s   |  j  j |  j  j d d   S(   s*   Return a list of all existing image names.t   imaget   names(   R.   R*   RP   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   image_names  s    c         C   s   |  j  j |  j  j d d   S(   s?   Return a list of all available image types (e.g. phote bitmap).R  t   types(   R.   R*   RP   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   image_types  s    N(   s   %#s   %bs   %fs   %hs   %ks   %ss   %ts   %ws   %xs   %ys   %As   %Es   %Ks   %Ns   %Ws   %Ts   %Xs   %Ys   %D(   R7   R8   R9   R   RW   R   RX   R   R   R   R   R   t   waitvarR   R   R   R   R?   Ry   t   floatR{   RO   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   t   liftR   R   R   R   R   R   R   R   R   R   R   R   R   R   R  R  R  R  R	  R  R  R  R  R  R  R  R  R  R  R!  R#  R%  R'  R)  R+  R-  R/  R1  R3  R5  R7  R9  R>  R=  R?  RD  RF  RH  RJ  RL  RM  RO  R   RQ  RR  R[  R\  R]  R_  R`  Ra  Rb  R~   Rc  R  Rd  Re  R   t   propertyR   R   Rn  R   R   t   registerRI   Rq  R   RV  RU  R  R  R  R  R  t   configR  t   __getitem__R  R  R  RZ   R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     sP  	
	
								
										
																																																												(	
									  	9																					R`   c           B   s    e  Z d  Z d   Z d   Z RS(   sw   Internal class. Stores function to call when some user
    defined Tcl function is called e.g. after an event occurred.c         C   s   | |  _  | |  _ | |  _ d S(   s(   Store FUNC, SUBST and WIDGET as members.N(   R   Ro  R{  (   RR   R   Ro  R{  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s    		c         G   sb   y, |  j  r |  j  |   } n  |  j |   SWn/ t k
 rJ } t |  n |  j j   n Xd S(   s3   Apply first function SUBST to arguments, than FUNC.N(   Ro  R   RA   R{  R  (   RR   R   R%   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRa     s    	(   R7   R8   R9   RU   Ra   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR`     s   	t   XViewc           B   s)   e  Z d  Z d   Z d   Z d   Z RS(   sX   Mix-in class for querying and changing the horizontal position
    of a widget's window.c         G   s2   |  j  j |  j d |  } | s. |  j |  Sd S(   s5   Query and change the horizontal position of the view.t   xviewN(   R.   RP   R   Rd  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s    |  j  j |  j d d |  d S(   ss   Adjusts the view in the window so that FRACTION of the
        total width of the canvas is off-screen to the left.R  t   movetoN(   R.   RP   R   (   RR   t   fraction(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   xview_moveto  s    c         C   s#   |  j  j |  j d d | |  d S(   s\   Shift the x-view according to NUMBER which is measured in "units"
        or "pages" (WHAT).R  t   scrollN(   R.   RP   R   (   RR   R   RW  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   xview_scroll  s    (   R7   R8   R9   R  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s   		t   YViewc           B   s)   e  Z d  Z d   Z d   Z d   Z RS(   sV   Mix-in class for querying and changing the vertical position
    of a widget's window.c         G   s2   |  j  j |  j d |  } | s. |  j |  Sd S(   s3   Query and change the vertical position of the view.t   yviewN(   R.   RP   R   Rd  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  )  s    c         C   s    |  j  j |  j d d |  d S(   ss   Adjusts the view in the window so that FRACTION of the
        total height of the canvas is off-screen to the top.R  R  N(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   yview_moveto/  s    c         C   s#   |  j  j |  j d d | |  d S(   s\   Shift the y-view according to NUMBER which is measured in
        "units" or "pages" (WHAT).R  R  N(   R.   RP   R   (   RR   R   RW  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   yview_scroll4  s    (   R7   R8   R9   R  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  %  s   		t   Wmc           B   s  e  Z d  Z d d d d d  Z e Z d   Z e Z d d  Z e Z	 d   Z
 e
 Z d d  Z e Z d   Z e Z d d  Z e Z d   Z e Z d d	  Z e Z d d d d d
  Z e Z d d  Z e Z d d d  Z e Z d   Z e Z d d  Z e Z d d  Z  e  Z! d d d  Z" e" Z# d d  Z$ e$ Z% d d d  Z& e& Z' d d d  Z( e( Z) d d  Z* e* Z+ d d  Z, e, Z- d d d  Z. e. Z/ d d d  Z0 e0 Z1 d d  Z2 e2 Z3 d d  Z4 e4 Z5 d d  Z6 e6 Z7 d d  Z8 e8 Z9 d   Z: e: Z; RS(   sA   Provides functions for the communication with the window manager.c      	   C   s.   |  j  |  j j d d |  j | | | |   S(   s   Instruct the window manager to set the aspect ratio (width/height)
        of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
        of the actual values if no argument is given.t   wmt   aspect(   R  R.   RP   R   (   RR   t   minNumert   minDenomt   maxNumert   maxDenom(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   wm_aspect=  s    c         G   s&   d d |  j  f | } |  j j |  S(   s  This subcommand returns or sets platform specific attributes

        The first form returns a list of the platform specific flags and
        their values. The second form returns the value for the specific
        option. The third form sets one or more of the values. The values
        are as follows:

        On Windows, -disabled gets or sets whether the window is in a
        disabled state. -toolwindow gets or sets the style of the window
        to toolwindow (as defined in the MSDN). -topmost gets or sets
        whether this is a topmost window (displays above all other
        windows).

        On Macintosh, XXXXX

        On Unix, there are currently no special attribute values.
        R  t
   attributes(   R   R.   RP   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_attributesI  s    c         C   s   |  j  j d d |  j |  S(   sV   Store NAME in WM_CLIENT_MACHINE property of this widget. Return
        current value.R  t   client(   R.   RP   R   (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   wm_client_  s    c         G   sy   t  |  d k r | f } n  d d |  j f | } | rM |  j j |  n( t |  j |  j j |  j j |    Sd S(   s   Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
        of this widget. This list contains windows whose colormaps differ from their
        parents. Return current list of widgets if WLIST is empty.i   R  t   colormapwindowsN(   R   R   R.   RP   R   R   R*   (   RR   t   wlistR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_colormapwindowsd  s    c         C   s   |  j  j d d |  j |  S(   s   Store VALUE in WM_COMMAND property. It is the command
        which shall be used to invoke the application. Return current
        command if VALUE is None.R  R   (   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   wm_commandp  s    c         C   s   |  j  j d d |  j  S(   s   Deiconify this widget. If it was never mapped it will not be mapped.
        On Windows it will raise this widget and give it the focus.R  t	   deiconify(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_deiconifyv  s    c         C   s   |  j  j d d |  j |  S(   s   Set focus model to MODEL. "active" means that this widget will claim
        the focus itself, "passive" means that the window manager shall give
        the focus. Return current focus model if MODEL is None.R  t
   focusmodel(   R.   RP   R   (   RR   t   model(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_focusmodel{  s    c         C   s   |  j  j d d |  j  S(   sA   Return identifier for decorative frame of this widget if present.R  t   frame(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_frame  s    c         C   s   |  j  j d d |  j |  S(   si   Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
        current value if None is given.R  R   (   R.   RP   R   (   RR   t   newGeometry(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_geometry  s    c      	   C   s.   |  j  |  j j d d |  j | | | |   S(   s  Instruct the window manager that this widget shall only be
        resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
        height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
        number of grid units requested in Tk_GeometryRequest.R  R  (   R  R.   RP   R   (   RR   t	   baseWidtht
   baseHeightt   widthInct	   heightInc(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_grid  s    c         C   s   |  j  j d d |  j |  S(   s~   Set the group leader widgets for related widgets to PATHNAME. Return
        the group leader of this widget if None is given.R  t   group(   R.   RP   R   (   RR   t   pathName(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_group  s    c         C   sE   | r% |  j  j d d |  j d |  S|  j  j d d |  j |  Sd S(   s  Set bitmap for the iconified widget to BITMAP. Return
        the bitmap if None is given.

        Under Windows, the DEFAULT parameter can be used to set the icon
        for the widget and any descendents that don't have an icon set
        explicitly.  DEFAULT can be the relative path to a .ico file
        (example: root.iconbitmap(default='myicon.ico') ).  See Tk
        documentation for more information.R  t
   iconbitmaps   -defaultN(   R.   RP   R   (   RR   t   bitmapt   default(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_iconbitmap  s    	c         C   s   |  j  j d d |  j  S(   s   Display widget as icon.R  t   iconify(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   wm_iconify  s    c         C   s   |  j  j d d |  j |  S(   sV   Set mask for the icon bitmap of this widget. Return the
        mask if None is given.R  t   iconmask(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_iconmask  s    c         C   s   |  j  j d d |  j |  S(   sS   Set the name of the icon for this widget. Return the name if
        None is given.R  t   iconname(   R.   RP   R   (   RR   t   newName(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_iconname  s    c         C   s(   |  j  |  j j d d |  j | |   S(   s   Set the position of the icon of this widget to X and Y. Return
        a tuple of the current values of X and X if None is given.R  t   iconposition(   R  R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_iconposition  s    c         C   s   |  j  j d d |  j |  S(   sg   Set widget PATHNAME to be displayed instead of icon. Return the current
        value if None is given.R  t
   iconwindow(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_iconwindow  s    c         C   s(   |  j  |  j j d d |  j | |   S(   s   Set max WIDTH and HEIGHT for this widget. If the window is gridded
        the values are given in grid units. Return the current values if None
        is given.R  t   maxsize(   R  R.   RP   R   (   RR   RK  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   wm_maxsize  s    c         C   s(   |  j  |  j j d d |  j | |   S(   s   Set min WIDTH and HEIGHT for this widget. If the window is gridded
        the values are given in grid units. Return the current values if None
        is given.R  t   minsize(   R  R.   RP   R   (   RR   RK  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   wm_minsize  s    c         C   s%   |  j  |  j j d d |  j |   S(   s   Instruct the window manager to ignore this widget
        if BOOLEAN is given with 1. Return the current value if None
        is given.R  t   overrideredirect(   Re  R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_overrideredirect  s    c         C   s   |  j  j d d |  j |  S(   s   Instruct the window manager that the position of this widget shall
        be defined by the user if WHO is "user", and by its own policy if WHO is
        "program".R  t   positionfrom(   R.   RP   R   (   RR   t   who(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_positionfrom  s    c         C   sF   t  | d  r! |  j |  } n | } |  j j d d |  j | |  S(   s   Bind function FUNC to command NAME for this widget.
        Return the function bound to NAME if None is given. NAME could be
        e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW".Ra   R  t   protocol(   Rj  R   R.   RP   R   (   RR   RT   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_protocol  s
    	c         C   s   |  j  j d d |  j | |  S(   sy   Instruct the window manager whether this width can be resized
        in WIDTH or HEIGHT. Both values are boolean values.R  t	   resizable(   R.   RP   R   (   RR   RK  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_resizable  s    c         C   s   |  j  j d d |  j |  S(   s   Instruct the window manager that the size of this widget shall
        be defined by the user if WHO is "user", and by its own policy if WHO is
        "program".R  t   sizefrom(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_sizefrom  s    c         C   s   |  j  j d d |  j |  S(   s   Query or set the state of this widget as one of normal, icon,
        iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only).R  Ru  (   R.   RP   R   (   RR   t   newstate(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_state  s    c         C   s   |  j  j d d |  j |  S(   s   Set the title of this widget.R  t   title(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_title  s    c         C   s   |  j  j d d |  j |  S(   s_   Instruct the window manager that this widget is transient
        with regard to widget MASTER.R  t	   transient(   R.   RP   R   (   RR   RS   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_transient  s    c         C   s   |  j  j d d |  j  S(   s   Withdraw this widget from the screen such that it is unmapped
        and forgotten by the window manager. Re-draw it with wm_deiconify.R  t   withdraw(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   wm_withdraw   s    N(<   R7   R8   R9   R   R  R  R  R  R  R  R  R  R  R   R  R  R  R  R  R  R  R   R  R  R  R  R  R   R  R  R  R  R
  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  Ru  R!  R   R#  R"  R%  R$  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  :  sv   					
	t   Tkc           B   se   e  Z d  Z d Z d d d d d d d  Z d   Z d   Z d   Z d	   Z	 d
   Z
 d   Z RS(   sz   Toplevel widget of Tk which represents mostly the main window
    of an application. It has an associated Tcl interpreter.Rl  R&  i   i    c   
   	   C   s   d |  _ i  |  _ d |  _ d |  _ | d k r d d l } | j j t j	 d  } | j j
 |  \ } } | d k r | | } q n  d }	 t j | | | |	 t | | |  |  _ | r |  j   n  t j j s |  j | |  n  d S(   s@  Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will
        be created. BASENAME will be used for the identification of the profile file (see
        readprofile).
        It is constructed from sys.argv[0] without extensions if None is given. CLASSNAME
        is the name of the widget class.i    iNs   .pys   .pycs   .pyo(   s   .pys   .pycs   .pyo(   R   RS   R   t	   _tkloadedR.   t   ost   patht   basenameR  t   argvt   splitextR  t   createt   wantobjectst   _loadtkt   flagst   ignore_environmentt   readprofile(
   RR   t
   screenNamet   baseNameR   t   useTkt   synct   useR(  t   extt   interactive(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s     				'c         C   s'   |  j  s# |  j j   |  j   n  d  S(   N(   R'  R.   t   loadtkR/  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR:  %  s    	c         C   s3  d |  _  |  j j d  } | t j k rC t d t j | f  n  t |  j j d   } | t j k r t d t j | f  n  t d k  r t d t t   n  |  j	 d  k r g  |  _	 n  |  j j d t  |  j j d	 t  |  j	 j d  |  j	 j d	  t rt r|  a n  |  j d
 |  j  d  S(   Ni   t
   tk_versions4   tk.h version (%s) doesn't match libtk.a version (%s)t   tcl_versions6   tcl.h version (%s) doesn't match libtcl.a version (%s)g      @s)   Tk 4.0 or higher is required; found Tk %st   tkerrort   exitt   WM_DELETE_WINDOW(   R'  R.   R   R  t
   TK_VERSIONR+   R   t   TCL_VERSIONt	   TkVersionRW   R   Rd   R>   RC   Re   R:   R;   R  R   (   RR   R;  R<  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR/  )  s0    		c         C   sf   x! |  j  j   D] } | j   q W|  j j d |  j  t j |   t rb t |  k rb d a n  d S(   sh   Destroy this and all descendants widgets. This will
        end the application of this Tcl interpreter.R   N(
   R   t   valuesR   R.   RP   R   R   R:   R;   R   (   RR   R$   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   H  s     c   
      B   sE  d d l  } d | j k r+ | j d } n	 | j } | j j | d |  } | j j | d |  } | j j | d |  } | j j | d |  } i |  d 6}	 d |	 U| j j |  r |  j j d |  n  | j j |  r e | |	  n  | j j |  r|  j j d |  n  | j j |  rAe | |	  n  d S(	   s   Internal function. It reads BASENAME.tcl and CLASSNAME.tcl into
        the Tcl Interpreter and calls execfile on BASENAME.py and CLASSNAME.py if
        such a file exists in the home directory.iNt   HOMEs   .%s.tcls   .%s.pyRR   s   from Tkinter import *t   source(	   R(  t   environt   curdirR)  R   t   isfileR.   RP   t   execfile(
   RR   R4  R   R(  t   homet	   class_tclt   class_pyt   base_tclt   base_pyt   dir(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR2  Q  s$     	c         C   sW   d d l  } d d l } | j d IJ| | _ | | _ | | _ | j | | |  d S(   s   Report callback exception on sys.stderr.

        Applications may want to override this internal function, and
        should when sys.stderr is None.iNs   Exception in Tkinter callback(   t	   tracebackR  t   stderrt	   last_typet
   last_valuet   last_tracebackt   print_exception(   RR   R  R  R  RP  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  f  s    			c         C   s   t  |  j |  S(   s3   Delegate attribute access to the interpreter object(   t   getattrR.   (   RR   t   attr(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   __getattr__q  s    N(   R7   R8   R9   R   R   RU   R:  R/  R   R2  R  RX  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR&    s   							c         C   s   t  |  | | |  S(   N(   R&  (   R3  R4  R   R5  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   Tcl  s    t   Packc           B   s`   e  Z d  Z i  d  Z e Z Z Z d   Z e Z d   Z	 e	 Z
 e j Z Z e j Z Z RS(   sQ   Geometry manager Pack.

    Base class to use the methods pack_* in every widget.c         K   s0   |  j  j d d |  j f |  j | |   d S(   s(  Pack a widget in the parent widget. Use as options:
        after=widget - pack it after you have packed widget
        anchor=NSEW (or subset) - position widget according to
                                  given direction
        before=widget - pack it before you will pack widget
        expand=bool - expand widget if parent size grows
        fill=NONE or X or Y or BOTH - fill widget if widget grows
        in=master - use master to contain this widget
        in_=master - see 'in' option description
        ipadx=amount - add internal padding in x direction
        ipady=amount - add internal padding in y direction
        padx=amount - add padding in x direction
        pady=amount - add padding in y direction
        side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
        R  R  N(   R.   RP   R   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   pack_configure  s    	c         C   s   |  j  j d d |  j  d S(   s:   Unmap this widget and do not use it for the packing order.R  t   forgetN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   pack_forget  s    c         C   sQ   t  |  j |  j j d d |  j   } d | k rM |  j | d  | d <n  | S(   sE   Return information about the packing options
        for this widget.R  RG   t   in(   R5   R.   RP   R   Rn  (   RR   t   d(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   pack_info  s    '(   R7   R8   R9   R[  R  R  R  R]  R\  R`  RG   R   R  R  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRZ    s   		t   Placec           B   sS   e  Z d  Z i  d  Z e Z Z Z d   Z e Z d   Z	 e	 Z
 e j Z Z RS(   sS   Geometry manager Place.

    Base class to use the methods place_* in every widget.c         K   s0   |  j  j d d |  j f |  j | |   d S(   s   Place a widget in the parent widget. Use as options:
        in=master - master relative to which the widget is placed
        in_=master - see 'in' option description
        x=amount - locate anchor of this widget at position x of master
        y=amount - locate anchor of this widget at position y of master
        relx=amount - locate anchor of this widget between 0.0 and 1.0
                      relative to width of master (1.0 is right edge)
        rely=amount - locate anchor of this widget between 0.0 and 1.0
                      relative to height of master (1.0 is bottom edge)
        anchor=NSEW (or subset) - position anchor according to given direction
        width=amount - width of this widget in pixel
        height=amount - height of this widget in pixel
        relwidth=amount - width of this widget between 0.0 and 1.0
                          relative to width of master (1.0 is the same width
                          as the master)
        relheight=amount - height of this widget between 0.0 and 1.0
                           relative to height of master (1.0 is the same
                           height as the master)
        bordermode="inside" or "outside" - whether to take border width of
                                           master widget into account
        R  R  N(   R.   RP   R   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   place_configure  s    	c         C   s   |  j  j d d |  j  d S(   s   Unmap this widget.R  R\  N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   place_forget  s    c         C   sQ   t  |  j |  j j d d |  j   } d | k rM |  j | d  | d <n  | S(   sE   Return information about the placing options
        for this widget.R  RG   R^  (   R5   R.   RP   R   Rn  (   RR   R_  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   place_info  s    '(   R7   R8   R9   Rb  R  R  R  Rc  R\  Rd  RG   R   R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRa    s   		t   Gridc           B   s   e  Z d  Z i  d  Z e Z Z Z e j Z	 Z e j
 Z Z
 d   Z e Z d   Z d   Z e Z e j Z Z e j Z Z e j Z Z e j Z Z e j Z Z RS(   sQ   Geometry manager Grid.

    Base class to use the methods grid_* in every widget.c         K   s0   |  j  j d d |  j f |  j | |   d S(   s  Position a widget in the parent widget in a grid. Use as options:
        column=number - use cell identified with given column (starting with 0)
        columnspan=number - this widget will span several columns
        in=master - use master to contain this widget
        in_=master - see 'in' option description
        ipadx=amount - add internal padding in x direction
        ipady=amount - add internal padding in y direction
        padx=amount - add padding in x direction
        pady=amount - add padding in y direction
        row=number - use cell identified with given row (starting with 0)
        rowspan=number - this widget will span several rows
        sticky=NSEW - if cell is larger on which sides will this
                      widget stick to the cell boundary
        R  R  N(   R.   RP   R   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grid_configure  s    	c         C   s   |  j  j d d |  j  d S(   s   Unmap this widget.R  R\  N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grid_forget  s    c         C   s   |  j  j d d |  j  d S(   s0   Unmap this widget but remember the grid options.R  Rm   N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   grid_remove  s    c         C   sQ   t  |  j |  j j d d |  j   } d | k rM |  j | d  | d <n  | S(   sS   Return information about the options
        for positioning this widget in a grid.R  RG   R^  (   R5   R.   RP   R   Rn  (   RR   R_  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   grid_info  s    '(   R7   R8   R9   Rf  R  R  R  R   R  R  R  R  Rg  R\  Rh  Ri  RG   R  R  R  R  R  R  R  R  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRe    s   			t
   BaseWidgetc           B   s>   e  Z d  Z d   Z i  i  d d  Z d   Z d d  Z RS(   s   Internal class.c         C   s  t  r* | s* t s t   a n  t } q* n  | |  _ | j |  _ d } d | k re | d } | d =n  | s t t |    } n  | |  _ | j	 d k r d | |  _	 n | j	 d | |  _	 i  |  _
 |  j |  j j
 k r |  j j
 |  j j   n  |  |  j j
 |  j <d S(   s6   Internal function. Sets up information about children.RT   Rl  N(   R:   R;   R&  RS   R.   R   RL   Rb   RK   R   R   R   (   RR   RS   R#   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _setup  s*    	

		c   	      C   s   | r t  | | f  } n  | |  _ t j |  | |  |  j d k rR g  |  _ n  g  } xG | j   D]9 } t |  t k re | j	 | | | f  | | =qe qe W|  j
 j | |  j f | |  j |   x$ | D] \ } } | j |  |  q Wd S(   sd   Construct a widget with the parent widget MASTER, a name WIDGETNAME
        and appropriate options.N(   R(   t
   widgetNameRj  Rk  RW   R   R  R   t	   ClassTypeRe   R.   RP   R   R   R  (	   RR   RS   Rl  R#   R   t   extrat   classesR&   R'   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   $  s    		!c         C   ss   x! |  j  j   D] } | j   q W|  j j d |  j  |  j |  j j  k rb |  j j  |  j =n  t j |   d S(   s)   Destroy this and all descendants widgets.R   N(	   R   RC  R   R.   RP   R   RK   RS   R   (   RR   R$   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   6  s     c         C   s   |  j  j |  j | f |  S(   N(   R.   RP   R   (   RR   RT   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _do=  s    (    (    (   R7   R8   R9   Rk  RU   R   Rp  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRj  	  s
   		t   Widgetc           B   s   e  Z d  Z RS(   sx   Internal class.

    Base class for a widget which can be positioned with the geometry managers
    Pack, Place or Grid.(   R7   R8   R9   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRq  A  s   t   Toplevelc           B   s   e  Z d  Z d i  d  Z RS(   s"   Toplevel widget, e.g. for dialogs.c   	      K   s  | r t  | | f  } n  d } xx d d d d d g D]a } | | k r7 | | } | d d k rt d | d  } n
 d | } | | | f } | | =q7 q7 Wt j |  | d	 | i  |  |  j   } |  j | j    |  j | j    |  j d
 |  j  d S(   s%  Construct a toplevel widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, class,
        colormap, container, cursor, height, highlightbackground,
        highlightcolor, highlightthickness, menu, relief, screen, takefocus,
        use, visual, width.R   t   class_R   R6  t   colormapiRi  R)   R2  R?  N(    (   R(   Rj  RU   RI   R  R   R  R   (	   RR   RS   R#   R   Rn  t   wmkeyR  t   optR  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   J  s"    
 
N(   R7   R8   R9   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRr  H  s   t   Buttonc           B   s\   e  Z d  Z d	 i  d  Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z RS(
   s   Button widget.c         K   s   t  j |  | d | |  d S(   sU  Construct a button widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, activeforeground, anchor,
            background, bitmap, borderwidth, cursor,
            disabledforeground, font, foreground
            highlightbackground, highlightcolor,
            highlightthickness, image, justify,
            padx, pady, relief, repeatdelay,
            repeatinterval, takefocus, text,
            textvariable, underline, wraplength

        WIDGET-SPECIFIC OPTIONS

            command, compound, default, height,
            overrelief, state, width
        t   buttonN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   f  s    c         G   s   |  j  j d |  j  d  S(   Nt   tkButtonEnter(   R.   RP   R   (   RR   t   dummy(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRy  {  s    c         G   s   |  j  j d |  j  d  S(   Nt   tkButtonLeave(   R.   RP   R   (   RR   Rz  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR{  ~  s    c         G   s   |  j  j d |  j  d  S(   Nt   tkButtonDown(   R.   RP   R   (   RR   Rz  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR|    s    c         G   s   |  j  j d |  j  d  S(   Nt
   tkButtonUp(   R.   RP   R   (   RR   Rz  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR}    s    c         G   s   |  j  j d |  j  d  S(   Nt   tkButtonInvoke(   R.   RP   R   (   RR   Rz  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR~    s    c         C   s   |  j  j |  j d  d S(   s_  Flash the button.

        This is accomplished by redisplaying
        the button several times, alternating between active and
        normal colors. At the end of the flash the button is left
        in the same normal/active state as when the command was
        invoked. This command is ignored if the button's state is
        disabled.
        t   flashN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    
c         C   s   |  j  j |  j d  S(   s  Invoke the command associated with the button.

        The return value is the return value from the command,
        or an empty string if there is no command associated with
        the button. This command is ignored if the button's state
        is disabled.
        t   invoke(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    N(   R7   R8   R9   R   RU   Ry  R{  R|  R}  R~  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRw  d  s   						c           C   s   d S(   Nt   end(    (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   AtEnd  s    c          G   s2   d } x% |  D] } | r | d | } q q W| S(   Nt   insertR   (    (   R   R   t   a(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   AtInsert  s
     c           C   s   d S(   Ns	   sel.first(    (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   AtSelFirst  s    c           C   s   d S(   Ns   sel.last(    (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   AtSelLast  s    c         C   s)   | d  k r d |  f Sd |  | f Sd  S(   Ns   @%rs   @%r,%r(   R   (   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   At  s    t   Canvasc           B   sI  e  Z d  Z d: i  d  Z d   Z d   Z d   Z d   Z d: d: d  Z	 d   Z
 d   Z d	   Z d
   Z d: d  Z d: d: d: d  Z d: d  Z d: d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z  d   Z! d   Z" d    Z# d: d: d!  Z$ d"   Z% d#   Z& d$   Z' d%   Z( d&   Z) d'   Z* d(   Z+ d)   Z, d*   Z- d: d+  Z. e. Z/ d,   Z0 e0 Z1 d-   Z2 i  d.  Z3 d/   Z4 e4 Z5 Z6 d0   Z7 d1   Z8 d2 d3  Z9 d4   Z: d5   Z; d6   Z< d7   Z= d8   Z> d9   Z? RS(;   s?   Canvas widget to display graphical elements like lines or text.c         K   s   t  j |  | d | |  d S(   s  Construct a canvas widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, closeenough,
        confine, cursor, height, highlightbackground, highlightcolor,
        highlightthickness, insertbackground, insertborderwidth,
        insertofftime, insertontime, insertwidth, offset, relief,
        scrollregion, selectbackground, selectborderwidth, selectforeground,
        state, takefocus, width, xscrollcommand, xscrollincrement,
        yscrollcommand, yscrollincrement.t   canvasN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s    
c         G   s!   |  j  j |  j d f |  d S(   s   Internal function.t   addtagN(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  | d |  d S(   s*   Add tag NEWTAG to all items above TAGORID.t   aboveN(   R  (   RR   t   newtagt   tagOrId(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   addtag_above  s    c         C   s   |  j  | d  d S(   s   Add tag NEWTAG to all items.R^  N(   R  (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   addtag_all  s    c         C   s   |  j  | d |  d S(   s*   Add tag NEWTAG to all items below TAGORID.t   belowN(   R  (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   addtag_below  s    c         C   s    |  j  | d | | | |  d S(   s   Add tag NEWTAG to item which is closest to pixel at X, Y.
        If several match take the top-most.
        All items closer than HALO are considered overlapping (all are
        closests). If START is specified the next below this tag is taken.t   closestN(   R  (   RR   R  RA  RN  t   halot   start(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   addtag_closest  s    c         C   s    |  j  | d | | | |  d S(   sL   Add tag NEWTAG to all items in the rectangle defined
        by X1,Y1,X2,Y2.t   enclosedN(   R  (   RR   R  t   x1t   y1t   x2t   y2(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   addtag_enclosed  s    c         C   s    |  j  | d | | | |  d S(   sW   Add tag NEWTAG to all items which overlap the rectangle
        defined by X1,Y1,X2,Y2.t   overlappingN(   R  (   RR   R  R  R  R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   addtag_overlapping  s    c         C   s   |  j  | d |  d S(   s)   Add tag NEWTAG to all items with TAGORID.t   withtagN(   R  (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   addtag_withtag  s    c         G   s,   |  j  |  j j |  j d f |   p+ d S(   s|   Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
        which encloses all items with tags specified as arguments.R  N(   R  R.   RP   R   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s9   |  j  j |  j d | | d  | r5 |  j |  n  d S(   sb   Unbind for all items with TAGORID for event SEQUENCE  the
        function identified with FUNCID.R\  RE   N(   R.   RP   R   RX   (   RR   R  RX  RZ  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   tag_unbind  s    c         C   s"   |  j  |  j d | f | | |  S(   s&  Bind to all items with TAGORID at event SEQUENCE a call to function FUNC.

        An additional boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or whether it will
        replace the previous function. See bind for the return value.R\  (   R[  R   (   RR   R  RX  R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   tag_bind  s    c         C   s"   t  |  j j |  j d | |   S(   sr   Return the canvas x coordinate of pixel position SCREENX rounded
        to nearest multiple of GRIDSPACING units.t   canvasx(   R{   R.   RP   R   (   RR   t   screenxt   gridspacing(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s"   t  |  j j |  j d | |   S(   sr   Return the canvas y coordinate of pixel position SCREENY rounded
        to nearest multiple of GRIDSPACING units.t   canvasy(   R{   R.   RP   R   (   RR   t   screenyR  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         G   s2   t  t |  j j |  j j |  j d f |    S(   s8   Return a list of coordinates for the item given in ARGS.t   coords(   R   R{   R.   R*   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    	c      	   C   ss   t  |  } | d } t |  t t f k r; | d  } n i  } t |  j j |  j d | | |  j | |    S(   s   Internal function.iR-  (	   R   R   R   R   Ry   R.   RP   R   R   (   RR   t   itemTypeR   R   R#   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _create 	  s    
c         O   s   |  j  d | |  S(   s6   Create arc shaped region with coordinates x1,y1,x2,y2.t   arc(   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   create_arc	  s    c         O   s   |  j  d | |  S(   s%   Create bitmap with coordinates x1,y1.R  (   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   create_bitmap	  s    c         O   s   |  j  d | |  S(   s)   Create image item with coordinates x1,y1.R  (   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   create_image	  s    c         O   s   |  j  d | |  S(   s-   Create line with coordinates x1,y1,...,xn,yn.t   line(   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   create_line	  s    c         O   s   |  j  d | |  S(   s)   Create oval with coordinates x1,y1,x2,y2.t   oval(   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   create_oval	  s    c         O   s   |  j  d | |  S(   s0   Create polygon with coordinates x1,y1,...,xn,yn.t   polygon(   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   create_polygon	  s    c         O   s   |  j  d | |  S(   s.   Create rectangle with coordinates x1,y1,x2,y2.t	   rectangle(   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   create_rectangle	  s    c         O   s   |  j  d | |  S(   s#   Create text with coordinates x1,y1.t   text(   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   create_text 	  s    c         O   s   |  j  d | |  S(   s+   Create window with coordinates x1,y1,x2,y2.R   (   R  (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   create_window#	  s    c         G   s!   |  j  j |  j d f |  d S(   s   Delete characters of text items identified by tag or id in ARGS (possibly
        several times) from FIRST to LAST character (including).t   dcharsN(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  &	  s    c         G   s!   |  j  j |  j d f |  d S(   s<   Delete items identified by all tag or ids contained in ARGS.R  N(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  *	  s    c         G   s!   |  j  j |  j d f |  d S(   si   Delete tag or id given as last arguments in ARGS from items
        identified by first argument in ARGS.t   dtagN(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  -	  s    c         G   s,   |  j  |  j j |  j d f |   p+ d S(   s   Internal function.t   find(    (   R  R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  1	  s    c         C   s   |  j  d |  S(   s   Return items above TAGORID.R  (   R  (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   find_above5	  s    c         C   s   |  j  d  S(   s   Return all items.R^  (   R  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   find_all8	  s    c         C   s   |  j  d |  S(   s   Return all items below TAGORID.R  (   R  (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   find_below;	  s    c         C   s   |  j  d | | | |  S(   s   Return item which is closest to pixel at X, Y.
        If several match take the top-most.
        All items closer than HALO are considered overlapping (all are
        closests). If START is specified the next below this tag is taken.R  (   R  (   RR   RA  RN  R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   find_closest>	  s    c         C   s   |  j  d | | | |  S(   s=   Return all items in rectangle defined
        by X1,Y1,X2,Y2.R  (   R  (   RR   R  R  R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   find_enclosedD	  s    c         C   s   |  j  d | | | |  S(   sL   Return all items which overlap the rectangle
        defined by X1,Y1,X2,Y2.R  (   R  (   RR   R  R  R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   find_overlappingH	  s    c         C   s   |  j  d |  S(   s   Return all items with TAGORID.R  (   R  (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   find_withtagL	  s    c         G   s   |  j  j |  j d f |  S(   s.   Set focus to the first item specified in ARGS.R   (   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   O	  s    c         G   s)   |  j  j |  j  j |  j d f |   S(   s=   Return tags associated with the first item specified in ARGS.t   gettags(   R.   R*   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  R	  s    	c         G   s!   |  j  j |  j d f |  d S(   sd   Set cursor at position POS in the item identified by TAGORID.
        In ARGS TAGORID must be first.t   icursorN(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  V	  s    c         G   s#   t  |  j j |  j d f |   S(   s?   Return position of cursor as integer in item specified in ARGS.R  (   Ry   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  Z	  s    c         G   s!   |  j  j |  j d f |  d S(   sS   Insert TEXT in item TAGORID at position POS. ARGS must
        be TAGORID POS TEXT.R  N(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  ]	  s    c         C   s'   |  j  j |  j d f | d | f  S(   s9   Return the resource value for an OPTION for item TAGORID.t   itemcgetR)   (   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  a	  s    	c         K   s   |  j  d | f | |  S(   s   Configure resources of an item TAGORID.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method without arguments.
        t   itemconfigure(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  e	  s    c         G   s!   |  j  j |  j d f |  d S(   sJ   Lower an item TAGORID given in ARGS
        (optional below another item).R   N(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   tag_lowerr	  s    c         G   s!   |  j  j |  j d f |  d S(   s#   Move an item TAGORID given in ARGS.t   moveN(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  w	  s    c         K   s)   |  j  j |  j d f |  j | |   S(   s   Print the contents of the canvas to a postscript
        file. Valid options: colormap, colormode, file, fontmap,
        height, pageanchor, pageheight, pagewidth, pagex, pagey,
        rotate, witdh, x, y.t
   postscript(   R.   RP   R   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  z	  s    c         G   s!   |  j  j |  j d f |  d S(   sJ   Raise an item TAGORID given in ARGS
        (optional above another item).R   N(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   tag_raise	  s    c         G   s!   |  j  j |  j d f |  d S(   s9   Scale item TAGORID with XORIGIN, YORIGIN, XSCALE, YSCALE.t   scaleN(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s#   |  j  j |  j d d | |  d S(   s&   Remember the current X, Y coordinates.t   scant   markN(   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   scan_mark	  s    i
   c         C   s&   |  j  j |  j d d | | |  d S(   s   Adjust the view of the canvas to GAIN times the
        difference between X and Y and the coordinates given in
        scan_mark.R  t   dragtoN(   R.   RP   R   (   RR   RA  RN  t   gain(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   scan_dragto	  s    c         C   s#   |  j  j |  j d d | |  d S(   sL   Adjust the end of the selection near the cursor of an item TAGORID to index.t   selectt   adjustN(   R.   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   select_adjust	  s    c         C   s   |  j  j |  j d d  d S(   s,   Clear the selection if it is in this widget.R  R   N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   select_clear	  s    c         C   s#   |  j  j |  j d d | |  d S(   s:   Set the fixed end of a selection in item TAGORID to INDEX.R  t   fromN(   R.   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   select_from	  s    c         C   s   |  j  j |  j d d  p d S(   s(   Return the item which has the selection.R  R   N(   R.   RP   R   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   select_item	  s    c         C   s#   |  j  j |  j d d | |  d S(   s=   Set the variable end of a selection in item TAGORID to INDEX.R  t   toN(   R.   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   select_to	  s    c         C   s   |  j  j |  j d |  p d S(   s$   Return the type of the item TAGORID.R   N(   R.   RP   R   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   	  s    N(@   R7   R8   R9   R   RU   R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R   R  R  R  R  R  R  t
   itemconfigR  R   R  R  R  R  R   R  R  R  R  R  R  R  R  R   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    sx   																																						
							t   Checkbuttonc           B   sJ   e  Z d  Z d i  d  Z d   Z d   Z d   Z d   Z d   Z	 RS(   s7   Checkbutton widget which is either in on- or off-state.c         K   s   t  j |  | d | |  d S(   s  Construct a checkbutton widget with the parent MASTER.

        Valid resource names: activebackground, activeforeground, anchor,
        background, bd, bg, bitmap, borderwidth, command, cursor,
        disabledforeground, fg, font, foreground, height,
        highlightbackground, highlightcolor, highlightthickness, image,
        indicatoron, justify, offvalue, onvalue, padx, pady, relief,
        selectcolor, selectimage, state, takefocus, text, textvariable,
        underline, variable, width, wraplength.t   checkbuttonN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   	  s    
c         C   s   |  j  j |  j d  d S(   s   Put the button in off-state.t   deselectN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s   |  j  j |  j d  d S(   s   Flash the button.R  N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s   |  j  j |  j d  S(   s<   Toggle the button and invoke a command if given as resource.R  (   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s   |  j  j |  j d  d S(   s   Put the button in on-state.R  N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s   |  j  j |  j d  d S(   s   Toggle the button.t   toggleN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    N(
   R7   R8   R9   R   RU   R  R  R  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s   				t   Entryc           B   s   e  Z d  Z d i  d  Z d d  Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z d	   Z e Z d
   Z e Z d   Z e Z d   Z e Z d   Z e Z d   Z e Z RS(   s1   Entry widget which allows displaying simple text.c         K   s   t  j |  | d | |  d S(   s  Construct an entry widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, cursor,
        exportselection, fg, font, foreground, highlightbackground,
        highlightcolor, highlightthickness, insertbackground,
        insertborderwidth, insertofftime, insertontime, insertwidth,
        invalidcommand, invcmd, justify, relief, selectbackground,
        selectborderwidth, selectforeground, show, state, takefocus,
        textvariable, validate, validatecommand, vcmd, width,
        xscrollcommand.t   entryN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   	  s    c         C   s    |  j  j |  j d | |  d S(   s.   Delete text from FIRST to LAST (not included).R  N(   R.   RP   R   (   RR   t   firstt   last(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s   |  j  j |  j d  S(   s   Return the text.R]   (   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]   	  s    c         C   s   |  j  j |  j d |  d S(   s   Insert cursor at INDEX.R  N(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s   t  |  j j |  j d |   S(   s   Return position of cursor.R  (   Ry   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s    |  j  j |  j d | |  d S(   s   Insert STRING at INDEX.R  N(   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s    |  j  j |  j d d |  d S(   s&   Remember the current X, Y coordinates.R  R  N(   R.   RP   R   (   RR   RA  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s    |  j  j |  j d d |  d S(   s   Adjust the view of the canvas to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark.R  R  N(   R.   RP   R   (   RR   RA  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s    c         C   s    |  j  j |  j d d |  d S(   s9   Adjust the end of the selection near the cursor to INDEX.R   R  N(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_adjust	  s    c         C   s   |  j  j |  j d d  d S(   s,   Clear the selection if it is in this widget.R   R   N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   	  s    c         C   s    |  j  j |  j d d |  d S(   s*   Set the fixed end of a selection to INDEX.R   R  N(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_from	  s    c         C   s%   |  j  j |  j  j |  j d d   S(   sS   Return True if there are characters selected in the entry, False
        otherwise.R   t   present(   R.   RO   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_present	  s    	c         C   s#   |  j  j |  j d d | |  d S(   s3   Set the selection from START to END (not included).R   t   rangeN(   R.   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_range	  s    c         C   s    |  j  j |  j d d |  d S(   s-   Set the variable end of a selection to INDEX.R   R  N(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_to	  s    N(   R7   R8   R9   R   RU   R  R]   R  R  R  R  R  R  R  R   R  R  R  R  t   select_presentR  t   select_rangeR  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  	  s*   												t   Framec           B   s   e  Z d  Z d i  d  Z RS(   sF   Frame widget which may contain other widgets and can have a 3D border.c         K   s   t  | | f  } d } d | k r> d | d f } | d =n& d | k rd d | d f } | d =n  t j |  | d | i  |  d S(   s  Construct a frame widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, class,
        colormap, container, cursor, height, highlightbackground,
        highlightcolor, highlightthickness, relief, takefocus, visual, width.Rs  s   -classR   R  N(    (   R(   Rq  RU   (   RR   RS   R#   R   Rn  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   
  s    

N(   R7   R8   R9   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s   t   Labelc           B   s   e  Z d  Z d i  d  Z RS(   s0   Label widget which can display text and bitmaps.c         K   s   t  j |  | d | |  d S(   s  Construct a label widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, activeforeground, anchor,
            background, bitmap, borderwidth, cursor,
            disabledforeground, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, image, justify,
            padx, pady, relief, takefocus, text,
            textvariable, underline, wraplength

        WIDGET-SPECIFIC OPTIONS

            height, state, width

        t   labelN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   
  s    N(   R7   R8   R9   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s   t   Listboxc           B   s   e  Z d  Z d i  d  Z d   Z d   Z d   Z d d  Z d d  Z	 d   Z
 d   Z d	   Z d
   Z d   Z d   Z d   Z e Z d d  Z e Z d   Z e Z d d  Z e Z d   Z d   Z d d  Z e Z RS(   s3   Listbox widget which can display a list of strings.c         K   s   t  j |  | d | |  d S(   s  Construct a listbox widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, cursor,
        exportselection, fg, font, foreground, height, highlightbackground,
        highlightcolor, highlightthickness, relief, selectbackground,
        selectborderwidth, selectforeground, selectmode, setgrid, takefocus,
        width, xscrollcommand, yscrollcommand, listvariable.t   listboxN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   ,
  s    c         C   s   |  j  j |  j d |  d S(   s"   Activate item identified by INDEX.t   activateN(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  5
  s    c         C   s(   |  j  |  j j |  j d |   p' d S(   sx   Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
        which encloses the item identified by the given index.R  N(   R  R.   RP   R   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  8
  s    c         C   s%   |  j  |  j j |  j d   p$ d S(   s.   Return the indices of currently selected item.t   curselection(    (   R  R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  <
  s    c         C   s    |  j  j |  j d | |  d S(   s+   Delete items from FIRST to LAST (included).R  N(   R.   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  ?
  s    c         C   sQ   | d k	 r4 |  j j |  j j |  j d | |   S|  j j |  j d |  Sd S(   s0   Get list of items from FIRST to LAST (included).R]   N(   R   R.   R*   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]   B
  s    c         C   s5   |  j  j |  j d |  } | d k r+ d St |  S(   s+   Return index of item identified with INDEX.R  R   N(   R.   RP   R   R   Ry   (   RR   R  t   i(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  I
  s     c         G   s$   |  j  j |  j d | f |  d S(   s   Insert ELEMENTS at INDEX.R  N(   R.   RP   R   (   RR   R  t   elements(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  N
  s    c         C   s   t  |  j j |  j d |   S(   s5   Get index of item which is nearest to y coordinate Y.t   nearest(   Ry   R.   RP   R   (   RR   RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  Q
  s    c         C   s#   |  j  j |  j d d | |  d S(   s&   Remember the current X, Y coordinates.R  R  N(   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  U
  s    c         C   s#   |  j  j |  j d d | |  d S(   s   Adjust the view of the listbox to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark.R  R  N(   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  X
  s    c         C   s   |  j  j |  j d |  d S(   s"   Scroll such that INDEX is visible.t   seeN(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  ]
  s    c         C   s    |  j  j |  j d d |  d S(   s-   Set the fixed end oft the selection to INDEX.R   t   anchorN(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_anchor`
  s    c         C   s#   |  j  j |  j d d | |  d S(   s2   Clear the selection from FIRST to LAST (included).R   R   N(   R.   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   d
  s    c         C   s(   |  j  j |  j  j |  j d d |   S(   s+   Return 1 if INDEX is part of the selection.R   t   includes(   R.   RO   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_includesi
  s    c         C   s#   |  j  j |  j d d | |  d S(   si   Set the selection from FIRST to LAST (included) without
        changing the currently selected elements.R   RN   N(   R.   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_setn
  s    c         C   s   t  |  j j |  j d   S(   s-   Return the number of elements in the listbox.R  (   Ry   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  s
  s    c         C   s'   |  j  j |  j d f | d | f  S(   s4   Return the resource value for an ITEM and an OPTION.R  R)   (   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  v
  s    	c         K   s   |  j  d | f | |  S(   s9  Configure resources of an ITEM.

        The values for resources are specified as keyword arguments.
        To get an overview about the allowed keyword arguments
        call the method without arguments.
        Valid resource names: background, bg, foreground, fg,
        selectbackground, selectforeground.R  (   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  z
  s    N(   R7   R8   R9   R   RU   R  R  R  R  R]   R  R  R  R  R  R  R  t   select_anchorR   R  R  t   select_includesR  t
   select_setR  R  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  *
  s2   															t   Menuc           B   s  e  Z d  Z d% i  d  Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z d	   Z d
   Z d   Z d   Z d d  Z d   Z i  d  Z i  d  Z i  d  Z i  d  Z i  d  Z i  d  Z i  d  Z i  d  Z i  d  Z i  d  Z i  d  Z i  d  Z d% d  Z d   Z d% d  Z  e  Z! d   Z" d    Z# d!   Z$ d"   Z% d#   Z& d$   Z' RS(&   sP   Menu widget which allows displaying menu bars, pull-down menus and pop-up menus.c         K   s   t  j |  | d | |  d S(   sA  Construct menu widget with the parent MASTER.

        Valid resource names: activebackground, activeborderwidth,
        activeforeground, background, bd, bg, borderwidth, cursor,
        disabledforeground, fg, font, foreground, postcommand, relief,
        selectcolor, takefocus, tearoff, tearoffcommand, title, type.t   menuN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   
  s    c         C   s&   d d  l  } | j d t d d d  S(   Nis=   tk_bindForTraversal() does nothing and will be removed in 3.6R   i   (   R   R   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   tk_bindForTraversal
  s    	c         C   s   |  j  j d |  j  d  S(   Nt	   tk_mbPost(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j d  d  S(   Nt   tk_mbUnpost(   R.   RP   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j d |  j |  d  S(   Nt   tk_traverseToMenu(   R.   RP   R   (   RR   Rw  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j d |  j |  d  S(   Nt   tk_traverseWithinMenu(   R.   RP   R   (   RR   Rw  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j d |  j  S(   Nt   tk_getMenuButtons(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j d |  d  S(   Nt   tk_nextMenu(   R.   RP   (   RR   t   count(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR	  
  s    c         C   s   |  j  j d |  d  S(   Nt   tk_nextMenuEntry(   R.   RP   (   RR   R
  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j d |  j  d  S(   Nt   tk_invokeMenu(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j d |  j  d  S(   Nt   tk_firstMenu(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j d |  j  d  S(   Nt   tk_mbButtonDown(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    RE   c         C   s#   |  j  j d |  j | | |  d S(   s/   Post the menu at position X,Y with entry ENTRY.t   tk_popupN(   R.   RP   R   (   RR   RA  RN  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s   |  j  j |  j d |  d S(   s   Activate entry at INDEX.R  N(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         K   s0   |  j  j |  j d | f |  j | |   d S(   s   Internal function.R   N(   R.   RP   R   R   (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   
  s    c         K   s   |  j  d | p |  d S(   s   Add hierarchical menu item.t   cascadeN(   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   add_cascade
  s    c         K   s   |  j  d | p |  d S(   s   Add checkbutton menu item.R  N(   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   add_checkbutton
  s    c         K   s   |  j  d | p |  d S(   s   Add command menu item.R   N(   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   add_command
  s    c         K   s   |  j  d | p |  d S(   s   Addd radio menu item.t   radiobuttonN(   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   add_radiobutton
  s    c         K   s   |  j  d | p |  d S(   s   Add separator.t	   separatorN(   R   (   RR   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   add_separator
  s    c         K   s3   |  j  j |  j d | | f |  j | |   d S(   s   Internal function.R  N(   R.   RP   R   R   (   RR   R  R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         K   s   |  j  | d | p |  d S(   s$   Add hierarchical menu item at INDEX.R  N(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   insert_cascade
  s    c         K   s   |  j  | d | p |  d S(   s#   Add checkbutton menu item at INDEX.R  N(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   insert_checkbutton
  s    c         K   s   |  j  | d | p |  d S(   s   Add command menu item at INDEX.R   N(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   insert_command
  s    c         K   s   |  j  | d | p |  d S(   s   Addd radio menu item at INDEX.R  N(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   insert_radiobutton
  s    c         K   s   |  j  | d | p |  d S(   s   Add separator at INDEX.R  N(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   insert_separator
  s    c         C   s   | d k r | } n  |  j |  |  j |  } } | d k sL | d k r[ d \ } } n  xa t | | d  D]L } d |  j |  k ro t |  j | d   } | r |  j |  q qo qo W|  j j |  j	 d | |  d S(   s7   Delete menu items between INDEX1 and INDEX2 (included).i    ii   R   R  N(   i    i(
   R   R  R  t   entryconfigR   t	   entrycgetRX   R.   RP   R   (   RR   t   index1t   index2t
   num_index1t
   num_index2R  R$   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    	c         C   s    |  j  j |  j d | d |  S(   s=   Return the resource value of a menu item for OPTION at INDEX.R  R)   (   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         K   s   |  j  d | f | |  S(   s   Configure a menu item at INDEX.t   entryconfigure(   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR#  
  s    c         C   s5   |  j  j |  j d |  } | d k r+ d St |  S(   s4   Return the index of a menu item identified by INDEX.R  R   N(   R.   RP   R   R   Ry   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s     c         C   s   |  j  j |  j d |  S(   sR   Invoke a menu item identified by INDEX and execute
        the associated command.R  (   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  s    c         C   s    |  j  j |  j d | |  d S(   s   Display a menu at position X,Y.t   postN(   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR$  
  s    c         C   s   |  j  j |  j d |  S(   s*   Return the type of the menu item at INDEX.R   (   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   
  s    c         C   s   |  j  j |  j d  d S(   s   Unmap a menu.t   unpostN(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR%  
  s    c         C   s   t  |  j j |  j d |   S(   sE   Return the y-position of the topmost pixel of the menu item at INDEX.t	   yposition(   Ry   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR&  
  s    N((   R7   R8   R9   R   RU   R  R  R  R  R  R  R	  R  R  R  R  R  R  R   R  R  R  R  R  R  R  R  R  R  R  R  R  R#  R  R  R  R$  R   R%  R&  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  
  sJ   																		t
   Menubuttonc           B   s   e  Z d  Z d i  d  Z RS(   s(   Menubutton widget, obsolete since Tk8.0.c         K   s   t  j |  | d | |  d  S(   Nt
   menubutton(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s    N(   R7   R8   R9   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR'    s   t   Messagec           B   s   e  Z d  Z d i  d  Z RS(   sK   Message widget to display multiline text. Obsolete since Label does it too.c         K   s   t  j |  | d | |  d  S(   Nt   message(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   	  s    N(   R7   R8   R9   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR)    s   t   Radiobuttonc           B   sA   e  Z d  Z d i  d  Z d   Z d   Z d   Z d   Z RS(   sG   Radiobutton widget which shows only one of several buttons in on-state.c         K   s   t  j |  | d | |  d S(   s  Construct a radiobutton widget with the parent MASTER.

        Valid resource names: activebackground, activeforeground, anchor,
        background, bd, bg, bitmap, borderwidth, command, cursor,
        disabledforeground, fg, font, foreground, height,
        highlightbackground, highlightcolor, highlightthickness, image,
        indicatoron, justify, padx, pady, relief, selectcolor, selectimage,
        state, takefocus, text, textvariable, underline, value, variable,
        width, wraplength.R  N(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s    
c         C   s   |  j  j |  j d  d S(   s   Put the button in off-state.R  N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  j |  j d  d S(   s   Flash the button.R  N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  j |  j d  S(   s<   Toggle the button and invoke a command if given as resource.R  (   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  j |  j d  d S(   s   Put the button in on-state.R  N(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  #  s    N(	   R7   R8   R9   R   RU   R  R  R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR+    s   			t   Scalec           B   sD   e  Z d  Z d i  d  Z d   Z d   Z d d  Z d   Z RS(   s1   Scale widget which can display a numerical scale.c         K   s   t  j |  | d | |  d S(   s  Construct a scale widget with the parent MASTER.

        Valid resource names: activebackground, background, bigincrement, bd,
        bg, borderwidth, command, cursor, digits, fg, font, foreground, from,
        highlightbackground, highlightcolor, highlightthickness, label,
        length, orient, relief, repeatdelay, repeatinterval, resolution,
        showvalue, sliderlength, sliderrelief, state, takefocus,
        tickinterval, to, troughcolor, variable, width.R  N(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   )  s    	c         C   sE   |  j  j |  j d  } y t |  SWn t k
 r@ t |  SXd S(   s*   Get the current value as integer or float.R]   N(   R.   RP   R   Ry   R@   R{   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]   3  s
    c         C   s   |  j  j |  j d |  d S(   s   Set the value to VALUE.RN   N(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRN   :  s    c         C   s"   |  j  |  j j |  j d |   S(   s   Return a tuple (X,Y) of the point along the centerline of the
        trough that corresponds to VALUE or the current value if None is
        given.R  (   R  R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  =  s    c         C   s   |  j  j |  j d | |  S(   sc   Return where the point X,Y lies. Valid return values are "slider",
        "though1" and "though2".t   identify(   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR-  C  s    N(	   R7   R8   R9   R   RU   R]   RN   R  R-  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR,  '  s   
		t	   Scrollbarc           B   sS   e  Z d  Z d i  d  Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 RS(	   s?   Scrollbar widget which displays a slider at a certain position.c         K   s   t  j |  | d | |  d S(   sl  Construct a scrollbar widget with the parent MASTER.

        Valid resource names: activebackground, activerelief,
        background, bd, bg, borderwidth, command, cursor,
        elementborderwidth, highlightbackground,
        highlightcolor, highlightthickness, jump, orient,
        relief, repeatdelay, repeatinterval, takefocus,
        troughcolor, width.t	   scrollbarN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   J  s    	c         C   s   |  j  j |  j d |  d S(   sx   Display the element at INDEX with activebackground and activerelief.
        INDEX can be "arrow1","slider" or "arrow2".R  N(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  T  s    c         C   s"   t  |  j j |  j d | |   S(   sn   Return the fractional change of the scrollbar setting if it
        would be moved by DELTAX or DELTAY pixels.R~  (   R{   R.   RP   R   (   RR   t   deltaxt   deltay(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR~  X  s    c         C   s"   t  |  j j |  j d | |   S(   sR   Return the fractional value which corresponds to a slider
        position of X,Y.R  (   R{   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  ]  s    c         C   s   |  j  j |  j d | |  S(   sY   Return the element under position X,Y as one of
        "arrow1","slider","arrow2" or "".R-  (   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR-  a  s    c         C   s   |  j  |  j j |  j d   S(   sZ   Return the current fractional values (upper and lower end)
        of the slider position.R]   (   Rd  R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]   e  s    c         G   s!   |  j  j |  j d f |  d S(   si   Set the fractional values of the slider position (upper and
        lower ends as value between 0 and 1).RN   N(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRN   i  s    N(   R7   R8   R9   R   RU   R  R~  R  R-  R]   RN   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR.  H  s   
					t   Textc        	   B   sH  e  Z d  Z d5 i  d  Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d5 d  Z d5 d	  Z d
   Z d5 d5 d  Z d   Z d5 d  Z d   Z d   Z d   Z d   Z d5 d  Z d   Z d5 d  Z i  d  Z d   Z d   Z d   Z d5 d  Z d   Z d   Z d   Z d   Z  d   Z! d   Z" d    Z# d5 d5 d5 d5 d5 d5 d5 d5 d!  Z$ d"   Z% d#   Z& d5 d$  Z' d5 d%  Z( d&   Z) d5 d'  Z* e* Z+ d(   Z, d5 d)  Z- d5 d*  Z. d5 d+  Z/ d5 d,  Z0 d5 d-  Z1 d.   Z2 d5 d/  Z3 d0   Z4 d5 d1  Z5 e5 Z6 i  d2  Z7 d3   Z8 d4   Z9 RS(6   s4   Text widget which can display text in various forms.c         K   s   t  j |  | d | |  d S(   s  Construct a text widget with the parent MASTER.

        STANDARD OPTIONS

            background, borderwidth, cursor,
            exportselection, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, insertbackground,
            insertborderwidth, insertofftime,
            insertontime, insertwidth, padx, pady,
            relief, selectbackground,
            selectborderwidth, selectforeground,
            setgrid, takefocus,
            xscrollcommand, yscrollcommand,

        WIDGET-SPECIFIC OPTIONS

            autoseparators, height, maxundo,
            spacing1, spacing2, spacing3,
            state, tabs, undo, width, wrap,

        R  N(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   r  s    c         G   s,   |  j  |  j j |  j d f |   p+ d S(   s   Return a tuple of (x,y,width,height) which gives the bounding
        box of the visible part of the character at the index in ARGS.R  N(   R  R.   RP   R   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  j d |  j |  d  S(   Nt   tk_textSelectTo(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR3    s    c         C   s   |  j  j d |  j  d  S(   Nt   tk_textBackspace(   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR4    s    c         C   s#   |  j  j d |  j | | |  d  S(   Nt   tk_textIndexCloser(   R.   RP   R   (   RR   R  R  R$   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR5    s    c         C   s   |  j  j d |  j |  d  S(   Nt   tk_textResetAnchor(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR6    s    c         C   s+   |  j  j |  j  j |  j d | | |   S(   s   Return whether between index INDEX1 and index INDEX2 the
        relation OP is satisfied. OP is one of <, <=, ==, >=, >, or !=.t   compare(   R.   RO   RP   R   (   RR   R  t   opR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR7    s    c         C   sK   | d k r. |  j j |  j j |  j d   S|  j j |  j d |  d S(   sj   Turn on the internal consistency checks of the B-Tree inside the text
        widget according to BOOLEAN.t   debugN(   R   R.   RO   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR9    s    "c         C   s    |  j  j |  j d | |  d S(   s?   Delete the characters between INDEX1 and INDEX2 (not included).R  N(   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s"   |  j  |  j j |  j d |   S(   s   Return tuple (x,y,width,height,baseline) giving the bounding box
        and baseline position of the visible part of the line containing
        the character at INDEX.t	   dlineinfo(   R  R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR:    s    c   
      K   s   g  } d } d } | s3 g  } | d  } | } n  z t | t  s[ |  j |  } } n  | d | g 7} x, | D]$ }	 | |	 rr | j d |	  qr qr W| j |  | r | j |  n  |  j j |  j d |  | SWd | r |  j |  n  Xd S(   s  Return the contents of the widget between index1 and index2.

        The type of contents returned in filtered based on the keyword
        parameters; if 'all', 'image', 'mark', 'tag', 'text', or 'window' are
        given and true, then the corresponding items are returned. The result
        is a list of triples of the form (key, value, index). If none of the
        keywords are true then 'all' is used by default.

        If the 'command' argument is given, it is called once for each element
        of the list of triples, with the values of each triple serving as the
        arguments to the function. In this case the list is not returned.c         S   s   | j  |  | | f  d  S(   N(   Re   (   R4   R   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   append_triple  s    s   -commandR)   t   dumpN(	   R   R
   R   R   Re   R.   RP   R   RX   (
   RR   R  R   R   R   R   t	   func_nameR   R;  R4   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR<    s*    	
 c         G   s   |  j  j |  j d |  S(   sr  Internal method

        This method controls the undo mechanism and
        the modified flag. The exact behavior of the
        command depends on the option argument that
        follows the edit argument. The following forms
        of the command are currently supported:

        edit_modified, edit_redo, edit_reset, edit_separator
        and edit_undo

        t   edit(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR>    s    c         C   s   |  j  d |  S(   s;  Get or Set the modified flag

        If arg is not specified, returns the modified
        flag of the widget. The insert, delete, edit undo and
        edit redo commands or the user can set or clear the
        modified flag. If boolean is specified, sets the
        modified flag of the widget to arg.
        t   modified(   R>  (   RR   t   arg(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   edit_modified  s    	c         C   s   |  j  d  S(   s  Redo the last undone edit

        When the undo option is true, reapplies the last
        undone edits provided no other edits were done since
        then. Generates an error when the redo stack is empty.
        Does nothing when the undo option is false.
        t   redo(   R>  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   edit_redo  s    c         C   s   |  j  d  S(   s(   Clears the undo and redo stacks
        t   reset(   R>  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   edit_reset  s    c         C   s   |  j  d  S(   sn   Inserts a separator (boundary) on the undo stack.

        Does nothing when the undo option is false
        R  (   R>  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   edit_separator  s    c         C   s   |  j  d  S(   sD  Undoes the last edit action

        If the undo option is true. An edit action is defined
        as all the insert and delete commands that are recorded
        on the undo stack in between two separators. Generates
        an error when the undo stack is empty. Does nothing
        when the undo option is false
        t   undo(   R>  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   edit_undo  s    	c         C   s   |  j  j |  j d | |  S(   s5   Return the text from INDEX1 to INDEX2 (not included).R]   (   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]     s    c         C   sY   | d  d k r d | } n  | d d k r: | d  } n  |  j  j |  j d d | |  S(   s9   Return the value of OPTION of an embedded image at INDEX.i   R)   iRi  R  R  (   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   image_cget  s
    c         K   s   |  j  d d | f | |  S(   s%   Configure an embedded image at INDEX.R  R  (   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   image_configure  s    c         K   s+   |  j  j |  j d d | |  j | |   S(   s"   Create an embedded image at INDEX.R  R-  (   R.   RP   R   R   (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   image_create  s    	c         C   s   |  j  j |  j d d  S(   s3   Return all names of embedded images in this widget.R  R  (   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   t  |  j j |  j d |   S(   s1   Return the index in the form line.char for INDEX.R  (   R   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  #  s    c         G   s'   |  j  j |  j d | | f |  d S(   s   Insert CHARS before the characters at INDEX. An additional
        tag can be given in ARGS. Additional CHARS and tags can follow in ARGS.R  N(   R.   RP   R   (   RR   R  t   charsR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  &  s    c         C   s"   |  j  j |  j d d | | f  S(   s   Change the gravity of a mark MARKNAME to DIRECTION (LEFT or RIGHT).
        Return the current value if None is given for DIRECTION.R  t   gravity(   R.   RP   R   (   RR   t   markNamet	   direction(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   mark_gravity*  s    	c         C   s%   |  j  j |  j  j |  j d d   S(   s   Return all mark names.R  R  (   R.   R*   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   mark_names/  s    c         C   s#   |  j  j |  j d d | |  d S(   s0   Set mark MARKNAME before the character at INDEX.R  RN   N(   R.   RP   R   (   RR   RN  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   mark_set3  s    c         G   s$   |  j  j |  j d d f |  d S(   s   Delete all marks in MARKNAMES.R  t   unsetN(   R.   RP   R   (   RR   t	   markNames(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   mark_unset6  s    c         C   s"   |  j  j |  j d d |  p! d S(   s-   Return the name of the next mark after INDEX.R  t   nextN(   R.   RP   R   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   mark_next9  s    c         C   s"   |  j  j |  j d d |  p! d S(   s2   Return the name of the previous mark before INDEX.R  t   previousN(   R.   RP   R   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   mark_previous<  s    c         C   s#   |  j  j |  j d d | |  d S(   s&   Remember the current X, Y coordinates.R  R  N(   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  ?  s    c         C   s#   |  j  j |  j d d | |  d S(   s~   Adjust the view of the text to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark.R  R  N(   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  B  s    c         C   s(  |  j  d g } | r% | j d  n  | r; | j d  n  | rQ | j d  n  | rg | j d  n  | r} | j d  n  |
 r | j d  n  |	 r | j d  | j |	  n  | r | d	 d
 k r | j d  n  | j |  | j |  | r| j |  n  t |  j j t |    S(   s   Search PATTERN beginning from INDEX until STOPINDEX.
        Return the index of the first character of a match or an
        empty string.R   s	   -forwardss
   -backwardss   -exacts   -regexps   -nocases   -elides   -counti    R)   s   --(   R   Re   R   R.   RP   R   (   RR   R   R  t	   stopindext   forwardst	   backwardst   exactt   regexpt   nocaseR
  t   elideR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   G  s.              c         C   s   |  j  j |  j d |  d S(   s3   Scroll such that the character at INDEX is visible.R  N(   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  Z  s    c         G   s*   |  j  j |  j d d | | f |  d S(   s|   Add tag TAGNAME to all characters between INDEX1 and index2 in ARGS.
        Additional pairs of indices may follow in ARGS.t   tagR   N(   R.   RP   R   (   RR   t   tagNameR  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   tag_add]  s    	c         C   s<   |  j  j |  j d d | | d  | r8 |  j |  n  d S(   sg   Unbind for all characters with TAGNAME for event SEQUENCE  the
        function identified with FUNCID.Ra  R\  RE   N(   R.   RP   R   RX   (   RR   Rb  RX  RZ  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  b  s    "c         C   s%   |  j  |  j d d | f | | |  S(   s+  Bind to all characters with TAGNAME at event SEQUENCE a call to function FUNC.

        An additional boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or whether it will
        replace the previous function. See bind for the return value.Ra  R\  (   R[  R   (   RR   Rb  RX  R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  h  s    c         C   sY   | d  d k r d | } n  | d d k r: | d  } n  |  j  j |  j d d | |  S(   s+   Return the value of OPTION for tag TAGNAME.i   R)   iRi  Ra  R  (   R.   RP   R   (   RR   Rb  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   tag_cgetp  s
    c         K   s   |  j  d d | f | |  S(   s   Configure a tag TAGNAME.Ra  R  (   R  (   RR   Rb  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   tag_configurew  s    c         G   s$   |  j  j |  j d d f |  d S(   s   Delete all tags in TAGNAMES.Ra  R  N(   R.   RP   R   (   RR   t   tagNames(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   tag_delete{  s    c         C   s#   |  j  j |  j d d | |  d S(   s`   Change the priority of tag TAGNAME such that it is lower
        than the priority of BELOWTHIS.Ra  R   N(   R.   RP   R   (   RR   Rb  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  ~  s    c         C   s(   |  j  j |  j  j |  j d d |   S(   s   Return a list of all tag names.Ra  R  (   R.   R*   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   tag_names  s    	c         C   s.   |  j  j |  j  j |  j d d | | |   S(   s   Return a list of start and end index for the first sequence of
        characters between INDEX1 and INDEX2 which all have tag TAGNAME.
        The text is searched forward from INDEX1.Ra  t	   nextrange(   R.   R*   RP   R   (   RR   Rb  R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   tag_nextrange  s    c         C   s.   |  j  j |  j  j |  j d d | | |   S(   s   Return a list of start and end index for the first sequence of
        characters between INDEX1 and INDEX2 which all have tag TAGNAME.
        The text is searched backwards from INDEX1.Ra  t	   prevrange(   R.   R*   RP   R   (   RR   Rb  R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   tag_prevrange  s    c         C   s#   |  j  j |  j d d | |  d S(   sa   Change the priority of tag TAGNAME such that it is higher
        than the priority of ABOVETHIS.Ra  R   N(   R.   RP   R   (   RR   Rb  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    	c         C   s(   |  j  j |  j  j |  j d d |   S(   s7   Return a list of ranges of text which have tag TAGNAME.Ra  t   ranges(   R.   R*   RP   R   (   RR   Rb  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   tag_ranges  s    c         C   s&   |  j  j |  j d d | | |  d S(   sA   Remove tag TAGNAME from all characters between INDEX1 and INDEX2.Ra  Rm   N(   R.   RP   R   (   RR   Rb  R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   tag_remove  s    	c         C   sY   | d  d k r d | } n  | d d k r: | d  } n  |  j  j |  j d d | |  S(   s:   Return the value of OPTION of an embedded window at INDEX.i   R)   iRi  R   R  (   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   window_cget  s
    c         K   s   |  j  d d | f | |  S(   s&   Configure an embedded window at INDEX.R   R  (   R  (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   window_configure  s    c         K   s3   |  j  j |  j d d | f |  j | |   d S(   s   Create a window at INDEX.R   R-  N(   R.   RP   R   R   (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   window_create  s    	c         C   s%   |  j  j |  j  j |  j d d   S(   s4   Return all names of embedded windows in this widget.R   R  (   R.   R*   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   window_names  s    	c         G   s$   |  j  j |  j d d f |  d S(   s   Obsolete function, use see.R  s
   -pickplaceN(   R.   RP   R   (   RR   RW  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   yview_pickplace  s    N(:   R7   R8   R9   R   RU   R  R3  R4  R5  R6  R7  R9  R  R:  R<  R>  RA  RC  RE  RF  RH  R]   RI  RJ  RK  R  R  R  RP  RQ  RR  RU  RW  RY  R  R  R   R  Rc  R  R  Rd  Re  t
   tag_configRg  R  Rh  Rj  Rl  R  Rn  Ro  Rp  Rq  t   window_configRr  Rs  Rt  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR2  p  sr   							(		
																						t   _setitc           B   s#   e  Z d  Z d d  Z d   Z RS(   s>   Internal class. It wraps the command in the widget OptionMenu.c         C   s   | |  _  | |  _ | |  _ d  S(   N(   t   _setit__valuet   _setit__vart   _setit__callback(   RR   t   varR   Rg   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s    		c         G   s6   |  j  j |  j  |  j r2 |  j |  j |  n  d  S(   N(   Ry  RN   Rx  Rz  (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRa     s    	N(   R7   R8   R9   R   RU   Ra   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRw    s   t
   OptionMenuc           B   s)   e  Z d  Z d   Z d   Z d   Z RS(   s?   OptionMenu which allows the user to select a value from a menu.c   
   	   O   s"  i d d 6| d 6d d 6t  d 6d d 6d d	 6} t j |  | d
 |  d |  _ t |  d d d d } |  _ | j |  _ | j d  } d | k r | d =n  | r t	 d | j
   d  n  | j d | d t | | |   x0 | D]( }	 | j d |	 d t | |	 |   q W| |  d <d S(   s   Construct an optionmenu widget with the parent MASTER, with
        the resource textvariable set to VARIABLE, the initially selected
        value VALUE, the other menu values VALUES and an additional
        keyword argument command.i   t   borderwidtht   textvariablei   t   indicatoront   reliefR$   R  t   highlightthicknessR(  t   tk_optionMenuRT   R  t   tearoffi    R   s   unknown option -R  N(   t   RAISEDRq  RU   Rl  R  t   _OptionMenu__menuR   t   menunameR]   R   R  R  Rw  (
   RR   RS   R_   R   RC  t   kwargsR   R  Rg   R'   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s$    
	
c         C   s#   | d k r |  j  St j |  |  S(   NR  (   R  Rq  R  (   RR   RT   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   t  j |   d |  _ d S(   s,   Destroy this widget and the associated menu.N(   R'  R   R   R  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    (   R7   R8   R9   RU   R  R   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR|    s   		t   Imagec           B   st   e  Z d  Z d Z d i  d d  Z d   Z d   Z d   Z d   Z	 d   Z
 e
 Z d   Z d	   Z d
   Z RS(   s   Base class for images.i    c   	      K   s^  d  |  _ | s* t } | s* t d  q* n  t | d |  |  _ | s t j d 7_ d t j f } | d d k r d | d } q n  | r | r t | | f  } n | r | } n  d } xp | j	   D]b \ } } t
 | d  r |  j |  } n! | d k r|  j j |  } n  | d | | f } q W|  j j d d | | f |  | |  _ d  S(   Ns   Too early to create imageR.   i   s	   pyimage%ri    R)   Ri  Ra   R   t   maskdataR  R-  (    (   R   R  (   R   RT   R;   R+   RV  R.   R  t   _last_idR(   R!   Rj  R   t   _createbytearrayRP   (	   RR   t   imgtypeRT   R#   RS   R   R  R&   R'   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s0    	   	 c         C   s   |  j  S(   N(   RT   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRZ     s    c         C   sA   |  j  r= y |  j j d d |  j   Wq= t k
 r9 q= Xn  d  S(   NR  R  (   RT   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRY     s
    	c         C   s$   |  j  j |  j d d | |  d  S(   NR  R)   (   R.   RP   RT   (   RR   R4   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  j |  j d d |  S(   NR  R)   (   R.   RP   RT   (   RR   R4   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         K   s   d	 } x t  |  j   D] \ } } | d k	 r | d d k rN | d  } n  t | d  ro |  j |  } n! | d
 k r |  j j |  } n  | d | | f } q q W|  j j |  j d f |  d S(   s   Configure the image.iRi  Ra   R   R  R)   R  N(    (   R   R  (	   R(   R!   R   Rj  R   R.   R  RP   RT   (   RR   R   R   R&   R'   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s     c         C   s   t  |  j j d d |  j   S(   s   Return the height of the image.R  R   (   Ry   R.   RP   RT   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  j d d |  j  S(   s8   Return the type of the imgage, e.g. "photo" or "bitmap".R  R   (   R.   RP   RT   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR      s    c         C   s   t  |  j j d d |  j   S(   s   Return the width of the image.R  RK  (   Ry   R.   RP   RT   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRK  #  s    N(   R7   R8   R9   R  R   RU   RZ   RY   R  R  R  R  R   R   RK  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s   							t
   PhotoImagec           B   s   e  Z d  Z d i  d d  Z d   Z d   Z d   Z d   Z d d  Z	 d d  Z
 d	   Z d d
  Z d d d  Z RS(   s?   Widget which can display colored images in GIF, PPM/PGM format.c         K   s    t  j |  d | | | |  d S(   st   Create an image with NAME.

        Valid resource names: data, format, file, gamma, height, palette,
        width.t   photoN(   R  RU   (   RR   RT   R#   RS   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   *  s    c         C   s   |  j  j |  j d  d S(   s   Display a transparent image.t   blankN(   R.   RP   RT   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  0  s    c         C   s   |  j  j |  j d d |  S(   s   Return the value of OPTION.R  R)   (   R.   RP   RT   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  3  s    c         C   s   |  j  j |  j d d |  S(   NR  R)   (   R.   RP   RT   (   RR   R4   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  7  s    c         C   s/   t  d |  j  } |  j j | d |  j  | S(   s;   Return a new PhotoImage with the same image as this widget.RS   t   copy(   R  R.   RP   RT   (   RR   t	   destImage(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  :  s    RE   c         C   sM   t  d |  j  } | d k r' | } n  |  j j | d |  j d | |  | S(   s   Return a new PhotoImage with the same image as this widget
        but zoom it with a factor of x in the X direction and y in the Y
        direction.  If y is not given, the default value is the same as x.
        RS   RE   R  s   -zoom(   R  R.   RP   RT   (   RR   RA  RN  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   zoom?  s
     	"c         C   sM   t  d |  j  } | d k r' | } n  |  j j | d |  j d | |  | S(   s   Return a new PhotoImage based on the same image as this widget
        but use only every Xth or Yth pixel.  If y is not given, the
        default value is the same as x.
        RS   RE   R  s
   -subsample(   R  R.   RP   RT   (   RR   RA  RN  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   subsampleH  s
     	"c         C   s   |  j  j |  j d | |  S(   s8   Return the color (red, green, blue) of the pixel at X,Y.R]   (   R.   RP   RT   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]   Q  s    c         C   s`   |  j  d | f } | rL | d d k r5 | d } n  | d t |  } n  |  j j |  d S(   sz   Put row formatted colors to image starting from
        position TO, e.g. image.put("{red green} {blue yellow}", to=(4,6))t   puti    s   -toi   N(   s   -to(   RT   R   R.   RP   (   RR   R   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  T  s    c         C   s\   |  j  d | f } | r+ | d | f } n  | rH | d t |  } n  |  j j |  d S(   sR   Write image to file FILENAME in FORMAT starting from
        position FROM_COORDS.t   writes   -formats   -fromN(   s   -from(   RT   R   R.   RP   (   RR   t   filenamet   formatt   from_coordsR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  ^  s    N(   R7   R8   R9   R   RU   R  R  R  R  R  R  R]   R  R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  (  s   							
t   BitmapImagec           B   s    e  Z d  Z d i  d d  Z RS(   s"   Widget which can display a bitmap.c         K   s    t  j |  d | | | |  d S(   sq   Create a bitmap with NAME.

        Valid resource names: background, data, file, foreground, maskdata, maskfile.R  N(   R  RU   (   RR   RT   R#   RS   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   j  s    N(   R7   R8   R9   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  h  s   c           C   s   t  j j t  j j d d   S(   NR  R  (   R;   R.   R*   RP   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  p  s    c           C   s   t  j j t  j j d d   S(   NR  R  (   R;   R.   R*   RP   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  s  s    t   Spinboxc           B   s   e  Z d  Z d i  d  Z d   Z d d  Z d   Z d   Z d   Z	 d   Z
 d   Z d	   Z d
   Z d   Z d   Z d   Z d   Z d   Z d d  Z RS(   s   spinbox widget.c         K   s   t  j |  | d | |  d S(   s  Construct a spinbox widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, background, borderwidth,
            cursor, exportselection, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, insertbackground,
            insertborderwidth, insertofftime,
            insertontime, insertwidth, justify, relief,
            repeatdelay, repeatinterval,
            selectbackground, selectborderwidth
            selectforeground, takefocus, textvariable
            xscrollcommand.

        WIDGET-SPECIFIC OPTIONS

            buttonbackground, buttoncursor,
            buttondownrelief, buttonuprelief,
            command, disabledbackground,
            disabledforeground, format, from,
            invalidcommand, increment,
            readonlybackground, state, to,
            validate, validatecommand values,
            width, wrap,
        t   spinboxN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   y  s    c         C   s(   |  j  |  j j |  j d |   p' d S(   s  Return a tuple of X1,Y1,X2,Y2 coordinates for a
        rectangle which encloses the character given by index.

        The first two elements of the list give the x and y
        coordinates of the upper-left corner of the screen
        area covered by the character (in pixels relative
        to the widget) and the last two elements give the
        width and height of the character, in pixels. The
        bounding box may refer to a region outside the
        visible area of the window.
        R  N(   R  R.   RP   R   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  j |  j d | |  S(   sW  Delete one or more elements of the spinbox.

        First is the index of the first character to delete,
        and last is the index of the character just after
        the last one to delete. If last isn't specified it
        defaults to first+1, i.e. a single character is
        deleted.  This command returns an empty string.
        R  (   R.   RP   R   (   RR   R  R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    	c         C   s   |  j  j |  j d  S(   s   Returns the spinbox's stringR]   (   R.   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR]     s    c         C   s   |  j  j |  j d |  S(   s   Alter the position of the insertion cursor.

        The insertion cursor will be displayed just before
        the character given by index. Returns an empty string
        R  (   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  j |  j d | |  S(   s{   Returns the name of the widget at position x, y

        Return value is one of: none, buttondown, buttonup, entry
        R-  (   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR-    s    c         C   s   |  j  j |  j d |  S(   s;   Returns the numerical index corresponding to index
        R  (   R.   RP   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  j |  j d | |  S(   sD   Insert string s at index

         Returns an empty string.
        R  (   R.   RP   R   (   RR   R  R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  j |  j d |  S(   s   Causes the specified element to be invoked

        The element could be buttondown or buttonup
        triggering the action associated with it.
        R  (   R.   RP   R   (   RR   t   element(    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         G   s,   |  j  |  j j |  j d f |   p+ d S(   s   Internal function.R  (    (   R  R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  d |  S(   s   Records x and the current view in the spinbox window;

        used in conjunction with later scan dragto commands.
        Typically this command is associated with a mouse button
        press in the widget. It returns an empty string.
        R  (   R  (   RR   RA  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  d |  S(   s  Compute the difference between the given x argument
        and the x argument to the last scan mark command

        It then adjusts the view left or right by 10 times the
        difference in x-coordinates. This command is typically
        associated with mouse motion events in the widget, to
        produce the effect of dragging the spinbox at high speed
        through the window. The return value is an empty string.
        R  (   R  (   RR   RA  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    
c         G   s,   |  j  |  j j |  j d f |   p+ d S(   s   Internal function.R   (    (   R  R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  d |  S(   s  Locate the end of the selection nearest to the character
        given by index,

        Then adjust that end of the selection to be at index
        (i.e including but not going beyond index). The other
        end of the selection is made the anchor point for future
        select to commands. If the selection isn't currently in
        the spinbox, then a new selection is created to include
        the characters between index and the most recent selection
        anchor point, inclusive. Returns an empty string.
        R  (   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    c         C   s   |  j  d  S(   s   Clear the selection

        If the selection isn't in this widget then the
        command has no effect. Returns an empty string.
        R   (   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR     s    c         C   s   |  j  d |  S(   s   Sets or gets the currently selected element.

        If a spinbutton element is specified, it will be
        displayed depressed
        R  (   R   (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   selection_element  s    N(   R7   R8   R9   R   RU   R  R  R]   R  R-  R  R  R  R  R  R  R   R  R   R  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  w  s"   														t
   LabelFramec           B   s   e  Z d  Z d i  d  Z RS(   s   labelframe widget.c         K   s   t  j |  | d | |  d S(   s  Construct a labelframe widget with the parent MASTER.

        STANDARD OPTIONS

            borderwidth, cursor, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, padx, pady, relief,
            takefocus, text

        WIDGET-SPECIFIC OPTIONS

            background, class, colormap, container,
            height, labelanchor, labelwidget,
            visual, width
        t
   labelframeN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s    N(   R7   R8   R9   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s   t   PanedWindowc           B   s   e  Z d  Z d i  d  Z d   Z d   Z e Z d   Z d   Z	 d   Z
 d   Z d   Z d	   Z d
   Z d   Z d   Z d   Z d d  Z e Z d   Z RS(   s   panedwindow widget.c         K   s   t  j |  | d | |  d S(   sT  Construct a panedwindow widget with the parent MASTER.

        STANDARD OPTIONS

            background, borderwidth, cursor, height,
            orient, relief, width

        WIDGET-SPECIFIC OPTIONS

            handlepad, handlesize, opaqueresize,
            sashcursor, sashpad, sashrelief,
            sashwidth, showhandle,
        t   panedwindowN(   Rq  RU   (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU   -  s    c         K   s-   |  j  j |  j d | f |  j |   d S(   s+  Add a child widget to the panedwindow in a new pane.

        The child argument is the name of the child widget
        followed by pairs of arguments that specify how to
        manage the windows. The possible options and values
        are the ones accepted by the paneconfigure method.
        R   N(   R.   RP   R   R   (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR   =  s    c         C   s   |  j  j |  j d |  d S(   s   Remove the pane containing child from the panedwindow

        All geometry management options for child will be forgotten.
        R\  N(   R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRm   G  s    c         C   s   |  j  j |  j d | |  S(   s  Identify the panedwindow component at point x, y

        If the point is over a sash or a sash handle, the result
        is a two element list containing the index of the sash or
        handle, and a word indicating whether it is over a sash
        or a handle, such as {0 sash} or {2 handle}. If the point
        is over any other part of the panedwindow, the result is
        an empty list.
        R-  (   R.   RP   R   (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR-  O  s    
c         G   s,   |  j  |  j j |  j d f |   p+ d S(   s   Internal function.t   proxy(    (   R  R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  [  s    c         C   s   |  j  d  S(   sB   Return the x and y pair of the most recent proxy location
        t   coord(   R  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   proxy_coord`  s    c         C   s   |  j  d  S(   s+   Remove the proxy from the display.
        R\  (   R  (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   proxy_forgete  s    c         C   s   |  j  d | |  S(   s:   Place the proxy at the given x and y coordinates.
        R  (   R  (   RR   RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   proxy_placej  s    c         G   s,   |  j  |  j j |  j d f |   p+ d S(   s   Internal function.t   sash(    (   R  R.   RP   R   (   RR   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  o  s    c         C   s   |  j  d |  S(   sA  Return the current x and y pair for the sash given by index.

        Index must be an integer between 0 and 1 less than the
        number of panes in the panedwindow. The coordinates given are
        those of the top left corner of the region containing the sash.
        pathName sash dragto index x y This command computes the
        difference between the given coordinates and the coordinates
        given to the last sash coord command for the given sash. It then
        moves that sash the computed difference. The return value is the
        empty string.
        R  (   R  (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   sash_coordt  s    c         C   s   |  j  d |  S(   s   Records x and y for the sash given by index;

        Used in conjunction with later dragto commands to move the sash.
        R  (   R  (   RR   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt	   sash_mark  s    c         C   s   |  j  d | | |  S(   s?   Place the sash given by index at the given coordinates
        R  (   R  (   RR   R  RA  RN  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt
   sash_place  s    c         C   s'   |  j  j |  j d f | d | f  S(   sw   Query a management option for window.

        Option may be any value allowed by the paneconfigure subcommand
        t   panecgetR)   (   R.   RP   R   (   RR   R   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    	c         K   s   | d k r) | r) |  j |  j d |  St |  t k r_ | r_ |  j |  j d | d |  S|  j j |  j d | f |  j | |   d S(   s  Query or modify the management options for window.

        If no option is specified, returns a list describing all
        of the available options for pathName.  If option is
        specified with no value, then the command returns a list
        describing the one named option (this list will be identical
        to the corresponding sublist of the value returned if no
        option is specified). If one or more option-value pairs are
        specified, then the command modifies the given widget
        option(s) to have the given value(s); in this case the
        command returns an empty string. The following options
        are supported:

        after window
            Insert the window after the window specified. window
            should be the name of a window already managed by pathName.
        before window
            Insert the window before the window specified. window
            should be the name of a window already managed by pathName.
        height size
            Specify a height for the window. The height will be the
            outer dimension of the window including its border, if
            any. If size is an empty string, or if -height is not
            specified, then the height requested internally by the
            window will be used initially; the height may later be
            adjusted by the movement of sashes in the panedwindow.
            Size may be any value accepted by Tk_GetPixels.
        minsize n
            Specifies that the size of the window cannot be made
            less than n. This constraint only affects the size of
            the widget in the paned dimension -- the x dimension
            for horizontal panedwindows, the y dimension for
            vertical panedwindows. May be any value accepted by
            Tk_GetPixels.
        padx n
            Specifies a non-negative value indicating how much
            extra space to leave on each side of the window in
            the X-direction. The value may have any of the forms
            accepted by Tk_GetPixels.
        pady n
            Specifies a non-negative value indicating how much
            extra space to leave on each side of the window in
            the Y-direction. The value may have any of the forms
            accepted by Tk_GetPixels.
        sticky style
            If a window's pane is larger than the requested
            dimensions of the window, this option may be used
            to position (or stretch) the window within its pane.
            Style is a string that contains zero or more of the
            characters n, s, e or w. The string can optionally
            contains spaces or commas, but they are ignored. Each
            letter refers to a side (north, south, east, or west)
            that the window will "stick" to. If both n and s
            (or e and w) are specified, the window will be
            stretched to fill the entire height (or width) of
            its cavity.
        width size
            Specify a width for the window. The width will be
            the outer dimension of the window including its
            border, if any. If size is an empty string, or
            if -width is not specified, then the width requested
            internally by the window will be used initially; the
            width may later be adjusted by the movement of sashes
            in the panedwindow. Size may be any value accepted by
            Tk_GetPixels.

        t   paneconfigureR)   N(	   R   R  R   R   R   R  R.   RP   R   (   RR   R  R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    Dc         C   s"   |  j  j |  j  j |  j d   S(   s+   Returns an ordered list of the child panes.t   panes(   R.   R*   RP   R   (   RR   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s    N(   R7   R8   R9   R   RU   R   Rm   R\  R-  R  R  R  R  R  R  R  R  R  R  t
   paneconfigR  (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR  +  s$   	
											Kt
   Studbuttonc           B   s   e  Z d i  d   Z RS(   c         K   si   t  j |  | d | |  |  j d |  j  |  j d |  j  |  j d |  j  |  j d |  j  d  S(   Nt
   studbuttons   <Any-Enter>s   <Any-Leave>s   <1>s   <ButtonRelease-1>(   Rq  RU   R\  Ry  R{  R|  R}  (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s
    N(   R7   R8   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s   t	   Tributtonc           B   s   e  Z d i  d   Z RS(   c         K   s   t  j |  | d | |  |  j d |  j  |  j d |  j  |  j d |  j  |  j d |  j  |  d |  d <|  d |  d <d  S(	   Nt	   tributtons   <Any-Enter>s   <Any-Leave>s   <1>s   <ButtonRelease-1>t   bgt   fgt   activebackground(   Rq  RU   R\  Ry  R{  R|  R}  (   RR   RS   R#   R   (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyRU     s    N(   R7   R8   R   RU   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyR    s   c          C   s   t    }  d t } t d k rM y | t d d  } WqM t k
 rI qM Xn  t |  d | } | j   t |  d d d |  d  } | j   | |  _ t |  d d	 d |  j } | j   |  j	   |  j
   |  j   |  j   d  S(
   Ns   This is Tcl/Tk version %sg333333 @s   
This should be a cedilla: s
   iso-8859-1R  s	   Click me!R   c         S   s   |  j  j d d |  j  d  S(   NR  s   [%s](   t   testR  (   R  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   <lambda>  s   t   QUIT(   R&  t
   TclVersionR   t	   NameErrorR  R  Rw  R  R   R  R   R  R~   (   R  R  R  R  Rc  (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   _test  s(    	
	

	



t   __main__(c   R9   t   __version__R  t   platformt   FixTkR  t   ImportErrorR%   R   t   tkinterR   R  t   Tkconstantst   reR.  R  R@  RB  RA  R  t   READABLEt   WRITABLEt	   EXCEPTIONt   createfilehandlerR   R   t   deletefilehandlert   compileR   R   R   R   R   R(   t   TrueR5   R6   R:   R;   R<   R>   RC   RM   RD   Ru   Rw   Rz   R|   R~   R?   Ry   R{   RO   R   R`   R  R  R  R&  RY  RZ  Ra  Re  Rj  Rq  Rr  Rw  R  R  R  R  R  R  R  R  R  R  R  R  R'  R)  R+  R,  R.  R2  Rw  R|  R  R  R  R  R  R  R  R  R  R  R  R7   (    (    (    s$   /usr/lib/python2.7/lib-tk/Tkinter.pyt   <module>   s   	

			    			
  	  ,		k	    O}',/8>				A[}!( I%@@			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
[c           @   sQ   d  d l  m Z d e f d     YZ d d  Z e d k rM d Ge   GHn  d S(   i(   t   Dialogt   Chooserc           B   s&   e  Z d  Z d Z d   Z d   Z RS(   s   Ask for a colort   tk_chooseColorc         C   sL   y4 |  j  d } t | t  r3 d | |  j  d <n  Wn t k
 rG n Xd  S(   Nt   initialcolors   #%02x%02x%02x(   t   optionst
   isinstancet   tuplet   KeyError(   t   selft   color(    (    s+   /usr/lib/python2.7/lib-tk/tkColorChooser.pyt   _fixoptions!   s    c         C   sU   | s t  |  r d S| j |  \ } } } | d | d | d f t  |  f S(   Ni   (   NN(   t   strt   Nonet	   winfo_rgb(   R   t   widgett   resultt   rt   gt   b(    (    s+   /usr/lib/python2.7/lib-tk/tkColorChooser.pyt
   _fixresult+   s    (   t   __name__t
   __module__t   __doc__t   commandR
   R   (    (    (    s+   /usr/lib/python2.7/lib-tk/tkColorChooser.pyR      s   	
c         K   s/   |  r | j    } |  | d <n  t |   j   S(   s   Ask for a colorR   (   t   copyR   t   show(   R	   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkColorChooser.pyt   askcolor:   s    t   __main__R	   N(   t   tkCommonDialogR    R   R   R   R   (    (    (    s+   /usr/lib/python2.7/lib-tk/tkColorChooser.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #
# Instant Python
# $Id: tkFileDialog.py 36560 2004-07-18 06:16:08Z tim_one $
#
# tk common file dialogues
#
# this module provides interfaces to the native file dialogues
# available in Tk 4.2 and newer, and the directory dialogue available
# in Tk 8.3 and newer.
#
# written by Fredrik Lundh, May 1997.
#

#
# options (all have default values):
#
# - defaultextension: added to filename if not explicitly given
#
# - filetypes: sequence of (label, pattern) tuples.  the same pattern
#   may occur with several patterns.  use "*" as pattern to indicate
#   all files.
#
# - initialdir: initial directory.  preserved by dialog instance.
#
# - initialfile: initial file (ignored by the open dialog).  preserved
#   by dialog instance.
#
# - parent: which window to place the dialog on top of
#
# - title: dialog title
#
# - multiple: if true user may select more than one file
#
# options for the directory chooser:
#
# - initialdir, parent, title: see above
#
# - mustexist: if true, user must pick an existing directory
#
#


from tkCommonDialog import Dialog

class _Dialog(Dialog):

    def _fixoptions(self):
        try:
            # make sure "filetypes" is a tuple
            self.options["filetypes"] = tuple(self.options["filetypes"])
        except KeyError:
            pass

    def _fixresult(self, widget, result):
        if result:
            # keep directory and filename until next time
            import os
            # convert Tcl path objects to strings
            try:
                result = result.string
            except AttributeError:
                # it already is a string
                pass
            path, file = os.path.split(result)
            self.options["initialdir"] = path
            self.options["initialfile"] = file
        self.filename = result # compatibility
        return result


#
# file dialogs

class Open(_Dialog):
    "Ask for a filename to open"

    command = "tk_getOpenFile"

    def _fixresult(self, widget, result):
        if isinstance(result, tuple):
            # multiple results:
            result = tuple([getattr(r, "string", r) for r in result])
            if result:
                import os
                path, file = os.path.split(result[0])
                self.options["initialdir"] = path
                # don't set initialfile or filename, as we have multiple of these
            return result
        if not widget.tk.wantobjects() and "multiple" in self.options:
            # Need to split result explicitly
            return self._fixresult(widget, widget.tk.splitlist(result))
        return _Dialog._fixresult(self, widget, result)

class SaveAs(_Dialog):
    "Ask for a filename to save as"

    command = "tk_getSaveFile"


# the directory dialog has its own _fix routines.
class Directory(Dialog):
    "Ask for a directory"

    command = "tk_chooseDirectory"

    def _fixresult(self, widget, result):
        if result:
            # convert Tcl path objects to strings
            try:
                result = result.string
            except AttributeError:
                # it already is a string
                pass
            # keep directory until next time
            self.options["initialdir"] = result
        self.directory = result # compatibility
        return result

#
# convenience stuff

def askopenfilename(**options):
    "Ask for a filename to open"

    return Open(**options).show()

def asksaveasfilename(**options):
    "Ask for a filename to save as"

    return SaveAs(**options).show()

def askopenfilenames(**options):
    """Ask for multiple filenames to open

    Returns a list of filenames or empty list if
    cancel button selected
    """
    options["multiple"]=1
    return Open(**options).show()

# FIXME: are the following  perhaps a bit too convenient?

def askopenfile(mode = "r", **options):
    "Ask for a filename to open, and returned the opened file"

    filename = Open(**options).show()
    if filename:
        return open(filename, mode)
    return None

def askopenfiles(mode = "r", **options):
    """Ask for multiple filenames and return the open file
    objects

    returns a list of open file objects or an empty list if
    cancel selected
    """

    files = askopenfilenames(**options)
    if files:
        ofiles=[]
        for filename in files:
            ofiles.append(open(filename, mode))
        files=ofiles
    return files


def asksaveasfile(mode = "w", **options):
    "Ask for a filename to save as, and returned the opened file"

    filename = SaveAs(**options).show()
    if filename:
        return open(filename, mode)
    return None

def askdirectory (**options):
    "Ask for a directory, and return the file name"
    return Directory(**options).show()

# --------------------------------------------------------------------
# test stuff

if __name__ == "__main__":
    # Since the file name may contain non-ASCII characters, we need
    # to find an encoding that likely supports the file name, and
    # displays correctly on the terminal.

    # Start off with UTF-8
    enc = "utf-8"
    import sys

    # See whether CODESET is defined
    try:
        import locale
        locale.setlocale(locale.LC_ALL,'')
        enc = locale.nl_langinfo(locale.CODESET)
    except (ImportError, AttributeError):
        pass

    # dialog for openening files

    openfilename=askopenfilename(filetypes=[("all files", "*")])
    try:
        fp=open(openfilename,"r")
        fp.close()
    except:
        print "Could not open File: "
        print sys.exc_info()[1]

    print "open", openfilename.encode(enc)

    # dialog for saving files

    saveasfilename=asksaveasfilename()
    print "saveas", saveasfilename.encode(enc)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
[c           @   s  d  d l  m Z d e f d     YZ d e f d     YZ d e f d     YZ d e f d	     YZ d
   Z d   Z d   Z d d  Z	 d d  Z
 d d  Z d   Z e d k rd Z d  d l Z y5 d  d l Z e j e j d  e j e j  Z Wn e e f k
 rn Xe d d g  Z y e e d  Z e j   Wn d GHe j   d GHn Xd Ge j e  GHe   Z d Ge j e  GHn  d S(   i(   t   Dialogt   _Dialogc           B   s   e  Z d    Z d   Z RS(   c         C   s6   y t  |  j d  |  j d <Wn t k
 r1 n Xd  S(   Nt	   filetypes(   t   tuplet   optionst   KeyError(   t   self(    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   _fixoptions/   s    c         C   su   | rh d d  l  } y | j } Wn t k
 r2 n X| j j |  \ } } | |  j d <| |  j d <n  | |  _ | S(   Nit
   initialdirt   initialfile(   t   ost   stringt   AttributeErrort   patht   splitR   t   filename(   R   t   widgett   resultR
   R   t   file(    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt
   _fixresult6   s    	(   t   __name__t
   __module__R   R   (    (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyR   -   s   	t   Openc           B   s   e  Z d  Z d Z d   Z RS(   s   Ask for a filename to opent   tk_getOpenFilec         C   s   t  | t  r| t g  | D] } t | d |  ^ q  } | rx d d  l } | j j | d  \ } } | |  j d <n  | S| j j   r d |  j k r |  j	 | | j j
 |   St j	 |  | |  S(   NR   ii    R   t   multiple(   t
   isinstanceR   t   getattrR
   R   R   R   t   tkt   wantobjectsR   t	   splitlistR   (   R   R   R   t   rR
   R   R   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyR   O   s    +(   R   R   t   __doc__t   commandR   (    (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyR   J   s   t   SaveAsc           B   s   e  Z d  Z d Z RS(   s   Ask for a filename to save ast   tk_getSaveFile(   R   R   R   R    (    (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyR!   ^   s   t	   Directoryc           B   s   e  Z d  Z d Z d   Z RS(   s   Ask for a directoryt   tk_chooseDirectoryc         C   sD   | r7 y | j  } Wn t k
 r& n X| |  j d <n  | |  _ | S(   NR   (   R   R   R   t	   directory(   R   R   R   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyR   j   s    	(   R   R   R   R    R   (    (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyR#   e   s   c          K   s   t  |    j   S(   s   Ask for a filename to open(   R   t   show(   R   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   askopenfilenamez   s    c          K   s   t  |    j   S(   s   Ask for a filename to save as(   R!   R&   (   R   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   asksaveasfilename   s    c          K   s   d |  d <t  |    j   S(   st   Ask for multiple filenames to open

    Returns a list of filenames or empty list if
    cancel button selected
    i   R   (   R   R&   (   R   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   askopenfilenames   s    
R   c         K   s)   t  |   j   } | r% t | |   Sd S(   s8   Ask for a filename to open, and returned the opened fileN(   R   R&   t   opent   None(   t   modeR   R   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   askopenfile   s    c         K   sL   t  |   } | rH g  } x$ | D] } | j t | |    q W| } n  | S(   s   Ask for multiple filenames and return the open file
    objects

    returns a list of open file objects or an empty list if
    cancel selected
    (   R)   t   appendR*   (   R,   R   t   filest   ofilesR   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   askopenfiles   s    	t   wc         K   s)   t  |   j   } | r% t | |   Sd S(   s;   Ask for a filename to save as, and returned the opened fileN(   R!   R&   R*   R+   (   R,   R   R   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   asksaveasfile   s    c          K   s   t  |    j   S(   s-   Ask for a directory, and return the file name(   R#   R&   (   R   (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   askdirectory   s    t   __main__s   utf-8Nt    R   s	   all filest   *s   Could not open File: i   R*   t   saveas(   s	   all filesR7   (   t   tkCommonDialogR    R   R   R!   R#   R'   R(   R)   R-   R1   R3   R4   R   t   enct   syst   localet	   setlocalet   LC_ALLt   nl_langinfot   CODESETt   ImportErrorR   t   openfilenameR*   t   fpt   closet   exc_infot   encodet   saveasfilename(    (    (    s)   /usr/lib/python2.7/lib-tk/tkFileDialog.pyt   <module>+   s<   					                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Tkinter font wrapper
#
# written by Fredrik Lundh, February 1998
#
# FIXME: should add 'displayof' option where relevant (actual, families,
#        measure, and metrics)
#

__version__ = "0.9"

import Tkinter

# weight/slant
NORMAL = "normal"
ROMAN = "roman"
BOLD   = "bold"
ITALIC = "italic"

def nametofont(name):
    """Given the name of a tk named font, returns a Font representation.
    """
    return Font(name=name, exists=True)

class Font:

    """Represents a named font.

    Constructor options are:

    font -- font specifier (name, system font, or (family, size, style)-tuple)
    name -- name to use for this font configuration (defaults to a unique name)
    exists -- does a named font by this name already exist?
       Creates a new named font if False, points to the existing font if True.
       Raises _Tkinter.TclError if the assertion is false.

       the following are ignored if font is specified:

    family -- font 'family', e.g. Courier, Times, Helvetica
    size -- font size in points
    weight -- font thickness: NORMAL, BOLD
    slant -- font slant: ROMAN, ITALIC
    underline -- font underlining: false (0), true (1)
    overstrike -- font strikeout: false (0), true (1)

    """

    def _set(self, kw):
        options = []
        for k, v in kw.items():
            options.append("-"+k)
            options.append(str(v))
        return tuple(options)

    def _get(self, args):
        options = []
        for k in args:
            options.append("-"+k)
        return tuple(options)

    def _mkdict(self, args):
        options = {}
        for i in range(0, len(args), 2):
            options[args[i][1:]] = args[i+1]
        return options

    def __init__(self, root=None, font=None, name=None, exists=False, **options):
        if not root:
            root = Tkinter._default_root
        tk = getattr(root, 'tk', root)
        if font:
            # get actual settings corresponding to the given font
            font = tk.splitlist(tk.call("font", "actual", font))
        else:
            font = self._set(options)
        if not name:
            name = "font" + str(id(self))
        self.name = name

        if exists:
            self.delete_font = False
            # confirm font exists
            if self.name not in tk.splitlist(tk.call("font", "names")):
                raise Tkinter._tkinter.TclError, "named font %s does not already exist" % (self.name,)
            # if font config info supplied, apply it
            if font:
                tk.call("font", "configure", self.name, *font)
        else:
            # create new font (raises TclError if the font exists)
            tk.call("font", "create", self.name, *font)
            self.delete_font = True
        self._tk = tk
        self._split = tk.splitlist
        self._call  = tk.call

    def __str__(self):
        return self.name

    def __eq__(self, other):
        return isinstance(other, Font) and self.name == other.name

    def __getitem__(self, key):
        return self.cget(key)

    def __setitem__(self, key, value):
        self.configure(**{key: value})

    def __del__(self):
        try:
            if self.delete_font:
                self._call("font", "delete", self.name)
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception:
            pass

    def copy(self):
        "Return a distinct copy of the current font"
        return Font(self._tk, **self.actual())

    def actual(self, option=None):
        "Return actual font attributes"
        if option:
            return self._call("font", "actual", self.name, "-"+option)
        else:
            return self._mkdict(
                self._split(self._call("font", "actual", self.name))
                )

    def cget(self, option):
        "Get font attribute"
        return self._call("font", "config", self.name, "-"+option)

    def config(self, **options):
        "Modify font attributes"
        if options:
            self._call("font", "config", self.name,
                  *self._set(options))
        else:
            return self._mkdict(
                self._split(self._call("font", "config", self.name))
                )

    configure = config

    def measure(self, text):
        "Return text width"
        return int(self._call("font", "measure", self.name, text))

    def metrics(self, *options):
        """Return font metrics.

        For best performance, create a dummy widget
        using this font before calling this method."""

        if options:
            return int(
                self._call("font", "metrics", self.name, self._get(options))
                )
        else:
            res = self._split(self._call("font", "metrics", self.name))
            options = {}
            for i in range(0, len(res), 2):
                options[res[i][1:]] = int(res[i+1])
            return options

def families(root=None):
    "Get font families (as a tuple)"
    if not root:
        root = Tkinter._default_root
    return root.tk.splitlist(root.tk.call("font", "families"))

def names(root=None):
    "Get names of defined fonts (as a tuple)"
    if not root:
        root = Tkinter._default_root
    return root.tk.splitlist(root.tk.call("font", "names"))

# --------------------------------------------------------------------
# test stuff

if __name__ == "__main__":

    root = Tkinter.Tk()

    # create a font
    f = Font(family="times", size=30, weight=NORMAL)

    print f.actual()
    print f.actual("family")
    print f.actual("weight")

    print f.config()
    print f.cget("family")
    print f.cget("weight")

    print names()

    print f.measure("hello"), f.metrics("linespace")

    print f.metrics()

    f = Font(font=("Courier", 20, "bold"))
    print f.measure("hello"), f.metrics("linespace")

    w = Tkinter.Label(root, text="Hello, world", font=f)
    w.pack()

    w = Tkinter.Button(root, text="Quit!", command=root.destroy)
    w.pack()

    fb = Font(font=w["font"]).copy()
    fb.config(weight=BOLD)

    w.config(font=fb)

    Tkinter.mainloop()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
[c           @   s  d  Z  d d l Z d Z d Z d Z d Z d   Z d d d	     YZ d d
  Z	 d d  Z
 e d k re j   Z e d d d d d e  Z e j   GHe j d  GHe j d  GHe j   GHe j d  GHe j d  GHe
   GHe j d  Ge j d  GHe j   GHe d d  Z e j d  Ge j d  GHe j e d d d e Z e j   e j e d d d e j Z e j   e d e d  j   Z e j d e  e j d e  e j   n  d S(   s   0.9iNt   normalt   romant   boldt   italicc         C   s   t  d |  d t  S(   sF   Given the name of a tk named font, returns a Font representation.
    t   namet   exists(   t   Fontt   True(   R   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt
   nametofont   s    R   c           B   s   e  Z d  Z d   Z d   Z d   Z d d d e d  Z d   Z	 d   Z
 d   Z d   Z d	   Z d
   Z d d  Z d   Z d   Z e Z d   Z d   Z RS(   s  Represents a named font.

    Constructor options are:

    font -- font specifier (name, system font, or (family, size, style)-tuple)
    name -- name to use for this font configuration (defaults to a unique name)
    exists -- does a named font by this name already exist?
       Creates a new named font if False, points to the existing font if True.
       Raises _Tkinter.TclError if the assertion is false.

       the following are ignored if font is specified:

    family -- font 'family', e.g. Courier, Times, Helvetica
    size -- font size in points
    weight -- font thickness: NORMAL, BOLD
    slant -- font slant: ROMAN, ITALIC
    underline -- font underlining: false (0), true (1)
    overstrike -- font strikeout: false (0), true (1)

    c         C   sQ   g  } x> | j    D]0 \ } } | j d |  | j t |   q Wt |  S(   Nt   -(   t   itemst   appendt   strt   tuple(   t   selft   kwt   optionst   kt   v(    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   _set/   s
    c         C   s2   g  } x | D] } | j  d |  q Wt |  S(   NR	   (   R   R   (   R   t   argsR   R   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   _get6   s    c         C   sG   i  } x: t  d t |  d  D]  } | | d | | | d <q W| S(   Ni    i   i   (   t   ranget   len(   R   R   R   t   i(    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   _mkdict<   s    c         K   s=  | s t  j } n  t | d |  } | rK | j | j d d |   } n |  j |  } | sy d t t |    } n  | |  _ | r t	 |  _
 |  j | j | j d d   k r t  j j d |  j f  n  | r| j d d |  j |  qn" | j d d |  j |  t |  _
 | |  _ | j |  _ | j |  _ d  S(   Nt   tkt   fontt   actualt   namess$   named font %s does not already existt	   configuret   create(   t   Tkintert   _default_roott   getattrt	   splitlistt   callR   R   t   idR   t   Falset   delete_fontt   _tkintert   TclErrorR   t   _tkt   _splitt   _call(   R   t   rootR   R   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   __init__B   s(    !		$		c         C   s   |  j  S(   N(   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   __str___   s    c         C   s   t  | t  o |  j | j k S(   N(   t
   isinstanceR   R   (   R   t   other(    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   __eq__b   s    c         C   s   |  j  |  S(   N(   t   cget(   R   t   key(    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   __getitem__e   s    c         C   s   |  j  i | | 6  d  S(   N(   R   (   R   R4   t   value(    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   __setitem__h   s    c         C   sW   y& |  j  r% |  j d d |  j  n  Wn* t t f k
 rB   n t k
 rR n Xd  S(   NR   t   delete(   R'   R,   R   t   KeyboardInterruptt
   SystemExitt	   Exception(   R   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   __del__k   s    	c         C   s   t  |  j |  j    S(   s*   Return a distinct copy of the current font(   R   R*   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   copyt   s    c         C   sO   | r# |  j  d d |  j d |  S|  j |  j |  j  d d |  j    Sd S(   s   Return actual font attributesR   R   R	   N(   R,   R   R   R+   (   R   t   option(    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyR   x   s    c         C   s   |  j  d d |  j d |  S(   s   Get font attributeR   t   configR	   (   R,   R   (   R   R>   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyR3      s    c         K   sW   | r+ |  j  d d |  j |  j |   n( |  j |  j |  j  d d |  j    Sd S(   s   Modify font attributesR   R?   N(   R,   R   R   R   R+   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyR?      s
    c         C   s   t  |  j d d |  j |   S(   s   Return text widthR   t   measure(   t   intR,   R   (   R   t   text(    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyR@      s    c         G   s   | r. t  |  j d d |  j |  j |    S|  j |  j d d |  j   } i  } x@ t d t |  d  D]& } t  | | d  | | | d <qn W| Sd S(   s}   Return font metrics.

        For best performance, create a dummy widget
        using this font before calling this method.R   t   metricsi    i   i   N(   RA   R,   R   R   R+   R   R   (   R   R   t   resR   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyRC      s    %!$N(   t   __name__t
   __module__t   __doc__R   R   R   t   NoneR&   R.   R/   R2   R5   R7   R<   R=   R   R3   R?   R   R@   RC   (    (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyR      s"   													
	c         C   s1   |  s t  j }  n  |  j j |  j j d d   S(   s   Get font families (as a tuple)R   t   families(   R    R!   R   R#   R$   (   R-   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyRI      s    c         C   s1   |  s t  j }  n  |  j j |  j j d d   S(   s'   Get names of defined fonts (as a tuple)R   R   (   R    R!   R   R#   R$   (   R-   (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyR      s    t   __main__t   familyt   timest   sizei   t   weightt   hellot	   linespaceR   t   Courieri   RB   s   Hello, worlds   Quit!t   command(    (   RQ   i   R   (   t   __version__R    t   NORMALt   ROMANt   BOLDt   ITALICR   R   RH   RI   R   RE   t   TkR-   t   fR   R?   R3   R@   RC   t   Labelt   wt   packt   Buttont   destroyR=   t   fbt   mainloop(    (    (    s#   /usr/lib/python2.7/lib-tk/tkFont.pyt   <module>	   s>   		

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # tk common message boxes
#
# this module provides an interface to the native message boxes
# available in Tk 4.2 and newer.
#
# written by Fredrik Lundh, May 1997
#

#
# options (all have default values):
#
# - default: which button to make default (one of the reply codes)
#
# - icon: which icon to display (see below)
#
# - message: the message to display
#
# - parent: which window to place the dialog on top of
#
# - title: dialog title
#
# - type: dialog type; that is, which buttons to display (see below)
#

from tkCommonDialog import Dialog

#
# constants

# icons
ERROR = "error"
INFO = "info"
QUESTION = "question"
WARNING = "warning"

# types
ABORTRETRYIGNORE = "abortretryignore"
OK = "ok"
OKCANCEL = "okcancel"
RETRYCANCEL = "retrycancel"
YESNO = "yesno"
YESNOCANCEL = "yesnocancel"

# replies
ABORT = "abort"
RETRY = "retry"
IGNORE = "ignore"
OK = "ok"
CANCEL = "cancel"
YES = "yes"
NO = "no"


#
# message dialog class

class Message(Dialog):
    "A message box"

    command  = "tk_messageBox"


#
# convenience stuff

# Rename _icon and _type options to allow overriding them in options
def _show(title=None, message=None, _icon=None, _type=None, **options):
    if _icon and "icon" not in options:    options["icon"] = _icon
    if _type and "type" not in options:    options["type"] = _type
    if title:   options["title"] = title
    if message: options["message"] = message
    res = Message(**options).show()
    # In some Tcl installations, yes/no is converted into a boolean.
    if isinstance(res, bool):
        if res:
            return YES
        return NO
    # In others we get a Tcl_Obj.
    return str(res)

def showinfo(title=None, message=None, **options):
    "Show an info message"
    return _show(title, message, INFO, OK, **options)

def showwarning(title=None, message=None, **options):
    "Show a warning message"
    return _show(title, message, WARNING, OK, **options)

def showerror(title=None, message=None, **options):
    "Show an error message"
    return _show(title, message, ERROR, OK, **options)

def askquestion(title=None, message=None, **options):
    "Ask a question"
    return _show(title, message, QUESTION, YESNO, **options)

def askokcancel(title=None, message=None, **options):
    "Ask if operation should proceed; return true if the answer is ok"
    s = _show(title, message, QUESTION, OKCANCEL, **options)
    return s == OK

def askyesno(title=None, message=None, **options):
    "Ask a question; return true if the answer is yes"
    s = _show(title, message, QUESTION, YESNO, **options)
    return s == YES

def askyesnocancel(title=None, message=None, **options):
    "Ask a question; return true if the answer is yes, None if cancelled."
    s = _show(title, message, QUESTION, YESNOCANCEL, **options)
    # s might be a Tcl index object, so convert it to a string
    s = str(s)
    if s == CANCEL:
        return None
    return s == YES

def askretrycancel(title=None, message=None, **options):
    "Ask if operation should be retried; return true if the answer is yes"
    s = _show(title, message, WARNING, RETRYCANCEL, **options)
    return s == RETRY


# --------------------------------------------------------------------
# test stuff

if __name__ == "__main__":

    print "info", showinfo("Spam", "Egg Information")
    print "warning", showwarning("Spam", "Egg Warning")
    print "error", showerror("Spam", "Egg Alert")
    print "question", askquestion("Spam", "Question?")
    print "proceed", askokcancel("Spam", "Proceed?")
    print "yes/no", askyesno("Spam", "Got it?")
    print "yes/no/cancel", askyesnocancel("Spam", "Want it?")
    print "try again", askretrycancel("Spam", "Try again?")
                                                                                                                                                                                                                                                                                                                                                                                                                         
[c           @   s  d  d l  m Z d Z d Z d Z d Z d Z d Z d Z d	 Z	 d
 Z
 d Z d Z d Z d Z d Z d Z d Z d Z d e f d     YZ d+ d+ d+ d+ d  Z d+ d+ d  Z d+ d+ d  Z d+ d+ d  Z d+ d+ d  Z d+ d+ d  Z d+ d+ d  Z d+ d+ d  Z d+ d+ d  Z e d k rd Ge d d  GHd Ge d d   GHd Ge d d!  GHd Ge d d"  GHd# Ge d d$  GHd% Ge d d&  GHd' Ge d d(  GHd) Ge d d*  GHn  d+ S(,   i(   t   Dialogt   errort   infot   questiont   warningt   abortretryignoret   okt   okcancelt   retrycancelt   yesnot   yesnocancelt   abortt   retryt   ignoret   cancelt   yest   not   Messagec           B   s   e  Z d  Z d Z RS(   s   A message boxt   tk_messageBox(   t   __name__t
   __module__t   __doc__t   command(    (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyR   9   s   c         K   s   | r d | k r | | d <n  | r> d | k r> | | d <n  |  rQ |  | d <n  | rd | | d <n  t  |   j   } t | t  r | r t St St |  S(   Nt   icont   typet   titlet   message(   R   t   showt
   isinstancet   boolt   YESt   NOt   str(   R   R   t   _icont   _typet   optionst   res(    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   _showC   s        c         K   s   t  |  | t t |  S(   s   Show an info message(   R%   t   INFOt   OK(   R   R   R#   (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   showinfoQ   s    c         K   s   t  |  | t t |  S(   s   Show a warning message(   R%   t   WARNINGR'   (   R   R   R#   (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   showwarningU   s    c         K   s   t  |  | t t |  S(   s   Show an error message(   R%   t   ERRORR'   (   R   R   R#   (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt	   showerrorY   s    c         K   s   t  |  | t t |  S(   s   Ask a question(   R%   t   QUESTIONt   YESNO(   R   R   R#   (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   askquestion]   s    c         K   s"   t  |  | t t |  } | t k S(   s@   Ask if operation should proceed; return true if the answer is ok(   R%   R-   t   OKCANCELR'   (   R   R   R#   t   s(    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   askokcancela   s    c         K   s"   t  |  | t t |  } | t k S(   s0   Ask a question; return true if the answer is yes(   R%   R-   R.   R   (   R   R   R#   R1   (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   askyesnof   s    c         K   s>   t  |  | t t |  } t |  } | t k r4 d S| t k S(   sD   Ask a question; return true if the answer is yes, None if cancelled.N(   R%   R-   t   YESNOCANCELR    t   CANCELt   NoneR   (   R   R   R#   R1   (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   askyesnocancelk   s
    c         K   s"   t  |  | t t |  } | t k S(   sD   Ask if operation should be retried; return true if the answer is yes(   R%   R)   t   RETRYCANCELt   RETRY(   R   R   R#   R1   (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   askretrycancelt   s    t   __main__t   Spams   Egg Informations   Egg Warnings	   Egg Alerts	   Question?t   proceeds   Proceed?s   yes/nos   Got it?s   yes/no/cancels   Want it?s	   try agains
   Try again?N(   t   tkCommonDialogR    R+   R&   R-   R)   t   ABORTRETRYIGNORER'   R0   R8   R.   R4   t   ABORTR9   t   IGNORER5   R   R   R   R6   R%   R(   R*   R,   R/   R2   R3   R7   R:   R   (    (    (    s)   /usr/lib/python2.7/lib-tk/tkMessageBox.pyt   <module>   sH   
		                                                                                                                                                                                                                                #
# An Introduction to Tkinter
# tkSimpleDialog.py
#
# Copyright (c) 1997 by Fredrik Lundh
#
# fredrik@pythonware.com
# http://www.pythonware.com
#

# --------------------------------------------------------------------
# dialog base class

'''Dialog boxes

This module handles dialog boxes. It contains the following
public symbols:

Dialog -- a base class for dialogs

askinteger -- get an integer from the user

askfloat -- get a float from the user

askstring -- get a string from the user
'''

from Tkinter import *

class Dialog(Toplevel):

    '''Class to open dialogs.

    This class is intended as a base class for custom dialogs
    '''

    def __init__(self, parent, title = None):

        '''Initialize a dialog.

        Arguments:

            parent -- a parent window (the application window)

            title -- the dialog title
        '''
        Toplevel.__init__(self, parent)

        self.withdraw() # remain invisible for now
        # If the master is not viewable, don't
        # make the child transient, or else it
        # would be opened withdrawn
        if parent.winfo_viewable():
            self.transient(parent)

        if title:
            self.title(title)

        self.parent = parent

        self.result = None

        body = Frame(self)
        self.initial_focus = self.body(body)
        body.pack(padx=5, pady=5)

        self.buttonbox()


        if not self.initial_focus:
            self.initial_focus = self

        self.protocol("WM_DELETE_WINDOW", self.cancel)

        if self.parent is not None:
            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

        self.deiconify() # become visibile now

        self.initial_focus.focus_set()

        # wait for window to appear on screen before calling grab_set
        self.wait_visibility()
        self.grab_set()
        self.wait_window(self)

    def destroy(self):
        '''Destroy the window'''
        self.initial_focus = None
        Toplevel.destroy(self)

    #
    # construction hooks

    def body(self, master):
        '''create dialog body.

        return widget that should have initial focus.
        This method should be overridden, and is called
        by the __init__ method.
        '''
        pass

    def buttonbox(self):
        '''add standard button box.

        override if you do not want the standard buttons
        '''

        box = Frame(self)

        w = Button(box, text="OK", width=10, command=self.ok, default=ACTIVE)
        w.pack(side=LEFT, padx=5, pady=5)
        w = Button(box, text="Cancel", width=10, command=self.cancel)
        w.pack(side=LEFT, padx=5, pady=5)

        self.bind("<Return>", self.ok)
        self.bind("<Escape>", self.cancel)

        box.pack()

    #
    # standard button semantics

    def ok(self, event=None):

        if not self.validate():
            self.initial_focus.focus_set() # put focus back
            return

        self.withdraw()
        self.update_idletasks()

        try:
            self.apply()
        finally:
            self.cancel()

    def cancel(self, event=None):

        # put focus back to the parent window
        if self.parent is not None:
            self.parent.focus_set()
        self.destroy()

    #
    # command hooks

    def validate(self):
        '''validate the data

        This method is called automatically to validate the data before the
        dialog is destroyed. By default, it always validates OK.
        '''

        return 1 # override

    def apply(self):
        '''process the data

        This method is called automatically to process the data, *after*
        the dialog is destroyed. By default, it does nothing.
        '''

        pass # override


# --------------------------------------------------------------------
# convenience dialogues

class _QueryDialog(Dialog):

    def __init__(self, title, prompt,
                 initialvalue=None,
                 minvalue = None, maxvalue = None,
                 parent = None):

        if not parent:
            import Tkinter
            parent = Tkinter._default_root

        self.prompt   = prompt
        self.minvalue = minvalue
        self.maxvalue = maxvalue

        self.initialvalue = initialvalue

        Dialog.__init__(self, parent, title)

    def destroy(self):
        self.entry = None
        Dialog.destroy(self)

    def body(self, master):

        w = Label(master, text=self.prompt, justify=LEFT)
        w.grid(row=0, padx=5, sticky=W)

        self.entry = Entry(master, name="entry")
        self.entry.grid(row=1, padx=5, sticky=W+E)

        if self.initialvalue is not None:
            self.entry.insert(0, self.initialvalue)
            self.entry.select_range(0, END)

        return self.entry

    def validate(self):

        import tkMessageBox

        try:
            result = self.getresult()
        except ValueError:
            tkMessageBox.showwarning(
                "Illegal value",
                self.errormessage + "\nPlease try again",
                parent = self
            )
            return 0

        if self.minvalue is not None and result < self.minvalue:
            tkMessageBox.showwarning(
                "Too small",
                "The allowed minimum value is %s. "
                "Please try again." % self.minvalue,
                parent = self
            )
            return 0

        if self.maxvalue is not None and result > self.maxvalue:
            tkMessageBox.showwarning(
                "Too large",
                "The allowed maximum value is %s. "
                "Please try again." % self.maxvalue,
                parent = self
            )
            return 0

        self.result = result

        return 1


class _QueryInteger(_QueryDialog):
    errormessage = "Not an integer."
    def getresult(self):
        return int(self.entry.get())

def askinteger(title, prompt, **kw):
    '''get an integer from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is an integer
    '''
    d = _QueryInteger(title, prompt, **kw)
    return d.result

class _QueryFloat(_QueryDialog):
    errormessage = "Not a floating point value."
    def getresult(self):
        return float(self.entry.get())

def askfloat(title, prompt, **kw):
    '''get a float from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is a float
    '''
    d = _QueryFloat(title, prompt, **kw)
    return d.result

class _QueryString(_QueryDialog):
    def __init__(self, *args, **kw):
        if "show" in kw:
            self.__show = kw["show"]
            del kw["show"]
        else:
            self.__show = None
        _QueryDialog.__init__(self, *args, **kw)

    def body(self, master):
        entry = _QueryDialog.body(self, master)
        if self.__show is not None:
            entry.configure(show=self.__show)
        return entry

    def getresult(self):
        return self.entry.get()

def askstring(title, prompt, **kw):
    '''get a string from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is a string
    '''
    d = _QueryString(title, prompt, **kw)
    return d.result

if __name__ == "__main__":

    root = Tk()
    root.update()

    print askinteger("Spam", "Egg count", initialvalue=12*12)
    print askfloat("Spam", "Egg weight\n(in tons)", minvalue=1, maxvalue=100)
    print askstring("Spam", "Egg label")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
[c           @   s   d  Z  d d l Td e f d     YZ d e f d     YZ d e f d     YZ d	   Z d
 e f d     YZ d   Z d e f d     YZ	 d   Z
 e d k r e   Z e j   e d d d d GHe d d d d d d GHe
 d d  GHn  d S(   s   Dialog boxes

This module handles dialog boxes. It contains the following
public symbols:

Dialog -- a base class for dialogs

askinteger -- get an integer from the user

askfloat -- get a float from the user

askstring -- get a string from the user
i(   t   *t   Dialogc           B   s_   e  Z d  Z d	 d  Z d   Z d   Z d   Z d	 d  Z d	 d  Z	 d   Z
 d   Z RS(
   sZ   Class to open dialogs.

    This class is intended as a base class for custom dialogs
    c         C   s=  t  j |  |  |  j   | j   r6 |  j |  n  | rL |  j |  n  | |  _ d |  _ t	 |   } |  j
 |  |  _ | j d d d d  |  j   |  j s |  |  _ n  |  j d |  j  |  j d k	 r|  j d | j   d | j   d f  n  |  j   |  j j   |  j   |  j   |  j |   d S(   s   Initialize a dialog.

        Arguments:

            parent -- a parent window (the application window)

            title -- the dialog title
        t   padxi   t   padyt   WM_DELETE_WINDOWs   +%d+%di2   N(   t   Toplevelt   __init__t   withdrawt   winfo_viewablet	   transientt   titlet   parentt   Nonet   resultt   Framet   bodyt   initial_focust   packt	   buttonboxt   protocolt   cancelt   geometryt   winfo_rootxt   winfo_rootyt	   deiconifyt	   focus_sett   wait_visibilityt   grab_sett   wait_window(   t   selfR   R
   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR   %   s.    

		
	


c         C   s   d |  _ t j |   d S(   s   Destroy the windowN(   R   R   R   t   destroy(   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR   X   s    	c         C   s   d S(   s   create dialog body.

        return widget that should have initial focus.
        This method should be overridden, and is called
        by the __init__ method.
        N(    (   R   t   master(    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR   `   s    c      
   C   s   t  |   } t | d d d d d |  j d t } | j d t d d	 d
 d	  t | d d d d d |  j } | j d t d d	 d
 d	  |  j d |  j  |  j d |  j  | j   d S(   s[   add standard button box.

        override if you do not want the standard buttons
        t   textt   OKt   widthi
   t   commandt   defaultt   sideR   i   R   t   Cancels   <Return>s   <Escape>N(   R   t   Buttont   okt   ACTIVER   t   LEFTR   t   bind(   R   t   boxt   w(    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR   i   s    '!c         C   sQ   |  j    s |  j j   d  S|  j   |  j   z |  j   Wd  |  j   Xd  S(   N(   t   validateR   R   R   t   update_idletaskst   applyR   (   R   t   event(    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR(   ~   s    

c         C   s-   |  j  d  k	 r |  j  j   n  |  j   d  S(   N(   R   R   R   R   (   R   R1   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR      s    c         C   s   d S(   s   validate the data

        This method is called automatically to validate the data before the
        dialog is destroyed. By default, it always validates OK.
        i   (    (   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR.      s    c         C   s   d S(   s   process the data

        This method is called automatically to process the data, *after*
        the dialog is destroyed. By default, it does nothing.
        N(    (   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR0      s    N(   t   __name__t
   __module__t   __doc__R   R   R   R   R   R(   R   R.   R0   (    (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR      s   3				
		t   _QueryDialogc           B   s8   e  Z d d d d d   Z d   Z d   Z d   Z RS(   c         C   sY   | s d d  l  } | j } n  | |  _ | |  _ | |  _ | |  _ t j |  | |  d  S(   Ni(   t   Tkintert   _default_roott   promptt   minvaluet   maxvaluet   initialvalueR   R   (   R   R
   R8   R;   R9   R:   R   R6   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR      s    				c         C   s   d  |  _ t j |   d  S(   N(   R   t   entryR   R   (   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR      s    	c         C   s   t  | d |  j d t } | j d d d d d t  t | d d	 |  _ |  j j d d
 d d d t t  |  j d  k	 r |  j j
 d |  j  |  j j d t  n  |  j S(   NR    t   justifyt   rowi    R   i   t   stickyt   nameR<   i   (   t   LabelR8   R*   t   gridt   Wt   EntryR<   t   ER;   R   t   insertt   select_ranget   END(   R   R   R-   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR      s    #c         C   s   d d  l  } y |  j   } Wn/ t k
 rM | j d |  j d d |  d SX|  j d  k	 r | |  j k  r | j d d |  j d |  d S|  j d  k	 r | |  j k r | j d d	 |  j d |  d S| |  _ d
 S(   Nis   Illegal values   
Please try againR   i    s	   Too smalls2   The allowed minimum value is %s. Please try again.s	   Too larges2   The allowed maximum value is %s. Please try again.i   (	   t   tkMessageBoxt	   getresultt
   ValueErrort   showwarningt   errormessageR9   R   R:   R   (   R   RI   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR.      s2    

	N(   R2   R3   R   R   R   R   R.   (    (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR5      s   		t   _QueryIntegerc           B   s   e  Z d  Z d   Z RS(   s   Not an integer.c         C   s   t  |  j j    S(   N(   t   intR<   t   get(   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyRJ      s    (   R2   R3   RM   RJ   (    (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyRN      s   c         K   s   t  |  | |  } | j S(   s   get an integer from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is an integer
    (   RN   R   (   R
   R8   t   kwt   d(    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyt
   askinteger   s    t   _QueryFloatc           B   s   e  Z d  Z d   Z RS(   s   Not a floating point value.c         C   s   t  |  j j    S(   N(   t   floatR<   RP   (   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyRJ     s    (   R2   R3   RM   RJ   (    (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyRT   	  s   c         K   s   t  |  | |  } | j S(   s   get a float from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is a float
    (   RT   R   (   R
   R8   RQ   RR   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyt   askfloat  s    t   _QueryStringc           B   s#   e  Z d    Z d   Z d   Z RS(   c         O   sC   d | k r# | d |  _  | d =n	 d  |  _  t j |  | |  d  S(   Nt   show(   t   _QueryString__showR   R5   R   (   R   t   argsRQ   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR     s
    
	c         C   s;   t  j |  |  } |  j d  k	 r7 | j d |  j  n  | S(   NRX   (   R5   R   RY   R   t	   configure(   R   R   R<   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyR   %  s    c         C   s   |  j  j   S(   N(   R<   RP   (   R   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyRJ   +  s    (   R2   R3   R   R   RJ   (    (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyRW     s   		c         K   s   t  |  | |  } | j S(   s   get a string from the user

    Arguments:

        title -- the dialog title
        prompt -- the label text
        **kw -- see SimpleDialog class

    Return value is a string
    (   RW   R   (   R
   R8   RQ   RR   (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyt	   askstring.  s    t   __main__t   Spams	   Egg countR;   i   s   Egg weight
(in tons)R9   i   R:   id   s	   Egg labelNi   (   R4   R6   R   R   R5   RN   RS   RT   RV   RW   R\   R2   t   Tkt   roott   update(    (    (    s+   /usr/lib/python2.7/lib-tk/tkSimpleDialog.pyt   <module>   s   
J				
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """Ttk wrapper.

This module provides classes to allow using Tk themed widget set.

Ttk is based on a revised and enhanced version of
TIP #48 (http://tip.tcl.tk/48) specified style engine.

Its basic idea is to separate, to the extent possible, the code
implementing a widget's behavior from the code implementing its
appearance. Widget class bindings are primarily responsible for
maintaining the widget state and invoking callbacks, all aspects
of the widgets appearance lies at Themes.
"""

__version__ = "0.3.1"

__author__ = "Guilherme Polo <ggpolo@gmail.com>"

__all__ = ["Button", "Checkbutton", "Combobox", "Entry", "Frame", "Label",
           "Labelframe", "LabelFrame", "Menubutton", "Notebook", "Panedwindow",
           "PanedWindow", "Progressbar", "Radiobutton", "Scale", "Scrollbar",
           "Separator", "Sizegrip", "Style", "Treeview",
           # Extensions
           "LabeledScale", "OptionMenu",
           # functions
           "tclobjs_to_py", "setup_master"]

import Tkinter
from Tkinter import _flatten, _join, _stringify, _splitdict

# Verify if Tk is new enough to not need the Tile package
_REQUIRE_TILE = True if Tkinter.TkVersion < 8.5 else False

def _load_tile(master):
    if _REQUIRE_TILE:
        import os
        tilelib = os.environ.get('TILE_LIBRARY')
        if tilelib:
            # append custom tile path to the list of directories that
            # Tcl uses when attempting to resolve packages with the package
            # command
            master.tk.eval(
                    'global auto_path; '
                    'lappend auto_path {%s}' % tilelib)

        master.tk.eval('package require tile') # TclError may be raised here
        master._tile_loaded = True

def _format_optvalue(value, script=False):
    """Internal function."""
    if script:
        # if caller passes a Tcl script to tk.call, all the values need to
        # be grouped into words (arguments to a command in Tcl dialect)
        value = _stringify(value)
    elif isinstance(value, (list, tuple)):
        value = _join(value)
    return value

def _format_optdict(optdict, script=False, ignore=None):
    """Formats optdict to a tuple to pass it to tk.call.

    E.g. (script=False):
      {'foreground': 'blue', 'padding': [1, 2, 3, 4]} returns:
      ('-foreground', 'blue', '-padding', '1 2 3 4')"""

    opts = []
    for opt, value in optdict.iteritems():
        if not ignore or opt not in ignore:
            opts.append("-%s" % opt)
            if value is not None:
                opts.append(_format_optvalue(value, script))

    return _flatten(opts)

def _mapdict_values(items):
    # each value in mapdict is expected to be a sequence, where each item
    # is another sequence containing a state (or several) and a value
    # E.g. (script=False):
    #   [('active', 'selected', 'grey'), ('focus', [1, 2, 3, 4])]
    #   returns:
    #   ['active selected', 'grey', 'focus', [1, 2, 3, 4]]
    opt_val = []
    for item in items:
        state = item[:-1]
        val = item[-1]
        # hacks for bakward compatibility
        state[0] # raise IndexError if empty
        if len(state) == 1:
            # if it is empty (something that evaluates to False), then
            # format it to Tcl code to denote the "normal" state
            state = state[0] or ''
        else:
            # group multiple states
            state = ' '.join(state) # raise TypeError if not str
        opt_val.append(state)
        if val is not None:
            opt_val.append(val)
    return opt_val

def _format_mapdict(mapdict, script=False):
    """Formats mapdict to pass it to tk.call.

    E.g. (script=False):
      {'expand': [('active', 'selected', 'grey'), ('focus', [1, 2, 3, 4])]}

      returns:

      ('-expand', '{active selected} grey focus {1, 2, 3, 4}')"""

    opts = []
    for opt, value in mapdict.iteritems():
        opts.extend(("-%s" % opt,
                     _format_optvalue(_mapdict_values(value), script)))

    return _flatten(opts)

def _format_elemcreate(etype, script=False, *args, **kw):
    """Formats args and kw according to the given element factory etype."""
    spec = None
    opts = ()
    if etype in ("image", "vsapi"):
        if etype == "image": # define an element based on an image
            # first arg should be the default image name
            iname = args[0]
            # next args, if any, are statespec/value pairs which is almost
            # a mapdict, but we just need the value
            imagespec = _join(_mapdict_values(args[1:]))
            spec = "%s %s" % (iname, imagespec)

        else:
            # define an element whose visual appearance is drawn using the
            # Microsoft Visual Styles API which is responsible for the
            # themed styles on Windows XP and Vista.
            # Availability: Tk 8.6, Windows XP and Vista.
            class_name, part_id = args[:2]
            statemap = _join(_mapdict_values(args[2:]))
            spec = "%s %s %s" % (class_name, part_id, statemap)

        opts = _format_optdict(kw, script)

    elif etype == "from": # clone an element
        # it expects a themename and optionally an element to clone from,
        # otherwise it will clone {} (empty element)
        spec = args[0] # theme name
        if len(args) > 1: # elementfrom specified
            opts = (_format_optvalue(args[1], script),)

    if script:
        spec = '{%s}' % spec
        opts = ' '.join(opts)

    return spec, opts

def _format_layoutlist(layout, indent=0, indent_size=2):
    """Formats a layout list so we can pass the result to ttk::style
    layout and ttk::style settings. Note that the layout doesn't have to
    be a list necessarily.

    E.g.:
      [("Menubutton.background", None),
       ("Menubutton.button", {"children":
           [("Menubutton.focus", {"children":
               [("Menubutton.padding", {"children":
                [("Menubutton.label", {"side": "left", "expand": 1})]
               })]
           })]
       }),
       ("Menubutton.indicator", {"side": "right"})
      ]

      returns:

      Menubutton.background
      Menubutton.button -children {
        Menubutton.focus -children {
          Menubutton.padding -children {
            Menubutton.label -side left -expand 1
          }
        }
      }
      Menubutton.indicator -side right"""
    script = []

    for layout_elem in layout:
        elem, opts = layout_elem
        opts = opts or {}
        fopts = ' '.join(_format_optdict(opts, True, ("children",)))
        head = "%s%s%s" % (' ' * indent, elem, (" %s" % fopts) if fopts else '')

        if "children" in opts:
            script.append(head + " -children {")
            indent += indent_size
            newscript, indent = _format_layoutlist(opts['children'], indent,
                indent_size)
            script.append(newscript)
            indent -= indent_size
            script.append('%s}' % (' ' * indent))
        else:
            script.append(head)

    return '\n'.join(script), indent

def _script_from_settings(settings):
    """Returns an appropriate script, based on settings, according to
    theme_settings definition to be used by theme_settings and
    theme_create."""
    script = []
    # a script will be generated according to settings passed, which
    # will then be evaluated by Tcl
    for name, opts in settings.iteritems():
        # will format specific keys according to Tcl code
        if opts.get('configure'): # format 'configure'
            s = ' '.join(_format_optdict(opts['configure'], True))
            script.append("ttk::style configure %s %s;" % (name, s))

        if opts.get('map'): # format 'map'
            s = ' '.join(_format_mapdict(opts['map'], True))
            script.append("ttk::style map %s %s;" % (name, s))

        if 'layout' in opts: # format 'layout' which may be empty
            if not opts['layout']:
                s = 'null' # could be any other word, but this one makes sense
            else:
                s, _ = _format_layoutlist(opts['layout'])
            script.append("ttk::style layout %s {\n%s\n}" % (name, s))

        if opts.get('element create'): # format 'element create'
            eopts = opts['element create']
            etype = eopts[0]

            # find where args end, and where kwargs start
            argc = 1 # etype was the first one
            while argc < len(eopts) and not hasattr(eopts[argc], 'iteritems'):
                argc += 1

            elemargs = eopts[1:argc]
            elemkw = eopts[argc] if argc < len(eopts) and eopts[argc] else {}
            spec, opts = _format_elemcreate(etype, True, *elemargs, **elemkw)

            script.append("ttk::style element create %s %s %s %s" % (
                name, etype, spec, opts))

    return '\n'.join(script)

def _list_from_statespec(stuple):
    """Construct a list from the given statespec tuple according to the
    accepted statespec accepted by _format_mapdict."""
    nval = []
    for val in stuple:
        typename = getattr(val, 'typename', None)
        if typename is None:
            nval.append(val)
        else: # this is a Tcl object
            val = str(val)
            if typename == 'StateSpec':
                val = val.split()
            nval.append(val)

    it = iter(nval)
    return [_flatten(spec) for spec in zip(it, it)]

def _list_from_layouttuple(tk, ltuple):
    """Construct a list from the tuple returned by ttk::layout, this is
    somewhat the reverse of _format_layoutlist."""
    ltuple = tk.splitlist(ltuple)
    res = []

    indx = 0
    while indx < len(ltuple):
        name = ltuple[indx]
        opts = {}
        res.append((name, opts))
        indx += 1

        while indx < len(ltuple): # grab name's options
            opt, val = ltuple[indx:indx + 2]
            if not opt.startswith('-'): # found next name
                break

            opt = opt[1:] # remove the '-' from the option
            indx += 2

            if opt == 'children':
                val = _list_from_layouttuple(tk, val)

            opts[opt] = val

    return res

def _val_or_dict(tk, options, *args):
    """Format options then call Tk command with args and options and return
    the appropriate result.

    If no option is specified, a dict is returned. If an option is
    specified with the None value, the value for that option is returned.
    Otherwise, the function just sets the passed options and the caller
    shouldn't be expecting a return value anyway."""
    options = _format_optdict(options)
    res = tk.call(*(args + options))

    if len(options) % 2: # option specified without a value, return its value
        return res

    return _splitdict(tk, res, conv=_tclobj_to_py)

def _convert_stringval(value):
    """Converts a value to, hopefully, a more appropriate Python object."""
    value = unicode(value)
    try:
        value = int(value)
    except (ValueError, TypeError):
        pass

    return value

def _to_number(x):
    if isinstance(x, str):
        if '.' in x:
            x = float(x)
        else:
            x = int(x)
    return x

def _tclobj_to_py(val):
    """Return value converted from Tcl object to Python object."""
    if val and hasattr(val, '__len__') and not isinstance(val, basestring):
        if getattr(val[0], 'typename', None) == 'StateSpec':
            val = _list_from_statespec(val)
        else:
            val = map(_convert_stringval, val)

    elif hasattr(val, 'typename'): # some other (single) Tcl object
        val = _convert_stringval(val)

    return val

def tclobjs_to_py(adict):
    """Returns adict with its values converted from Tcl objects to Python
    objects."""
    for opt, val in adict.items():
        adict[opt] = _tclobj_to_py(val)

    return adict

def setup_master(master=None):
    """If master is not None, itself is returned. If master is None,
    the default master is returned if there is one, otherwise a new
    master is created and returned.

    If it is not allowed to use the default root and master is None,
    RuntimeError is raised."""
    if master is None:
        if Tkinter._support_default_root:
            master = Tkinter._default_root or Tkinter.Tk()
        else:
            raise RuntimeError(
                    "No master specified and Tkinter is "
                    "configured to not support default root")
    return master


class Style(object):
    """Manipulate style database."""

    _name = "ttk::style"

    def __init__(self, master=None):
        master = setup_master(master)

        if not getattr(master, '_tile_loaded', False):
            # Load tile now, if needed
            _load_tile(master)

        self.master = master
        self.tk = self.master.tk


    def configure(self, style, query_opt=None, **kw):
        """Query or sets the default value of the specified option(s) in
        style.

        Each key in kw is an option and each value is either a string or
        a sequence identifying the value for that option."""
        if query_opt is not None:
            kw[query_opt] = None
        return _val_or_dict(self.tk, kw, self._name, "configure", style)


    def map(self, style, query_opt=None, **kw):
        """Query or sets dynamic values of the specified option(s) in
        style.

        Each key in kw is an option and each value should be a list or a
        tuple (usually) containing statespecs grouped in tuples, or list,
        or something else of your preference. A statespec is compound of
        one or more states and then a value."""
        if query_opt is not None:
            return _list_from_statespec(self.tk.splitlist(
                self.tk.call(self._name, "map", style, '-%s' % query_opt)))

        return _splitdict(
            self.tk,
            self.tk.call(self._name, "map", style, *_format_mapdict(kw)),
            conv=_tclobj_to_py)


    def lookup(self, style, option, state=None, default=None):
        """Returns the value specified for option in style.

        If state is specified it is expected to be a sequence of one
        or more states. If the default argument is set, it is used as
        a fallback value in case no specification for option is found."""
        state = ' '.join(state) if state else ''

        return self.tk.call(self._name, "lookup", style, '-%s' % option,
            state, default)


    def layout(self, style, layoutspec=None):
        """Define the widget layout for given style. If layoutspec is
        omitted, return the layout specification for given style.

        layoutspec is expected to be a list or an object different than
        None that evaluates to False if you want to "turn off" that style.
        If it is a list (or tuple, or something else), each item should be
        a tuple where the first item is the layout name and the second item
        should have the format described below:

        LAYOUTS

            A layout can contain the value None, if takes no options, or
            a dict of options specifying how to arrange the element.
            The layout mechanism uses a simplified version of the pack
            geometry manager: given an initial cavity, each element is
            allocated a parcel. Valid options/values are:

                side: whichside
                    Specifies which side of the cavity to place the
                    element; one of top, right, bottom or left. If
                    omitted, the element occupies the entire cavity.

                sticky: nswe
                    Specifies where the element is placed inside its
                    allocated parcel.

                children: [sublayout... ]
                    Specifies a list of elements to place inside the
                    element. Each element is a tuple (or other sequence)
                    where the first item is the layout name, and the other
                    is a LAYOUT."""
        lspec = None
        if layoutspec:
            lspec = _format_layoutlist(layoutspec)[0]
        elif layoutspec is not None: # will disable the layout ({}, '', etc)
            lspec = "null" # could be any other word, but this may make sense
                           # when calling layout(style) later

        return _list_from_layouttuple(self.tk,
            self.tk.call(self._name, "layout", style, lspec))


    def element_create(self, elementname, etype, *args, **kw):
        """Create a new element in the current theme of given etype."""
        spec, opts = _format_elemcreate(etype, False, *args, **kw)
        self.tk.call(self._name, "element", "create", elementname, etype,
            spec, *opts)


    def element_names(self):
        """Returns the list of elements defined in the current theme."""
        return self.tk.splitlist(self.tk.call(self._name, "element", "names"))


    def element_options(self, elementname):
        """Return the list of elementname's options."""
        return self.tk.splitlist(self.tk.call(self._name, "element", "options", elementname))


    def theme_create(self, themename, parent=None, settings=None):
        """Creates a new theme.

        It is an error if themename already exists. If parent is
        specified, the new theme will inherit styles, elements and
        layouts from the specified parent theme. If settings are present,
        they are expected to have the same syntax used for theme_settings."""
        script = _script_from_settings(settings) if settings else ''

        if parent:
            self.tk.call(self._name, "theme", "create", themename,
                "-parent", parent, "-settings", script)
        else:
            self.tk.call(self._name, "theme", "create", themename,
                "-settings", script)


    def theme_settings(self, themename, settings):
        """Temporarily sets the current theme to themename, apply specified
        settings and then restore the previous theme.

        Each key in settings is a style and each value may contain the
        keys 'configure', 'map', 'layout' and 'element create' and they
        are expected to have the same format as specified by the methods
        configure, map, layout and element_create respectively."""
        script = _script_from_settings(settings)
        self.tk.call(self._name, "theme", "settings", themename, script)


    def theme_names(self):
        """Returns a list of all known themes."""
        return self.tk.splitlist(self.tk.call(self._name, "theme", "names"))


    def theme_use(self, themename=None):
        """If themename is None, returns the theme in use, otherwise, set
        the current theme to themename, refreshes all widgets and emits
        a <<ThemeChanged>> event."""
        if themename is None:
            # Starting on Tk 8.6, checking this global is no longer needed
            # since it allows doing self.tk.call(self._name, "theme", "use")
            return self.tk.eval("return $ttk::currentTheme")

        # using "ttk::setTheme" instead of "ttk::style theme use" causes
        # the variable currentTheme to be updated, also, ttk::setTheme calls
        # "ttk::style theme use" in order to change theme.
        self.tk.call("ttk::setTheme", themename)


class Widget(Tkinter.Widget):
    """Base class for Tk themed widgets."""

    def __init__(self, master, widgetname, kw=None):
        """Constructs a Ttk Widget with the parent master.

        STANDARD OPTIONS

            class, cursor, takefocus, style

        SCROLLABLE WIDGET OPTIONS

            xscrollcommand, yscrollcommand

        LABEL WIDGET OPTIONS

            text, textvariable, underline, image, compound, width

        WIDGET STATES

            active, disabled, focus, pressed, selected, background,
            readonly, alternate, invalid
        """
        master = setup_master(master)
        if not getattr(master, '_tile_loaded', False):
            # Load tile now, if needed
            _load_tile(master)
        Tkinter.Widget.__init__(self, master, widgetname, kw=kw)


    def identify(self, x, y):
        """Returns the name of the element at position x, y, or the empty
        string if the point does not lie within any element.

        x and y are pixel coordinates relative to the widget."""
        return self.tk.call(self._w, "identify", x, y)


    def instate(self, statespec, callback=None, *args, **kw):
        """Test the widget's state.

        If callback is not specified, returns True if the widget state
        matches statespec and False otherwise. If callback is specified,
        then it will be invoked with *args, **kw if the widget state
        matches statespec. statespec is expected to be a sequence."""
        ret = self.tk.getboolean(
                self.tk.call(self._w, "instate", ' '.join(statespec)))
        if ret and callback:
            return callback(*args, **kw)

        return ret


    def state(self, statespec=None):
        """Modify or inquire widget state.

        Widget state is returned if statespec is None, otherwise it is
        set according to the statespec flags and then a new state spec
        is returned indicating which flags were changed. statespec is
        expected to be a sequence."""
        if statespec is not None:
            statespec = ' '.join(statespec)

        return self.tk.splitlist(str(self.tk.call(self._w, "state", statespec)))


class Button(Widget):
    """Ttk Button widget, displays a textual label and/or image, and
    evaluates a command when pressed."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Button widget with the parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, default, width
        """
        Widget.__init__(self, master, "ttk::button", kw)


    def invoke(self):
        """Invokes the command associated with the button."""
        return self.tk.call(self._w, "invoke")


class Checkbutton(Widget):
    """Ttk Checkbutton widget which is either in on- or off-state."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Checkbutton widget with the parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, offvalue, onvalue, variable
        """
        Widget.__init__(self, master, "ttk::checkbutton", kw)


    def invoke(self):
        """Toggles between the selected and deselected states and
        invokes the associated command. If the widget is currently
        selected, sets the option variable to the offvalue option
        and deselects the widget; otherwise, sets the option variable
        to the option onvalue.

        Returns the result of the associated command."""
        return self.tk.call(self._w, "invoke")


class Entry(Widget, Tkinter.Entry):
    """Ttk Entry widget displays a one-line text string and allows that
    string to be edited by the user."""

    def __init__(self, master=None, widget=None, **kw):
        """Constructs a Ttk Entry widget with the parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus, xscrollcommand

        WIDGET-SPECIFIC OPTIONS

            exportselection, invalidcommand, justify, show, state,
            textvariable, validate, validatecommand, width

        VALIDATION MODES

            none, key, focus, focusin, focusout, all
        """
        Widget.__init__(self, master, widget or "ttk::entry", kw)


    def bbox(self, index):
        """Return a tuple of (x, y, width, height) which describes the
        bounding box of the character given by index."""
        return self._getints(self.tk.call(self._w, "bbox", index))


    def identify(self, x, y):
        """Returns the name of the element at position x, y, or the
        empty string if the coordinates are outside the window."""
        return self.tk.call(self._w, "identify", x, y)


    def validate(self):
        """Force revalidation, independent of the conditions specified
        by the validate option. Returns False if validation fails, True
        if it succeeds. Sets or clears the invalid state accordingly."""
        return self.tk.getboolean(self.tk.call(self._w, "validate"))


class Combobox(Entry):
    """Ttk Combobox widget combines a text field with a pop-down list of
    values."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Combobox widget with the parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            exportselection, justify, height, postcommand, state,
            textvariable, values, width
        """
        Entry.__init__(self, master, "ttk::combobox", **kw)


    def current(self, newindex=None):
        """If newindex is supplied, sets the combobox value to the
        element at position newindex in the list of values. Otherwise,
        returns the index of the current value in the list of values
        or -1 if the current value does not appear in the list."""
        if newindex is None:
            return self.tk.getint(self.tk.call(self._w, "current"))
        return self.tk.call(self._w, "current", newindex)


    def set(self, value):
        """Sets the value of the combobox to value."""
        self.tk.call(self._w, "set", value)


class Frame(Widget):
    """Ttk Frame widget is a container, used to group other widgets
    together."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Frame with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            borderwidth, relief, padding, width, height
        """
        Widget.__init__(self, master, "ttk::frame", kw)


class Label(Widget):
    """Ttk Label widget displays a textual label and/or image."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Label with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, style, takefocus, text,
            textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            anchor, background, font, foreground, justify, padding,
            relief, text, wraplength
        """
        Widget.__init__(self, master, "ttk::label", kw)


class Labelframe(Widget):
    """Ttk Labelframe widget is a container used to group other widgets
    together. It has an optional label, which may be a plain text string
    or another widget."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Labelframe with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS
            labelanchor, text, underline, padding, labelwidget, width,
            height
        """
        Widget.__init__(self, master, "ttk::labelframe", kw)

LabelFrame = Labelframe # Tkinter name compatibility


class Menubutton(Widget):
    """Ttk Menubutton widget displays a textual label and/or image, and
    displays a menu when pressed."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Menubutton with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            direction, menu
        """
        Widget.__init__(self, master, "ttk::menubutton", kw)


class Notebook(Widget):
    """Ttk Notebook widget manages a collection of windows and displays
    a single one at a time. Each child window is associated with a tab,
    which the user may select to change the currently-displayed window."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Notebook with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            height, padding, width

        TAB OPTIONS

            state, sticky, padding, text, image, compound, underline

        TAB IDENTIFIERS (tab_id)

            The tab_id argument found in several methods may take any of
            the following forms:

                * An integer between zero and the number of tabs
                * The name of a child window
                * A positional specification of the form "@x,y", which
                  defines the tab
                * The string "current", which identifies the
                  currently-selected tab
                * The string "end", which returns the number of tabs (only
                  valid for method index)
        """
        Widget.__init__(self, master, "ttk::notebook", kw)


    def add(self, child, **kw):
        """Adds a new tab to the notebook.

        If window is currently managed by the notebook but hidden, it is
        restored to its previous position."""
        self.tk.call(self._w, "add", child, *(_format_optdict(kw)))


    def forget(self, tab_id):
        """Removes the tab specified by tab_id, unmaps and unmanages the
        associated window."""
        self.tk.call(self._w, "forget", tab_id)


    def hide(self, tab_id):
        """Hides the tab specified by tab_id.

        The tab will not be displayed, but the associated window remains
        managed by the notebook and its configuration remembered. Hidden
        tabs may be restored with the add command."""
        self.tk.call(self._w, "hide", tab_id)


    def identify(self, x, y):
        """Returns the name of the tab element at position x, y, or the
        empty string if none."""
        return self.tk.call(self._w, "identify", x, y)


    def index(self, tab_id):
        """Returns the numeric index of the tab specified by tab_id, or
        the total number of tabs if tab_id is the string "end"."""
        return self.tk.getint(self.tk.call(self._w, "index", tab_id))


    def insert(self, pos, child, **kw):
        """Inserts a pane at the specified position.

        pos is either the string end, an integer index, or the name of
        a managed child. If child is already managed by the notebook,
        moves it to the specified position."""
        self.tk.call(self._w, "insert", pos, child, *(_format_optdict(kw)))


    def select(self, tab_id=None):
        """Selects the specified tab.

        The associated child window will be displayed, and the
        previously-selected window (if different) is unmapped. If tab_id
        is omitted, returns the widget name of the currently selected
        pane."""
        return self.tk.call(self._w, "select", tab_id)


    def tab(self, tab_id, option=None, **kw):
        """Query or modify the options of the specific tab_id.

        If kw is not given, returns a dict of the tab option values. If option
        is specified, returns the value of that option. Otherwise, sets the
        options to the corresponding values."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "tab", tab_id)


    def tabs(self):
        """Returns a list of windows managed by the notebook."""
        return self.tk.splitlist(self.tk.call(self._w, "tabs") or ())


    def enable_traversal(self):
        """Enable keyboard traversal for a toplevel window containing
        this notebook.

        This will extend the bindings for the toplevel window containing
        this notebook as follows:

            Control-Tab: selects the tab following the currently selected
                         one

            Shift-Control-Tab: selects the tab preceding the currently
                               selected one

            Alt-K: where K is the mnemonic (underlined) character of any
                   tab, will select that tab.

        Multiple notebooks in a single toplevel may be enabled for
        traversal, including nested notebooks. However, notebook traversal
        only works properly if all panes are direct children of the
        notebook."""
        # The only, and good, difference I see is about mnemonics, which works
        # after calling this method. Control-Tab and Shift-Control-Tab always
        # works (here at least).
        self.tk.call("ttk::notebook::enableTraversal", self._w)


class Panedwindow(Widget, Tkinter.PanedWindow):
    """Ttk Panedwindow widget displays a number of subwindows, stacked
    either vertically or horizontally."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Panedwindow with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient, width, height

        PANE OPTIONS

            weight
        """
        Widget.__init__(self, master, "ttk::panedwindow", kw)


    forget = Tkinter.PanedWindow.forget # overrides Pack.forget


    def insert(self, pos, child, **kw):
        """Inserts a pane at the specified positions.

        pos is either the string end, and integer index, or the name
        of a child. If child is already managed by the paned window,
        moves it to the specified position."""
        self.tk.call(self._w, "insert", pos, child, *(_format_optdict(kw)))


    def pane(self, pane, option=None, **kw):
        """Query or modify the options of the specified pane.

        pane is either an integer index or the name of a managed subwindow.
        If kw is not given, returns a dict of the pane option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "pane", pane)


    def sashpos(self, index, newpos=None):
        """If newpos is specified, sets the position of sash number index.

        May adjust the positions of adjacent sashes to ensure that
        positions are monotonically increasing. Sash positions are further
        constrained to be between 0 and the total size of the widget.

        Returns the new position of sash number index."""
        return self.tk.getint(self.tk.call(self._w, "sashpos", index, newpos))

PanedWindow = Panedwindow # Tkinter name compatibility


class Progressbar(Widget):
    """Ttk Progressbar widget shows the status of a long-running
    operation. They can operate in two modes: determinate mode shows the
    amount completed relative to the total amount of work to be done, and
    indeterminate mode provides an animated display to let the user know
    that something is happening."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Progressbar with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient, length, mode, maximum, value, variable, phase
        """
        Widget.__init__(self, master, "ttk::progressbar", kw)


    def start(self, interval=None):
        """Begin autoincrement mode: schedules a recurring timer event
        that calls method step every interval milliseconds.

        interval defaults to 50 milliseconds (20 steps/second) if omitted."""
        self.tk.call(self._w, "start", interval)


    def step(self, amount=None):
        """Increments the value option by amount.

        amount defaults to 1.0 if omitted."""
        self.tk.call(self._w, "step", amount)


    def stop(self):
        """Stop autoincrement mode: cancels any recurring timer event
        initiated by start."""
        self.tk.call(self._w, "stop")


class Radiobutton(Widget):
    """Ttk Radiobutton widgets are used in groups to show or change a
    set of mutually-exclusive options."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Radiobutton with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, value, variable
        """
        Widget.__init__(self, master, "ttk::radiobutton", kw)


    def invoke(self):
        """Sets the option variable to the option value, selects the
        widget, and invokes the associated command.

        Returns the result of the command, or an empty string if
        no command is specified."""
        return self.tk.call(self._w, "invoke")


class Scale(Widget, Tkinter.Scale):
    """Ttk Scale widget is typically used to control the numeric value of
    a linked variable that varies uniformly over some range."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Scale with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            command, from, length, orient, to, value, variable
        """
        Widget.__init__(self, master, "ttk::scale", kw)


    def configure(self, cnf=None, **kw):
        """Modify or query scale options.

        Setting a value for any of the "from", "from_" or "to" options
        generates a <<RangeChanged>> event."""
        if cnf:
            kw.update(cnf)
        Widget.configure(self, **kw)
        if any(['from' in kw, 'from_' in kw, 'to' in kw]):
            self.event_generate('<<RangeChanged>>')


    def get(self, x=None, y=None):
        """Get the current value of the value option, or the value
        corresponding to the coordinates x, y if they are specified.

        x and y are pixel coordinates relative to the scale widget
        origin."""
        return self.tk.call(self._w, 'get', x, y)


class Scrollbar(Widget, Tkinter.Scrollbar):
    """Ttk Scrollbar controls the viewport of a scrollable widget."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Scrollbar with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            command, orient
        """
        Widget.__init__(self, master, "ttk::scrollbar", kw)


class Separator(Widget):
    """Ttk Separator widget displays a horizontal or vertical separator
    bar."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Separator with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient
        """
        Widget.__init__(self, master, "ttk::separator", kw)


class Sizegrip(Widget):
    """Ttk Sizegrip allows the user to resize the containing toplevel
    window by pressing and dragging the grip."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Sizegrip with parent master.

        STANDARD OPTIONS

            class, cursor, state, style, takefocus
        """
        Widget.__init__(self, master, "ttk::sizegrip", kw)


class Treeview(Widget, Tkinter.XView, Tkinter.YView):
    """Ttk Treeview widget displays a hierarchical collection of items.

    Each item has a textual label, an optional image, and an optional list
    of data values. The data values are displayed in successive columns
    after the tree label."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Treeview with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus, xscrollcommand,
            yscrollcommand

        WIDGET-SPECIFIC OPTIONS

            columns, displaycolumns, height, padding, selectmode, show

        ITEM OPTIONS

            text, image, values, open, tags

        TAG OPTIONS

            foreground, background, font, image
        """
        Widget.__init__(self, master, "ttk::treeview", kw)


    def bbox(self, item, column=None):
        """Returns the bounding box (relative to the treeview widget's
        window) of the specified item in the form x y width height.

        If column is specified, returns the bounding box of that cell.
        If the item is not visible (i.e., if it is a descendant of a
        closed item or is scrolled offscreen), returns an empty string."""
        return self._getints(self.tk.call(self._w, "bbox", item, column)) or ''


    def get_children(self, item=None):
        """Returns a tuple of children belonging to item.

        If item is not specified, returns root children."""
        return self.tk.splitlist(
                self.tk.call(self._w, "children", item or '') or ())


    def set_children(self, item, *newchildren):
        """Replaces item's child with newchildren.

        Children present in item that are not present in newchildren
        are detached from tree. No items in newchildren may be an
        ancestor of item."""
        self.tk.call(self._w, "children", item, newchildren)


    def column(self, column, option=None, **kw):
        """Query or modify the options for the specified column.

        If kw is not given, returns a dict of the column option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "column", column)


    def delete(self, *items):
        """Delete all specified items and all their descendants. The root
        item may not be deleted."""
        self.tk.call(self._w, "delete", items)


    def detach(self, *items):
        """Unlinks all of the specified items from the tree.

        The items and all of their descendants are still present, and may
        be reinserted at another point in the tree, but will not be
        displayed. The root item may not be detached."""
        self.tk.call(self._w, "detach", items)


    def exists(self, item):
        """Returns True if the specified item is present in the tree,
        False otherwise."""
        return self.tk.getboolean(self.tk.call(self._w, "exists", item))


    def focus(self, item=None):
        """If item is specified, sets the focus item to item. Otherwise,
        returns the current focus item, or '' if there is none."""
        return self.tk.call(self._w, "focus", item)


    def heading(self, column, option=None, **kw):
        """Query or modify the heading options for the specified column.

        If kw is not given, returns a dict of the heading option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values.

        Valid options/values are:
            text: text
                The text to display in the column heading
            image: image_name
                Specifies an image to display to the right of the column
                heading
            anchor: anchor
                Specifies how the heading text should be aligned. One of
                the standard Tk anchor values
            command: callback
                A callback to be invoked when the heading label is
                pressed.

        To configure the tree column heading, call this with column = "#0" """
        cmd = kw.get('command')
        if cmd and not isinstance(cmd, basestring):
            # callback not registered yet, do it now
            kw['command'] = self.master.register(cmd, self._substitute)

        if option is not None:
            kw[option] = None

        return _val_or_dict(self.tk, kw, self._w, 'heading', column)


    def identify(self, component, x, y):
        """Returns a description of the specified component under the
        point given by x and y, or the empty string if no such component
        is present at that position."""
        return self.tk.call(self._w, "identify", component, x, y)


    def identify_row(self, y):
        """Returns the item ID of the item at position y."""
        return self.identify("row", 0, y)


    def identify_column(self, x):
        """Returns the data column identifier of the cell at position x.

        The tree column has ID #0."""
        return self.identify("column", x, 0)


    def identify_region(self, x, y):
        """Returns one of:

        heading: Tree heading area.
        separator: Space between two columns headings;
        tree: The tree area.
        cell: A data cell.

        * Availability: Tk 8.6"""
        return self.identify("region", x, y)


    def identify_element(self, x, y):
        """Returns the element at position x, y.

        * Availability: Tk 8.6"""
        return self.identify("element", x, y)


    def index(self, item):
        """Returns the integer index of item within its parent's list
        of children."""
        return self.tk.getint(self.tk.call(self._w, "index", item))


    def insert(self, parent, index, iid=None, **kw):
        """Creates a new item and return the item identifier of the newly
        created item.

        parent is the item ID of the parent item, or the empty string
        to create a new top-level item. index is an integer, or the value
        end, specifying where in the list of parent's children to insert
        the new item. If index is less than or equal to zero, the new node
        is inserted at the beginning, if index is greater than or equal to
        the current number of children, it is inserted at the end. If iid
        is specified, it is used as the item identifier, iid must not
        already exist in the tree. Otherwise, a new unique identifier
        is generated."""
        opts = _format_optdict(kw)
        if iid:
            res = self.tk.call(self._w, "insert", parent, index,
                "-id", iid, *opts)
        else:
            res = self.tk.call(self._w, "insert", parent, index, *opts)

        return res


    def item(self, item, option=None, **kw):
        """Query or modify the options for the specified item.

        If no options are given, a dict with options/values for the item
        is returned. If option is specified then the value for that option
        is returned. Otherwise, sets the options to the corresponding
        values as given by kw."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "item", item)


    def move(self, item, parent, index):
        """Moves item to position index in parent's list of children.

        It is illegal to move an item under one of its descendants. If
        index is less than or equal to zero, item is moved to the
        beginning, if greater than or equal to the number of children,
        it is moved to the end. If item was detached it is reattached."""
        self.tk.call(self._w, "move", item, parent, index)

    reattach = move # A sensible method name for reattaching detached items


    def next(self, item):
        """Returns the identifier of item's next sibling, or '' if item
        is the last child of its parent."""
        return self.tk.call(self._w, "next", item)


    def parent(self, item):
        """Returns the ID of the parent of item, or '' if item is at the
        top level of the hierarchy."""
        return self.tk.call(self._w, "parent", item)


    def prev(self, item):
        """Returns the identifier of item's previous sibling, or '' if
        item is the first child of its parent."""
        return self.tk.call(self._w, "prev", item)


    def see(self, item):
        """Ensure that item is visible.

        Sets all of item's ancestors open option to True, and scrolls
        the widget if necessary so that item is within the visible
        portion of the tree."""
        self.tk.call(self._w, "see", item)


    def selection(self, selop=None, items=None):
        """If selop is not specified, returns selected items."""
        if isinstance(items, basestring):
            items = (items,)
        return self.tk.splitlist(self.tk.call(self._w, "selection", selop, items))


    def selection_set(self, items):
        """items becomes the new selection."""
        self.selection("set", items)


    def selection_add(self, items):
        """Add items to the selection."""
        self.selection("add", items)


    def selection_remove(self, items):
        """Remove items from the selection."""
        self.selection("remove", items)


    def selection_toggle(self, items):
        """Toggle the selection state of each item in items."""
        self.selection("toggle", items)


    def set(self, item, column=None, value=None):
        """Query or set the value of given item.

        With one argument, return a dictionary of column/value pairs
        for the specified item. With two arguments, return the current
        value of the specified column. With three arguments, set the
        value of given column in given item to the specified value."""
        res = self.tk.call(self._w, "set", item, column, value)
        if column is None and value is None:
            return _splitdict(self.tk, res,
                              cut_minus=False, conv=_tclobj_to_py)
        else:
            return res


    def tag_bind(self, tagname, sequence=None, callback=None):
        """Bind a callback for the given event sequence to the tag tagname.
        When an event is delivered to an item, the callbacks for each
        of the item's tags option are called."""
        self._bind((self._w, "tag", "bind", tagname), sequence, callback, add=0)


    def tag_configure(self, tagname, option=None, **kw):
        """Query or modify the options for the specified tagname.

        If kw is not given, returns a dict of the option settings for tagname.
        If option is specified, returns the value for that option for the
        specified tagname. Otherwise, sets the options to the corresponding
        values for the given tagname."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "tag", "configure",
            tagname)


    def tag_has(self, tagname, item=None):
        """If item is specified, returns 1 or 0 depending on whether the
        specified item has the given tagname. Otherwise, returns a list of
        all items which have the specified tag.

        * Availability: Tk 8.6"""
        if item is None:
            return self.tk.splitlist(
                self.tk.call(self._w, "tag", "has", tagname))
        else:
            return self.tk.getboolean(
                self.tk.call(self._w, "tag", "has", tagname, item))


# Extensions

class LabeledScale(Frame, object):
    """A Ttk Scale widget with a Ttk Label widget indicating its
    current value.

    The Ttk Scale can be accessed through instance.scale, and Ttk Label
    can be accessed through instance.label"""

    def __init__(self, master=None, variable=None, from_=0, to=10, **kw):
        """Construct a horizontal LabeledScale with parent master, a
        variable to be associated with the Ttk Scale widget and its range.
        If variable is not specified, a Tkinter.IntVar is created.

        WIDGET-SPECIFIC OPTIONS

            compound: 'top' or 'bottom'
                Specifies how to display the label relative to the scale.
                Defaults to 'top'.
        """
        self._label_top = kw.pop('compound', 'top') == 'top'

        Frame.__init__(self, master, **kw)
        self._variable = variable or Tkinter.IntVar(master)
        self._variable.set(from_)
        self._last_valid = from_

        self.label = Label(self)
        self.scale = Scale(self, variable=self._variable, from_=from_, to=to)
        self.scale.bind('<<RangeChanged>>', self._adjust)

        # position scale and label according to the compound option
        scale_side = 'bottom' if self._label_top else 'top'
        label_side = 'top' if scale_side == 'bottom' else 'bottom'
        self.scale.pack(side=scale_side, fill='x')
        tmp = Label(self).pack(side=label_side) # place holder
        self.label.place(anchor='n' if label_side == 'top' else 's')

        # update the label as scale or variable changes
        self.__tracecb = self._variable.trace_variable('w', self._adjust)
        self.bind('<Configure>', self._adjust)
        self.bind('<Map>', self._adjust)


    def destroy(self):
        """Destroy this widget and possibly its associated variable."""
        try:
            self._variable.trace_vdelete('w', self.__tracecb)
        except AttributeError:
            # widget has been destroyed already
            pass
        else:
            del self._variable
            Frame.destroy(self)


    def _adjust(self, *args):
        """Adjust the label position according to the scale."""
        def adjust_label():
            self.update_idletasks() # "force" scale redraw

            x, y = self.scale.coords()
            if self._label_top:
                y = self.scale.winfo_y() - self.label.winfo_reqheight()
            else:
                y = self.scale.winfo_reqheight() + self.label.winfo_reqheight()

            self.label.place_configure(x=x, y=y)

        from_ = _to_number(self.scale['from'])
        to = _to_number(self.scale['to'])
        if to < from_:
            from_, to = to, from_
        newval = self._variable.get()
        if not from_ <= newval <= to:
            # value outside range, set value back to the last valid one
            self.value = self._last_valid
            return

        self._last_valid = newval
        self.label['text'] = newval
        self.after_idle(adjust_label)


    def _get_value(self):
        """Return current scale value."""
        return self._variable.get()


    def _set_value(self, val):
        """Set new scale value."""
        self._variable.set(val)


    value = property(_get_value, _set_value)


class OptionMenu(Menubutton):
    """Themed OptionMenu, based after Tkinter's OptionMenu, which allows
    the user to select a value from a menu."""

    def __init__(self, master, variable, default=None, *values, **kwargs):
        """Construct a themed OptionMenu widget with master as the parent,
        the resource textvariable set to variable, the initially selected
        value specified by the default parameter, the menu values given by
        *values and additional keywords.

        WIDGET-SPECIFIC OPTIONS

            style: stylename
                Menubutton style.
            direction: 'above', 'below', 'left', 'right', or 'flush'
                Menubutton direction.
            command: callback
                A callback that will be invoked after selecting an item.
        """
        kw = {'textvariable': variable, 'style': kwargs.pop('style', None),
              'direction': kwargs.pop('direction', None)}
        Menubutton.__init__(self, master, **kw)
        self['menu'] = Tkinter.Menu(self, tearoff=False)

        self._variable = variable
        self._callback = kwargs.pop('command', None)
        if kwargs:
            raise Tkinter.TclError('unknown option -%s' % (
                kwargs.iterkeys().next()))

        self.set_menu(default, *values)


    def __getitem__(self, item):
        if item == 'menu':
            return self.nametowidget(Menubutton.__getitem__(self, item))

        return Menubutton.__getitem__(self, item)


    def set_menu(self, default=None, *values):
        """Build a new menu of radiobuttons with *values and optionally
        a default value."""
        menu = self['menu']
        menu.delete(0, 'end')
        for val in values:
            menu.add_radiobutton(label=val,
                command=Tkinter._setit(self._variable, val, self._callback))

        if default:
            self._variable.set(default)


    def destroy(self):
        """Destroy this widget and its associated variable."""
        del self._variable
        Menubutton.destroy(self)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

# A grammar to describe tree matching patterns.
# Not shown here:
# - 'TOKEN' stands for any token (leaf node)
# - 'any' stands for any node (leaf or interior)
# With 'any' we can still specify the sub-structure.

# The start symbol is 'Matcher'.

Matcher: Alternatives ENDMARKER

Alternatives: Alternative ('|' Alternative)*

Alternative: (Unit | NegatedUnit)+

Unit: [NAME '='] ( STRING [Repeater]
                 | NAME [Details] [Repeater]
                 | '(' Alternatives ')' [Repeater]
                 | '[' Alternatives ']'
		 )

NegatedUnit: 'not' (STRING | NAME [Details] | '(' Alternatives ')')

Repeater: '*' | '+' | '{' NUMBER [',' NUMBER] '}'

Details: '<' Alternatives '>'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Grammar for 2to3. This grammar supports Python 2.x and 3.x.

# Note:  Changing the grammar specified in this file will most likely
#        require corresponding changes in the parser module
#        (../Modules/parsermodule.c).  If you can't make the changes to
#        that module yourself, please co-ordinate the required changes
#        with someone who can; ask around on python-dev for help.  Fred
#        Drake <fdrake@acm.org> will probably be listening there.

# NOTE WELL: You should also follow all the steps listed in PEP 306,
# "How to Change Python's Grammar"

# Commands for Kees Blom's railroad program
#diagram:token NAME
#diagram:token NUMBER
#diagram:token STRING
#diagram:token NEWLINE
#diagram:token ENDMARKER
#diagram:token INDENT
#diagram:output\input python.bla
#diagram:token DEDENT
#diagram:output\textwidth 20.04cm\oddsidemargin  0.0cm\evensidemargin 0.0cm
#diagram:rules

# Start symbols for the grammar:
#	file_input is a module or sequence of commands read from an input file;
#	single_input is a single interactive statement;
#	eval_input is the input for the eval() and input() functions.
# NB: compound_stmt in single_input is followed by extra NEWLINE!
file_input: (NEWLINE | stmt)* ENDMARKER
single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE
eval_input: testlist NEWLINE* ENDMARKER

decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
decorators: decorator+
decorated: decorators (classdef | funcdef)
funcdef: 'def' NAME parameters ['->' test] ':' suite
parameters: '(' [typedargslist] ')'
typedargslist: ((tfpdef ['=' test] ',')*
                ('*' [tname] (',' tname ['=' test])* [',' '**' tname] | '**' tname)
                | tfpdef ['=' test] (',' tfpdef ['=' test])* [','])
tname: NAME [':' test]
tfpdef: tname | '(' tfplist ')'
tfplist: tfpdef (',' tfpdef)* [',']
varargslist: ((vfpdef ['=' test] ',')*
              ('*' [vname] (',' vname ['=' test])*  [',' '**' vname] | '**' vname)
              | vfpdef ['=' test] (',' vfpdef ['=' test])* [','])
vname: NAME
vfpdef: vname | '(' vfplist ')'
vfplist: vfpdef (',' vfpdef)* [',']

stmt: simple_stmt | compound_stmt
simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
small_stmt: (expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt |
             import_stmt | global_stmt | exec_stmt | assert_stmt)
expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) |
                     ('=' (yield_expr|testlist_star_expr))*)
testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |
            '<<=' | '>>=' | '**=' | '//=')
# For normal assignments, additional restrictions enforced by the interpreter
print_stmt: 'print' ( [ test (',' test)* [','] ] |
                      '>>' test [ (',' test)+ [','] ] )
del_stmt: 'del' exprlist
pass_stmt: 'pass'
flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
break_stmt: 'break'
continue_stmt: 'continue'
return_stmt: 'return' [testlist]
yield_stmt: yield_expr
raise_stmt: 'raise' [test ['from' test | ',' test [',' test]]]
import_stmt: import_name | import_from
import_name: 'import' dotted_as_names
import_from: ('from' ('.'* dotted_name | '.'+)
              'import' ('*' | '(' import_as_names ')' | import_as_names))
import_as_name: NAME ['as' NAME]
dotted_as_name: dotted_name ['as' NAME]
import_as_names: import_as_name (',' import_as_name)* [',']
dotted_as_names: dotted_as_name (',' dotted_as_name)*
dotted_name: NAME ('.' NAME)*
global_stmt: ('global' | 'nonlocal') NAME (',' NAME)*
exec_stmt: 'exec' expr ['in' test [',' test]]
assert_stmt: 'assert' test [',' test]

compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated
if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
while_stmt: 'while' test ':' suite ['else' ':' suite]
for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
try_stmt: ('try' ':' suite
           ((except_clause ':' suite)+
	    ['else' ':' suite]
	    ['finally' ':' suite] |
	   'finally' ':' suite))
with_stmt: 'with' with_item (',' with_item)*  ':' suite
with_item: test ['as' expr]
with_var: 'as' expr
# NB compile.c makes sure that the default except clause is last
except_clause: 'except' [test [(',' | 'as') test]]
suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT

# Backward compatibility cruft to support:
# [ x for x in lambda: True, lambda: False if x() ]
# even while also allowing:
# lambda x: 5 if x else 2
# (But not a mix of the two)
testlist_safe: old_test [(',' old_test)+ [',']]
old_test: or_test | old_lambdef
old_lambdef: 'lambda' [varargslist] ':' old_test

test: or_test ['if' or_test 'else' test] | lambdef
or_test: and_test ('or' and_test)*
and_test: not_test ('and' not_test)*
not_test: 'not' not_test | comparison
comparison: expr (comp_op expr)*
comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
star_expr: '*' expr
expr: xor_expr ('|' xor_expr)*
xor_expr: and_expr ('^' and_expr)*
and_expr: shift_expr ('&' shift_expr)*
shift_expr: arith_expr (('<<'|'>>') arith_expr)*
arith_expr: term (('+'|'-') term)*
term: factor (('*'|'@'|'/'|'%'|'//') factor)*
factor: ('+'|'-'|'~') factor | power
power: atom trailer* ['**' factor]
atom: ('(' [yield_expr|testlist_gexp] ')' |
       '[' [listmaker] ']' |
       '{' [dictsetmaker] '}' |
       '`' testlist1 '`' |
       NAME | NUMBER | STRING+ | '.' '.' '.')
listmaker: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
testlist_gexp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
lambdef: 'lambda' [varargslist] ':' test
trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
subscriptlist: subscript (',' subscript)* [',']
subscript: test | [test] ':' [test] [sliceop]
sliceop: ':' [test]
exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']
testlist: test (',' test)* [',']
dictsetmaker: ( ((test ':' test | '**' expr)
                 (comp_for | (',' (test ':' test | '**' expr))* [','])) |
                ((test | star_expr)
		 (comp_for | (',' (test | star_expr))* [','])) )

classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

arglist: argument (',' argument)* [',']

# "test '=' test" is really "keyword '=' test", but we have no such token.
# These need to be in a single rule to avoid grammar that is ambiguous
# to our LL(1) parser. Even though 'test' includes '*expr' in star_expr,
# we explicitly match '*' here, too, to give it proper precedence.
# Illegal combinations and orderings are blocked in ast.c:
# multiple (test comp_for) arguments are blocked; keyword unpackings
# that precede iterable unpackings are blocked; etc.
argument: ( test [comp_for] |
            test '=' test |
	    '**' expr |
	    star_expr )

comp_iter: comp_for | comp_if
comp_for: 'for' exprlist 'in' testlist_safe [comp_iter]
comp_if: 'if' old_test [comp_iter]

testlist1: test (',' test)*

# not used in grammar, but may appear in "node" passed from Parser to Compiler
encoding_decl: NAME

yield_expr: 'yield' [yield_arg]
yield_arg: 'from' test | testlist
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #empty
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
[c           @   s   d  S(   N(    (    (    (    s&   /usr/lib/python2.7/lib2to3/__init__.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
[c           @   s   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d e
 f d	     YZ d
 e
 f d     YZ i  a d   Z d S(   s  A bottom-up tree matching algorithm implementation meant to speed
up 2to3's matching process. After the tree patterns are reduced to
their rarest linear path, a linear Aho-Corasick automaton is
created. The linear automaton traverses the linear paths from the
leaves to the root of the AST and returns a set of nodes for further
matching. This reduces significantly the number of candidate nodes.s+   George Boutsioukis <gboutsioukis@gmail.com>iN(   t   defaultdicti   (   t   pytree(   t   reduce_treet   BMNodec           B   s#   e  Z d  Z e j   Z d   Z RS(   s?   Class for a node of the Aho-Corasick automaton used in matchingc         C   s1   i  |  _  g  |  _ t t j  |  _ d |  _ d  S(   Nt    (   t   transition_tablet   fixerst   nextR   t   countt   idt   content(   t   self(    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyt   __init__   s    		(   t   __name__t
   __module__t   __doc__t	   itertoolsR   R   (    (    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyR      s   t   BottomMatcherc           B   s;   e  Z d  Z d   Z d   Z d   Z d   Z d   Z RS(   sg   The main matcher class. After instantiating the patterns should
    be added using the add_fixer methodc         C   sF   t    |  _ t   |  _ |  j g |  _ g  |  _ t j d  |  _ d  S(   Nt   RefactoringTool(	   t   sett   matchR   t   roott   nodesR   t   loggingt	   getLoggert   logger(   R   (    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyR      s
    	c         C   sh   |  j  j |  t | j  } | j   } |  j | d |  j } x | D] } | j  j |  qJ Wd S(   s   Reduces a fixer's pattern tree to a linear path and adds it
        to the matcher(a common Aho-Corasick automaton). The fixer is
        appended on the matching states and called when they are
        reachedt   startN(   R   t   appendR   t   pattern_treet   get_linear_subpatternt   addR   (   R   t   fixert   treet   lineart   match_nodest
   match_node(    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyt	   add_fixer%   s    c         C   s   | s | g St  | d t  r g  } xU | d D]I } |  j | d | } x+ | D]# } | j |  j | d |   qS Wq1 W| S| d | j k r t   } | | j | d <n | j | d } | d r |  j | d d | } n	 | g } | Sd S(   s5   Recursively adds a linear pattern to the AC automatoni    R   i   N(   t
   isinstancet   tupleR   t   extendR   R   (   R   t   patternR   R"   t   alternativet	   end_nodest   endt	   next_node(    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyR   1   s"    %	
	c   	      C   s  |  j  } t t  } x| D]y} | } xj| rt | _ x? | j D]4 } t | t j  rD | j	 d k rD t
 | _ PqD qD W| j d k r | j	 } n	 | j } | | j k r | j | } x | j D]0 } | | k r g  | | <n  | | j |  q Wn |  j  } | j d k	 r%| j j r%Pn  | | j k r| j | } xD | j D]6 } | | j   k rpg  | | <n  | | j |  qKWn  | j } q+ Wq W| S(   su  The main interface with the bottom matcher. The tree is
        traversed from the bottom using the constructed
        automaton. Nodes are only checked once as the tree is
        retraversed. When the automaton fails, we give it one more
        shot(in case the above tree matches as a whole with the
        rejected leaf), then we break for the next leaf. There is the
        special case of multiple arguments(see code comments) where we
        recheck the nodes

        Args:
           The leaves of the AST tree to be matched

        Returns:
           A dictionary of node matches with fixers as the keys
        u   ;i   N(   R   R    t   listt   Truet   was_checkedt   childrenR%   R   t   Leaft   valuet   Falset   typeR   R   R   t   parentt   Nonet   keys(	   R   t   leavest   current_ac_nodet   resultst   leaft   current_ast_nodet   childt
   node_tokenR   (    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyt   runS   s>    			!			c            s*   d GH  f d       |  j   d GHd S(   s<   Prints a graphviz diagram of the BM automaton(for debugging)s
   digraph g{c            sv   xo |  j  j   D]^ } |  j  | } d |  j | j t |  t | j  f GH| d k rd | j GHn    |  q Wd  S(   Ns   %d -> %d [label=%s] //%si   (   R   R7   R	   t	   type_reprt   strR   R
   (   t   nodet   subnode_keyt   subnode(   t
   print_node(    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyRE      s    't   }N(   R   (   R   (    (   RE   s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyt   print_ac   s    (   R   R   R   R   R$   R   R?   RG   (    (    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyR      s   			"	=c         C   sh   t  sX d d l m } x? | j j   D]+ \ } } t |  t k r& | t  | <q& q& Wn  t  j |  |   S(   Ni   (   t   python_symbols(   t   _type_reprst   pygramRH   t   __dict__t   itemsR4   t   intt
   setdefault(   t   type_numRH   t   namet   val(    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyR@      s     (   R   t
   __author__R   R   t   collectionsR    R   R   t	   btm_utilsR   t   objectR   R   RI   R@   (    (    (    s)   /usr/lib/python2.7/lib2to3/btm_matcher.pyt   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "Utility functions used by the btm_matcher module"

from . import pytree
from .pgen2 import grammar, token
from .pygram import pattern_symbols, python_symbols

syms = pattern_symbols
pysyms = python_symbols
tokens = grammar.opmap
token_labels = token

TYPE_ANY = -1
TYPE_ALTERNATIVES = -2
TYPE_GROUP = -3

class MinNode(object):
    """This class serves as an intermediate representation of the
    pattern tree during the conversion to sets of leaf-to-root
    subpatterns"""

    def __init__(self, type=None, name=None):
        self.type = type
        self.name = name
        self.children = []
        self.leaf = False
        self.parent = None
        self.alternatives = []
        self.group = []

    def __repr__(self):
        return str(self.type) + ' ' + str(self.name)

    def leaf_to_root(self):
        """Internal method. Returns a characteristic path of the
        pattern tree. This method must be run for all leaves until the
        linear subpatterns are merged into a single"""
        node = self
        subp = []
        while node:
            if node.type == TYPE_ALTERNATIVES:
                node.alternatives.append(subp)
                if len(node.alternatives) == len(node.children):
                    #last alternative
                    subp = [tuple(node.alternatives)]
                    node.alternatives = []
                    node = node.parent
                    continue
                else:
                    node = node.parent
                    subp = None
                    break

            if node.type == TYPE_GROUP:
                node.group.append(subp)
                #probably should check the number of leaves
                if len(node.group) == len(node.children):
                    subp = get_characteristic_subpattern(node.group)
                    node.group = []
                    node = node.parent
                    continue
                else:
                    node = node.parent
                    subp = None
                    break

            if node.type == token_labels.NAME and node.name:
                #in case of type=name, use the name instead
                subp.append(node.name)
            else:
                subp.append(node.type)

            node = node.parent
        return subp

    def get_linear_subpattern(self):
        """Drives the leaf_to_root method. The reason that
        leaf_to_root must be run multiple times is because we need to
        reject 'group' matches; for example the alternative form
        (a | b c) creates a group [b c] that needs to be matched. Since
        matching multiple linear patterns overcomes the automaton's
        capabilities, leaf_to_root merges each group into a single
        choice based on 'characteristic'ity,

        i.e. (a|b c) -> (a|b) if b more characteristic than c

        Returns: The most 'characteristic'(as defined by
          get_characteristic_subpattern) path for the compiled pattern
          tree.
        """

        for l in self.leaves():
            subp = l.leaf_to_root()
            if subp:
                return subp

    def leaves(self):
        "Generator that returns the leaves of the tree"
        for child in self.children:
            for x in child.leaves():
                yield x
        if not self.children:
            yield self

def reduce_tree(node, parent=None):
    """
    Internal function. Reduces a compiled pattern tree to an
    intermediate representation suitable for feeding the
    automaton. This also trims off any optional pattern elements(like
    [a], a*).
    """

    new_node = None
    #switch on the node type
    if node.type == syms.Matcher:
        #skip
        node = node.children[0]

    if node.type == syms.Alternatives  :
        #2 cases
        if len(node.children) <= 2:
            #just a single 'Alternative', skip this node
            new_node = reduce_tree(node.children[0], parent)
        else:
            #real alternatives
            new_node = MinNode(type=TYPE_ALTERNATIVES)
            #skip odd children('|' tokens)
            for child in node.children:
                if node.children.index(child)%2:
                    continue
                reduced = reduce_tree(child, new_node)
                if reduced is not None:
                    new_node.children.append(reduced)
    elif node.type == syms.Alternative:
        if len(node.children) > 1:

            new_node = MinNode(type=TYPE_GROUP)
            for child in node.children:
                reduced = reduce_tree(child, new_node)
                if reduced:
                    new_node.children.append(reduced)
            if not new_node.children:
                # delete the group if all of the children were reduced to None
                new_node = None

        else:
            new_node = reduce_tree(node.children[0], parent)

    elif node.type == syms.Unit:
        if (isinstance(node.children[0], pytree.Leaf) and
            node.children[0].value == '('):
            #skip parentheses
            return reduce_tree(node.children[1], parent)
        if ((isinstance(node.children[0], pytree.Leaf) and
               node.children[0].value == '[')
               or
               (len(node.children)>1 and
               hasattr(node.children[1], "value") and
               node.children[1].value == '[')):
            #skip whole unit if its optional
            return None

        leaf = True
        details_node = None
        alternatives_node = None
        has_repeater = False
        repeater_node = None
        has_variable_name = False

        for child in node.children:
            if child.type == syms.Details:
                leaf = False
                details_node = child
            elif child.type == syms.Repeater:
                has_repeater = True
                repeater_node = child
            elif child.type == syms.Alternatives:
                alternatives_node = child
            if hasattr(child, 'value') and child.value == '=': # variable name
                has_variable_name = True

        #skip variable name
        if has_variable_name:
            #skip variable name, '='
            name_leaf = node.children[2]
            if hasattr(name_leaf, 'value') and name_leaf.value == '(':
                # skip parenthesis
                name_leaf = node.children[3]
        else:
            name_leaf = node.children[0]

        #set node type
        if name_leaf.type == token_labels.NAME:
            #(python) non-name or wildcard
            if name_leaf.value == 'any':
                new_node = MinNode(type=TYPE_ANY)
            else:
                if hasattr(token_labels, name_leaf.value):
                    new_node = MinNode(type=getattr(token_labels, name_leaf.value))
                else:
                    new_node = MinNode(type=getattr(pysyms, name_leaf.value))

        elif name_leaf.type == token_labels.STRING:
            #(python) name or character; remove the apostrophes from
            #the string value
            name = name_leaf.value.strip("'")
            if name in tokens:
                new_node = MinNode(type=tokens[name])
            else:
                new_node = MinNode(type=token_labels.NAME, name=name)
        elif name_leaf.type == syms.Alternatives:
            new_node = reduce_tree(alternatives_node, parent)

        #handle repeaters
        if has_repeater:
            if repeater_node.children[0].value == '*':
                #reduce to None
                new_node = None
            elif repeater_node.children[0].value == '+':
                #reduce to a single occurrence i.e. do nothing
                pass
            else:
                #TODO: handle {min, max} repeaters
                raise NotImplementedError
                pass

        #add children
        if details_node and new_node is not None:
            for child in details_node.children[1:-1]:
                #skip '<', '>' markers
                reduced = reduce_tree(child, new_node)
                if reduced is not None:
                    new_node.children.append(reduced)
    if new_node:
        new_node.parent = parent
    return new_node


def get_characteristic_subpattern(subpatterns):
    """Picks the most characteristic from a list of linear patterns
    Current order used is:
    names > common_names > common_chars
    """
    if not isinstance(subpatterns, list):
        return subpatterns
    if len(subpatterns)==1:
        return subpatterns[0]

    # first pick out the ones containing variable names
    subpatterns_with_names = []
    subpatterns_with_common_names = []
    common_names = ['in', 'for', 'if' , 'not', 'None']
    subpatterns_with_common_chars = []
    common_chars = "[]().,:"
    for subpattern in subpatterns:
        if any(rec_test(subpattern, lambda x: type(x) is str)):
            if any(rec_test(subpattern,
                            lambda x: isinstance(x, str) and x in common_chars)):
                subpatterns_with_common_chars.append(subpattern)
            elif any(rec_test(subpattern,
                              lambda x: isinstance(x, str) and x in common_names)):
                subpatterns_with_common_names.append(subpattern)

            else:
                subpatterns_with_names.append(subpattern)

    if subpatterns_with_names:
        subpatterns = subpatterns_with_names
    elif subpatterns_with_common_names:
        subpatterns = subpatterns_with_common_names
    elif subpatterns_with_common_chars:
        subpatterns = subpatterns_with_common_chars
    # of the remaining subpatterns pick out the longest one
    return max(subpatterns, key=len)

def rec_test(sequence, test_func):
    """Tests test_func on all items of sequence and items of included
    sub-iterables"""
    for x in sequence:
        if isinstance(x, (list, tuple)):
            for y in rec_test(x, test_func):
                yield y
        else:
            yield test_func(x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Export the Python grammar and symbols."""

# Python imports
import os

# Local imports
from .pgen2 import token
from .pgen2 import driver
from . import pytree

# The grammar file
_GRAMMAR_FILE = os.path.join(os.path.dirname(__file__), "Grammar.txt")
_PATTERN_GRAMMAR_FILE = os.path.join(os.path.dirname(__file__),
                                     "PatternGrammar.txt")


class Symbols(object):

    def __init__(self, grammar):
        """Initializer.

        Creates an attribute for each grammar symbol (nonterminal),
        whose value is the symbol's type (an int >= 256).
        """
        for name, symbol in grammar.symbol2number.iteritems():
            setattr(self, name, symbol)


python_grammar = driver.load_grammar(_GRAMMAR_FILE)

python_symbols = Symbols(python_grammar)

python_grammar_no_print_statement = python_grammar.copy()
del python_grammar_no_print_statement.keywords["print"]

pattern_grammar = driver.load_grammar(_PATTERN_GRAMMAR_FILE)
pattern_symbols = Symbols(pattern_grammar)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
[c           @   s   d  Z  d d l m Z d d l m Z m Z d d l m Z m Z e Z	 e Z
 e j Z e Z d Z d Z d Z d e f d	     YZ d d
  Z d   Z d   Z d S(   s0   Utility functions used by the btm_matcher modulei   (   t   pytree(   t   grammart   token(   t   pattern_symbolst   python_symbolsiiit   MinNodec           B   sA   e  Z d  Z d d d  Z d   Z d   Z d   Z d   Z RS(   s   This class serves as an intermediate representation of the
    pattern tree during the conversion to sets of leaf-to-root
    subpatternsc         C   sC   | |  _  | |  _ g  |  _ t |  _ d  |  _ g  |  _ g  |  _ d  S(   N(	   t   typet   namet   childrent   Falset   leaft   Nonet   parentt   alternativest   group(   t   selfR   R   (    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyt   __init__   s    						c         C   s   t  |  j  d t  |  j  S(   Nt    (   t   strR   R   (   R   (    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyt   __repr__   s    c         C   sU  |  } g  } xB| rP| j  t k r | j j |  t | j  t | j  k r| t | j  g } g  | _ | j } q q | j } d } Pn  | j  t	 k r| j
 j |  t | j
  t | j  k r t | j
  } g  | _
 | j } q q| j } d } Pn  | j  t j k r4| j r4| j | j  n | j | j   | j } q W| S(   s   Internal method. Returns a characteristic path of the
        pattern tree. This method must be run for all leaves until the
        linear subpatterns are merged into a singleN(   R   t   TYPE_ALTERNATIVESR   t   appendt   lenR   t   tupleR   R   t
   TYPE_GROUPR   t   get_characteristic_subpatternt   token_labelst   NAMER   (   R   t   nodet   subp(    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyt   leaf_to_root!   s8    							c         C   s1   x* |  j    D] } | j   } | r | Sq Wd S(   s  Drives the leaf_to_root method. The reason that
        leaf_to_root must be run multiple times is because we need to
        reject 'group' matches; for example the alternative form
        (a | b c) creates a group [b c] that needs to be matched. Since
        matching multiple linear patterns overcomes the automaton's
        capabilities, leaf_to_root merges each group into a single
        choice based on 'characteristic'ity,

        i.e. (a|b c) -> (a|b) if b more characteristic than c

        Returns: The most 'characteristic'(as defined by
          get_characteristic_subpattern) path for the compiled pattern
          tree.
        N(   t   leavesR   (   R   t   lR   (    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyt   get_linear_subpatternK   s    c         c   sE   x- |  j  D]" } x | j   D] } | Vq Wq
 W|  j  sA |  Vn  d S(   s-   Generator that returns the leaves of the treeN(   R   R   (   R   t   childt   x(    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyR   `   s
    	N(	   t   __name__t
   __module__t   __doc__R   R   R   R   R!   R   (    (    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyR      s   			*	c         C   s  d } |  j t j k r( |  j d }  n  |  j t j k r t |  j  d k rh t |  j d |  } qt d t	  } x|  j D]P } |  j j
 |  d r q n  t | |  } | d k	 r | j j |  q q Wn$|  j t j k rxt |  j  d k r_t d t  } x9 |  j D]. } t | |  } | r| j j |  qqW| j sud } quqt |  j d |  } n|  j t j k rt |  j d t j  r|  j d j d k rt |  j d |  St |  j d t j  r|  j d j d k s=t |  j  d k rAt |  j d d  rA|  j d j d k rAd St } d } d } t } d }	 t }
 x |  j D] } | j t j k rt } | } n< | j t j k rt } | }	 n | j t j k r| } n  t | d  ro| j d k rot }
 qoqoW|
 rA|  j d } t | d  rN| j d k rN|  j d	 } qNn |  j d } | j t j k r| j d
 k rt d t  } qTt t | j  rt d t t | j   } qTt d t t | j   } n | j t j k r0| j j d  } | t k rt d t |  } qTt d t j d |  } n$ | j t j k rTt | |  } n  | r|	 j d j d k ryd } q|	 j d j d k rqt   n  | r| d k	 rxI | j d d !D]4 } t | |  } | d k	 r| j j |  qqWqn  | r| | _! n  | S(   s   
    Internal function. Reduces a compiled pattern tree to an
    intermediate representation suitable for feeding the
    automaton. This also trims off any optional pattern elements(like
    [a], a*).
    i    i   R   i   t   (t   [t   valuet   =i   t   anyt   'R   t   *t   +iN("   R   R   t   symst   MatcherR   t   AlternativesR   t   reduce_treeR   R   t   indexR   t   AlternativeR   t   Unitt
   isinstanceR    t   LeafR)   t   hasattrt   TrueR	   t   Detailst   RepeaterR   R   t   TYPE_ANYt   getattrt   pysymst   STRINGt   stript   tokenst   NotImplementedErrorR   (   R   R   t   new_nodeR"   t   reducedR
   t   details_nodet   alternatives_nodet   has_repeatert   repeater_nodet   has_variable_namet	   name_leafR   (    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyR2   h   s    					c            s,  t  |  t  s |  St |   d k r- |  d Sg  } g  } d d d d d g  g  } d   x |  D] } t t | d	     ra t t |   f d
     r | j |  q t t |  f d     r | j |  q | j |  qa qa W| r | }  n | r| }  n | r| }  n  t |  d t S(   s   Picks the most characteristic from a list of linear patterns
    Current order used is:
    names > common_names > common_chars
    i   i    t   int   fort   ift   notR   s   []().,:c         S   s   t  |   t k S(   N(   R   R   (   R#   (    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyt   <lambda>   s    c            s   t  |  t  o |    k S(   N(   R6   R   (   R#   (   t   common_chars(    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyRO     s    c            s   t  |  t  o |    k S(   N(   R6   R   (   R#   (   t   common_names(    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyRO     s    t   key(   R6   t   listR   R+   t   rec_testR   t   max(   t   subpatternst   subpatterns_with_namest   subpatterns_with_common_namest   subpatterns_with_common_charst
   subpattern(    (   RP   RQ   s'   /usr/lib/python2.7/lib2to3/btm_utils.pyR      s2    					c         c   sW   xP |  D]H } t  | t t f  rD x* t | |  D] } | Vq2 Wq | |  Vq Wd S(   sP   Tests test_func on all items of sequence and items of included
    sub-iterablesN(   R6   RS   R   RT   (   t   sequencet	   test_funcR#   t   y(    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyRT     s
    N(   R&   t    R    t   pgen2R   R   t   pygramR   R   R/   R>   t   opmapRA   R   R<   R   R   t   objectR   R   R2   R   RT   (    (    (    s'   /usr/lib/python2.7/lib2to3/btm_utils.pyt   <module>   s   	X	%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
[c           @   sY  d  Z  d Z d Z d d d d d d d	 d
 d d d d d d d d d d d d d d d d g Z d d l Z d d l m Z m Z m Z m Z e j	 d k  r e
 n e Z d   Z e d   Z e e d!  Z d"   Z e d#  Z e d$  Z d% d& d'  Z d(   Z d)   Z d*   Z d+   Z d,   Z d-   Z d.   Z d/   Z e d0  Z d e f d1     YZ d2 e j  f d3     YZ  d e  f d4     YZ! d e  f d5     YZ" d e  e j# f d6     YZ# d e# f d7     YZ$ d e  f d8     YZ% d e  f d9     YZ& d	 e  f d:     YZ' e' Z( d e  f d;     YZ) d e  f d<     YZ* d e  e j+ f d=     YZ, e, Z+ d e  f d>     YZ- d e  f d?     YZ. d e  e j/ f d@     YZ/ d e  e j0 f dA     YZ0 d e  f dB     YZ1 d e  f dC     YZ2 d e  e j3 e j4 f dD     YZ5 d e% e f dE     YZ6 d e) f dF     YZ7 d S(G   s  Ttk wrapper.

This module provides classes to allow using Tk themed widget set.

Ttk is based on a revised and enhanced version of
TIP #48 (http://tip.tcl.tk/48) specified style engine.

Its basic idea is to separate, to the extent possible, the code
implementing a widget's behavior from the code implementing its
appearance. Widget class bindings are primarily responsible for
maintaining the widget state and invoking callbacks, all aspects
of the widgets appearance lies at Themes.
s   0.3.1s!   Guilherme Polo <ggpolo@gmail.com>t   Buttont   Checkbuttont   Comboboxt   Entryt   Framet   Labelt
   Labelframet
   LabelFramet
   Menubuttont   Notebookt   Panedwindowt   PanedWindowt   Progressbart   Radiobuttont   Scalet	   Scrollbart	   Separatort   Sizegript   Stylet   Treeviewt   LabeledScalet
   OptionMenut   tclobjs_to_pyt   setup_masteriN(   t   _flattent   _joint
   _stringifyt
   _splitdictg      !@c         C   sa   t  r] d d  l } | j j d  } | rA |  j j d |  n  |  j j d  t |  _ n  d  S(   Nit   TILE_LIBRARYs(   global auto_path; lappend auto_path {%s}s   package require tile(   t   _REQUIRE_TILEt   ost   environt   gett   tkt   evalt   Truet   _tile_loaded(   t   masterR   t   tilelib(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt
   _load_tile"   s    	c         C   s=   | r t  |   }  n$ t |  t t f  r9 t |   }  n  |  S(   s   Internal function.(   R   t
   isinstancet   listt   tupleR   (   t   valuet   script(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _format_optvalue1   s
    c         C   sy   g  } xf |  j    D]X \ } } | s2 | | k r | j d |  | d k	 rk | j t | |   qk q q Wt |  S(   s   Formats optdict to a tuple to pass it to tk.call.

    E.g. (script=False):
      {'foreground': 'blue', 'padding': [1, 2, 3, 4]} returns:
      ('-foreground', 'blue', '-padding', '1 2 3 4')s   -%sN(   t	   iteritemst   appendt   NoneR-   R   (   t   optdictR,   t   ignoret   optst   optR+   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _format_optdict;   s     c         C   s   g  } x |  D] } | d  } | d } | d t  |  d k rT | d pN d } n d j |  } | j |  | d  k	 r | j |  q q W| S(   Nii    i   t    t    (   t   lent   joinR/   R0   (   t   itemst   opt_valt   itemt   statet   val(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _mapdict_valuesK   s    

c         C   sS   g  } x@ |  j    D]2 \ } } | j d | t t |  |  f  q Wt |  S(   s   Formats mapdict to pass it to tk.call.

    E.g. (script=False):
      {'expand': [('active', 'selected', 'grey'), ('focus', [1, 2, 3, 4])]}

      returns:

      ('-expand', '{active selected} grey focus {1, 2, 3, 4}')s   -%s(   R.   t   extendR-   R?   R   (   t   mapdictR,   R3   R4   R+   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _format_mapdictd   s
    
c         O   s  d } d } |  d k r |  d k rW | d } t t | d   } d | | f } n9 | d  \ } }	 t t | d   }
 d | |	 |
 f } t | |  } nD |  d k r | d } t |  d k r t | d |  f } q n  | rd	 | } d
 j |  } n  | | f S(   sA   Formats args and kw according to the given element factory etype.t   imaget   vsapii    i   s   %s %si   s   %s %s %st   froms   {%s}R7   N(    (   RC   RD   (   R0   R   R?   R5   R8   R-   R9   (   t   etypeR,   t   argst   kwt   specR3   t   inamet	   imagespect
   class_namet   part_idt   statemap(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _format_elemcreateu   s&    


i    i   c   
      C   s  g  } x |  D] } | \ } } | p( i  } d j  t | t d	   } d d | | | rc d | n d f } d | k r | j | d  | | 7} t | d | |  \ }	 } | j |	  | | 8} | j d d |  q | j |  q Wd j  |  | f S(
   s$  Formats a layout list so we can pass the result to ttk::style
    layout and ttk::style settings. Note that the layout doesn't have to
    be a list necessarily.

    E.g.:
      [("Menubutton.background", None),
       ("Menubutton.button", {"children":
           [("Menubutton.focus", {"children":
               [("Menubutton.padding", {"children":
                [("Menubutton.label", {"side": "left", "expand": 1})]
               })]
           })]
       }),
       ("Menubutton.indicator", {"side": "right"})
      ]

      returns:

      Menubutton.background
      Menubutton.button -children {
        Menubutton.focus -children {
          Menubutton.padding -children {
            Menubutton.label -side left -expand 1
          }
        }
      }
      Menubutton.indicator -side rightR7   t   childrens   %s%s%ss    %sR6   s    -children {s   %s}s   
(   RP   (   R9   R5   R#   R/   t   _format_layoutlist(
   t   layoutt   indentt   indent_sizeR,   t   layout_elemt   elemR3   t   foptst   headt	   newscript(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyRQ      s     '

c         C   s  g  } x|  j    D]\ } } | j d  rd d j t | d t   } | j d | | f  n  | j d  r d j t | d t   } | j d | | f  n  d | k r | d s d } n t | d  \ } } | j d | | f  n  | j d	  r | d	 } | d
 } d } x4 | t |  k  rWt	 | | d  rW| d 7} q$W| d | !}	 | t |  k  r| | r| | n i  }
 t
 | t |	 |
  \ } } | j d | | | | f  q q Wd j |  S(   s   Returns an appropriate script, based on settings, according to
    theme_settings definition to be used by theme_settings and
    theme_create.t	   configureR7   s   ttk::style configure %s %s;t   maps   ttk::style map %s %s;RR   t   nulls   ttk::style layout %s {
%s
}s   element createi    i   R.   s%   ttk::style element create %s %s %s %ss   
(   R.   R    R9   R5   R#   R/   RB   RQ   R8   t   hasattrRO   (   t   settingsR,   t   nameR3   t   st   _t   eoptsRF   t   argct   elemargst   elemkwRI   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _script_from_settings   s2    
	

),	c         C   s   g  } xp |  D]h } t  | d d  } | d k rA | j |  q t |  } | d k rh | j   } n  | j |  q Wt |  } g  t | |  D] } t |  ^ q S(   st   Construct a list from the given statespec tuple according to the
    accepted statespec accepted by _format_mapdict.t   typenamet	   StateSpecN(   t   getattrR0   R/   t   strt   splitt   itert   zipR   (   t   stuplet   nvalR>   Rg   t   itRI   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _list_from_statespec   s    c         C   s   |  j  |  } g  } d } x | t |  k  r | | } i  } | j | | f  | d 7} x| | t |  k  r | | | d !\ } } | j d  s Pn  | d } | d 7} | d k r t |  |  } n  | | | <q` Wq W| S(   sp   Construct a list from the tuple returned by ttk::layout, this is
    somewhat the reverse of _format_layoutlist.i    i   i   t   -RP   (   t	   splitlistR8   R/   t
   startswitht   _list_from_layouttuple(   R!   t   ltuplet   rest   indxR_   R3   R4   R>   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyRu     s$    



c         G   sF   t  |  } |  j | |   } t |  d r3 | St |  | d t S(   sh  Format options then call Tk command with args and options and return
    the appropriate result.

    If no option is specified, a dict is returned. If an option is
    specified with the None value, the value for that option is returned.
    Otherwise, the function just sets the passed options and the caller
    shouldn't be expecting a return value anyway.i   t   conv(   R5   t   callR8   R   t   _tclobj_to_py(   R!   t   optionsRG   Rw   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _val_or_dict"  s
    c         C   s:   t  |   }  y t |   }  Wn t t f k
 r5 n X|  S(   sA   Converts a value to, hopefully, a more appropriate Python object.(   t   unicodet   intt
   ValueErrort	   TypeError(   R+   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   _convert_stringval2  s    c         C   s=   t  |  t  r9 d |  k r* t |   }  q9 t |   }  n  |  S(   Nt   .(   R(   Rj   t   floatR   (   t   x(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt
   _to_number<  s
    c         C   s   |  rb t  |  d  rb t |  t  rb t |  d d d  d k rP t |   }  q t t |   }  n t  |  d  r t |   }  n  |  S(   s8   Return value converted from Tcl object to Python object.t   __len__i    Rg   Rh   N(   R]   R(   t
   basestringRi   R0   Rq   R[   R   (   R>   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR{   D  s    %c         C   s1   x* |  j    D] \ } } t |  |  | <q W|  S(   sO   Returns adict with its values converted from Tcl objects to Python
    objects.(   R:   R{   (   t   adictR4   R>   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   Q  s    c         C   s@   |  d k r< t j r- t j p' t j   }  q< t d   n  |  S(   s  If master is not None, itself is returned. If master is None,
    the default master is returned if there is one, otherwise a new
    master is created and returned.

    If it is not allowed to use the default root and master is None,
    RuntimeError is raised.sI   No master specified and Tkinter is configured to not support default rootN(   R0   t   Tkintert   _support_default_roott   _default_roott   Tkt   RuntimeError(   R%   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   Y  s    	c           B   s   e  Z d  Z d Z d d  Z d d  Z d d  Z d d d  Z d d  Z	 d   Z
 d   Z d	   Z d d d
  Z d   Z d   Z d d  Z RS(   s   Manipulate style database.s
   ttk::stylec         C   sG   t  |  } t | d t  s+ t |  n  | |  _ |  j j |  _ d  S(   NR$   (   R   Ri   t   FalseR'   R%   R!   (   t   selfR%   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   __init__o  s
    	c         K   s5   | d k	 r d | | <n  t |  j | |  j d |  S(   s   Query or sets the default value of the specified option(s) in
        style.

        Each key in kw is an option and each value is either a string or
        a sequence identifying the value for that option.RZ   N(   R0   R}   R!   t   _name(   R   t   stylet	   query_optRH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyRZ   z  s    c         K   sr   | d k	 r> t |  j j |  j j |  j d | d |    St |  j |  j j |  j d | t |   d t S(   sS  Query or sets dynamic values of the specified option(s) in
        style.

        Each key in kw is an option and each value should be a list or a
        tuple (usually) containing statespecs grouped in tuples, or list,
        or something else of your preference. A statespec is compound of
        one or more states and then a value.R[   s   -%sRy   N(	   R0   Rq   R!   Rs   Rz   R   R   RB   R{   (   R   R   R   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR[     s    &$c         C   sA   | r d j  |  n d } |  j j |  j d | d | | |  S(   s  Returns the value specified for option in style.

        If state is specified it is expected to be a sequence of one
        or more states. If the default argument is set, it is used as
        a fallback value in case no specification for option is found.R7   R6   t   lookups   -%s(   R9   R!   Rz   R   (   R   R   t   optionR=   t   default(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s\   d } | r t |  d } n | d k	 r4 d } n  t |  j |  j j |  j d | |   S(   s  Define the widget layout for given style. If layoutspec is
        omitted, return the layout specification for given style.

        layoutspec is expected to be a list or an object different than
        None that evaluates to False if you want to "turn off" that style.
        If it is a list (or tuple, or something else), each item should be
        a tuple where the first item is the layout name and the second item
        should have the format described below:

        LAYOUTS

            A layout can contain the value None, if takes no options, or
            a dict of options specifying how to arrange the element.
            The layout mechanism uses a simplified version of the pack
            geometry manager: given an initial cavity, each element is
            allocated a parcel. Valid options/values are:

                side: whichside
                    Specifies which side of the cavity to place the
                    element; one of top, right, bottom or left. If
                    omitted, the element occupies the entire cavity.

                sticky: nswe
                    Specifies where the element is placed inside its
                    allocated parcel.

                children: [sublayout... ]
                    Specifies a list of elements to place inside the
                    element. Each element is a tuple (or other sequence)
                    where the first item is the layout name, and the other
                    is a LAYOUT.i    R\   RR   N(   R0   RQ   Ru   R!   Rz   R   (   R   R   t
   layoutspect   lspec(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyRR     s     		c         O   sD   t  | t | |  \ } } |  j j |  j d d | | | |  d S(   s9   Create a new element in the current theme of given etype.t   elementt   createN(   RO   R   R!   Rz   R   (   R   t   elementnameRF   RG   RH   RI   R3   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   element_create  s    c         C   s%   |  j  j |  j  j |  j d d   S(   s:   Returns the list of elements defined in the current theme.R   t   names(   R!   Rs   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   element_names  s    c         C   s(   |  j  j |  j  j |  j d d |   S(   s)   Return the list of elementname's options.R   R|   (   R!   Rs   Rz   R   (   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   element_options  s    c      	   C   so   | r t  |  n d } | rI |  j j |  j d d | d | d |  n" |  j j |  j d d | d |  d S(   s.  Creates a new theme.

        It is an error if themename already exists. If parent is
        specified, the new theme will inherit styles, elements and
        layouts from the specified parent theme. If settings are present,
        they are expected to have the same syntax used for theme_settings.R6   t   themeR   s   -parents	   -settingsN(   Rf   R!   Rz   R   (   R   t	   themenamet   parentR^   R,   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   theme_create  s    c         C   s/   t  |  } |  j j |  j d d | |  d S(   s  Temporarily sets the current theme to themename, apply specified
        settings and then restore the previous theme.

        Each key in settings is a style and each value may contain the
        keys 'configure', 'map', 'layout' and 'element create' and they
        are expected to have the same format as specified by the methods
        configure, map, layout and element_create respectively.R   R^   N(   Rf   R!   Rz   R   (   R   R   R^   R,   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   theme_settings  s    c         C   s%   |  j  j |  j  j |  j d d   S(   s#   Returns a list of all known themes.R   R   (   R!   Rs   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   theme_names  s    c         C   s3   | d k r |  j j d  S|  j j d |  d S(   s   If themename is None, returns the theme in use, otherwise, set
        the current theme to themename, refreshes all widgets and emits
        a <<ThemeChanged>> event.s   return $ttk::currentThemes   ttk::setThemeN(   R0   R!   R"   Rz   (   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt	   theme_use  s    N(   t   __name__t
   __module__t   __doc__R   R0   R   RZ   R[   R   RR   R   R   R   R   R   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   j  s   +					t   Widgetc           B   s;   e  Z d  Z d d  Z d   Z d d  Z d d  Z RS(   s!   Base class for Tk themed widgets.c         C   sK   t  |  } t | d t  s+ t |  n  t j j |  | | d | d S(   s  Constructs a Ttk Widget with the parent master.

        STANDARD OPTIONS

            class, cursor, takefocus, style

        SCROLLABLE WIDGET OPTIONS

            xscrollcommand, yscrollcommand

        LABEL WIDGET OPTIONS

            text, textvariable, underline, image, compound, width

        WIDGET STATES

            active, disabled, focus, pressed, selected, background,
            readonly, alternate, invalid
        R$   RH   N(   R   Ri   R   R'   R   R   R   (   R   R%   t
   widgetnameRH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j |  j d | |  S(   s   Returns the name of the element at position x, y, or the empty
        string if the point does not lie within any element.

        x and y are pixel coordinates relative to the widget.t   identify(   R!   Rz   t   _w(   R   R   t   y(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   .  s    c         O   sM   |  j  j |  j  j |  j d d j |    } | rI | rI | | |   S| S(   s1  Test the widget's state.

        If callback is not specified, returns True if the widget state
        matches statespec and False otherwise. If callback is specified,
        then it will be invoked with *args, **kw if the widget state
        matches statespec. statespec is expected to be a sequence.t   instateR7   (   R!   t
   getbooleanRz   R   R9   (   R   t	   statespect   callbackRG   RH   t   ret(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   6  s
    	'c         C   sI   | d k	 r d j |  } n  |  j j t |  j j |  j d |    S(   s  Modify or inquire widget state.

        Widget state is returned if statespec is None, otherwise it is
        set according to the statespec flags and then a new state spec
        is returned indicating which flags were changed. statespec is
        expected to be a sequence.R7   R=   N(   R0   R9   R!   Rs   Rj   Rz   R   (   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR=   E  s    N(   R   R   R   R0   R   R   R   R=   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s
   	c           B   s#   e  Z d  Z d d  Z d   Z RS(   sc   Ttk Button widget, displays a textual label and/or image, and
    evaluates a command when pressed.c         K   s   t  j |  | d |  d S(   s  Construct a Ttk Button widget with the parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, default, width
        s   ttk::buttonN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   V  s    c         C   s   |  j  j |  j d  S(   s/   Invokes the command associated with the button.t   invoke(   R!   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   e  s    N(   R   R   R   R0   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR    R  s   c           B   s#   e  Z d  Z d d  Z d   Z RS(   s;   Ttk Checkbutton widget which is either in on- or off-state.c         K   s   t  j |  | d |  d S(   s'  Construct a Ttk Checkbutton widget with the parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, offvalue, onvalue, variable
        s   ttk::checkbuttonN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   m  s    c         C   s   |  j  j |  j d  S(   sW  Toggles between the selected and deselected states and
        invokes the associated command. If the widget is currently
        selected, sets the option variable to the offvalue option
        and deselects the widget; otherwise, sets the option variable
        to the option onvalue.

        Returns the result of the associated command.R   (   R!   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   |  s    N(   R   R   R   R0   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   j  s   c           B   s8   e  Z d  Z d d d  Z d   Z d   Z d   Z RS(   se   Ttk Entry widget displays a one-line text string and allows that
    string to be edited by the user.c         K   s    t  j |  | | p d |  d S(   s  Constructs a Ttk Entry widget with the parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus, xscrollcommand

        WIDGET-SPECIFIC OPTIONS

            exportselection, invalidcommand, justify, show, state,
            textvariable, validate, validatecommand, width

        VALIDATION MODES

            none, key, focus, focusin, focusout, all
        s
   ttk::entryN(   R   R   (   R   R%   t   widgetRH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s"   |  j  |  j j |  j d |   S(   sq   Return a tuple of (x, y, width, height) which describes the
        bounding box of the character given by index.t   bbox(   t   _getintsR!   Rz   R   (   R   t   index(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j |  j d | |  S(   sx   Returns the name of the element at position x, y, or the
        empty string if the coordinates are outside the window.R   (   R!   Rz   R   (   R   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s"   |  j  j |  j  j |  j d   S(   s   Force revalidation, independent of the conditions specified
        by the validate option. Returns False if validation fails, True
        if it succeeds. Sets or clears the invalid state accordingly.t   validate(   R!   R   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   R   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s
   		c           B   s/   e  Z d  Z d d  Z d d  Z d   Z RS(   sM   Ttk Combobox widget combines a text field with a pop-down list of
    values.c         K   s   t  j |  | d |  d S(   s  Construct a Ttk Combobox widget with the parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            exportselection, justify, height, postcommand, state,
            textvariable, values, width
        s   ttk::comboboxN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   sG   | d k r. |  j j |  j j |  j d   S|  j j |  j d |  S(   s  If newindex is supplied, sets the combobox value to the
        element at position newindex in the list of values. Otherwise,
        returns the index of the current value in the list of values
        or -1 if the current value does not appear in the list.t   currentN(   R0   R!   t   getintRz   R   (   R   t   newindex(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    "c         C   s   |  j  j |  j d |  d S(   s(   Sets the value of the combobox to value.t   setN(   R!   Rz   R   (   R   R+   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s   
c           B   s   e  Z d  Z d d  Z RS(   sJ   Ttk Frame widget is a container, used to group other widgets
    together.c         K   s   t  j |  | d |  d S(   s   Construct a Ttk Frame with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            borderwidth, relief, padding, width, height
        s
   ttk::frameN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s   c           B   s   e  Z d  Z d d  Z RS(   s7   Ttk Label widget displays a textual label and/or image.c         K   s   t  j |  | d |  d S(   sG  Construct a Ttk Label with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, style, takefocus, text,
            textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            anchor, background, font, foreground, justify, padding,
            relief, text, wraplength
        s
   ttk::labelN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s   c           B   s   e  Z d  Z d d  Z RS(   s   Ttk Labelframe widget is a container used to group other widgets
    together. It has an optional label, which may be a plain text string
    or another widget.c         K   s   t  j |  | d |  d S(   s   Construct a Ttk Labelframe with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS
            labelanchor, text, underline, padding, labelwidget, width,
            height
        s   ttk::labelframeN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s   c           B   s   e  Z d  Z d d  Z RS(   sb   Ttk Menubutton widget displays a textual label and/or image, and
    displays a menu when pressed.c         K   s   t  j |  | d |  d S(   s  Construct a Ttk Menubutton with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            direction, menu
        s   ttk::menubuttonN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s   c           B   sz   e  Z d  Z d d  Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d d  Z d d	  Z d
   Z d   Z RS(   s   Ttk Notebook widget manages a collection of windows and displays
    a single one at a time. Each child window is associated with a tab,
    which the user may select to change the currently-displayed window.c         K   s   t  j |  | d |  d S(   s\  Construct a Ttk Notebook with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            height, padding, width

        TAB OPTIONS

            state, sticky, padding, text, image, compound, underline

        TAB IDENTIFIERS (tab_id)

            The tab_id argument found in several methods may take any of
            the following forms:

                * An integer between zero and the number of tabs
                * The name of a child window
                * A positional specification of the form "@x,y", which
                  defines the tab
                * The string "current", which identifies the
                  currently-selected tab
                * The string "end", which returns the number of tabs (only
                  valid for method index)
        s   ttk::notebookN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   %  s    c         K   s&   |  j  j |  j d | t |   d S(   s   Adds a new tab to the notebook.

        If window is currently managed by the notebook but hidden, it is
        restored to its previous position.t   addN(   R!   Rz   R   R5   (   R   t   childRH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   E  s    c         C   s   |  j  j |  j d |  d S(   sX   Removes the tab specified by tab_id, unmaps and unmanages the
        associated window.t   forgetN(   R!   Rz   R   (   R   t   tab_id(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   M  s    c         C   s   |  j  j |  j d |  d S(   s   Hides the tab specified by tab_id.

        The tab will not be displayed, but the associated window remains
        managed by the notebook and its configuration remembered. Hidden
        tabs may be restored with the add command.t   hideN(   R!   Rz   R   (   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   S  s    c         C   s   |  j  j |  j d | |  S(   sZ   Returns the name of the tab element at position x, y, or the
        empty string if none.R   (   R!   Rz   R   (   R   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   \  s    c         C   s%   |  j  j |  j  j |  j d |   S(   s|   Returns the numeric index of the tab specified by tab_id, or
        the total number of tabs if tab_id is the string "end".R   (   R!   R   Rz   R   (   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   b  s    c         K   s)   |  j  j |  j d | | t |   d S(   s   Inserts a pane at the specified position.

        pos is either the string end, an integer index, or the name of
        a managed child. If child is already managed by the notebook,
        moves it to the specified position.t   insertN(   R!   Rz   R   R5   (   R   t   posR   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   h  s    c         C   s   |  j  j |  j d |  S(   s   Selects the specified tab.

        The associated child window will be displayed, and the
        previously-selected window (if different) is unmapped. If tab_id
        is omitted, returns the widget name of the currently selected
        pane.t   select(   R!   Rz   R   (   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   q  s    c         K   s5   | d k	 r d | | <n  t |  j | |  j d |  S(   s   Query or modify the options of the specific tab_id.

        If kw is not given, returns a dict of the tab option values. If option
        is specified, returns the value of that option. Otherwise, sets the
        options to the corresponding values.t   tabN(   R0   R}   R!   R   (   R   R   R   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   {  s    c         C   s(   |  j  j |  j  j |  j d  p$ d  S(   s2   Returns a list of windows managed by the notebook.t   tabs(    (   R!   Rs   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j d |  j  d S(   s  Enable keyboard traversal for a toplevel window containing
        this notebook.

        This will extend the bindings for the toplevel window containing
        this notebook as follows:

            Control-Tab: selects the tab following the currently selected
                         one

            Shift-Control-Tab: selects the tab preceding the currently
                               selected one

            Alt-K: where K is the mnemonic (underlined) character of any
                   tab, will select that tab.

        Multiple notebooks in a single toplevel may be enabled for
        traversal, including nested notebooks. However, notebook traversal
        only works properly if all panes are direct children of the
        notebook.s   ttk::notebook::enableTraversalN(   R!   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   enable_traversal  s    N(   R   R   R   R0   R   R   R   R   R   R   R   R   R   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR	      s    								
	c           B   sG   e  Z d  Z d d  Z e j j Z d   Z d d  Z	 d d  Z
 RS(   sf   Ttk Panedwindow widget displays a number of subwindows, stacked
    either vertically or horizontally.c         K   s   t  j |  | d |  d S(   s   Construct a Ttk Panedwindow with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient, width, height

        PANE OPTIONS

            weight
        s   ttk::panedwindowN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         K   s)   |  j  j |  j d | | t |   d S(   s   Inserts a pane at the specified positions.

        pos is either the string end, and integer index, or the name
        of a child. If child is already managed by the paned window,
        moves it to the specified position.R   N(   R!   Rz   R   R5   (   R   R   R   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         K   s5   | d k	 r d | | <n  t |  j | |  j d |  S(   sQ  Query or modify the options of the specified pane.

        pane is either an integer index or the name of a managed subwindow.
        If kw is not given, returns a dict of the pane option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values.t   paneN(   R0   R}   R!   R   (   R   R   R   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s(   |  j  j |  j  j |  j d | |   S(   sL  If newpos is specified, sets the position of sash number index.

        May adjust the positions of adjacent sashes to ensure that
        positions are monotonically increasing. Sash positions are further
        constrained to be between 0 and the total size of the widget.

        Returns the new position of sash number index.t   sashpos(   R!   R   Rz   R   (   R   R   t   newpos(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   R   R   R   R   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR
     s   		c           B   s;   e  Z d  Z d d  Z d d  Z d d  Z d   Z RS(   s6  Ttk Progressbar widget shows the status of a long-running
    operation. They can operate in two modes: determinate mode shows the
    amount completed relative to the total amount of work to be done, and
    indeterminate mode provides an animated display to let the user know
    that something is happening.c         K   s   t  j |  | d |  d S(   s   Construct a Ttk Progressbar with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient, length, mode, maximum, value, variable, phase
        s   ttk::progressbarN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j |  j d |  d S(   s   Begin autoincrement mode: schedules a recurring timer event
        that calls method step every interval milliseconds.

        interval defaults to 50 milliseconds (20 steps/second) if omitted.t   startN(   R!   Rz   R   (   R   t   interval(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j |  j d |  d S(   sR   Increments the value option by amount.

        amount defaults to 1.0 if omitted.t   stepN(   R!   Rz   R   (   R   t   amount(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j |  j d  d S(   sV   Stop autoincrement mode: cancels any recurring timer event
        initiated by start.t   stopN(   R!   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   R   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s
   c           B   s#   e  Z d  Z d d  Z d   Z RS(   se   Ttk Radiobutton widgets are used in groups to show or change a
    set of mutually-exclusive options.c         K   s   t  j |  | d |  d S(   s  Construct a Ttk Radiobutton with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, value, variable
        s   ttk::radiobuttonN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j |  j d  S(   s   Sets the option variable to the option value, selects the
        widget, and invokes the associated command.

        Returns the result of the command, or an empty string if
        no command is specified.R   (   R!   Rz   R   (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    N(   R   R   R   R0   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   
  s   c           B   s5   e  Z d  Z d d  Z d d  Z d d d  Z RS(   s   Ttk Scale widget is typically used to control the numeric value of
    a linked variable that varies uniformly over some range.c         K   s   t  j |  | d |  d S(   s   Construct a Ttk Scale with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            command, from, length, orient, to, value, variable
        s
   ttk::scaleN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   *  s    c         K   sa   | r | j  |  n  t j |  |  t d | k d | k d | k g  r] |  j d  n  d S(   s   Modify or query scale options.

        Setting a value for any of the "from", "from_" or "to" options
        generates a <<RangeChanged>> event.RE   t   from_t   tos   <<RangeChanged>>N(   t   updateR   RZ   t   anyt   event_generate(   R   t   cnfRH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyRZ   8  s
    'c         C   s   |  j  j |  j d | |  S(   s   Get the current value of the value option, or the value
        corresponding to the coordinates x, y if they are specified.

        x and y are pixel coordinates relative to the scale widget
        origin.R    (   R!   Rz   R   (   R   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR    D  s    N(   R   R   R   R0   R   RZ   R    (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   &  s   c           B   s   e  Z d  Z d d  Z RS(   s;   Ttk Scrollbar controls the viewport of a scrollable widget.c         K   s   t  j |  | d |  d S(   s   Construct a Ttk Scrollbar with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            command, orient
        s   ttk::scrollbarN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   P  s    N(   R   R   R   R0   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   M  s   c           B   s   e  Z d  Z d d  Z RS(   sI   Ttk Separator widget displays a horizontal or vertical separator
    bar.c         K   s   t  j |  | d |  d S(   s   Construct a Ttk Separator with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient
        s   ttk::separatorN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   b  s    N(   R   R   R   R0   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   ^  s   c           B   s   e  Z d  Z d d  Z RS(   sl   Ttk Sizegrip allows the user to resize the containing toplevel
    window by pressing and dragging the grip.c         K   s   t  j |  | d |  d S(   s   Construct a Ttk Sizegrip with parent master.

        STANDARD OPTIONS

            class, cursor, state, style, takefocus
        s   ttk::sizegripN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   t  s    N(   R   R   R   R0   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   p  s   c           B   sd  e  Z d  Z d! d  Z d! d  Z d! d  Z d   Z d! d  Z d   Z	 d   Z
 d   Z d! d	  Z d! d
  Z d   Z d   Z d   Z d   Z d   Z d   Z d! d  Z d! d  Z d   Z e Z d   Z d   Z d   Z d   Z d! d! d  Z d   Z d   Z d   Z d   Z  d! d! d  Z! d! d! d  Z" d! d  Z# d! d   Z$ RS("   s   Ttk Treeview widget displays a hierarchical collection of items.

    Each item has a textual label, an optional image, and an optional list
    of data values. The data values are displayed in successive columns
    after the tree label.c         K   s   t  j |  | d |  d S(   s  Construct a Ttk Treeview with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus, xscrollcommand,
            yscrollcommand

        WIDGET-SPECIFIC OPTIONS

            columns, displaycolumns, height, padding, selectmode, show

        ITEM OPTIONS

            text, image, values, open, tags

        TAG OPTIONS

            foreground, background, font, image
        s   ttk::treeviewN(   R   R   (   R   R%   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s+   |  j  |  j j |  j d | |   p* d S(   sT  Returns the bounding box (relative to the treeview widget's
        window) of the specified item in the form x y width height.

        If column is specified, returns the bounding box of that cell.
        If the item is not visible (i.e., if it is a descendant of a
        closed item or is scrolled offscreen), returns an empty string.R   R6   (   R   R!   Rz   R   (   R   R<   t   column(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s1   |  j  j |  j  j |  j d | p$ d  p- d  S(   sh   Returns a tuple of children belonging to item.

        If item is not specified, returns root children.RP   R6   (    (   R!   Rs   Rz   R   (   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   get_children  s    	c         G   s    |  j  j |  j d | |  d S(   s   Replaces item's child with newchildren.

        Children present in item that are not present in newchildren
        are detached from tree. No items in newchildren may be an
        ancestor of item.RP   N(   R!   Rz   R   (   R   R<   t   newchildren(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   set_children  s    c         K   s5   | d k	 r d | | <n  t |  j | |  j d |  S(   s
  Query or modify the options for the specified column.

        If kw is not given, returns a dict of the column option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values.R   N(   R0   R}   R!   R   (   R   R   R   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         G   s   |  j  j |  j d |  d S(   s_   Delete all specified items and all their descendants. The root
        item may not be deleted.t   deleteN(   R!   Rz   R   (   R   R:   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         G   s   |  j  j |  j d |  d S(   s   Unlinks all of the specified items from the tree.

        The items and all of their descendants are still present, and may
        be reinserted at another point in the tree, but will not be
        displayed. The root item may not be detached.t   detachN(   R!   Rz   R   (   R   R:   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s%   |  j  j |  j  j |  j d |   S(   sS   Returns True if the specified item is present in the tree,
        False otherwise.t   exists(   R!   R   Rz   R   (   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j |  j d |  S(   s}   If item is specified, sets the focus item to item. Otherwise,
        returns the current focus item, or '' if there is none.t   focus(   R!   Rz   R   (   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         K   sy   | j  d  } | rD t | t  rD |  j j | |  j  | d <n  | d k	 r] d | | <n  t |  j | |  j	 d |  S(   s_  Query or modify the heading options for the specified column.

        If kw is not given, returns a dict of the heading option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values.

        Valid options/values are:
            text: text
                The text to display in the column heading
            image: image_name
                Specifies an image to display to the right of the column
                heading
            anchor: anchor
                Specifies how the heading text should be aligned. One of
                the standard Tk anchor values
            command: callback
                A callback to be invoked when the heading label is
                pressed.

        To configure the tree column heading, call this with column = "#0" t   commandt   headingN(
   R    R(   R   R%   t   registert   _substituteR0   R}   R!   R   (   R   R   R   RH   t   cmd(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  j |  j d | | |  S(   s   Returns a description of the specified component under the
        point given by x and y, or the empty string if no such component
        is present at that position.R   (   R!   Rz   R   (   R   t	   componentR   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s    c         C   s   |  j  d d |  S(   s.   Returns the item ID of the item at position y.t   rowi    (   R   (   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   identify_row  s    c         C   s   |  j  d | d  S(   sa   Returns the data column identifier of the cell at position x.

        The tree column has ID #0.R   i    (   R   (   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   identify_column	  s    c         C   s   |  j  d | |  S(   s   Returns one of:

        heading: Tree heading area.
        separator: Space between two columns headings;
        tree: The tree area.
        cell: A data cell.

        * Availability: Tk 8.6t   region(   R   (   R   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   identify_region  s    	c         C   s   |  j  d | |  S(   sE   Returns the element at position x, y.

        * Availability: Tk 8.6R   (   R   (   R   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   identify_element  s    c         C   s%   |  j  j |  j  j |  j d |   S(   sO   Returns the integer index of item within its parent's list
        of children.R   (   R!   R   Rz   R   (   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   #  s    c         K   sa   t  |  } | r< |  j j |  j d | | d | |  } n! |  j j |  j d | | |  } | S(   s  Creates a new item and return the item identifier of the newly
        created item.

        parent is the item ID of the parent item, or the empty string
        to create a new top-level item. index is an integer, or the value
        end, specifying where in the list of parent's children to insert
        the new item. If index is less than or equal to zero, the new node
        is inserted at the beginning, if index is greater than or equal to
        the current number of children, it is inserted at the end. If iid
        is specified, it is used as the item identifier, iid must not
        already exist in the tree. Otherwise, a new unique identifier
        is generated.R   s   -id(   R5   R!   Rz   R   (   R   R   R   t   iidRH   R3   Rw   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   )  s    !c         K   s5   | d k	 r d | | <n  t |  j | |  j d |  S(   s-  Query or modify the options for the specified item.

        If no options are given, a dict with options/values for the item
        is returned. If option is specified then the value for that option
        is returned. Otherwise, sets the options to the corresponding
        values as given by kw.R<   N(   R0   R}   R!   R   (   R   R<   R   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR<   @  s    c         C   s#   |  j  j |  j d | | |  d S(   sR  Moves item to position index in parent's list of children.

        It is illegal to move an item under one of its descendants. If
        index is less than or equal to zero, item is moved to the
        beginning, if greater than or equal to the number of children,
        it is moved to the end. If item was detached it is reattached.t   moveN(   R!   Rz   R   (   R   R<   R   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   L  s    c         C   s   |  j  j |  j d |  S(   se   Returns the identifier of item's next sibling, or '' if item
        is the last child of its parent.t   next(   R!   Rz   R   (   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   X  s    c         C   s   |  j  j |  j d |  S(   sa   Returns the ID of the parent of item, or '' if item is at the
        top level of the hierarchy.R   (   R!   Rz   R   (   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   ^  s    c         C   s   |  j  j |  j d |  S(   sj   Returns the identifier of item's previous sibling, or '' if
        item is the first child of its parent.t   prev(   R!   Rz   R   (   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   d  s    c         C   s   |  j  j |  j d |  d S(   s   Ensure that item is visible.

        Sets all of item's ancestors open option to True, and scrolls
        the widget if necessary so that item is within the visible
        portion of the tree.t   seeN(   R!   Rz   R   (   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   j  s    c         C   sC   t  | t  r | f } n  |  j j |  j j |  j d | |   S(   s2   If selop is not specified, returns selected items.t	   selection(   R(   R   R!   Rs   Rz   R   (   R   t   selopR:   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   s  s    c         C   s   |  j  d |  d S(   s    items becomes the new selection.R   N(   R   (   R   R:   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   selection_setz  s    c         C   s   |  j  d |  d S(   s   Add items to the selection.R   N(   R   (   R   R:   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   selection_add  s    c         C   s   |  j  d |  d S(   s    Remove items from the selection.t   removeN(   R   (   R   R:   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   selection_remove  s    c         C   s   |  j  d |  d S(   s1   Toggle the selection state of each item in items.t   toggleN(   R   (   R   R:   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   selection_toggle  s    c         C   s]   |  j  j |  j d | | |  } | d k rU | d k rU t |  j  | d t d t S| Sd S(   s;  Query or set the value of given item.

        With one argument, return a dictionary of column/value pairs
        for the specified item. With two arguments, return the current
        value of the specified column. With three arguments, set the
        value of given column in given item to the specified value.R   t	   cut_minusRy   N(   R!   Rz   R   R0   R   R   R{   (   R   R<   R   R+   Rw   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s
    !c         C   s,   |  j  |  j d d | f | | d d d S(   s   Bind a callback for the given event sequence to the tag tagname.
        When an event is delivered to an item, the callbacks for each
        of the item's tags option are called.t   tagt   bindR   i    N(   t   _bindR   (   R   t   tagnamet   sequenceR   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   tag_bind  s    c         K   s8   | d k	 r d | | <n  t |  j | |  j d d |  S(   sB  Query or modify the options for the specified tagname.

        If kw is not given, returns a dict of the option settings for tagname.
        If option is specified, returns the value for that option for the
        specified tagname. Otherwise, sets the options to the corresponding
        values for the given tagname.R   RZ   N(   R0   R}   R!   R   (   R   R   R   RH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   tag_configure  s    c         C   sc   | d k r4 |  j j |  j j |  j d d |   S|  j j |  j j |  j d d | |   Sd S(   s   If item is specified, returns 1 or 0 depending on whether the
        specified item has the given tagname. Otherwise, returns a list of
        all items which have the specified tag.

        * Availability: Tk 8.6R   t   hasN(   R0   R!   Rs   Rz   R   R   (   R   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   tag_has  s
    		N(%   R   R   R   R0   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R<   R   t   reattachR   R   R   R   R   R   R   R   R   R   R   R   R  (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   ~  sD   
						 																	c           B   sV   e  Z d  Z d d d d d  Z d   Z d   Z d   Z d   Z e	 e e  Z
 RS(	   s   A Ttk Scale widget with a Ttk Label widget indicating its
    current value.

    The Ttk Scale can be accessed through instance.scale, and Ttk Label
    can be accessed through instance.labeli    i
   c   	      K   sp  | j  d d  d k |  _ t j |  | |  | p@ t j |  |  _ |  j j |  | |  _ t	 |   |  _
 t |  d |  j d | d | |  _ |  j j d |  j  |  j r d n d } | d k r d n d } |  j j d | d	 d
  t	 |   j d |  } |  j
 j d | d k r$d n d  |  j j d |  j  |  _ |  j d |  j  |  j d |  j  d S(   s  Construct a horizontal LabeledScale with parent master, a
        variable to be associated with the Ttk Scale widget and its range.
        If variable is not specified, a Tkinter.IntVar is created.

        WIDGET-SPECIFIC OPTIONS

            compound: 'top' or 'bottom'
                Specifies how to display the label relative to the scale.
                Defaults to 'top'.
        t   compoundt   topt   variableR   R   s   <<RangeChanged>>t   bottomt   sidet   fillR   t   anchort   nR`   t   ws   <Configure>s   <Map>N(   t   popt
   _label_topR   R   R   t   IntVart	   _variableR   t   _last_validR   t   labelR   t   scaleR   t   _adjustt   packt   placet   trace_variablet   _LabeledScale__tracecb(	   R   R%   R  R   R   RH   t
   scale_sidet
   label_sidet   tmp(    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s     	$%c         C   sE   y |  j  j d |  j  Wn t k
 r- n X|  `  t j |   d S(   s9   Destroy this widget and possibly its associated variable.R  N(   R  t   trace_vdeleteR  t   AttributeErrorR   t   destroy(   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR    s    c            s     f d   } t    j d  } t    j d  } | | k  rQ | | } } n    j j   } | | k ow | k n s   j   _ d S|   _ |   j d <  j |  d S(   s1   Adjust the label position according to the scale.c             s     j      j j   \ }  }   j rG   j j     j j   } n   j j     j j   }   j j d |  d |  d  S(   NR   R   (   t   update_idletasksR  t   coordsR  t   winfo_yR  t   winfo_reqheightt   place_configure(   R   R   (   R   (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   adjust_label  s    
	RE   R   Nt   text(   R   R  R  R    R  R+   R  t
   after_idle(   R   RG   R$  R   R   t   newval(    (   R   s    /usr/lib/python2.7/lib-tk/ttk.pyR    s    	c         C   s   |  j  j   S(   s   Return current scale value.(   R  R    (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt
   _get_value  s    c         C   s   |  j  j |  d S(   s   Set new scale value.N(   R  R   (   R   R>   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt
   _set_value  s    N(   R   R   R   R0   R   R  R  R(  R)  t   propertyR+   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR     s   #				c           B   s8   e  Z d  Z d d  Z d   Z d d  Z d   Z RS(   sm   Themed OptionMenu, based after Tkinter's OptionMenu, which allows
    the user to select a value from a menu.c         O   s   i | d 6| j  d d  d 6| j  d d  d 6} t j |  | |  t j |  d t |  d <| |  _ | j  d d  |  _ | r t j	 d | j
   j     n  |  j | |  d S(	   s9  Construct a themed OptionMenu widget with master as the parent,
        the resource textvariable set to variable, the initially selected
        value specified by the default parameter, the menu values given by
        *values and additional keywords.

        WIDGET-SPECIFIC OPTIONS

            style: stylename
                Menubutton style.
            direction: 'above', 'below', 'left', 'right', or 'flush'
                Menubutton direction.
            command: callback
                A callback that will be invoked after selecting an item.
        t   textvariableR   t	   directiont   tearofft   menuR   s   unknown option -%sN(   R  R0   R   R   R   t   MenuR   R  t	   _callbackt   TclErrort   iterkeysR   t   set_menu(   R   R%   R  R   t   valuest   kwargsRH   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR   $  s    		c         C   s5   | d k r% |  j  t j |  |   St j |  |  S(   NR.  (   t   nametowidgetR   t   __getitem__(   R   R<   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR7  A  s    c      	   G   ss   |  d } | j  d d  x9 | D]1 } | j d | d t j |  j | |  j   q! W| ro |  j j |  n  d S(   sU   Build a new menu of radiobuttons with *values and optionally
        a default value.R.  i    t   endR  R   N(   R   t   add_radiobuttonR   t   _setitR  R0  R   (   R   R   R4  R.  R>   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR3  H  s    
 c         C   s   |  `  t j |   d S(   s0   Destroy this widget and its associated variable.N(   R  R   R  (   R   (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR  U  s    N(   R   R   R   R0   R   R7  R3  R  (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyR      s
   	(8   R   t   __version__t
   __author__t   __all__R   R   R   R   R   t	   TkVersionR#   R   R   R'   R-   R0   R5   R?   RB   RO   RQ   Rf   Rq   Ru   R}   R   R   R{   R   R   t   objectR   R   R    R   R   R   R   R   R   R   R   R	   R   R
   R   R   R   R   R   R   t   XViewt   YViewR   R   R   (    (    (    s    /usr/lib/python2.7/lib-tk/ttk.pyt   <module>   sf   "	
	%1	*				
			B*"8*'" D_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #
# turtle.py: a Tkinter based turtle graphics module for Python
# Version 1.0.1 - 24. 9. 2009
#
# Copyright (C) 2006 - 2010  Gregor Lingl
# email: glingl@aon.at
#
# This software is provided 'as-is', without any express or implied
# warranty.  In no event will the authors be held liable for any damages
# arising from the use of this software.
#
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
#
# 1. The origin of this software must not be misrepresented; you must not
#    claim that you wrote the original software. If you use this software
#    in a product, an acknowledgment in the product documentation would be
#    appreciated but is not required.
# 2. Altered source versions must be plainly marked as such, and must not be
#    misrepresented as being the original software.
# 3. This notice may not be removed or altered from any source distribution.


"""
Turtle graphics is a popular way for introducing programming to
kids. It was part of the original Logo programming language developed
by Wally Feurzig and Seymour Papert in 1966.

Imagine a robotic turtle starting at (0, 0) in the x-y plane. After an ``import turtle``, give it
the command turtle.forward(15), and it moves (on-screen!) 15 pixels in
the direction it is facing, drawing a line as it moves. Give it the
command turtle.right(25), and it rotates in-place 25 degrees clockwise.

By combining together these and similar commands, intricate shapes and
pictures can easily be drawn.

----- turtle.py

This module is an extended reimplementation of turtle.py from the
Python standard distribution up to Python 2.5. (See: http://www.python.org)

It tries to keep the merits of turtle.py and to be (nearly) 100%
compatible with it. This means in the first place to enable the
learning programmer to use all the commands, classes and methods
interactively when using the module from within IDLE run with
the -n switch.

Roughly it has the following features added:

- Better animation of the turtle movements, especially of turning the
  turtle. So the turtles can more easily be used as a visual feedback
  instrument by the (beginning) programmer.

- Different turtle shapes, gif-images as turtle shapes, user defined
  and user controllable turtle shapes, among them compound
  (multicolored) shapes. Turtle shapes can be stretched and tilted, which
  makes turtles very versatile geometrical objects.

- Fine control over turtle movement and screen updates via delay(),
  and enhanced tracer() and speed() methods.

- Aliases for the most commonly used commands, like fd for forward etc.,
  following the early Logo traditions. This reduces the boring work of
  typing long sequences of commands, which often occur in a natural way
  when kids try to program fancy pictures on their first encounter with
  turtle graphics.

- Turtles now have an undo()-method with configurable undo-buffer.

- Some simple commands/methods for creating event driven programs
  (mouse-, key-, timer-events). Especially useful for programming games.

- A scrollable Canvas class. The default scrollable Canvas can be
  extended interactively as needed while playing around with the turtle(s).

- A TurtleScreen class with methods controlling background color or
  background image, window and canvas size and other properties of the
  TurtleScreen.

- There is a method, setworldcoordinates(), to install a user defined
  coordinate-system for the TurtleScreen.

- The implementation uses a 2-vector class named Vec2D, derived from tuple.
  This class is public, so it can be imported by the application programmer,
  which makes certain types of computations very natural and compact.

- Appearance of the TurtleScreen and the Turtles at startup/import can be
  configured by means of a turtle.cfg configuration file.
  The default configuration mimics the appearance of the old turtle module.

- If configured appropriately the module reads in docstrings from a docstring
  dictionary in some different language, supplied separately  and replaces
  the English ones by those read in. There is a utility function
  write_docstringdict() to write a dictionary with the original (English)
  docstrings to disc, so it can serve as a template for translations.

Behind the scenes there are some features included with possible
extensions in mind. These will be commented and documented elsewhere.

"""

_ver = "turtle 1.0b1 - for Python 2.6   -  30. 5. 2008, 18:08"

#print _ver

import Tkinter as TK
import types
import math
import time
import os

from os.path import isfile, split, join
from copy import deepcopy

from math import *    ## for compatibility with old turtle module

_tg_classes = ['ScrolledCanvas', 'TurtleScreen', 'Screen',
               'RawTurtle', 'Turtle', 'RawPen', 'Pen', 'Shape', 'Vec2D']
_tg_screen_functions = ['addshape', 'bgcolor', 'bgpic', 'bye',
        'clearscreen', 'colormode', 'delay', 'exitonclick', 'getcanvas',
        'getshapes', 'listen', 'mode', 'onkey', 'onscreenclick', 'ontimer',
        'register_shape', 'resetscreen', 'screensize', 'setup',
        'setworldcoordinates', 'title', 'tracer', 'turtles', 'update',
        'window_height', 'window_width']
_tg_turtle_functions = ['back', 'backward', 'begin_fill', 'begin_poly', 'bk',
        'circle', 'clear', 'clearstamp', 'clearstamps', 'clone', 'color',
        'degrees', 'distance', 'dot', 'down', 'end_fill', 'end_poly', 'fd',
        'fill', 'fillcolor', 'forward', 'get_poly', 'getpen', 'getscreen',
        'getturtle', 'goto', 'heading', 'hideturtle', 'home', 'ht', 'isdown',
        'isvisible', 'left', 'lt', 'onclick', 'ondrag', 'onrelease', 'pd',
        'pen', 'pencolor', 'pendown', 'pensize', 'penup', 'pos', 'position',
        'pu', 'radians', 'right', 'reset', 'resizemode', 'rt',
        'seth', 'setheading', 'setpos', 'setposition', 'settiltangle',
        'setundobuffer', 'setx', 'sety', 'shape', 'shapesize', 'showturtle',
        'speed', 'st', 'stamp', 'tilt', 'tiltangle', 'towards', 'tracer',
        'turtlesize', 'undo', 'undobufferentries', 'up', 'width',
        'window_height', 'window_width', 'write', 'xcor', 'ycor']
_tg_utilities = ['write_docstringdict', 'done', 'mainloop']
_math_functions = ['acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'cosh',
        'e', 'exp', 'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log',
        'log10', 'modf', 'pi', 'pow', 'sin', 'sinh', 'sqrt', 'tan', 'tanh']

__all__ = (_tg_classes + _tg_screen_functions + _tg_turtle_functions +
           _tg_utilities + ['Terminator'] + _math_functions)

_alias_list = ['addshape', 'backward', 'bk', 'fd', 'ht', 'lt', 'pd', 'pos',
               'pu', 'rt', 'seth', 'setpos', 'setposition', 'st',
               'turtlesize', 'up', 'width']

_CFG = {"width" : 0.5,               # Screen
        "height" : 0.75,
        "canvwidth" : 400,
        "canvheight": 300,
        "leftright": None,
        "topbottom": None,
        "mode": "standard",          # TurtleScreen
        "colormode": 1.0,
        "delay": 10,
        "undobuffersize": 1000,      # RawTurtle
        "shape": "classic",
        "pencolor" : "black",
        "fillcolor" : "black",
        "resizemode" : "noresize",
        "visible" : True,
        "language": "english",        # docstrings
        "exampleturtle": "turtle",
        "examplescreen": "screen",
        "title": "Python Turtle Graphics",
        "using_IDLE": False
       }

##print "cwd:", os.getcwd()
##print "__file__:", __file__
##
##def show(dictionary):
##    print "=========================="
##    for key in sorted(dictionary.keys()):
##        print key, ":", dictionary[key]
##    print "=========================="
##    print

def config_dict(filename):
    """Convert content of config-file into dictionary."""
    f = open(filename, "r")
    cfglines = f.readlines()
    f.close()
    cfgdict = {}
    for line in cfglines:
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        try:
            key, value = line.split("=")
        except ValueError:
            print "Bad line in config-file %s:\n%s" % (filename,line)
            continue
        key = key.strip()
        value = value.strip()
        if value in ["True", "False", "None", "''", '""']:
            value = eval(value)
        else:
            try:
                if "." in value:
                    value = float(value)
                else:
                    value = int(value)
            except ValueError:
                pass # value need not be converted
        cfgdict[key] = value
    return cfgdict

def readconfig(cfgdict):
    """Read config-files, change configuration-dict accordingly.

    If there is a turtle.cfg file in the current working directory,
    read it from there. If this contains an importconfig-value,
    say 'myway', construct filename turtle_mayway.cfg else use
    turtle.cfg and read it from the import-directory, where
    turtle.py is located.
    Update configuration dictionary first according to config-file,
    in the import directory, then according to config-file in the
    current working directory.
    If no config-file is found, the default configuration is used.
    """
    default_cfg = "turtle.cfg"
    cfgdict1 = {}
    cfgdict2 = {}
    if isfile(default_cfg):
        cfgdict1 = config_dict(default_cfg)
        #print "1. Loading config-file %s from: %s" % (default_cfg, os.getcwd())
    if "importconfig" in cfgdict1:
        default_cfg = "turtle_%s.cfg" % cfgdict1["importconfig"]
    try:
        head, tail = split(__file__)
        cfg_file2 = join(head, default_cfg)
    except BaseException:
        cfg_file2 = ""
    if isfile(cfg_file2):
        #print "2. Loading config-file %s:" % cfg_file2
        cfgdict2 = config_dict(cfg_file2)
##    show(_CFG)
##    show(cfgdict2)
    _CFG.update(cfgdict2)
##    show(_CFG)
##    show(cfgdict1)
    _CFG.update(cfgdict1)
##    show(_CFG)

try:
    readconfig(_CFG)
except BaseException:
    print "No configfile read, reason unknown"


class Vec2D(tuple):
    """A 2 dimensional vector class, used as a helper class
    for implementing turtle graphics.
    May be useful for turtle graphics programs also.
    Derived from tuple, so a vector is a tuple!

    Provides (for a, b vectors, k number):
       a+b vector addition
       a-b vector subtraction
       a*b inner product
       k*a and a*k multiplication with scalar
       |a| absolute value of a
       a.rotate(angle) rotation
    """
    def __new__(cls, x, y):
        return tuple.__new__(cls, (x, y))
    def __add__(self, other):
        return Vec2D(self[0]+other[0], self[1]+other[1])
    def __mul__(self, other):
        if isinstance(other, Vec2D):
            return self[0]*other[0]+self[1]*other[1]
        return Vec2D(self[0]*other, self[1]*other)
    def __rmul__(self, other):
        if isinstance(other, int) or isinstance(other, float):
            return Vec2D(self[0]*other, self[1]*other)
    def __sub__(self, other):
        return Vec2D(self[0]-other[0], self[1]-other[1])
    def __neg__(self):
        return Vec2D(-self[0], -self[1])
    def __abs__(self):
        return (self[0]**2 + self[1]**2)**0.5
    def rotate(self, angle):
        """rotate self counterclockwise by angle
        """
        perp = Vec2D(-self[1], self[0])
        angle = angle * math.pi / 180.0
        c, s = math.cos(angle), math.sin(angle)
        return Vec2D(self[0]*c+perp[0]*s, self[1]*c+perp[1]*s)
    def __getnewargs__(self):
        return (self[0], self[1])
    def __repr__(self):
        return "(%.2f,%.2f)" % self


##############################################################################
### From here up to line    : Tkinter - Interface for turtle.py            ###
### May be replaced by an interface to some different graphics toolkit     ###
##############################################################################

## helper functions for Scrolled Canvas, to forward Canvas-methods
## to ScrolledCanvas class

def __methodDict(cls, _dict):
    """helper function for Scrolled Canvas"""
    baseList = list(cls.__bases__)
    baseList.reverse()
    for _super in baseList:
        __methodDict(_super, _dict)
    for key, value in cls.__dict__.items():
        if type(value) == types.FunctionType:
            _dict[key] = value

def __methods(cls):
    """helper function for Scrolled Canvas"""
    _dict = {}
    __methodDict(cls, _dict)
    return _dict.keys()

__stringBody = (
    'def %(method)s(self, *args, **kw): return ' +
    'self.%(attribute)s.%(method)s(*args, **kw)')

def __forwardmethods(fromClass, toClass, toPart, exclude = ()):
    """Helper functions for Scrolled Canvas, used to forward
    ScrolledCanvas-methods to Tkinter.Canvas class.
    """
    _dict = {}
    __methodDict(toClass, _dict)
    for ex in _dict.keys():
        if ex[:1] == '_' or ex[-1:] == '_':
            del _dict[ex]
    for ex in exclude:
        if ex in _dict:
            del _dict[ex]
    for ex in __methods(fromClass):
        if ex in _dict:
            del _dict[ex]

    for method, func in _dict.items():
        d = {'method': method, 'func': func}
        if type(toPart) == types.StringType:
            execString = \
                __stringBody % {'method' : method, 'attribute' : toPart}
        exec execString in d
        fromClass.__dict__[method] = d[method]


class ScrolledCanvas(TK.Frame):
    """Modeled after the scrolled canvas class from Grayons's Tkinter book.

    Used as the default canvas, which pops up automatically when
    using turtle graphics functions or the Turtle class.
    """
    def __init__(self, master, width=500, height=350,
                                          canvwidth=600, canvheight=500):
        TK.Frame.__init__(self, master, width=width, height=height)
        self._rootwindow = self.winfo_toplevel()
        self.width, self.height = width, height
        self.canvwidth, self.canvheight = canvwidth, canvheight
        self.bg = "white"
        self._canvas = TK.Canvas(master, width=width, height=height,
                                 bg=self.bg, relief=TK.SUNKEN, borderwidth=2)
        self.hscroll = TK.Scrollbar(master, command=self._canvas.xview,
                                    orient=TK.HORIZONTAL)
        self.vscroll = TK.Scrollbar(master, command=self._canvas.yview)
        self._canvas.configure(xscrollcommand=self.hscroll.set,
                               yscrollcommand=self.vscroll.set)
        self.rowconfigure(0, weight=1, minsize=0)
        self.columnconfigure(0, weight=1, minsize=0)
        self._canvas.grid(padx=1, in_ = self, pady=1, row=0,
                column=0, rowspan=1, columnspan=1, sticky='news')
        self.vscroll.grid(padx=1, in_ = self, pady=1, row=0,
                column=1, rowspan=1, columnspan=1, sticky='news')
        self.hscroll.grid(padx=1, in_ = self, pady=1, row=1,
                column=0, rowspan=1, columnspan=1, sticky='news')
        self.reset()
        self._rootwindow.bind('<Configure>', self.onResize)

    def reset(self, canvwidth=None, canvheight=None, bg = None):
        """Adjust canvas and scrollbars according to given canvas size."""
        if canvwidth:
            self.canvwidth = canvwidth
        if canvheight:
            self.canvheight = canvheight
        if bg:
            self.bg = bg
        self._canvas.config(bg=bg,
                        scrollregion=(-self.canvwidth//2, -self.canvheight//2,
                                       self.canvwidth//2, self.canvheight//2))
        self._canvas.xview_moveto(0.5*(self.canvwidth - self.width + 30) /
                                                               self.canvwidth)
        self._canvas.yview_moveto(0.5*(self.canvheight- self.height + 30) /
                                                              self.canvheight)
        self.adjustScrolls()


    def adjustScrolls(self):
        """ Adjust scrollbars according to window- and canvas-size.
        """
        cwidth = self._canvas.winfo_width()
        cheight = self._canvas.winfo_height()
        self._canvas.xview_moveto(0.5*(self.canvwidth-cwidth)/self.canvwidth)
        self._canvas.yview_moveto(0.5*(self.canvheight-cheight)/self.canvheight)
        if cwidth < self.canvwidth or cheight < self.canvheight:
            self.hscroll.grid(padx=1, in_ = self, pady=1, row=1,
                              column=0, rowspan=1, columnspan=1, sticky='news')
            self.vscroll.grid(padx=1, in_ = self, pady=1, row=0,
                              column=1, rowspan=1, columnspan=1, sticky='news')
        else:
            self.hscroll.grid_forget()
            self.vscroll.grid_forget()

    def onResize(self, event):
        """self-explanatory"""
        self.adjustScrolls()

    def bbox(self, *args):
        """ 'forward' method, which canvas itself has inherited...
        """
        return self._canvas.bbox(*args)

    def cget(self, *args, **kwargs):
        """ 'forward' method, which canvas itself has inherited...
        """
        return self._canvas.cget(*args, **kwargs)

    def config(self, *args, **kwargs):
        """ 'forward' method, which canvas itself has inherited...
        """
        self._canvas.config(*args, **kwargs)

    def bind(self, *args, **kwargs):
        """ 'forward' method, which canvas itself has inherited...
        """
        self._canvas.bind(*args, **kwargs)

    def unbind(self, *args, **kwargs):
        """ 'forward' method, which canvas itself has inherited...
        """
        self._canvas.unbind(*args, **kwargs)

    def focus_force(self):
        """ 'forward' method, which canvas itself has inherited...
        """
        self._canvas.focus_force()

__forwardmethods(ScrolledCanvas, TK.Canvas, '_canvas')


class _Root(TK.Tk):
    """Root class for Screen based on Tkinter."""
    def __init__(self):
        TK.Tk.__init__(self)

    def setupcanvas(self, width, height, cwidth, cheight):
        self._canvas = ScrolledCanvas(self, width, height, cwidth, cheight)
        self._canvas.pack(expand=1, fill="both")

    def _getcanvas(self):
        return self._canvas

    def set_geometry(self, width, height, startx, starty):
        self.geometry("%dx%d%+d%+d"%(width, height, startx, starty))

    def ondestroy(self, destroy):
        self.wm_protocol("WM_DELETE_WINDOW", destroy)

    def win_width(self):
        return self.winfo_screenwidth()

    def win_height(self):
        return self.winfo_screenheight()

Canvas = TK.Canvas


class TurtleScreenBase(object):
    """Provide the basic graphics functionality.
       Interface between Tkinter and turtle.py.

       To port turtle.py to some different graphics toolkit
       a corresponding TurtleScreenBase class has to be implemented.
    """

    @staticmethod
    def _blankimage():
        """return a blank image object
        """
        img = TK.PhotoImage(width=1, height=1)
        img.blank()
        return img

    @staticmethod
    def _image(filename):
        """return an image object containing the
        imagedata from a gif-file named filename.
        """
        return TK.PhotoImage(file=filename)

    def __init__(self, cv):
        self.cv = cv
        if isinstance(cv, ScrolledCanvas):
            w = self.cv.canvwidth
            h = self.cv.canvheight
        else:  # expected: ordinary TK.Canvas
            w = int(self.cv.cget("width"))
            h = int(self.cv.cget("height"))
            self.cv.config(scrollregion = (-w//2, -h//2, w//2, h//2 ))
        self.canvwidth = w
        self.canvheight = h
        self.xscale = self.yscale = 1.0

    def _createpoly(self):
        """Create an invisible polygon item on canvas self.cv)
        """
        return self.cv.create_polygon((0, 0, 0, 0, 0, 0), fill="", outline="")

    def _drawpoly(self, polyitem, coordlist, fill=None,
                  outline=None, width=None, top=False):
        """Configure polygonitem polyitem according to provided
        arguments:
        coordlist is sequence of coordinates
        fill is filling color
        outline is outline color
        top is a boolean value, which specifies if polyitem
        will be put on top of the canvas' displaylist so it
        will not be covered by other items.
        """
        cl = []
        for x, y in coordlist:
            cl.append(x * self.xscale)
            cl.append(-y * self.yscale)
        self.cv.coords(polyitem, *cl)
        if fill is not None:
            self.cv.itemconfigure(polyitem, fill=fill)
        if outline is not None:
            self.cv.itemconfigure(polyitem, outline=outline)
        if width is not None:
            self.cv.itemconfigure(polyitem, width=width)
        if top:
            self.cv.tag_raise(polyitem)

    def _createline(self):
        """Create an invisible line item on canvas self.cv)
        """
        return self.cv.create_line(0, 0, 0, 0, fill="", width=2,
                                   capstyle = TK.ROUND)

    def _drawline(self, lineitem, coordlist=None,
                  fill=None, width=None, top=False):
        """Configure lineitem according to provided arguments:
        coordlist is sequence of coordinates
        fill is drawing color
        width is width of drawn line.
        top is a boolean value, which specifies if polyitem
        will be put on top of the canvas' displaylist so it
        will not be covered by other items.
        """
        if coordlist is not None:
            cl = []
            for x, y in coordlist:
                cl.append(x * self.xscale)
                cl.append(-y * self.yscale)
            self.cv.coords(lineitem, *cl)
        if fill is not None:
            self.cv.itemconfigure(lineitem, fill=fill)
        if width is not None:
            self.cv.itemconfigure(lineitem, width=width)
        if top:
            self.cv.tag_raise(lineitem)

    def _delete(self, item):
        """Delete graphics item from canvas.
        If item is"all" delete all graphics items.
        """
        self.cv.delete(item)

    def _update(self):
        """Redraw graphics items on canvas
        """
        self.cv.update()

    def _delay(self, delay):
        """Delay subsequent canvas actions for delay ms."""
        self.cv.after(delay)

    def _iscolorstring(self, color):
        """Check if the string color is a legal Tkinter color string.
        """
        try:
            rgb = self.cv.winfo_rgb(color)
            ok = True
        except TK.TclError:
            ok = False
        return ok

    def _bgcolor(self, color=None):
        """Set canvas' backgroundcolor if color is not None,
        else return backgroundcolor."""
        if color is not None:
            self.cv.config(bg = color)
            self._update()
        else:
            return self.cv.cget("bg")

    def _write(self, pos, txt, align, font, pencolor):
        """Write txt at pos in canvas with specified font
        and color.
        Return text item and x-coord of right bottom corner
        of text's bounding box."""
        x, y = pos
        x = x * self.xscale
        y = y * self.yscale
        anchor = {"left":"sw", "center":"s", "right":"se" }
        item = self.cv.create_text(x-1, -y, text = txt, anchor = anchor[align],
                                        fill = pencolor, font = font)
        x0, y0, x1, y1 = self.cv.bbox(item)
        self.cv.update()
        return item, x1-1

##    def _dot(self, pos, size, color):
##        """may be implemented for some other graphics toolkit"""

    def _onclick(self, item, fun, num=1, add=None):
        """Bind fun to mouse-click event on turtle.
        fun must be a function with two arguments, the coordinates
        of the clicked point on the canvas.
        num, the number of the mouse-button defaults to 1
        """
        if fun is None:
            self.cv.tag_unbind(item, "<Button-%s>" % num)
        else:
            def eventfun(event):
                x, y = (self.cv.canvasx(event.x)/self.xscale,
                        -self.cv.canvasy(event.y)/self.yscale)
                fun(x, y)
            self.cv.tag_bind(item, "<Button-%s>" % num, eventfun, add)

    def _onrelease(self, item, fun, num=1, add=None):
        """Bind fun to mouse-button-release event on turtle.
        fun must be a function with two arguments, the coordinates
        of the point on the canvas where mouse button is released.
        num, the number of the mouse-button defaults to 1

        If a turtle is clicked, first _onclick-event will be performed,
        then _onscreensclick-event.
        """
        if fun is None:
            self.cv.tag_unbind(item, "<Button%s-ButtonRelease>" % num)
        else:
            def eventfun(event):
                x, y = (self.cv.canvasx(event.x)/self.xscale,
                        -self.cv.canvasy(event.y)/self.yscale)
                fun(x, y)
            self.cv.tag_bind(item, "<Button%s-ButtonRelease>" % num,
                             eventfun, add)

    def _ondrag(self, item, fun, num=1, add=None):
        """Bind fun to mouse-move-event (with pressed mouse button) on turtle.
        fun must be a function with two arguments, the coordinates of the
        actual mouse position on the canvas.
        num, the number of the mouse-button defaults to 1

        Every sequence of mouse-move-events on a turtle is preceded by a
        mouse-click event on that turtle.
        """
        if fun is None:
            self.cv.tag_unbind(item, "<Button%s-Motion>" % num)
        else:
            def eventfun(event):
                try:
                    x, y = (self.cv.canvasx(event.x)/self.xscale,
                           -self.cv.canvasy(event.y)/self.yscale)
                    fun(x, y)
                except BaseException:
                    pass
            self.cv.tag_bind(item, "<Button%s-Motion>" % num, eventfun, add)

    def _onscreenclick(self, fun, num=1, add=None):
        """Bind fun to mouse-click event on canvas.
        fun must be a function with two arguments, the coordinates
        of the clicked point on the canvas.
        num, the number of the mouse-button defaults to 1

        If a turtle is clicked, first _onclick-event will be performed,
        then _onscreensclick-event.
        """
        if fun is None:
            self.cv.unbind("<Button-%s>" % num)
        else:
            def eventfun(event):
                x, y = (self.cv.canvasx(event.x)/self.xscale,
                        -self.cv.canvasy(event.y)/self.yscale)
                fun(x, y)
            self.cv.bind("<Button-%s>" % num, eventfun, add)

    def _onkey(self, fun, key):
        """Bind fun to key-release event of key.
        Canvas must have focus. See method listen
        """
        if fun is None:
            self.cv.unbind("<KeyRelease-%s>" % key, None)
        else:
            def eventfun(event):
                fun()
            self.cv.bind("<KeyRelease-%s>" % key, eventfun)

    def _listen(self):
        """Set focus on canvas (in order to collect key-events)
        """
        self.cv.focus_force()

    def _ontimer(self, fun, t):
        """Install a timer, which calls fun after t milliseconds.
        """
        if t == 0:
            self.cv.after_idle(fun)
        else:
            self.cv.after(t, fun)

    def _createimage(self, image):
        """Create and return image item on canvas.
        """
        return self.cv.create_image(0, 0, image=image)

    def _drawimage(self, item, pos, image):
        """Configure image item as to draw image object
        at position (x,y) on canvas)
        """
        x, y = pos
        self.cv.coords(item, (x * self.xscale, -y * self.yscale))
        self.cv.itemconfig(item, image=image)

    def _setbgpic(self, item, image):
        """Configure image item as to draw image object
        at center of canvas. Set item to the first item
        in the displaylist, so it will be drawn below
        any other item ."""
        self.cv.itemconfig(item, image=image)
        self.cv.tag_lower(item)

    def _type(self, item):
        """Return 'line' or 'polygon' or 'image' depending on
        type of item.
        """
        return self.cv.type(item)

    def _pointlist(self, item):
        """returns list of coordinate-pairs of points of item
        Example (for insiders):
        >>> from turtle import *
        >>> getscreen()._pointlist(getturtle().turtle._item)
        [(0.0, 9.9999999999999982), (0.0, -9.9999999999999982),
        (9.9999999999999982, 0.0)]
        >>> """
        cl = self.cv.coords(item)
        pl = [(cl[i], -cl[i+1]) for i in range(0, len(cl), 2)]
        return  pl

    def _setscrollregion(self, srx1, sry1, srx2, sry2):
        self.cv.config(scrollregion=(srx1, sry1, srx2, sry2))

    def _rescale(self, xscalefactor, yscalefactor):
        items = self.cv.find_all()
        for item in items:
            coordinates = self.cv.coords(item)
            newcoordlist = []
            while coordinates:
                x, y = coordinates[:2]
                newcoordlist.append(x * xscalefactor)
                newcoordlist.append(y * yscalefactor)
                coordinates = coordinates[2:]
            self.cv.coords(item, *newcoordlist)

    def _resize(self, canvwidth=None, canvheight=None, bg=None):
        """Resize the canvas the turtles are drawing on. Does
        not alter the drawing window.
        """
        # needs amendment
        if not isinstance(self.cv, ScrolledCanvas):
            return self.canvwidth, self.canvheight
        if canvwidth is canvheight is bg is None:
            return self.cv.canvwidth, self.cv.canvheight
        if canvwidth is not None:
            self.canvwidth = canvwidth
        if canvheight is not None:
            self.canvheight = canvheight
        self.cv.reset(canvwidth, canvheight, bg)

    def _window_size(self):
        """ Return the width and height of the turtle window.
        """
        width = self.cv.winfo_width()
        if width <= 1:  # the window isn't managed by a geometry manager
            width = self.cv['width']
        height = self.cv.winfo_height()
        if height <= 1: # the window isn't managed by a geometry manager
            height = self.cv['height']
        return width, height


##############################################################################
###                  End of Tkinter - interface                            ###
##############################################################################


class Terminator (Exception):
    """Will be raised in TurtleScreen.update, if _RUNNING becomes False.

    This stops execution of a turtle graphics script.
    Main purpose: use in the Demo-Viewer turtle.Demo.py.
    """
    pass


class TurtleGraphicsError(Exception):
    """Some TurtleGraphics Error
    """


class Shape(object):
    """Data structure modeling shapes.

    attribute _type is one of "polygon", "image", "compound"
    attribute _data is - depending on _type a poygon-tuple,
    an image or a list constructed using the addcomponent method.
    """
    def __init__(self, type_, data=None):
        self._type = type_
        if type_ == "polygon":
            if isinstance(data, list):
                data = tuple(data)
        elif type_ == "image":
            if isinstance(data, basestring):
                if data.lower().endswith(".gif") and isfile(data):
                    data = TurtleScreen._image(data)
                # else data assumed to be Photoimage
        elif type_ == "compound":
            data = []
        else:
            raise TurtleGraphicsError("There is no shape type %s" % type_)
        self._data = data

    def addcomponent(self, poly, fill, outline=None):
        """Add component to a shape of type compound.

        Arguments: poly is a polygon, i. e. a tuple of number pairs.
        fill is the fillcolor of the component,
        outline is the outline color of the component.

        call (for a Shapeobject namend s):
        --   s.addcomponent(((0,0), (10,10), (-10,10)), "red", "blue")

        Example:
        >>> poly = ((0,0),(10,-5),(0,10),(-10,-5))
        >>> s = Shape("compound")
        >>> s.addcomponent(poly, "red", "blue")
        >>> # .. add more components and then use register_shape()
        """
        if self._type != "compound":
            raise TurtleGraphicsError("Cannot add component to %s Shape"
                                                                % self._type)
        if outline is None:
            outline = fill
        self._data.append([poly, fill, outline])


class Tbuffer(object):
    """Ring buffer used as undobuffer for RawTurtle objects."""
    def __init__(self, bufsize=10):
        self.bufsize = bufsize
        self.buffer = [[None]] * bufsize
        self.ptr = -1
        self.cumulate = False
    def reset(self, bufsize=None):
        if bufsize is None:
            for i in range(self.bufsize):
                self.buffer[i] = [None]
        else:
            self.bufsize = bufsize
            self.buffer = [[None]] * bufsize
        self.ptr = -1
    def push(self, item):
        if self.bufsize > 0:
            if not self.cumulate:
                self.ptr = (self.ptr + 1) % self.bufsize
                self.buffer[self.ptr] = item
            else:
                self.buffer[self.ptr].append(item)
    def pop(self):
        if self.bufsize > 0:
            item = self.buffer[self.ptr]
            if item is None:
                return None
            else:
                self.buffer[self.ptr] = [None]
                self.ptr = (self.ptr - 1) % self.bufsize
                return (item)
    def nr_of_items(self):
        return self.bufsize - self.buffer.count([None])
    def __repr__(self):
        return str(self.buffer) + " " + str(self.ptr)



class TurtleScreen(TurtleScreenBase):
    """Provides screen oriented methods like setbg etc.

    Only relies upon the methods of TurtleScreenBase and NOT
    upon components of the underlying graphics toolkit -
    which is Tkinter in this case.
    """
#    _STANDARD_DELAY = 5
    _RUNNING = True

    def __init__(self, cv, mode=_CFG["mode"],
                 colormode=_CFG["colormode"], delay=_CFG["delay"]):
        self._shapes = {
                   "arrow" : Shape("polygon", ((-10,0), (10,0), (0,10))),
                  "turtle" : Shape("polygon", ((0,16), (-2,14), (-1,10), (-4,7),
                              (-7,9), (-9,8), (-6,5), (-7,1), (-5,-3), (-8,-6),
                              (-6,-8), (-4,-5), (0,-7), (4,-5), (6,-8), (8,-6),
                              (5,-3), (7,1), (6,5), (9,8), (7,9), (4,7), (1,10),
                              (2,14))),
                  "circle" : Shape("polygon", ((10,0), (9.51,3.09), (8.09,5.88),
                              (5.88,8.09), (3.09,9.51), (0,10), (-3.09,9.51),
                              (-5.88,8.09), (-8.09,5.88), (-9.51,3.09), (-10,0),
                              (-9.51,-3.09), (-8.09,-5.88), (-5.88,-8.09),
                              (-3.09,-9.51), (-0.00,-10.00), (3.09,-9.51),
                              (5.88,-8.09), (8.09,-5.88), (9.51,-3.09))),
                  "square" : Shape("polygon", ((10,-10), (10,10), (-10,10),
                              (-10,-10))),
                "triangle" : Shape("polygon", ((10,-5.77), (0,11.55),
                              (-10,-5.77))),
                  "classic": Shape("polygon", ((0,0),(-5,-9),(0,-7),(5,-9))),
                   "blank" : Shape("image", self._blankimage())
                  }

        self._bgpics = {"nopic" : ""}

        TurtleScreenBase.__init__(self, cv)
        self._mode = mode
        self._delayvalue = delay
        self._colormode = _CFG["colormode"]
        self._keys = []
        self.clear()

    def clear(self):
        """Delete all drawings and all turtles from the TurtleScreen.

        Reset empty TurtleScreen to its initial state: white background,
        no backgroundimage, no eventbindings and tracing on.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.clear()

        Note: this method is not available as function.
        """
        self._delayvalue = _CFG["delay"]
        self._colormode = _CFG["colormode"]
        self._delete("all")
        self._bgpic = self._createimage("")
        self._bgpicname = "nopic"
        self._tracing = 1
        self._updatecounter = 0
        self._turtles = []
        self.bgcolor("white")
        for btn in 1, 2, 3:
            self.onclick(None, btn)
        for key in self._keys[:]:
            self.onkey(None, key)
        Turtle._pen = None

    def mode(self, mode=None):
        """Set turtle-mode ('standard', 'logo' or 'world') and perform reset.

        Optional argument:
        mode -- one of the strings 'standard', 'logo' or 'world'

        Mode 'standard' is compatible with turtle.py.
        Mode 'logo' is compatible with most Logo-Turtle-Graphics.
        Mode 'world' uses userdefined 'worldcoordinates'. *Attention*: in
        this mode angles appear distorted if x/y unit-ratio doesn't equal 1.
        If mode is not given, return the current mode.

             Mode      Initial turtle heading     positive angles
         ------------|-------------------------|-------------------
          'standard'    to the right (east)       counterclockwise
            'logo'        upward    (north)         clockwise

        Examples:
        >>> mode('logo')   # resets turtle heading to north
        >>> mode()
        'logo'
        """
        if mode is None:
            return self._mode
        mode = mode.lower()
        if mode not in ["standard", "logo", "world"]:
            raise TurtleGraphicsError("No turtle-graphics-mode %s" % mode)
        self._mode = mode
        if mode in ["standard", "logo"]:
            self._setscrollregion(-self.canvwidth//2, -self.canvheight//2,
                                       self.canvwidth//2, self.canvheight//2)
            self.xscale = self.yscale = 1.0
        self.reset()

    def setworldcoordinates(self, llx, lly, urx, ury):
        """Set up a user defined coordinate-system.

        Arguments:
        llx -- a number, x-coordinate of lower left corner of canvas
        lly -- a number, y-coordinate of lower left corner of canvas
        urx -- a number, x-coordinate of upper right corner of canvas
        ury -- a number, y-coordinate of upper right corner of canvas

        Set up user coodinat-system and switch to mode 'world' if necessary.
        This performs a screen.reset. If mode 'world' is already active,
        all drawings are redrawn according to the new coordinates.

        But ATTENTION: in user-defined coordinatesystems angles may appear
        distorted. (see Screen.mode())

        Example (for a TurtleScreen instance named screen):
        >>> screen.setworldcoordinates(-10,-0.5,50,1.5)
        >>> for _ in range(36):
        ...     left(10)
        ...     forward(0.5)
        """
        if self.mode() != "world":
            self.mode("world")
        xspan = float(urx - llx)
        yspan = float(ury - lly)
        wx, wy = self._window_size()
        self.screensize(wx-20, wy-20)
        oldxscale, oldyscale = self.xscale, self.yscale
        self.xscale = self.canvwidth / xspan
        self.yscale = self.canvheight / yspan
        srx1 = llx * self.xscale
        sry1 = -ury * self.yscale
        srx2 = self.canvwidth + srx1
        sry2 = self.canvheight + sry1
        self._setscrollregion(srx1, sry1, srx2, sry2)
        self._rescale(self.xscale/oldxscale, self.yscale/oldyscale)
        self.update()

    def register_shape(self, name, shape=None):
        """Adds a turtle shape to TurtleScreen's shapelist.

        Arguments:
        (1) name is the name of a gif-file and shape is None.
            Installs the corresponding image shape.
            !! Image-shapes DO NOT rotate when turning the turtle,
            !! so they do not display the heading of the turtle!
        (2) name is an arbitrary string and shape is a tuple
            of pairs of coordinates. Installs the corresponding
            polygon shape
        (3) name is an arbitrary string and shape is a
            (compound) Shape object. Installs the corresponding
            compound shape.
        To use a shape, you have to issue the command shape(shapename).

        call: register_shape("turtle.gif")
        --or: register_shape("tri", ((0,0), (10,10), (-10,10)))

        Example (for a TurtleScreen instance named screen):
        >>> screen.register_shape("triangle", ((5,-3),(0,5),(-5,-3)))

        """
        if shape is None:
            # image
            if name.lower().endswith(".gif"):
                shape = Shape("image", self._image(name))
            else:
                raise TurtleGraphicsError("Bad arguments for register_shape.\n"
                                          + "Use  help(register_shape)" )
        elif isinstance(shape, tuple):
            shape = Shape("polygon", shape)
        ## else shape assumed to be Shape-instance
        self._shapes[name] = shape
        # print "shape added:" , self._shapes

    def _colorstr(self, color):
        """Return color string corresponding to args.

        Argument may be a string or a tuple of three
        numbers corresponding to actual colormode,
        i.e. in the range 0<=n<=colormode.

        If the argument doesn't represent a color,
        an error is raised.
        """
        if len(color) == 1:
            color = color[0]
        if isinstance(color, basestring):
            if self._iscolorstring(color) or color == "":
                return color
            else:
                raise TurtleGraphicsError("bad color string: %s" % str(color))
        try:
            r, g, b = color
        except (TypeError, ValueError):
            raise TurtleGraphicsError("bad color arguments: %s" % str(color))
        if self._colormode == 1.0:
            r, g, b = [round(255.0*x) for x in (r, g, b)]
        if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):
            raise TurtleGraphicsError("bad color sequence: %s" % str(color))
        return "#%02x%02x%02x" % (r, g, b)

    def _color(self, cstr):
        if not cstr.startswith("#"):
            return cstr
        if len(cstr) == 7:
            cl = [int(cstr[i:i+2], 16) for i in (1, 3, 5)]
        elif len(cstr) == 4:
            cl = [16*int(cstr[h], 16) for h in cstr[1:]]
        else:
            raise TurtleGraphicsError("bad colorstring: %s" % cstr)
        return tuple([c * self._colormode/255 for c in cl])

    def colormode(self, cmode=None):
        """Return the colormode or set it to 1.0 or 255.

        Optional argument:
        cmode -- one of the values 1.0 or 255

        r, g, b values of colortriples have to be in range 0..cmode.

        Example (for a TurtleScreen instance named screen):
        >>> screen.colormode()
        1.0
        >>> screen.colormode(255)
        >>> pencolor(240,160,80)
        """
        if cmode is None:
            return self._colormode
        if cmode == 1.0:
            self._colormode = float(cmode)
        elif cmode == 255:
            self._colormode = int(cmode)

    def reset(self):
        """Reset all Turtles on the Screen to their initial state.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.reset()
        """
        for turtle in self._turtles:
            turtle._setmode(self._mode)
            turtle.reset()

    def turtles(self):
        """Return the list of turtles on the screen.

        Example (for a TurtleScreen instance named screen):
        >>> screen.turtles()
        [<turtle.Turtle object at 0x00E11FB0>]
        """
        return self._turtles

    def bgcolor(self, *args):
        """Set or return backgroundcolor of the TurtleScreen.

        Arguments (if given): a color string or three numbers
        in the range 0..colormode or a 3-tuple of such numbers.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bgcolor("orange")
        >>> screen.bgcolor()
        'orange'
        >>> screen.bgcolor(0.5,0,0.5)
        >>> screen.bgcolor()
        '#800080'
        """
        if args:
            color = self._colorstr(args)
        else:
            color = None
        color = self._bgcolor(color)
        if color is not None:
            color = self._color(color)
        return color

    def tracer(self, n=None, delay=None):
        """Turns turtle animation on/off and set delay for update drawings.

        Optional arguments:
        n -- nonnegative  integer
        delay -- nonnegative  integer

        If n is given, only each n-th regular screen update is really performed.
        (Can be used to accelerate the drawing of complex graphics.)
        Second arguments sets delay value (see RawTurtle.delay())

        Example (for a TurtleScreen instance named screen):
        >>> screen.tracer(8, 25)
        >>> dist = 2
        >>> for i in range(200):
        ...     fd(dist)
        ...     rt(90)
        ...     dist += 2
        """
        if n is None:
            return self._tracing
        self._tracing = int(n)
        self._updatecounter = 0
        if delay is not None:
            self._delayvalue = int(delay)
        if self._tracing:
            self.update()

    def delay(self, delay=None):
        """ Return or set the drawing delay in milliseconds.

        Optional argument:
        delay -- positive integer

        Example (for a TurtleScreen instance named screen):
        >>> screen.delay(15)
        >>> screen.delay()
        15
        """
        if delay is None:
            return self._delayvalue
        self._delayvalue = int(delay)

    def _incrementudc(self):
        """Increment update counter."""
        if not TurtleScreen._RUNNING:
            TurtleScreen._RUNNING = True
            raise Terminator
        if self._tracing > 0:
            self._updatecounter += 1
            self._updatecounter %= self._tracing

    def update(self):
        """Perform a TurtleScreen update.
        """
        tracing = self._tracing
        self._tracing = True
        for t in self.turtles():
            t._update_data()
            t._drawturtle()
        self._tracing = tracing
        self._update()

    def window_width(self):
        """ Return the width of the turtle window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_width()
        640
        """
        return self._window_size()[0]

    def window_height(self):
        """ Return the height of the turtle window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_height()
        480
        """
        return self._window_size()[1]

    def getcanvas(self):
        """Return the Canvas of this TurtleScreen.

        No argument.

        Example (for a Screen instance named screen):
        >>> cv = screen.getcanvas()
        >>> cv
        <turtle.ScrolledCanvas instance at 0x010742D8>
        """
        return self.cv

    def getshapes(self):
        """Return a list of names of all currently available turtle shapes.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.getshapes()
        ['arrow', 'blank', 'circle', ... , 'turtle']
        """
        return sorted(self._shapes.keys())

    def onclick(self, fun, btn=1, add=None):
        """Bind fun to mouse-click event on canvas.

        Arguments:
        fun -- a function with two arguments, the coordinates of the
               clicked point on the canvas.
        num -- the number of the mouse-button, defaults to 1

        Example (for a TurtleScreen instance named screen
        and a Turtle instance named turtle):

        >>> screen.onclick(goto)
        >>> # Subsequently clicking into the TurtleScreen will
        >>> # make the turtle move to the clicked point.
        >>> screen.onclick(None)
        """
        self._onscreenclick(fun, btn, add)

    def onkey(self, fun, key):
        """Bind fun to key-release event of key.

        Arguments:
        fun -- a function with no arguments
        key -- a string: key (e.g. "a") or key-symbol (e.g. "space")

        In order to be able to register key-events, TurtleScreen
        must have focus. (See method listen.)

        Example (for a TurtleScreen instance named screen):

        >>> def f():
        ...     fd(50)
        ...     lt(60)
        ...
        >>> screen.onkey(f, "Up")
        >>> screen.listen()

        Subsequently the turtle can be moved by repeatedly pressing
        the up-arrow key, consequently drawing a hexagon

        """
        if fun is None:
            if key in self._keys:
                self._keys.remove(key)
        elif key not in self._keys:
            self._keys.append(key)
        self._onkey(fun, key)

    def listen(self, xdummy=None, ydummy=None):
        """Set focus on TurtleScreen (in order to collect key-events)

        No arguments.
        Dummy arguments are provided in order
        to be able to pass listen to the onclick method.

        Example (for a TurtleScreen instance named screen):
        >>> screen.listen()
        """
        self._listen()

    def ontimer(self, fun, t=0):
        """Install a timer, which calls fun after t milliseconds.

        Arguments:
        fun -- a function with no arguments.
        t -- a number >= 0

        Example (for a TurtleScreen instance named screen):

        >>> running = True
        >>> def f():
        ...     if running:
        ...             fd(50)
        ...             lt(60)
        ...             screen.ontimer(f, 250)
        ...
        >>> f()   # makes the turtle marching around
        >>> running = False
        """
        self._ontimer(fun, t)

    def bgpic(self, picname=None):
        """Set background image or return name of current backgroundimage.

        Optional argument:
        picname -- a string, name of a gif-file or "nopic".

        If picname is a filename, set the corresponding image as background.
        If picname is "nopic", delete backgroundimage, if present.
        If picname is None, return the filename of the current backgroundimage.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bgpic()
        'nopic'
        >>> screen.bgpic("landscape.gif")
        >>> screen.bgpic()
        'landscape.gif'
        """
        if picname is None:
            return self._bgpicname
        if picname not in self._bgpics:
            self._bgpics[picname] = self._image(picname)
        self._setbgpic(self._bgpic, self._bgpics[picname])
        self._bgpicname = picname

    def screensize(self, canvwidth=None, canvheight=None, bg=None):
        """Resize the canvas the turtles are drawing on.

        Optional arguments:
        canvwidth -- positive integer, new width of canvas in pixels
        canvheight --  positive integer, new height of canvas in pixels
        bg -- colorstring or color-tuple, new backgroundcolor
        If no arguments are given, return current (canvaswidth, canvasheight)

        Do not alter the drawing window. To observe hidden parts of
        the canvas use the scrollbars. (Can make visible those parts
        of a drawing, which were outside the canvas before!)

        Example (for a Turtle instance named turtle):
        >>> turtle.screensize(2000,1500)
        >>> # e. g. to search for an erroneously escaped turtle ;-)
        """
        return self._resize(canvwidth, canvheight, bg)

    onscreenclick = onclick
    resetscreen = reset
    clearscreen = clear
    addshape = register_shape

class TNavigator(object):
    """Navigation part of the RawTurtle.
    Implements methods for turtle movement.
    """
    START_ORIENTATION = {
        "standard": Vec2D(1.0, 0.0),
        "world"   : Vec2D(1.0, 0.0),
        "logo"    : Vec2D(0.0, 1.0)  }
    DEFAULT_MODE = "standard"
    DEFAULT_ANGLEOFFSET = 0
    DEFAULT_ANGLEORIENT = 1

    def __init__(self, mode=DEFAULT_MODE):
        self._angleOffset = self.DEFAULT_ANGLEOFFSET
        self._angleOrient = self.DEFAULT_ANGLEORIENT
        self._mode = mode
        self.undobuffer = None
        self.degrees()
        self._mode = None
        self._setmode(mode)
        TNavigator.reset(self)

    def reset(self):
        """reset turtle to its initial values

        Will be overwritten by parent class
        """
        self._position = Vec2D(0.0, 0.0)
        self._orient =  TNavigator.START_ORIENTATION[self._mode]

    def _setmode(self, mode=None):
        """Set turtle-mode to 'standard', 'world' or 'logo'.
        """
        if mode is None:
            return self._mode
        if mode not in ["standard", "logo", "world"]:
            return
        self._mode = mode
        if mode in ["standard", "world"]:
            self._angleOffset = 0
            self._angleOrient = 1
        else: # mode == "logo":
            self._angleOffset = self._fullcircle/4.
            self._angleOrient = -1

    def _setDegreesPerAU(self, fullcircle):
        """Helper function for degrees() and radians()"""
        self._fullcircle = fullcircle
        self._degreesPerAU = 360/fullcircle
        if self._mode == "standard":
            self._angleOffset = 0
        else:
            self._angleOffset = fullcircle/4.

    def degrees(self, fullcircle=360.0):
        """ Set angle measurement units to degrees.

        Optional argument:
        fullcircle -  a number

        Set angle measurement units, i. e. set number
        of 'degrees' for a full circle. Dafault value is
        360 degrees.

        Example (for a Turtle instance named turtle):
        >>> turtle.left(90)
        >>> turtle.heading()
        90

        Change angle measurement unit to grad (also known as gon,
        grade, or gradian and equals 1/100-th of the right angle.)
        >>> turtle.degrees(400.0)
        >>> turtle.heading()
        100

        """
        self._setDegreesPerAU(fullcircle)

    def radians(self):
        """ Set the angle measurement units to radians.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        90
        >>> turtle.radians()
        >>> turtle.heading()
        1.5707963267948966
        """
        self._setDegreesPerAU(2*math.pi)

    def _go(self, distance):
        """move turtle forward by specified distance"""
        ende = self._position + self._orient * distance
        self._goto(ende)

    def _rotate(self, angle):
        """Turn turtle counterclockwise by specified angle if angle > 0."""
        angle *= self._degreesPerAU
        self._orient = self._orient.rotate(angle)

    def _goto(self, end):
        """move turtle to position end."""
        self._position = end

    def forward(self, distance):
        """Move the turtle forward by the specified distance.

        Aliases: forward | fd

        Argument:
        distance -- a number (integer or float)

        Move the turtle forward by the specified distance, in the direction
        the turtle is headed.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 0.00)
        >>> turtle.forward(25)
        >>> turtle.position()
        (25.00,0.00)
        >>> turtle.forward(-75)
        >>> turtle.position()
        (-50.00,0.00)
        """
        self._go(distance)

    def back(self, distance):
        """Move the turtle backward by distance.

        Aliases: back | backward | bk

        Argument:
        distance -- a number

        Move the turtle backward by distance ,opposite to the direction the
        turtle is headed. Do not change the turtle's heading.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 0.00)
        >>> turtle.backward(30)
        >>> turtle.position()
        (-30.00, 0.00)
        """
        self._go(-distance)

    def right(self, angle):
        """Turn turtle right by angle units.

        Aliases: right | rt

        Argument:
        angle -- a number (integer or float)

        Turn turtle right by angle units. (Units are by default degrees,
        but can be set via the degrees() and radians() functions.)
        Angle orientation depends on mode. (See this.)

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        22.0
        >>> turtle.right(45)
        >>> turtle.heading()
        337.0
        """
        self._rotate(-angle)

    def left(self, angle):
        """Turn turtle left by angle units.

        Aliases: left | lt

        Argument:
        angle -- a number (integer or float)

        Turn turtle left by angle units. (Units are by default degrees,
        but can be set via the degrees() and radians() functions.)
        Angle orientation depends on mode. (See this.)

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        22.0
        >>> turtle.left(45)
        >>> turtle.heading()
        67.0
        """
        self._rotate(angle)

    def pos(self):
        """Return the turtle's current location (x,y), as a Vec2D-vector.

        Aliases: pos | position

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (0.00, 240.00)
        """
        return self._position

    def xcor(self):
        """ Return the turtle's x coordinate.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> reset()
        >>> turtle.left(60)
        >>> turtle.forward(100)
        >>> print turtle.xcor()
        50.0
        """
        return self._position[0]

    def ycor(self):
        """ Return the turtle's y coordinate
        ---
        No arguments.

        Example (for a Turtle instance named turtle):
        >>> reset()
        >>> turtle.left(60)
        >>> turtle.forward(100)
        >>> print turtle.ycor()
        86.6025403784
        """
        return self._position[1]


    def goto(self, x, y=None):
        """Move turtle to an absolute position.

        Aliases: setpos | setposition | goto:

        Arguments:
        x -- a number      or     a pair/vector of numbers
        y -- a number             None

        call: goto(x, y)         # two coordinates
        --or: goto((x, y))       # a pair (tuple) of coordinates
        --or: goto(vec)          # e.g. as returned by pos()

        Move turtle to an absolute position. If the pen is down,
        a line will be drawn. The turtle's orientation does not change.

        Example (for a Turtle instance named turtle):
        >>> tp = turtle.pos()
        >>> tp
        (0.00, 0.00)
        >>> turtle.setpos(60,30)
        >>> turtle.pos()
        (60.00,30.00)
        >>> turtle.setpos((20,80))
        >>> turtle.pos()
        (20.00,80.00)
        >>> turtle.setpos(tp)
        >>> turtle.pos()
        (0.00,0.00)
        """
        if y is None:
            self._goto(Vec2D(*x))
        else:
            self._goto(Vec2D(x, y))

    def home(self):
        """Move turtle to the origin - coordinates (0,0).

        No arguments.

        Move turtle to the origin - coordinates (0,0) and set its
        heading to its start-orientation (which depends on mode).

        Example (for a Turtle instance named turtle):
        >>> turtle.home()
        """
        self.goto(0, 0)
        self.setheading(0)

    def setx(self, x):
        """Set the turtle's first coordinate to x

        Argument:
        x -- a number (integer or float)

        Set the turtle's first coordinate to x, leave second coordinate
        unchanged.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 240.00)
        >>> turtle.setx(10)
        >>> turtle.position()
        (10.00, 240.00)
        """
        self._goto(Vec2D(x, self._position[1]))

    def sety(self, y):
        """Set the turtle's second coordinate to y

        Argument:
        y -- a number (integer or float)

        Set the turtle's first coordinate to x, second coordinate remains
        unchanged.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 40.00)
        >>> turtle.sety(-10)
        >>> turtle.position()
        (0.00, -10.00)
        """
        self._goto(Vec2D(self._position[0], y))

    def distance(self, x, y=None):
        """Return the distance from the turtle to (x,y) in turtle step units.

        Arguments:
        x -- a number   or  a pair/vector of numbers   or   a turtle instance
        y -- a number       None                            None

        call: distance(x, y)         # two coordinates
        --or: distance((x, y))       # a pair (tuple) of coordinates
        --or: distance(vec)          # e.g. as returned by pos()
        --or: distance(mypen)        # where mypen is another turtle

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (0.00, 0.00)
        >>> turtle.distance(30,40)
        50.0
        >>> pen = Turtle()
        >>> pen.forward(77)
        >>> turtle.distance(pen)
        77.0
        """
        if y is not None:
            pos = Vec2D(x, y)
        if isinstance(x, Vec2D):
            pos = x
        elif isinstance(x, tuple):
            pos = Vec2D(*x)
        elif isinstance(x, TNavigator):
            pos = x._position
        return abs(pos - self._position)

    def towards(self, x, y=None):
        """Return the angle of the line from the turtle's position to (x, y).

        Arguments:
        x -- a number   or  a pair/vector of numbers   or   a turtle instance
        y -- a number       None                            None

        call: distance(x, y)         # two coordinates
        --or: distance((x, y))       # a pair (tuple) of coordinates
        --or: distance(vec)          # e.g. as returned by pos()
        --or: distance(mypen)        # where mypen is another turtle

        Return the angle, between the line from turtle-position to position
        specified by x, y and the turtle's start orientation. (Depends on
        modes - "standard" or "logo")

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (10.00, 10.00)
        >>> turtle.towards(0,0)
        225.0
        """
        if y is not None:
            pos = Vec2D(x, y)
        if isinstance(x, Vec2D):
            pos = x
        elif isinstance(x, tuple):
            pos = Vec2D(*x)
        elif isinstance(x, TNavigator):
            pos = x._position
        x, y = pos - self._position
        result = round(math.atan2(y, x)*180.0/math.pi, 10) % 360.0
        result /= self._degreesPerAU
        return (self._angleOffset + self._angleOrient*result) % self._fullcircle

    def heading(self):
        """ Return the turtle's current heading.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.left(67)
        >>> turtle.heading()
        67.0
        """
        x, y = self._orient
        result = round(math.atan2(y, x)*180.0/math.pi, 10) % 360.0
        result /= self._degreesPerAU
        return (self._angleOffset + self._angleOrient*result) % self._fullcircle

    def setheading(self, to_angle):
        """Set the orientation of the turtle to to_angle.

        Aliases:  setheading | seth

        Argument:
        to_angle -- a number (integer or float)

        Set the orientation of the turtle to to_angle.
        Here are some common directions in degrees:

         standard - mode:          logo-mode:
        -------------------|--------------------
           0 - east                0 - north
          90 - north              90 - east
         180 - west              180 - south
         270 - south             270 - west

        Example (for a Turtle instance named turtle):
        >>> turtle.setheading(90)
        >>> turtle.heading()
        90
        """
        angle = (to_angle - self.heading())*self._angleOrient
        full = self._fullcircle
        angle = (angle+full/2.)%full - full/2.
        self._rotate(angle)

    def circle(self, radius, extent = None, steps = None):
        """ Draw a circle with given radius.

        Arguments:
        radius -- a number
        extent (optional) -- a number
        steps (optional) -- an integer

        Draw a circle with given radius. The center is radius units left
        of the turtle; extent - an angle - determines which part of the
        circle is drawn. If extent is not given, draw the entire circle.
        If extent is not a full circle, one endpoint of the arc is the
        current pen position. Draw the arc in counterclockwise direction
        if radius is positive, otherwise in clockwise direction. Finally
        the direction of the turtle is changed by the amount of extent.

        As the circle is approximated by an inscribed regular polygon,
        steps determines the number of steps to use. If not given,
        it will be calculated automatically. Maybe used to draw regular
        polygons.

        call: circle(radius)                  # full circle
        --or: circle(radius, extent)          # arc
        --or: circle(radius, extent, steps)
        --or: circle(radius, steps=6)         # 6-sided polygon

        Example (for a Turtle instance named turtle):
        >>> turtle.circle(50)
        >>> turtle.circle(120, 180)  # semicircle
        """
        if self.undobuffer:
            self.undobuffer.push(["seq"])
            self.undobuffer.cumulate = True
        speed = self.speed()
        if extent is None:
            extent = self._fullcircle
        if steps is None:
            frac = abs(extent)/self._fullcircle
            steps = 1+int(min(11+abs(radius)/6.0, 59.0)*frac)
        w = 1.0 * extent / steps
        w2 = 0.5 * w
        l = 2.0 * radius * math.sin(w2*math.pi/180.0*self._degreesPerAU)
        if radius < 0:
            l, w, w2 = -l, -w, -w2
        tr = self.tracer()
        dl = self._delay()
        if speed == 0:
            self.tracer(0, 0)
        else:
            self.speed(0)
        self._rotate(w2)
        for i in range(steps):
            self.speed(speed)
            self._go(l)
            self.speed(0)
            self._rotate(w)
        self._rotate(-w2)
        if speed == 0:
            self.tracer(tr, dl)
        self.speed(speed)
        if self.undobuffer:
            self.undobuffer.cumulate = False

## three dummy methods to be implemented by child class:

    def speed(self, s=0):
        """dummy method - to be overwritten by child class"""
    def tracer(self, a=None, b=None):
        """dummy method - to be overwritten by child class"""
    def _delay(self, n=None):
        """dummy method - to be overwritten by child class"""

    fd = forward
    bk = back
    backward = back
    rt = right
    lt = left
    position = pos
    setpos = goto
    setposition = goto
    seth = setheading


class TPen(object):
    """Drawing part of the RawTurtle.
    Implements drawing properties.
    """
    def __init__(self, resizemode=_CFG["resizemode"]):
        self._resizemode = resizemode # or "user" or "noresize"
        self.undobuffer = None
        TPen._reset(self)

    def _reset(self, pencolor=_CFG["pencolor"],
                     fillcolor=_CFG["fillcolor"]):
        self._pensize = 1
        self._shown = True
        self._pencolor = pencolor
        self._fillcolor = fillcolor
        self._drawing = True
        self._speed = 3
        self._stretchfactor = (1, 1)
        self._tilt = 0
        self._outlinewidth = 1
        ### self.screen = None  # to override by child class

    def resizemode(self, rmode=None):
        """Set resizemode to one of the values: "auto", "user", "noresize".

        (Optional) Argument:
        rmode -- one of the strings "auto", "user", "noresize"

        Different resizemodes have the following effects:
          - "auto" adapts the appearance of the turtle
                   corresponding to the value of pensize.
          - "user" adapts the appearance of the turtle according to the
                   values of stretchfactor and outlinewidth (outline),
                   which are set by shapesize()
          - "noresize" no adaption of the turtle's appearance takes place.
        If no argument is given, return current resizemode.
        resizemode("user") is called by a call of shapesize with arguments.


        Examples (for a Turtle instance named turtle):
        >>> turtle.resizemode("noresize")
        >>> turtle.resizemode()
        'noresize'
        """
        if rmode is None:
            return self._resizemode
        rmode = rmode.lower()
        if rmode in ["auto", "user", "noresize"]:
            self.pen(resizemode=rmode)

    def pensize(self, width=None):
        """Set or return the line thickness.

        Aliases:  pensize | width

        Argument:
        width -- positive number

        Set the line thickness to width or return it. If resizemode is set
        to "auto" and turtleshape is a polygon, that polygon is drawn with
        the same line thickness. If no argument is given, current pensize
        is returned.

        Example (for a Turtle instance named turtle):
        >>> turtle.pensize()
        1
        >>> turtle.pensize(10)   # from here on lines of width 10 are drawn
        """
        if width is None:
            return self._pensize
        self.pen(pensize=width)


    def penup(self):
        """Pull the pen up -- no drawing when moving.

        Aliases: penup | pu | up

        No argument

        Example (for a Turtle instance named turtle):
        >>> turtle.penup()
        """
        if not self._drawing:
            return
        self.pen(pendown=False)

    def pendown(self):
        """Pull the pen down -- drawing when moving.

        Aliases: pendown | pd | down

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.pendown()
        """
        if self._drawing:
            return
        self.pen(pendown=True)

    def isdown(self):
        """Return True if pen is down, False if it's up.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.penup()
        >>> turtle.isdown()
        False
        >>> turtle.pendown()
        >>> turtle.isdown()
        True
        """
        return self._drawing

    def speed(self, speed=None):
        """ Return or set the turtle's speed.

        Optional argument:
        speed -- an integer in the range 0..10 or a speedstring (see below)

        Set the turtle's speed to an integer value in the range 0 .. 10.
        If no argument is given: return current speed.

        If input is a number greater than 10 or smaller than 0.5,
        speed is set to 0.
        Speedstrings  are mapped to speedvalues in the following way:
            'fastest' :  0
            'fast'    :  10
            'normal'  :  6
            'slow'    :  3
            'slowest' :  1
        speeds from 1 to 10 enforce increasingly faster animation of
        line drawing and turtle turning.

        Attention:
        speed = 0 : *no* animation takes place. forward/back makes turtle jump
        and likewise left/right make the turtle turn instantly.

        Example (for a Turtle instance named turtle):
        >>> turtle.speed(3)
        """
        speeds = {'fastest':0, 'fast':10, 'normal':6, 'slow':3, 'slowest':1 }
        if speed is None:
            return self._speed
        if speed in speeds:
            speed = speeds[speed]
        elif 0.5 < speed < 10.5:
            speed = int(round(speed))
        else:
            speed = 0
        self.pen(speed=speed)

    def color(self, *args):
        """Return or set the pencolor and fillcolor.

        Arguments:
        Several input formats are allowed.
        They use 0, 1, 2, or 3 arguments as follows:

        color()
            Return the current pencolor and the current fillcolor
            as a pair of color specification strings as are returned
            by pencolor and fillcolor.
        color(colorstring), color((r,g,b)), color(r,g,b)
            inputs as in pencolor, set both, fillcolor and pencolor,
            to the given value.
        color(colorstring1, colorstring2),
        color((r1,g1,b1), (r2,g2,b2))
            equivalent to pencolor(colorstring1) and fillcolor(colorstring2)
            and analogously, if the other input format is used.

        If turtleshape is a polygon, outline and interior of that polygon
        is drawn with the newly set colors.
        For mor info see: pencolor, fillcolor

        Example (for a Turtle instance named turtle):
        >>> turtle.color('red', 'green')
        >>> turtle.color()
        ('red', 'green')
        >>> colormode(255)
        >>> color((40, 80, 120), (160, 200, 240))
        >>> color()
        ('#285078', '#a0c8f0')
        """
        if args:
            l = len(args)
            if l == 1:
                pcolor = fcolor = args[0]
            elif l == 2:
                pcolor, fcolor = args
            elif l == 3:
                pcolor = fcolor = args
            pcolor = self._colorstr(pcolor)
            fcolor = self._colorstr(fcolor)
            self.pen(pencolor=pcolor, fillcolor=fcolor)
        else:
            return self._color(self._pencolor), self._color(self._fillcolor)

    def pencolor(self, *args):
        """ Return or set the pencolor.

        Arguments:
        Four input formats are allowed:
          - pencolor()
            Return the current pencolor as color specification string,
            possibly in hex-number format (see example).
            May be used as input to another color/pencolor/fillcolor call.
          - pencolor(colorstring)
            s is a Tk color specification string, such as "red" or "yellow"
          - pencolor((r, g, b))
            *a tuple* of r, g, and b, which represent, an RGB color,
            and each of r, g, and b are in the range 0..colormode,
            where colormode is either 1.0 or 255
          - pencolor(r, g, b)
            r, g, and b represent an RGB color, and each of r, g, and b
            are in the range 0..colormode

        If turtleshape is a polygon, the outline of that polygon is drawn
        with the newly set pencolor.

        Example (for a Turtle instance named turtle):
        >>> turtle.pencolor('brown')
        >>> tup = (0.2, 0.8, 0.55)
        >>> turtle.pencolor(tup)
        >>> turtle.pencolor()
        '#33cc8c'
        """
        if args:
            color = self._colorstr(args)
            if color == self._pencolor:
                return
            self.pen(pencolor=color)
        else:
            return self._color(self._pencolor)

    def fillcolor(self, *args):
        """ Return or set the fillcolor.

        Arguments:
        Four input formats are allowed:
          - fillcolor()
            Return the current fillcolor as color specification string,
            possibly in hex-number format (see example).
            May be used as input to another color/pencolor/fillcolor call.
          - fillcolor(colorstring)
            s is a Tk color specification string, such as "red" or "yellow"
          - fillcolor((r, g, b))
            *a tuple* of r, g, and b, which represent, an RGB color,
            and each of r, g, and b are in the range 0..colormode,
            where colormode is either 1.0 or 255
          - fillcolor(r, g, b)
            r, g, and b represent an RGB color, and each of r, g, and b
            are in the range 0..colormode

        If turtleshape is a polygon, the interior of that polygon is drawn
        with the newly set fillcolor.

        Example (for a Turtle instance named turtle):
        >>> turtle.fillcolor('violet')
        >>> col = turtle.pencolor()
        >>> turtle.fillcolor(col)
        >>> turtle.fillcolor(0, .5, 0)
        """
        if args:
            color = self._colorstr(args)
            if color == self._fillcolor:
                return
            self.pen(fillcolor=color)
        else:
            return self._color(self._fillcolor)

    def showturtle(self):
        """Makes the turtle visible.

        Aliases: showturtle | st

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        >>> turtle.showturtle()
        """
        self.pen(shown=True)

    def hideturtle(self):
        """Makes the turtle invisible.

        Aliases: hideturtle | ht

        No argument.

        It's a good idea to do this while you're in the
        middle of a complicated drawing, because hiding
        the turtle speeds up the drawing observably.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        """
        self.pen(shown=False)

    def isvisible(self):
        """Return True if the Turtle is shown, False if it's hidden.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        >>> print turtle.isvisible():
        False
        """
        return self._shown

    def pen(self, pen=None, **pendict):
        """Return or set the pen's attributes.

        Arguments:
            pen -- a dictionary with some or all of the below listed keys.
            **pendict -- one or more keyword-arguments with the below
                         listed keys as keywords.

        Return or set the pen's attributes in a 'pen-dictionary'
        with the following key/value pairs:
           "shown"      :   True/False
           "pendown"    :   True/False
           "pencolor"   :   color-string or color-tuple
           "fillcolor"  :   color-string or color-tuple
           "pensize"    :   positive number
           "speed"      :   number in range 0..10
           "resizemode" :   "auto" or "user" or "noresize"
           "stretchfactor": (positive number, positive number)
           "outline"    :   positive number
           "tilt"       :   number

        This dictionary can be used as argument for a subsequent
        pen()-call to restore the former pen-state. Moreover one
        or more of these attributes can be provided as keyword-arguments.
        This can be used to set several pen attributes in one statement.


        Examples (for a Turtle instance named turtle):
        >>> turtle.pen(fillcolor="black", pencolor="red", pensize=10)
        >>> turtle.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',
        'stretchfactor': (1,1), 'speed': 3}
        >>> penstate=turtle.pen()
        >>> turtle.color("yellow","")
        >>> turtle.penup()
        >>> turtle.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',
        'stretchfactor': (1,1), 'speed': 3}
        >>> p.pen(penstate, fillcolor="green")
        >>> p.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',
        'stretchfactor': (1,1), 'speed': 3}
        """
        _pd =  {"shown"         : self._shown,
                "pendown"       : self._drawing,
                "pencolor"      : self._pencolor,
                "fillcolor"     : self._fillcolor,
                "pensize"       : self._pensize,
                "speed"         : self._speed,
                "resizemode"    : self._resizemode,
                "stretchfactor" : self._stretchfactor,
                "outline"       : self._outlinewidth,
                "tilt"          : self._tilt
               }

        if not (pen or pendict):
            return _pd

        if isinstance(pen, dict):
            p = pen
        else:
            p = {}
        p.update(pendict)

        _p_buf = {}
        for key in p:
            _p_buf[key] = _pd[key]

        if self.undobuffer:
            self.undobuffer.push(("pen", _p_buf))

        newLine = False
        if "pendown" in p:
            if self._drawing != p["pendown"]:
                newLine = True
        if "pencolor" in p:
            if isinstance(p["pencolor"], tuple):
                p["pencolor"] = self._colorstr((p["pencolor"],))
            if self._pencolor != p["pencolor"]:
                newLine = True
        if "pensize" in p:
            if self._pensize != p["pensize"]:
                newLine = True
        if newLine:
            self._newLine()
        if "pendown" in p:
            self._drawing = p["pendown"]
        if "pencolor" in p:
            self._pencolor = p["pencolor"]
        if "pensize" in p:
            self._pensize = p["pensize"]
        if "fillcolor" in p:
            if isinstance(p["fillcolor"], tuple):
                p["fillcolor"] = self._colorstr((p["fillcolor"],))
            self._fillcolor = p["fillcolor"]
        if "speed" in p:
            self._speed = p["speed"]
        if "resizemode" in p:
            self._resizemode = p["resizemode"]
        if "stretchfactor" in p:
            sf = p["stretchfactor"]
            if isinstance(sf, (int, float)):
                sf = (sf, sf)
            self._stretchfactor = sf
        if "outline" in p:
            self._outlinewidth = p["outline"]
        if "shown" in p:
            self._shown = p["shown"]
        if "tilt" in p:
            self._tilt = p["tilt"]
        self._update()

## three dummy methods to be implemented by child class:

    def _newLine(self, usePos = True):
        """dummy method - to be overwritten by child class"""
    def _update(self, count=True, forced=False):
        """dummy method - to be overwritten by child class"""
    def _color(self, args):
        """dummy method - to be overwritten by child class"""
    def _colorstr(self, args):
        """dummy method - to be overwritten by child class"""

    width = pensize
    up = penup
    pu = penup
    pd = pendown
    down = pendown
    st = showturtle
    ht = hideturtle


class _TurtleImage(object):
    """Helper class: Datatype to store Turtle attributes
    """

    def __init__(self, screen, shapeIndex):
        self.screen = screen
        self._type = None
        self._setshape(shapeIndex)

    def _setshape(self, shapeIndex):
        screen = self.screen # RawTurtle.screens[self.screenIndex]
        self.shapeIndex = shapeIndex
        if self._type == "polygon" == screen._shapes[shapeIndex]._type:
            return
        if self._type == "image" == screen._shapes[shapeIndex]._type:
            return
        if self._type in ["image", "polygon"]:
            screen._delete(self._item)
        elif self._type == "compound":
            for item in self._item:
                screen._delete(item)
        self._type = screen._shapes[shapeIndex]._type
        if self._type == "polygon":
            self._item = screen._createpoly()
        elif self._type == "image":
            self._item = screen._createimage(screen._shapes["blank"]._data)
        elif self._type == "compound":
            self._item = [screen._createpoly() for item in
                                          screen._shapes[shapeIndex]._data]


class RawTurtle(TPen, TNavigator):
    """Animation part of the RawTurtle.
    Puts RawTurtle upon a TurtleScreen and provides tools for
    its animation.
    """
    screens = []

    def __init__(self, canvas=None,
                 shape=_CFG["shape"],
                 undobuffersize=_CFG["undobuffersize"],
                 visible=_CFG["visible"]):
        if isinstance(canvas, _Screen):
            self.screen = canvas
        elif isinstance(canvas, TurtleScreen):
            if canvas not in RawTurtle.screens:
                RawTurtle.screens.append(canvas)
            self.screen = canvas
        elif isinstance(canvas, (ScrolledCanvas, Canvas)):
            for screen in RawTurtle.screens:
                if screen.cv == canvas:
                    self.screen = screen
                    break
            else:
                self.screen = TurtleScreen(canvas)
                RawTurtle.screens.append(self.screen)
        else:
            raise TurtleGraphicsError("bad canvas argument %s" % canvas)

        screen = self.screen
        TNavigator.__init__(self, screen.mode())
        TPen.__init__(self)
        screen._turtles.append(self)
        self.drawingLineItem = screen._createline()
        self.turtle = _TurtleImage(screen, shape)
        self._poly = None
        self._creatingPoly = False
        self._fillitem = self._fillpath = None
        self._shown = visible
        self._hidden_from_screen = False
        self.currentLineItem = screen._createline()
        self.currentLine = [self._position]
        self.items = [self.currentLineItem]
        self.stampItems = []
        self._undobuffersize = undobuffersize
        self.undobuffer = Tbuffer(undobuffersize)
        self._update()

    def reset(self):
        """Delete the turtle's drawings and restore its default values.

        No argument.
,
        Delete the turtle's drawings from the screen, re-center the turtle
        and set variables to the default values.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00,-22.00)
        >>> turtle.heading()
        100.0
        >>> turtle.reset()
        >>> turtle.position()
        (0.00,0.00)
        >>> turtle.heading()
        0.0
        """
        TNavigator.reset(self)
        TPen._reset(self)
        self._clear()
        self._drawturtle()
        self._update()

    def setundobuffer(self, size):
        """Set or disable undobuffer.

        Argument:
        size -- an integer or None

        If size is an integer an empty undobuffer of given size is installed.
        Size gives the maximum number of turtle-actions that can be undone
        by the undo() function.
        If size is None, no undobuffer is present.

        Example (for a Turtle instance named turtle):
        >>> turtle.setundobuffer(42)
        """
        if size is None or size <= 0:
            self.undobuffer = None
        else:
            self.undobuffer = Tbuffer(size)

    def undobufferentries(self):
        """Return count of entries in the undobuffer.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> while undobufferentries():
        ...     undo()
        """
        if self.undobuffer is None:
            return 0
        return self.undobuffer.nr_of_items()

    def _clear(self):
        """Delete all of pen's drawings"""
        self._fillitem = self._fillpath = None
        for item in self.items:
            self.screen._delete(item)
        self.currentLineItem = self.screen._createline()
        self.currentLine = []
        if self._drawing:
            self.currentLine.append(self._position)
        self.items = [self.currentLineItem]
        self.clearstamps()
        self.setundobuffer(self._undobuffersize)


    def clear(self):
        """Delete the turtle's drawings from the screen. Do not move turtle.

        No arguments.

        Delete the turtle's drawings from the screen. Do not move turtle.
        State and position of the turtle as well as drawings of other
        turtles are not affected.

        Examples (for a Turtle instance named turtle):
        >>> turtle.clear()
        """
        self._clear()
        self._update()

    def _update_data(self):
        self.screen._incrementudc()
        if self.screen._updatecounter != 0:
            return
        if len(self.currentLine)>1:
            self.screen._drawline(self.currentLineItem, self.currentLine,
                                  self._pencolor, self._pensize)

    def _update(self):
        """Perform a Turtle-data update.
        """
        screen = self.screen
        if screen._tracing == 0:
            return
        elif screen._tracing == 1:
            self._update_data()
            self._drawturtle()
            screen._update()                  # TurtleScreenBase
            screen._delay(screen._delayvalue) # TurtleScreenBase
        else:
            self._update_data()
            if screen._updatecounter == 0:
                for t in screen.turtles():
                    t._drawturtle()
                screen._update()

    def tracer(self, flag=None, delay=None):
        """Turns turtle animation on/off and set delay for update drawings.

        Optional arguments:
        n -- nonnegative  integer
        delay -- nonnegative  integer

        If n is given, only each n-th regular screen update is really performed.
        (Can be used to accelerate the drawing of complex graphics.)
        Second arguments sets delay value (see RawTurtle.delay())

        Example (for a Turtle instance named turtle):
        >>> turtle.tracer(8, 25)
        >>> dist = 2
        >>> for i in range(200):
        ...     turtle.fd(dist)
        ...     turtle.rt(90)
        ...     dist += 2
        """
        return self.screen.tracer(flag, delay)

    def _color(self, args):
        return self.screen._color(args)

    def _colorstr(self, args):
        return self.screen._colorstr(args)

    def _cc(self, args):
        """Convert colortriples to hexstrings.
        """
        if isinstance(args, basestring):
            return args
        try:
            r, g, b = args
        except (TypeError, ValueError):
            raise TurtleGraphicsError("bad color arguments: %s" % str(args))
        if self.screen._colormode == 1.0:
            r, g, b = [round(255.0*x) for x in (r, g, b)]
        if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):
            raise TurtleGraphicsError("bad color sequence: %s" % str(args))
        return "#%02x%02x%02x" % (r, g, b)

    def clone(self):
        """Create and return a clone of the turtle.

        No argument.

        Create and return a clone of the turtle with same position, heading
        and turtle properties.

        Example (for a Turtle instance named mick):
        mick = Turtle()
        joe = mick.clone()
        """
        screen = self.screen
        self._newLine(self._drawing)

        turtle = self.turtle
        self.screen = None
        self.turtle = None  # too make self deepcopy-able

        q = deepcopy(self)

        self.screen = screen
        self.turtle = turtle

        q.screen = screen
        q.turtle = _TurtleImage(screen, self.turtle.shapeIndex)

        screen._turtles.append(q)
        ttype = screen._shapes[self.turtle.shapeIndex]._type
        if ttype == "polygon":
            q.turtle._item = screen._createpoly()
        elif ttype == "image":
            q.turtle._item = screen._createimage(screen._shapes["blank"]._data)
        elif ttype == "compound":
            q.turtle._item = [screen._createpoly() for item in
                              screen._shapes[self.turtle.shapeIndex]._data]
        q.currentLineItem = screen._createline()
        q._update()
        return q

    def shape(self, name=None):
        """Set turtle shape to shape with given name / return current shapename.

        Optional argument:
        name -- a string, which is a valid shapename

        Set turtle shape to shape with given name or, if name is not given,
        return name of current shape.
        Shape with name must exist in the TurtleScreen's shape dictionary.
        Initially there are the following polygon shapes:
        'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.
        To learn about how to deal with shapes see Screen-method register_shape.

        Example (for a Turtle instance named turtle):
        >>> turtle.shape()
        'arrow'
        >>> turtle.shape("turtle")
        >>> turtle.shape()
        'turtle'
        """
        if name is None:
            return self.turtle.shapeIndex
        if not name in self.screen.getshapes():
            raise TurtleGraphicsError("There is no shape named %s" % name)
        self.turtle._setshape(name)
        self._update()

    def shapesize(self, stretch_wid=None, stretch_len=None, outline=None):
        """Set/return turtle's stretchfactors/outline. Set resizemode to "user".

        Optional arguments:
           stretch_wid : positive number
           stretch_len : positive number
           outline  : positive number

        Return or set the pen's attributes x/y-stretchfactors and/or outline.
        Set resizemode to "user".
        If and only if resizemode is set to "user", the turtle will be displayed
        stretched according to its stretchfactors:
        stretch_wid is stretchfactor perpendicular to orientation
        stretch_len is stretchfactor in direction of turtles orientation.
        outline determines the width of the shapes's outline.

        Examples (for a Turtle instance named turtle):
        >>> turtle.resizemode("user")
        >>> turtle.shapesize(5, 5, 12)
        >>> turtle.shapesize(outline=8)
        """
        if stretch_wid is stretch_len is outline is None:
            stretch_wid, stretch_len = self._stretchfactor
            return stretch_wid, stretch_len, self._outlinewidth
        if stretch_wid is not None:
            if stretch_len is None:
                stretchfactor = stretch_wid, stretch_wid
            else:
                stretchfactor = stretch_wid, stretch_len
        elif stretch_len is not None:
            stretchfactor = self._stretchfactor[0], stretch_len
        else:
            stretchfactor = self._stretchfactor
        if outline is None:
            outline = self._outlinewidth
        self.pen(resizemode="user",
                 stretchfactor=stretchfactor, outline=outline)

    def settiltangle(self, angle):
        """Rotate the turtleshape to point in the specified direction

        Optional argument:
        angle -- number

        Rotate the turtleshape to point in the direction specified by angle,
        regardless of its current tilt-angle. DO NOT change the turtle's
        heading (direction of movement).


        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.settiltangle(45)
        >>> stamp()
        >>> turtle.fd(50)
        >>> turtle.settiltangle(-45)
        >>> stamp()
        >>> turtle.fd(50)
        """
        tilt = -angle * self._degreesPerAU * self._angleOrient
        tilt = (tilt * math.pi / 180.0) % (2*math.pi)
        self.pen(resizemode="user", tilt=tilt)

    def tiltangle(self):
        """Return the current tilt-angle.

        No argument.

        Return the current tilt-angle, i. e. the angle between the
        orientation of the turtleshape and the heading of the turtle
        (its direction of movement).

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.tilt(45)
        >>> turtle.tiltangle()
        """
        tilt = -self._tilt * (180.0/math.pi) * self._angleOrient
        return (tilt / self._degreesPerAU) % self._fullcircle

    def tilt(self, angle):
        """Rotate the turtleshape by angle.

        Argument:
        angle - a number

        Rotate the turtleshape by angle from its current tilt-angle,
        but do NOT change the turtle's heading (direction of movement).

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.tilt(30)
        >>> turtle.fd(50)
        >>> turtle.tilt(30)
        >>> turtle.fd(50)
        """
        self.settiltangle(angle + self.tiltangle())

    def _polytrafo(self, poly):
        """Computes transformed polygon shapes from a shape
        according to current position and heading.
        """
        screen = self.screen
        p0, p1 = self._position
        e0, e1 = self._orient
        e = Vec2D(e0, e1 * screen.yscale / screen.xscale)
        e0, e1 = (1.0 / abs(e)) * e
        return [(p0+(e1*x+e0*y)/screen.xscale, p1+(-e0*x+e1*y)/screen.yscale)
                                                           for (x, y) in poly]

    def _drawturtle(self):
        """Manages the correct rendering of the turtle with respect to
        its shape, resizemode, stretch and tilt etc."""
        screen = self.screen
        shape = screen._shapes[self.turtle.shapeIndex]
        ttype = shape._type
        titem = self.turtle._item
        if self._shown and screen._updatecounter == 0 and screen._tracing > 0:
            self._hidden_from_screen = False
            tshape = shape._data
            if ttype == "polygon":
                if self._resizemode == "noresize":
                    w = 1
                    shape = tshape
                else:
                    if self._resizemode == "auto":
                        lx = ly = max(1, self._pensize/5.0)
                        w = self._pensize
                        tiltangle = 0
                    elif self._resizemode == "user":
                        lx, ly = self._stretchfactor
                        w = self._outlinewidth
                        tiltangle = self._tilt
                    shape = [(lx*x, ly*y) for (x, y) in tshape]
                    t0, t1 = math.sin(tiltangle), math.cos(tiltangle)
                    shape = [(t1*x+t0*y, -t0*x+t1*y) for (x, y) in shape]
                shape = self._polytrafo(shape)
                fc, oc = self._fillcolor, self._pencolor
                screen._drawpoly(titem, shape, fill=fc, outline=oc,
                                                      width=w, top=True)
            elif ttype == "image":
                screen._drawimage(titem, self._position, tshape)
            elif ttype == "compound":
                lx, ly = self._stretchfactor
                w = self._outlinewidth
                for item, (poly, fc, oc) in zip(titem, tshape):
                    poly = [(lx*x, ly*y) for (x, y) in poly]
                    poly = self._polytrafo(poly)
                    screen._drawpoly(item, poly, fill=self._cc(fc),
                                     outline=self._cc(oc), width=w, top=True)
        else:
            if self._hidden_from_screen:
                return
            if ttype == "polygon":
                screen._drawpoly(titem, ((0, 0), (0, 0), (0, 0)), "", "")
            elif ttype == "image":
                screen._drawimage(titem, self._position,
                                          screen._shapes["blank"]._data)
            elif ttype == "compound":
                for item in titem:
                    screen._drawpoly(item, ((0, 0), (0, 0), (0, 0)), "", "")
            self._hidden_from_screen = True

##############################  stamp stuff  ###############################

    def stamp(self):
        """Stamp a copy of the turtleshape onto the canvas and return its id.

        No argument.

        Stamp a copy of the turtle shape onto the canvas at the current
        turtle position. Return a stamp_id for that stamp, which can be
        used to delete it by calling clearstamp(stamp_id).

        Example (for a Turtle instance named turtle):
        >>> turtle.color("blue")
        >>> turtle.stamp()
        13
        >>> turtle.fd(50)
        """
        screen = self.screen
        shape = screen._shapes[self.turtle.shapeIndex]
        ttype = shape._type
        tshape = shape._data
        if ttype == "polygon":
            stitem = screen._createpoly()
            if self._resizemode == "noresize":
                w = 1
                shape = tshape
            else:
                if self._resizemode == "auto":
                    lx = ly = max(1, self._pensize/5.0)
                    w = self._pensize
                    tiltangle = 0
                elif self._resizemode == "user":
                    lx, ly = self._stretchfactor
                    w = self._outlinewidth
                    tiltangle = self._tilt
                shape = [(lx*x, ly*y) for (x, y) in tshape]
                t0, t1 = math.sin(tiltangle), math.cos(tiltangle)
                shape = [(t1*x+t0*y, -t0*x+t1*y) for (x, y) in shape]
            shape = self._polytrafo(shape)
            fc, oc = self._fillcolor, self._pencolor
            screen._drawpoly(stitem, shape, fill=fc, outline=oc,
                                                  width=w, top=True)
        elif ttype == "image":
            stitem = screen._createimage("")
            screen._drawimage(stitem, self._position, tshape)
        elif ttype == "compound":
            stitem = []
            for element in tshape:
                item = screen._createpoly()
                stitem.append(item)
            stitem = tuple(stitem)
            lx, ly = self._stretchfactor
            w = self._outlinewidth
            for item, (poly, fc, oc) in zip(stitem, tshape):
                poly = [(lx*x, ly*y) for (x, y) in poly]
                poly = self._polytrafo(poly)
                screen._drawpoly(item, poly, fill=self._cc(fc),
                                 outline=self._cc(oc), width=w, top=True)
        self.stampItems.append(stitem)
        self.undobuffer.push(("stamp", stitem))
        return stitem

    def _clearstamp(self, stampid):
        """does the work for clearstamp() and clearstamps()
        """
        if stampid in self.stampItems:
            if isinstance(stampid, tuple):
                for subitem in stampid:
                    self.screen._delete(subitem)
            else:
                self.screen._delete(stampid)
            self.stampItems.remove(stampid)
        # Delete stampitem from undobuffer if necessary
        # if clearstamp is called directly.
        item = ("stamp", stampid)
        buf = self.undobuffer
        if item not in buf.buffer:
            return
        index = buf.buffer.index(item)
        buf.buffer.remove(item)
        if index <= buf.ptr:
            buf.ptr = (buf.ptr - 1) % buf.bufsize
        buf.buffer.insert((buf.ptr+1)%buf.bufsize, [None])

    def clearstamp(self, stampid):
        """Delete stamp with given stampid

        Argument:
        stampid - an integer, must be return value of previous stamp() call.

        Example (for a Turtle instance named turtle):
        >>> turtle.color("blue")
        >>> astamp = turtle.stamp()
        >>> turtle.fd(50)
        >>> turtle.clearstamp(astamp)
        """
        self._clearstamp(stampid)
        self._update()

    def clearstamps(self, n=None):
        """Delete all or first/last n of turtle's stamps.

        Optional argument:
        n -- an integer

        If n is None, delete all of pen's stamps,
        else if n > 0 delete first n stamps
        else if n < 0 delete last n stamps.

        Example (for a Turtle instance named turtle):
        >>> for i in range(8):
        ...     turtle.stamp(); turtle.fd(30)
        ...
        >>> turtle.clearstamps(2)
        >>> turtle.clearstamps(-2)
        >>> turtle.clearstamps()
        """
        if n is None:
            toDelete = self.stampItems[:]
        elif n >= 0:
            toDelete = self.stampItems[:n]
        else:
            toDelete = self.stampItems[n:]
        for item in toDelete:
            self._clearstamp(item)
        self._update()

    def _goto(self, end):
        """Move the pen to the point end, thereby drawing a line
        if pen is down. All other methods for turtle movement depend
        on this one.
        """
        ## Version mit undo-stuff
        go_modes = ( self._drawing,
                     self._pencolor,
                     self._pensize,
                     isinstance(self._fillpath, list))
        screen = self.screen
        undo_entry = ("go", self._position, end, go_modes,
                      (self.currentLineItem,
                      self.currentLine[:],
                      screen._pointlist(self.currentLineItem),
                      self.items[:])
                      )
        if self.undobuffer:
            self.undobuffer.push(undo_entry)
        start = self._position
        if self._speed and screen._tracing == 1:
            diff = (end-start)
            diffsq = (diff[0]*screen.xscale)**2 + (diff[1]*screen.yscale)**2
            nhops = 1+int((diffsq**0.5)/(3*(1.1**self._speed)*self._speed))
            delta = diff * (1.0/nhops)
            for n in range(1, nhops):
                if n == 1:
                    top = True
                else:
                    top = False
                self._position = start + delta * n
                if self._drawing:
                    screen._drawline(self.drawingLineItem,
                                     (start, self._position),
                                     self._pencolor, self._pensize, top)
                self._update()
            if self._drawing:
                screen._drawline(self.drawingLineItem, ((0, 0), (0, 0)),
                                               fill="", width=self._pensize)
        # Turtle now at end,
        if self._drawing: # now update currentLine
            self.currentLine.append(end)
        if isinstance(self._fillpath, list):
            self._fillpath.append(end)
        ######    vererbung!!!!!!!!!!!!!!!!!!!!!!
        self._position = end
        if self._creatingPoly:
            self._poly.append(end)
        if len(self.currentLine) > 42: # 42! answer to the ultimate question
                                       # of life, the universe and everything
            self._newLine()
        self._update() #count=True)

    def _undogoto(self, entry):
        """Reverse a _goto. Used for undo()
        """
        old, new, go_modes, coodata = entry
        drawing, pc, ps, filling = go_modes
        cLI, cL, pl, items = coodata
        screen = self.screen
        if abs(self._position - new) > 0.5:
            print "undogoto: HALLO-DA-STIMMT-WAS-NICHT!"
        # restore former situation
        self.currentLineItem = cLI
        self.currentLine = cL

        if pl == [(0, 0), (0, 0)]:
            usepc = ""
        else:
            usepc = pc
        screen._drawline(cLI, pl, fill=usepc, width=ps)

        todelete = [i for i in self.items if (i not in items) and
                                       (screen._type(i) == "line")]
        for i in todelete:
            screen._delete(i)
            self.items.remove(i)

        start = old
        if self._speed and screen._tracing == 1:
            diff = old - new
            diffsq = (diff[0]*screen.xscale)**2 + (diff[1]*screen.yscale)**2
            nhops = 1+int((diffsq**0.5)/(3*(1.1**self._speed)*self._speed))
            delta = diff * (1.0/nhops)
            for n in range(1, nhops):
                if n == 1:
                    top = True
                else:
                    top = False
                self._position = new + delta * n
                if drawing:
                    screen._drawline(self.drawingLineItem,
                                     (start, self._position),
                                     pc, ps, top)
                self._update()
            if drawing:
                screen._drawline(self.drawingLineItem, ((0, 0), (0, 0)),
                                               fill="", width=ps)
        # Turtle now at position old,
        self._position = old
        ##  if undo is done during creating a polygon, the last vertex
        ##  will be deleted. if the polygon is entirely deleted,
        ##  creatingPoly will be set to False.
        ##  Polygons created before the last one will not be affected by undo()
        if self._creatingPoly:
            if len(self._poly) > 0:
                self._poly.pop()
            if self._poly == []:
                self._creatingPoly = False
                self._poly = None
        if filling:
            if self._fillpath == []:
                self._fillpath = None
                print "Unwahrscheinlich in _undogoto!"
            elif self._fillpath is not None:
                self._fillpath.pop()
        self._update() #count=True)

    def _rotate(self, angle):
        """Turns pen clockwise by angle.
        """
        if self.undobuffer:
            self.undobuffer.push(("rot", angle, self._degreesPerAU))
        angle *= self._degreesPerAU
        neworient = self._orient.rotate(angle)
        tracing = self.screen._tracing
        if tracing == 1 and self._speed > 0:
            anglevel = 3.0 * self._speed
            steps = 1 + int(abs(angle)/anglevel)
            delta = 1.0*angle/steps
            for _ in range(steps):
                self._orient = self._orient.rotate(delta)
                self._update()
        self._orient = neworient
        self._update()

    def _newLine(self, usePos=True):
        """Closes current line item and starts a new one.
           Remark: if current line became too long, animation
           performance (via _drawline) slowed down considerably.
        """
        if len(self.currentLine) > 1:
            self.screen._drawline(self.currentLineItem, self.currentLine,
                                      self._pencolor, self._pensize)
            self.currentLineItem = self.screen._createline()
            self.items.append(self.currentLineItem)
        else:
            self.screen._drawline(self.currentLineItem, top=True)
        self.currentLine = []
        if usePos:
            self.currentLine = [self._position]

    def fill(self, flag=None):
        """Call fill(True) before drawing a shape to fill, fill(False) when done.

        Optional argument:
        flag -- True/False (or 1/0 respectively)

        Call fill(True) before drawing the shape you want to fill,
        and  fill(False) when done.
        When used without argument: return fillstate (True if filling,
        False else)

        Example (for a Turtle instance named turtle):
        >>> turtle.fill(True)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.fill(False)
        """
        filling = isinstance(self._fillpath, list)
        if flag is None:
            return filling
        screen = self.screen
        entry1 = entry2 = ()
        if filling:
            if len(self._fillpath) > 2:
                self.screen._drawpoly(self._fillitem, self._fillpath,
                                      fill=self._fillcolor)
                entry1 = ("dofill", self._fillitem)
        if flag:
            self._fillitem = self.screen._createpoly()
            self.items.append(self._fillitem)
            self._fillpath = [self._position]
            entry2 = ("beginfill", self._fillitem) # , self._fillpath)
            self._newLine()
        else:
            self._fillitem = self._fillpath = None
        if self.undobuffer:
            if entry1 == ():
                if entry2 != ():
                    self.undobuffer.push(entry2)
            else:
                if entry2 == ():
                    self.undobuffer.push(entry1)
                else:
                    self.undobuffer.push(["seq", entry1, entry2])
        self._update()

    def begin_fill(self):
        """Called just before drawing a shape to be filled.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.begin_fill()
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.end_fill()
        """
        self.fill(True)

    def end_fill(self):
        """Fill the shape drawn after the call begin_fill().

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.begin_fill()
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.end_fill()
        """
        self.fill(False)

    def dot(self, size=None, *color):
        """Draw a dot with diameter size, using color.

        Optional arguments:
        size -- an integer >= 1 (if given)
        color -- a colorstring or a numeric color tuple

        Draw a circular dot with diameter size, using color.
        If size is not given, the maximum of pensize+4 and 2*pensize is used.

        Example (for a Turtle instance named turtle):
        >>> turtle.dot()
        >>> turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)
        """
        #print "dot-1:", size, color
        if not color:
            if isinstance(size, (basestring, tuple)):
                color = self._colorstr(size)
                size = self._pensize + max(self._pensize, 4)
            else:
                color = self._pencolor
                if not size:
                    size = self._pensize + max(self._pensize, 4)
        else:
            if size is None:
                size = self._pensize + max(self._pensize, 4)
            color = self._colorstr(color)
        #print "dot-2:", size, color
        if hasattr(self.screen, "_dot"):
            item = self.screen._dot(self._position, size, color)
            #print "dot:", size, color, "item:", item
            self.items.append(item)
            if self.undobuffer:
                self.undobuffer.push(("dot", item))
        else:
            pen = self.pen()
            if self.undobuffer:
                self.undobuffer.push(["seq"])
                self.undobuffer.cumulate = True
            try:
                if self.resizemode() == 'auto':
                    self.ht()
                self.pendown()
                self.pensize(size)
                self.pencolor(color)
                self.forward(0)
            finally:
                self.pen(pen)
            if self.undobuffer:
                self.undobuffer.cumulate = False

    def _write(self, txt, align, font):
        """Performs the writing for write()
        """
        item, end = self.screen._write(self._position, txt, align, font,
                                                          self._pencolor)
        self.items.append(item)
        if self.undobuffer:
            self.undobuffer.push(("wri", item))
        return end

    def write(self, arg, move=False, align="left", font=("Arial", 8, "normal")):
        """Write text at the current turtle position.

        Arguments:
        arg -- info, which is to be written to the TurtleScreen
        move (optional) -- True/False
        align (optional) -- one of the strings "left", "center" or right"
        font (optional) -- a triple (fontname, fontsize, fonttype)

        Write text - the string representation of arg - at the current
        turtle position according to align ("left", "center" or right")
        and with the given font.
        If move is True, the pen is moved to the bottom-right corner
        of the text. By default, move is False.

        Example (for a Turtle instance named turtle):
        >>> turtle.write('Home = ', True, align="center")
        >>> turtle.write((0,0), True)
        """
        if self.undobuffer:
            self.undobuffer.push(["seq"])
            self.undobuffer.cumulate = True
        end = self._write(str(arg), align.lower(), font)
        if move:
            x, y = self.pos()
            self.setpos(end, y)
        if self.undobuffer:
            self.undobuffer.cumulate = False

    def begin_poly(self):
        """Start recording the vertices of a polygon.

        No argument.

        Start recording the vertices of a polygon. Current turtle position
        is first point of polygon.

        Example (for a Turtle instance named turtle):
        >>> turtle.begin_poly()
        """
        self._poly = [self._position]
        self._creatingPoly = True

    def end_poly(self):
        """Stop recording the vertices of a polygon.

        No argument.

        Stop recording the vertices of a polygon. Current turtle position is
        last point of polygon. This will be connected with the first point.

        Example (for a Turtle instance named turtle):
        >>> turtle.end_poly()
        """
        self._creatingPoly = False

    def get_poly(self):
        """Return the lastly recorded polygon.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> p = turtle.get_poly()
        >>> turtle.register_shape("myFavouriteShape", p)
        """
        ## check if there is any poly?  -- 1st solution:
        if self._poly is not None:
            return tuple(self._poly)

    def getscreen(self):
        """Return the TurtleScreen object, the turtle is drawing  on.

        No argument.

        Return the TurtleScreen object, the turtle is drawing  on.
        So TurtleScreen-methods can be called for that object.

        Example (for a Turtle instance named turtle):
        >>> ts = turtle.getscreen()
        >>> ts
        <turtle.TurtleScreen object at 0x0106B770>
        >>> ts.bgcolor("pink")
        """
        return self.screen

    def getturtle(self):
        """Return the Turtleobject itself.

        No argument.

        Only reasonable use: as a function to return the 'anonymous turtle':

        Example:
        >>> pet = getturtle()
        >>> pet.fd(50)
        >>> pet
        <turtle.Turtle object at 0x0187D810>
        >>> turtles()
        [<turtle.Turtle object at 0x0187D810>]
        """
        return self

    getpen = getturtle


    ################################################################
    ### screen oriented methods recurring to methods of TurtleScreen
    ################################################################

    def window_width(self):
        """ Returns the width of the turtle window.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_width()
        640
        """
        return self.screen._window_size()[0]

    def window_height(self):
        """ Return the height of the turtle window.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_height()
        480
        """
        return self.screen._window_size()[1]

    def _delay(self, delay=None):
        """Set delay value which determines speed of turtle animation.
        """
        return self.screen.delay(delay)

    #####   event binding methods   #####

    def onclick(self, fun, btn=1, add=None):
        """Bind fun to mouse-click event on this turtle on canvas.

        Arguments:
        fun --  a function with two arguments, to which will be assigned
                the coordinates of the clicked point on the canvas.
        num --  number of the mouse-button defaults to 1 (left mouse button).
        add --  True or False. If True, new binding will be added, otherwise
                it will replace a former binding.

        Example for the anonymous turtle, i. e. the procedural way:

        >>> def turn(x, y):
        ...     left(360)
        ...
        >>> onclick(turn)  # Now clicking into the turtle will turn it.
        >>> onclick(None)  # event-binding will be removed
        """
        self.screen._onclick(self.turtle._item, fun, btn, add)
        self._update()

    def onrelease(self, fun, btn=1, add=None):
        """Bind fun to mouse-button-release event on this turtle on canvas.

        Arguments:
        fun -- a function with two arguments, to which will be assigned
                the coordinates of the clicked point on the canvas.
        num --  number of the mouse-button defaults to 1 (left mouse button).

        Example (for a MyTurtle instance named joe):
        >>> class MyTurtle(Turtle):
        ...     def glow(self,x,y):
        ...             self.fillcolor("red")
        ...     def unglow(self,x,y):
        ...             self.fillcolor("")
        ...
        >>> joe = MyTurtle()
        >>> joe.onclick(joe.glow)
        >>> joe.onrelease(joe.unglow)

        Clicking on joe turns fillcolor red, unclicking turns it to
        transparent.
        """
        self.screen._onrelease(self.turtle._item, fun, btn, add)
        self._update()

    def ondrag(self, fun, btn=1, add=None):
        """Bind fun to mouse-move event on this turtle on canvas.

        Arguments:
        fun -- a function with two arguments, to which will be assigned
               the coordinates of the clicked point on the canvas.
        num -- number of the mouse-button defaults to 1 (left mouse button).

        Every sequence of mouse-move-events on a turtle is preceded by a
        mouse-click event on that turtle.

        Example (for a Turtle instance named turtle):
        >>> turtle.ondrag(turtle.goto)

        Subsequently clicking and dragging a Turtle will move it
        across the screen thereby producing handdrawings (if pen is
        down).
        """
        self.screen._ondrag(self.turtle._item, fun, btn, add)


    def _undo(self, action, data):
        """Does the main part of the work for undo()
        """
        if self.undobuffer is None:
            return
        if action == "rot":
            angle, degPAU = data
            self._rotate(-angle*degPAU/self._degreesPerAU)
            dummy = self.undobuffer.pop()
        elif action == "stamp":
            stitem = data[0]
            self.clearstamp(stitem)
        elif action == "go":
            self._undogoto(data)
        elif action in ["wri", "dot"]:
            item = data[0]
            self.screen._delete(item)
            self.items.remove(item)
        elif action == "dofill":
            item = data[0]
            self.screen._drawpoly(item, ((0, 0),(0, 0),(0, 0)),
                                  fill="", outline="")
        elif action == "beginfill":
            item = data[0]
            self._fillitem = self._fillpath = None
            self.screen._delete(item)
            self.items.remove(item)
        elif action == "pen":
            TPen.pen(self, data[0])
            self.undobuffer.pop()

    def undo(self):
        """undo (repeatedly) the last turtle action.

        No argument.

        undo (repeatedly) the last turtle action.
        Number of available undo actions is determined by the size of
        the undobuffer.

        Example (for a Turtle instance named turtle):
        >>> for i in range(4):
        ...     turtle.fd(50); turtle.lt(80)
        ...
        >>> for i in range(8):
        ...     turtle.undo()
        ...
        """
        if self.undobuffer is None:
            return
        item = self.undobuffer.pop()
        action = item[0]
        data = item[1:]
        if action == "seq":
            while data:
                item = data.pop()
                self._undo(item[0], item[1:])
        else:
            self._undo(action, data)

    turtlesize = shapesize

RawPen = RawTurtle

###  Screen - Singleton  ########################

def Screen():
    """Return the singleton screen object.
    If none exists at the moment, create a new one and return it,
    else return the existing one."""
    if Turtle._screen is None:
        Turtle._screen = _Screen()
    return Turtle._screen

class _Screen(TurtleScreen):

    _root = None
    _canvas = None
    _title = _CFG["title"]

    def __init__(self):
        # XXX there is no need for this code to be conditional,
        # as there will be only a single _Screen instance, anyway
        # XXX actually, the turtle demo is injecting root window,
        # so perhaps the conditional creation of a root should be
        # preserved (perhaps by passing it as an optional parameter)
        if _Screen._root is None:
            _Screen._root = self._root = _Root()
            self._root.title(_Screen._title)
            self._root.ondestroy(self._destroy)
        if _Screen._canvas is None:
            width = _CFG["width"]
            height = _CFG["height"]
            canvwidth = _CFG["canvwidth"]
            canvheight = _CFG["canvheight"]
            leftright = _CFG["leftright"]
            topbottom = _CFG["topbottom"]
            self._root.setupcanvas(width, height, canvwidth, canvheight)
            _Screen._canvas = self._root._getcanvas()
            TurtleScreen.__init__(self, _Screen._canvas)
            self.setup(width, height, leftright, topbottom)

    def setup(self, width=_CFG["width"], height=_CFG["height"],
              startx=_CFG["leftright"], starty=_CFG["topbottom"]):
        """ Set the size and position of the main window.

        Arguments:
        width: as integer a size in pixels, as float a fraction of the screen.
          Default is 50% of screen.
        height: as integer the height in pixels, as float a fraction of the
          screen. Default is 75% of screen.
        startx: if positive, starting position in pixels from the left
          edge of the screen, if negative from the right edge
          Default, startx=None is to center window horizontally.
        starty: if positive, starting position in pixels from the top
          edge of the screen, if negative from the bottom edge
          Default, starty=None is to center window vertically.

        Examples (for a Screen instance named screen):
        >>> screen.setup (width=200, height=200, startx=0, starty=0)

        sets window to 200x200 pixels, in upper left of screen

        >>> screen.setup(width=.75, height=0.5, startx=None, starty=None)

        sets window to 75% of screen by 50% of screen and centers
        """
        if not hasattr(self._root, "set_geometry"):
            return
        sw = self._root.win_width()
        sh = self._root.win_height()
        if isinstance(width, float) and 0 <= width <= 1:
            width = sw*width
        if startx is None:
            startx = (sw - width) / 2
        if isinstance(height, float) and 0 <= height <= 1:
            height = sh*height
        if starty is None:
            starty = (sh - height) / 2
        self._root.set_geometry(width, height, startx, starty)
        self.update()

    def title(self, titlestring):
        """Set title of turtle-window

        Argument:
        titlestring -- a string, to appear in the titlebar of the
                       turtle graphics window.

        This is a method of Screen-class. Not available for TurtleScreen-
        objects.

        Example (for a Screen instance named screen):
        >>> screen.title("Welcome to the turtle-zoo!")
        """
        if _Screen._root is not None:
            _Screen._root.title(titlestring)
        _Screen._title = titlestring

    def _destroy(self):
        root = self._root
        if root is _Screen._root:
            Turtle._pen = None
            Turtle._screen = None
            _Screen._root = None
            _Screen._canvas = None
        TurtleScreen._RUNNING = False
        root.destroy()

    def bye(self):
        """Shut the turtlegraphics window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bye()
        """
        self._destroy()

    def exitonclick(self):
        """Go into mainloop until the mouse is clicked.

        No arguments.

        Bind bye() method to mouseclick on TurtleScreen.
        If "using_IDLE" - value in configuration dictionary is False
        (default value), enter mainloop.
        If IDLE with -n switch (no subprocess) is used, this value should be
        set to True in turtle.cfg. In this case IDLE's mainloop
        is active also for the client script.

        This is a method of the Screen-class and not available for
        TurtleScreen instances.

        Example (for a Screen instance named screen):
        >>> screen.exitonclick()

        """
        def exitGracefully(x, y):
            """Screen.bye() with two dummy-parameters"""
            self.bye()
        self.onclick(exitGracefully)
        if _CFG["using_IDLE"]:
            return
        try:
            mainloop()
        except AttributeError:
            exit(0)

class Turtle(RawTurtle):
    """RawTurtle auto-creating (scrolled) canvas.

    When a Turtle object is created or a function derived from some
    Turtle method is called a TurtleScreen object is automatically created.
    """
    _pen = None
    _screen = None

    def __init__(self,
                 shape=_CFG["shape"],
                 undobuffersize=_CFG["undobuffersize"],
                 visible=_CFG["visible"]):
        if Turtle._screen is None:
            Turtle._screen = Screen()
        RawTurtle.__init__(self, Turtle._screen,
                           shape=shape,
                           undobuffersize=undobuffersize,
                           visible=visible)

Pen = Turtle

def write_docstringdict(filename="turtle_docstringdict"):
    """Create and write docstring-dictionary to file.

    Optional argument:
    filename -- a string, used as filename
                default value is turtle_docstringdict

    Has to be called explicitly, (not used by the turtle-graphics classes)
    The docstring dictionary will be written to the Python script <filname>.py
    It is intended to serve as a template for translation of the docstrings
    into different languages.
    """
    docsdict = {}

    for methodname in _tg_screen_functions:
        key = "_Screen."+methodname
        docsdict[key] = eval(key).__doc__
    for methodname in _tg_turtle_functions:
        key = "Turtle."+methodname
        docsdict[key] = eval(key).__doc__

    f = open("%s.py" % filename,"w")
    keys = sorted([x for x in docsdict.keys()
                        if x.split('.')[1] not in _alias_list])
    f.write('docsdict = {\n\n')
    for key in keys[:-1]:
        f.write('%s :\n' % repr(key))
        f.write('        """%s\n""",\n\n' % docsdict[key])
    key = keys[-1]
    f.write('%s :\n' % repr(key))
    f.write('        """%s\n"""\n\n' % docsdict[key])
    f.write("}\n")
    f.close()

def read_docstrings(lang):
    """Read in docstrings from lang-specific docstring dictionary.

    Transfer docstrings, translated to lang, from a dictionary-file
    to the methods of classes Screen and Turtle and - in revised form -
    to the corresponding functions.
    """
    modname = "turtle_docstringdict_%(language)s" % {'language':lang.lower()}
    module = __import__(modname)
    docsdict = module.docsdict
    for key in docsdict:
        #print key
        try:
            eval(key).im_func.__doc__ = docsdict[key]
        except BaseException:
            print "Bad docstring-entry: %s" % key

_LANGUAGE = _CFG["language"]

try:
    if _LANGUAGE != "english":
        read_docstrings(_LANGUAGE)
except ImportError:
    print "Cannot find docsdict for", _LANGUAGE
except BaseException:
    print ("Unknown Error when trying to import %s-docstring-dictionary" %
                                                                  _LANGUAGE)


def getmethparlist(ob):
    "Get strings describing the arguments for the given object"
    argText1 = argText2 = ""
    # bit of a hack for methods - turn it into a function
    # but we drop the "self" param.
    if type(ob)==types.MethodType:
        fob = ob.im_func
        argOffset = 1
    else:
        fob = ob
        argOffset = 0
    # Try and build one for Python defined functions
    if type(fob) in [types.FunctionType, types.LambdaType]:
        try:
            counter = fob.func_code.co_argcount
            items2 = list(fob.func_code.co_varnames[argOffset:counter])
            realArgs = fob.func_code.co_varnames[argOffset:counter]
            defaults = fob.func_defaults or []
            defaults = list(map(lambda name: "=%s" % repr(name), defaults))
            defaults = [""] * (len(realArgs)-len(defaults)) + defaults
            items1 = map(lambda arg, dflt: arg+dflt, realArgs, defaults)
            if fob.func_code.co_flags & 0x4:
                items1.append("*"+fob.func_code.co_varnames[counter])
                items2.append("*"+fob.func_code.co_varnames[counter])
                counter += 1
            if fob.func_code.co_flags & 0x8:
                items1.append("**"+fob.func_code.co_varnames[counter])
                items2.append("**"+fob.func_code.co_varnames[counter])
            argText1 = ", ".join(items1)
            argText1 = "(%s)" % argText1
            argText2 = ", ".join(items2)
            argText2 = "(%s)" % argText2
        except:
            pass
    return argText1, argText2

def _turtle_docrevise(docstr):
    """To reduce docstrings from RawTurtle class for functions
    """
    import re
    if docstr is None:
        return None
    turtlename = _CFG["exampleturtle"]
    newdocstr = docstr.replace("%s." % turtlename,"")
    parexp = re.compile(r' \(.+ %s\):' % turtlename)
    newdocstr = parexp.sub(":", newdocstr)
    return newdocstr

def _screen_docrevise(docstr):
    """To reduce docstrings from TurtleScreen class for functions
    """
    import re
    if docstr is None:
        return None
    screenname = _CFG["examplescreen"]
    newdocstr = docstr.replace("%s." % screenname,"")
    parexp = re.compile(r' \(.+ %s\):' % screenname)
    newdocstr = parexp.sub(":", newdocstr)
    return newdocstr

## The following mechanism makes all methods of RawTurtle and Turtle available
## as functions. So we can enhance, change, add, delete methods to these
## classes and do not need to change anything here.

__func_body = """\
def {name}{paramslist}:
    if {obj} is None:
        if not TurtleScreen._RUNNING:
            TurtleScreen._RUNNING = True
            raise Terminator
        {obj} = {init}
    try:
        return {obj}.{name}{argslist}
    except TK.TclError:
        if not TurtleScreen._RUNNING:
            TurtleScreen._RUNNING = True
            raise Terminator
        raise
"""

def _make_global_funcs(functions, cls, obj, init, docrevise):
    for methodname in functions:
        method = getattr(cls, methodname)
        pl1, pl2 = getmethparlist(method)
        if pl1 == "":
            print ">>>>>>", pl1, pl2
            continue
        defstr = __func_body.format(obj=obj, init=init, name=methodname,
                                    paramslist=pl1, argslist=pl2)
        exec defstr in globals()
        globals()[methodname].__doc__ = docrevise(method.__doc__)

_make_global_funcs(_tg_screen_functions, _Screen,
                   'Turtle._screen', 'Screen()', _screen_docrevise)
_make_global_funcs(_tg_turtle_functions, Turtle,
                   'Turtle._pen', 'Turtle()', _turtle_docrevise)


done = mainloop = TK.mainloop

if __name__ == "__main__":
    def switchpen():
        if isdown():
            pu()
        else:
            pd()

    def demo1():
        """Demo of old turtle.py - module"""
        reset()
        tracer(True)
        up()
        backward(100)
        down()
        # draw 3 squares; the last filled
        width(3)
        for i in range(3):
            if i == 2:
                fill(1)
            for _ in range(4):
                forward(20)
                left(90)
            if i == 2:
                color("maroon")
                fill(0)
            up()
            forward(30)
            down()
        width(1)
        color("black")
        # move out of the way
        tracer(False)
        up()
        right(90)
        forward(100)
        right(90)
        forward(100)
        right(180)
        down()
        # some text
        write("startstart", 1)
        write(u"start", 1)
        color("red")
        # staircase
        for i in range(5):
            forward(20)
            left(90)
            forward(20)
            right(90)
        # filled staircase
        tracer(True)
        fill(1)
        for i in range(5):
            forward(20)
            left(90)
            forward(20)
            right(90)
        fill(0)
        # more text

    def demo2():
        """Demo of some new features."""
        speed(1)
        st()
        pensize(3)
        setheading(towards(0, 0))
        radius = distance(0, 0)/2.0
        rt(90)
        for _ in range(18):
            switchpen()
            circle(radius, 10)
        write("wait a moment...")
        while undobufferentries():
            undo()
        reset()
        lt(90)
        colormode(255)
        laenge = 10
        pencolor("green")
        pensize(3)
        lt(180)
        for i in range(-2, 16):
            if i > 0:
                begin_fill()
                fillcolor(255-15*i, 0, 15*i)
            for _ in range(3):
                fd(laenge)
                lt(120)
            laenge += 10
            lt(15)
            speed((speed()+1)%12)
        end_fill()

        lt(120)
        pu()
        fd(70)
        rt(30)
        pd()
        color("red","yellow")
        speed(0)
        fill(1)
        for _ in range(4):
            circle(50, 90)
            rt(90)
            fd(30)
            rt(90)
        fill(0)
        lt(90)
        pu()
        fd(30)
        pd()
        shape("turtle")

        tri = getturtle()
        tri.resizemode("auto")
        turtle = Turtle()
        turtle.resizemode(u"auto")
        turtle.shape("turtle")
        turtle.reset()
        turtle.left(90)
        turtle.speed(0)
        turtle.up()
        turtle.goto(280, 40)
        turtle.lt(30)
        turtle.down()
        turtle.speed(6)
        turtle.color("blue",u"orange")
        turtle.pensize(2)
        tri.speed(6)
        setheading(towards(turtle))
        count = 1
        while tri.distance(turtle) > 4:
            turtle.fd(3.5)
            turtle.lt(0.6)
            tri.setheading(tri.towards(turtle))
            tri.fd(4)
            if count % 20 == 0:
                turtle.stamp()
                tri.stamp()
                switchpen()
            count += 1
        tri.write("CAUGHT! ", font=("Arial", 16, "bold"), align=u"right")
        tri.pencolor("black")
        tri.pencolor(u"red")

        def baba(xdummy, ydummy):
            clearscreen()
            bye()

        time.sleep(2)

        while undobufferentries():
            tri.undo()
            turtle.undo()
        tri.fd(50)
        tri.write("  Click me!", font = ("Courier", 12, "bold") )
        tri.onclick(baba, 1)

    demo1()
    demo2()
    exitonclick()
                                                                                                                                                                                                                              
[c        O   @   s+  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m	 Z	 m
 Z
 m Z d d l m Z d d l Td d d	 d
 d d d d d g	 Z d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) g Z d* d+ d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA dB dC dD dE dF dG dH dI dJ dK dL dM dN dO dP dQ dR dS dT dU dV dW dX dY dZ d[ d\ d] d^ d_ d` da db dc dd de df dg dh di dj dk dl dm d% dn do dp dq dr d( d) ds dt du gO Z dv dw dx g Z dy dz d{ d| d} d~ d d d d d d d d d d d d d d d d d d d g Z e e e e d g e Z d d+ d. d; dG dK dO dU dW d\ d] d_ d` di dn dq dr g Z i d dr 6d d 6d d 6d d 6e d 6e d 6d d 6d d 6d d 6d d 6d de 6d dQ 6d d= 6d d[ 6e d 6d d 6d d 6d d 6d d$ 6e d 6Z d   Z d   Z y e e  Wn e k
 rfd GHn Xd e f d     YZ d   Z d   Z d d Z  f  d  Z! d e j" f d     YZ# e! e# e j$ d  d e j% f d     YZ& e j$ Z$ d e' f d     YZ( d e) f d     YZ* d e) f d     YZ+ d e' f d     YZ, d e' f d     YZ- d e( f d     YZ. d e' f d     YZ/ d e' f d     YZ0 d e' f d     YZ1 d
 e0 e/ f d     YZ2 e2 Z3 d   Z4 d e. f d     YZ5 d e2 f d     YZ6 e6 Z7 d d  Z8 d   Z9 e d Z: y e: d k rNe9 e:  n  Wn3 e; k
 rkd Ge: GHn e k
 rd e: GHn Xd   Z< d   Z= d   Z> d Z? d   Z@ e@ e e5 d d e>  e@ e e6 d d e=  e jA ZB ZA eC d k r'd   ZD d   ZE d   ZF eE   eF   eG   n  d S(   s  
Turtle graphics is a popular way for introducing programming to
kids. It was part of the original Logo programming language developed
by Wally Feurzig and Seymour Papert in 1966.

Imagine a robotic turtle starting at (0, 0) in the x-y plane. After an ``import turtle``, give it
the command turtle.forward(15), and it moves (on-screen!) 15 pixels in
the direction it is facing, drawing a line as it moves. Give it the
command turtle.right(25), and it rotates in-place 25 degrees clockwise.

By combining together these and similar commands, intricate shapes and
pictures can easily be drawn.

----- turtle.py

This module is an extended reimplementation of turtle.py from the
Python standard distribution up to Python 2.5. (See: http://www.python.org)

It tries to keep the merits of turtle.py and to be (nearly) 100%
compatible with it. This means in the first place to enable the
learning programmer to use all the commands, classes and methods
interactively when using the module from within IDLE run with
the -n switch.

Roughly it has the following features added:

- Better animation of the turtle movements, especially of turning the
  turtle. So the turtles can more easily be used as a visual feedback
  instrument by the (beginning) programmer.

- Different turtle shapes, gif-images as turtle shapes, user defined
  and user controllable turtle shapes, among them compound
  (multicolored) shapes. Turtle shapes can be stretched and tilted, which
  makes turtles very versatile geometrical objects.

- Fine control over turtle movement and screen updates via delay(),
  and enhanced tracer() and speed() methods.

- Aliases for the most commonly used commands, like fd for forward etc.,
  following the early Logo traditions. This reduces the boring work of
  typing long sequences of commands, which often occur in a natural way
  when kids try to program fancy pictures on their first encounter with
  turtle graphics.

- Turtles now have an undo()-method with configurable undo-buffer.

- Some simple commands/methods for creating event driven programs
  (mouse-, key-, timer-events). Especially useful for programming games.

- A scrollable Canvas class. The default scrollable Canvas can be
  extended interactively as needed while playing around with the turtle(s).

- A TurtleScreen class with methods controlling background color or
  background image, window and canvas size and other properties of the
  TurtleScreen.

- There is a method, setworldcoordinates(), to install a user defined
  coordinate-system for the TurtleScreen.

- The implementation uses a 2-vector class named Vec2D, derived from tuple.
  This class is public, so it can be imported by the application programmer,
  which makes certain types of computations very natural and compact.

- Appearance of the TurtleScreen and the Turtles at startup/import can be
  configured by means of a turtle.cfg configuration file.
  The default configuration mimics the appearance of the old turtle module.

- If configured appropriately the module reads in docstrings from a docstring
  dictionary in some different language, supplied separately  and replaces
  the English ones by those read in. There is a utility function
  write_docstringdict() to write a dictionary with the original (English)
  docstrings to disc, so it can serve as a template for translations.

Behind the scenes there are some features included with possible
extensions in mind. These will be commented and documented elsewhere.

s5   turtle 1.0b1 - for Python 2.6   -  30. 5. 2008, 18:08iN(   t   isfilet   splitt   join(   t   deepcopy(   t   *t   ScrolledCanvast   TurtleScreent   Screent	   RawTurtlet   Turtlet   RawPent   Pent   Shapet   Vec2Dt   addshapet   bgcolort   bgpict   byet   clearscreent	   colormodet   delayt   exitonclickt	   getcanvast	   getshapest   listent   modet   onkeyt   onscreenclickt   ontimert   register_shapet   resetscreent
   screensizet   setupt   setworldcoordinatest   titlet   tracert   turtlest   updatet   window_heightt   window_widtht   backt   backwardt
   begin_fillt
   begin_polyt   bkt   circlet   cleart
   clearstampt   clearstampst   clonet   colort   degreest   distancet   dott   downt   end_fillt   end_polyt   fdt   fillt	   fillcolort   forwardt   get_polyt   getpent	   getscreent	   getturtlet   gotot   headingt
   hideturtlet   homet   htt   isdownt	   isvisiblet   leftt   ltt   onclickt   ondragt	   onreleaset   pdt   pent   pencolort   pendownt   pensizet   penupt   post   positiont   put   radianst   rightt   resett
   resizemodet   rtt   setht
   setheadingt   setpost   setpositiont   settiltanglet   setundobuffert   setxt   setyt   shapet	   shapesizet
   showturtlet   speedt   stt   stampt   tiltt	   tiltanglet   towardst
   turtlesizet   undot   undobufferentriest   upt   widtht   writet   xcort   ycort   write_docstringdictt   donet   mainloopt   acost   asint   atant   atan2t   ceilt   cost   cosht   et   expt   fabst   floort   fmodt   frexpt   hypott   ldexpt   logt   log10t   modft   pit   powt   sint   sinht   sqrtt   tant   tanht
   Terminatorg      ?g      ?t   heighti  t	   canvwidthi,  t
   canvheightt	   leftrightt	   topbottomt   standardg      ?i
   i  t   undobuffersizet   classict   blackt   noresizet   visiblet   englisht   languaget   turtlet   exampleturtlet   screent   examplescreens   Python Turtle Graphicst
   using_IDLEc         C   s#  t  |  d  } | j   } | j   i  } x | D] } | j   } | s2 | j d  r` q2 n  y | j d  \ } } Wn# t k
 r d |  | f GHq2 n X| j   } | j   } | d k r t |  } n? y+ d
 | k r t |  } n t	 |  } Wn t k
 rn X| | | <q2 W| S(   s/   Convert content of config-file into dictionary.t   rt   #t   =s   Bad line in config-file %s:
%st   Truet   Falset   Nones   ''s   ""t   .(   R   R   R   s   ''s   ""(
   t   opent	   readlinest   closet   stript
   startswithR   t
   ValueErrort   evalt   floatt   int(   t   filenamet   ft   cfglinest   cfgdictt   linet   keyt   value(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   config_dict   s2    
c         C   s   d } i  } i  } t  |  r- t |  } n  d | k rJ d | d } n  y% t t  \ } } t | |  } Wn t k
 r d } n Xt  |  r t |  } n  t j |  t j |  d S(   s@  Read config-files, change configuration-dict accordingly.

    If there is a turtle.cfg file in the current working directory,
    read it from there. If this contains an importconfig-value,
    say 'myway', construct filename turtle_mayway.cfg else use
    turtle.cfg and read it from the import-directory, where
    turtle.py is located.
    Update configuration dictionary first according to config-file,
    in the import directory, then according to config-file in the
    current working directory.
    If no config-file is found, the default configuration is used.
    s
   turtle.cfgt   importconfigs   turtle_%s.cfgt    N(   R    R   R   t   __file__R   t   BaseExceptiont   _CFGR%   (   R   t   default_cfgt   cfgdict1t   cfgdict2t   headt   tailt	   cfg_file2(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt
   readconfig   s     
s"   No configfile read, reason unknownc           B   sh   e  Z d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d	   Z d
   Z RS(   s  A 2 dimensional vector class, used as a helper class
    for implementing turtle graphics.
    May be useful for turtle graphics programs also.
    Derived from tuple, so a vector is a tuple!

    Provides (for a, b vectors, k number):
       a+b vector addition
       a-b vector subtraction
       a*b inner product
       k*a and a*k multiplication with scalar
       |a| absolute value of a
       a.rotate(angle) rotation
    c         C   s   t  j |  | | f  S(   N(   t   tuplet   __new__(   t   clst   xt   y(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    c         C   s%   t  |  d | d |  d | d  S(   Ni    i   (   R   (   t   selft   other(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __add__  s    c         C   sL   t  | t  r/ |  d | d |  d | d St |  d | |  d |  S(   Ni    i   (   t
   isinstanceR   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __mul__  s     c         C   s?   t  | t  s t  | t  r; t |  d | |  d |  Sd  S(   Ni    i   (   R   R   R   R   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __rmul__  s    c         C   s%   t  |  d | d |  d | d  S(   Ni    i   (   R   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __sub__  s    c         C   s   t  |  d |  d  S(   Ni    i   (   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __neg__  s    c         C   s   |  d d |  d d d S(   Ni    i   i   g      ?(    (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __abs__  s    c         C   s}   t  |  d |  d  } | t j d } t j |  t j |  } } t  |  d | | d | |  d | | d |  S(   s.   rotate self counterclockwise by angle
        i   i    g     f@(   R   t   mathR   R|   R   (   R   t   anglet   perpt   ct   s(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   rotate  s    c         C   s   |  d |  d f S(   Ni    i   (    (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __getnewargs__&  s    c         C   s   d |  S(   Ns   (%.2f,%.2f)(    (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __repr__(  s    (   t   __name__t
   __module__t   __doc__R   R   R   R   R   R   R   R   R   R   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR      s   									c         C   s}   t  |  j  } | j   x | D] } t | |  q  Wx? |  j j   D]. \ } } t |  t j k rG | | | <qG qG Wd S(   s#   helper function for Scrolled CanvasN(	   t   listt	   __bases__t   reverset   __methodDictt   __dict__t   itemst   typet   typest   FunctionType(   R   t   _dictt   baseListt   _superR   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   4  s    
c         C   s   i  } t  |  |  | j   S(   s#   helper function for Scrolled Canvas(   R   t   keys(   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   __methods>  s    s*   def %(method)s(self, *args, **kw): return s*   self.%(attribute)s.%(method)s(*args, **kw)c   
      B   s&  i  } e  | |  x> | j   D]0 } | d  d k sF | d d k r  | | =q  q  Wx$ | D] } | | k r[ | | =q[ q[ Wx* e |   D] } | | k r | | =q q Wxw | j   D]i \ } } i | d 6| d 6} e |  e j k re i | d 6| d 6}	 n  |	 | U| | |  j | <q Wd S(   sn   Helper functions for Scrolled Canvas, used to forward
    ScrolledCanvas-methods to Tkinter.Canvas class.
    i   t   _it   methodt   funct	   attributeN(	   R   R   R   R   R   R   t
   StringTypet   __stringBodyR   (
   t	   fromClasst   toClasst   toPartt   excludeR   t   exR   R   t   dt
   execString(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   __forwardmethodsH  s"     c           B   s}   e  Z d  Z d d d d d  Z d d d d  Z d   Z d   Z d   Z d	   Z	 d
   Z
 d   Z d   Z d   Z RS(   s   Modeled after the scrolled canvas class from Grayons's Tkinter book.

    Used as the default canvas, which pops up automatically when
    using turtle graphics functions or the Turtle class.
    i  i^  iX  c         C   s
  t  j j |  | d | d | |  j   |  _ | | |  _ |  _ | | |  _ |  _ d |  _	 t  j
 | d | d | d |  j	 d t  j d d |  _ t  j | d |  j j d	 t  j |  _ t  j | d |  j j |  _ |  j j d
 |  j j d |  j j  |  j d d d d d |  j d d d d d |  j j d d d |  d d d d d d d d d d d d  |  j j d d d |  d d d d d d d d d d d d  |  j j d d d |  d d d d d d d d d d d d  |  j   |  j j d |  j  d  S(   NRp   R   t   whitet   bgt   relieft   borderwidthi   t   commandt   orientt   xscrollcommandt   yscrollcommandi    t   weighti   t   minsizet   padxt   in_t   padyt   rowt   columnt   rowspant
   columnspant   stickyt   newss   <Configure>(   t   TKt   Framet   __init__t   winfo_toplevelt   _rootwindowRp   R   R   R   R   t   Canvast   SUNKENt   _canvast	   Scrollbart   xviewt
   HORIZONTALt   hscrollt   yviewt   vscrollt	   configuret   sett   rowconfiguret   columnconfiguret   gridRX   t   bindt   onResize(   R   t   masterRp   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  g  s,    	$$$
c      	   C   s   | r | |  _  n  | r$ | |  _ n  | r6 | |  _ n  |  j j d | d |  j  d |  j d |  j  d |  j d f  |  j j d |  j  |  j d |  j   |  j j d |  j |  j d |  j  |  j	   d S(   s<   Adjust canvas and scrollbars according to given canvas size.R   t   scrollregioni   g      ?i   N(
   R   R   R   R  t   configt   xview_movetoRp   t   yview_movetoR   t   adjustScrolls(   R   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRX     s    c         C   s  |  j  j   } |  j  j   } |  j  j d |  j | |  j  |  j  j d |  j | |  j  | |  j k  s | |  j k  r |  j j d d d |  d d d d d d d	 d d
 d d d  |  j	 j d d d |  d d d d d d d	 d d
 d d d  n |  j j
   |  j	 j
   d S(   sA    Adjust scrollbars according to window- and canvas-size.
        g      ?R  i   R  R  R	  R
  i    R  R  R  R  N(   R  t   winfo_widtht   winfo_heightR'  R   R(  R   R  R!  R  t   grid_forget(   R   t   cwidtht   cheight(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR)    s    ""$$c         C   s   |  j    d S(   s   self-explanatoryN(   R)  (   R   t   event(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR#    s    c         G   s   |  j  j |   S(   s@    'forward' method, which canvas itself has inherited...
        (   R  t   bbox(   R   t   args(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR0    s    c         O   s   |  j  j | |   S(   s@    'forward' method, which canvas itself has inherited...
        (   R  t   cget(   R   R1  t   kwargs(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR2    s    c         O   s   |  j  j | |   d S(   s@    'forward' method, which canvas itself has inherited...
        N(   R  R&  (   R   R1  R3  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR&    s    c         O   s   |  j  j | |   d S(   s@    'forward' method, which canvas itself has inherited...
        N(   R  R"  (   R   R1  R3  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR"    s    c         O   s   |  j  j | |   d S(   s@    'forward' method, which canvas itself has inherited...
        N(   R  t   unbind(   R   R1  R3  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR4    s    c         C   s   |  j  j   d S(   s@    'forward' method, which canvas itself has inherited...
        N(   R  t   focus_force(   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR5    s    N(   R   R   R   R  R   RX   R)  R#  R0  R2  R&  R"  R4  R5  (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   a  s   							R  t   _Rootc           B   sM   e  Z d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 RS(   s'   Root class for Screen based on Tkinter.c         C   s   t  j j |   d  S(   N(   R  t   TkR  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    c         C   s8   t  |  | | | |  |  _ |  j j d d d d  d  S(   Nt   expandi   R:   t   both(   R   R  t   pack(   R   Rp   R   R-  R.  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   setupcanvas  s    c         C   s   |  j  S(   N(   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt
   _getcanvas  s    c         C   s!   |  j  d | | | | f  d  S(   Ns   %dx%d%+d%+d(   t   geometry(   R   Rp   R   t   startxt   starty(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   set_geometry  s    c         C   s   |  j  d |  d  S(   Nt   WM_DELETE_WINDOW(   t   wm_protocol(   R   t   destroy(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   ondestroy  s    c         C   s
   |  j    S(   N(   t   winfo_screenwidth(   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   win_width  s    c         C   s
   |  j    S(   N(   t   winfo_screenheight(   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt
   win_height  s    (
   R   R   R   R  R;  R<  R@  RD  RF  RH  (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR6    s   						t   TurtleScreenBasec           B   s[  e  Z d  Z e d    Z e d    Z d   Z d   Z d d d e	 d  Z
 d   Z d d d e	 d  Z d   Z d	   Z d
   Z d   Z d d  Z d   Z d d d  Z d d d  Z d d d  Z d d d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z  d d d d  Z! d   Z" RS(    s   Provide the basic graphics functionality.
       Interface between Tkinter and turtle.py.

       To port turtle.py to some different graphics toolkit
       a corresponding TurtleScreenBase class has to be implemented.
    c          C   s&   t  j d d d d  }  |  j   |  S(   s$   return a blank image object
        Rp   i   R   (   R  t
   PhotoImaget   blank(   t   img(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _blankimage  s    
c         C   s   t  j d |   S(   s`   return an image object containing the
        imagedata from a gif-file named filename.
        t   file(   R  RJ  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _image  s    c         C   s   | |  _  t | t  r3 |  j  j } |  j  j } na t |  j  j d   } t |  j  j d   } |  j  j d | d | d | d | d f  | |  _ | |  _ d |  _ |  _	 d  S(   NRp   R   R%  i   g      ?(
   t   cvR   R   R   R   R   R2  R&  t   xscalet   yscale(   R   RP  t   wt   h(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    	1		c         C   s   |  j  j d d d d d S(   s<   Create an invisible polygon item on canvas self.cv)
        i    R:   R   t   outline(   i    i    i    i    i    i    (   RP  t   create_polygon(   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _createpoly  s    c   
      C   s   g  } x= | D]5 \ } }	 | j  | |  j  | j  |	 |  j  q W|  j j | |  | d k	 r~ |  j j | d | n  | d k	 r |  j j | d | n  | d k	 r |  j j | d | n  | r |  j j |  n  d S(   s`  Configure polygonitem polyitem according to provided
        arguments:
        coordlist is sequence of coordinates
        fill is filling color
        outline is outline color
        top is a boolean value, which specifies if polyitem
        will be put on top of the canvas' displaylist so it
        will not be covered by other items.
        R:   RU  Rp   N(   t   appendRQ  RR  RP  t   coordsR   t   itemconfiguret	   tag_raise(
   R   t   polyitemt	   coordlistR:   RU  Rp   t   topt   clR   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   _drawpoly  s    c         C   s.   |  j  j d d d d d d d d d t j S(   s9   Create an invisible line item on canvas self.cv)
        i    R:   R   Rp   i   t   capstyle(   RP  t   create_lineR  t   ROUND(   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _createline$  s    $c   	      C   s   | d k	 rh g  } x= | D]5 \ } } | j | |  j  | j | |  j  q W|  j j | |  n  | d k	 r |  j j | d | n  | d k	 r |  j j | d | n  | r |  j j |  n  d S(   sQ  Configure lineitem according to provided arguments:
        coordlist is sequence of coordinates
        fill is drawing color
        width is width of drawn line.
        top is a boolean value, which specifies if polyitem
        will be put on top of the canvas' displaylist so it
        will not be covered by other items.
        R:   Rp   N(   R   RX  RQ  RR  RP  RY  RZ  R[  (	   R   t   lineitemR]  R:   Rp   R^  R_  R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   _drawline*  s    
c         C   s   |  j  j |  d S(   s]   Delete graphics item from canvas.
        If item is"all" delete all graphics items.
        N(   RP  t   delete(   R   t   item(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _deleteA  s    c         C   s   |  j  j   d S(   s(   Redraw graphics items on canvas
        N(   RP  R%   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _updateG  s    c         C   s   |  j  j |  d S(   s-   Delay subsequent canvas actions for delay ms.N(   RP  t   after(   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _delayL  s    c         C   s=   y |  j  j |  } t } Wn t j k
 r8 t } n X| S(   sC   Check if the string color is a legal Tkinter color string.
        (   RP  t	   winfo_rgbR   R  t   TclErrorR   (   R   R2   t   rgbt   ok(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _iscolorstringP  s    

c         C   s@   | d k	 r, |  j j d |  |  j   n |  j j d  Sd S(   sV   Set canvas' backgroundcolor if color is not None,
        else return backgroundcolor.R   N(   R   RP  R&  Rj  R2  (   R   R2   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _bgcolorZ  s    c         C   s   | \ } } | |  j  } | |  j } i d d 6d d 6d d 6} |  j j | d | d | d	 | | d
 | d | }	 |  j j |	  \ }
 } } } |  j j   |	 | d f S(   s   Write txt at pos in canvas with specified font
        and color.
        Return text item and x-coord of right bottom corner
        of text's bounding box.t   swRH   R   t   centert   seRW   i   t   textt   anchorR:   t   font(   RQ  RR  RP  t   create_textR0  R%   (   R   RS   t   txtt   alignRx  RO   R   R   Rw  Rh  t   x0t   y0t   x1t   y1(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _writec  s    'i   c            sY     d k r&  j j | d |  n/    f d   }  j j | d | | |  d S(   s   Bind fun to mouse-click event on turtle.
        fun must be a function with two arguments, the coordinates
        of the clicked point on the canvas.
        num, the number of the mouse-button defaults to 1
        s   <Button-%s>c            sK    j  j |  j   j  j  j |  j   j } }   | |  d  S(   N(   RP  t   canvasxR   RQ  t   canvasyR   RR  (   R/  R   R   (   t   funR   (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   eventfun~  s    !N(   R   RP  t
   tag_unbindt   tag_bind(   R   Rh  R  t   numt   addR  (    (   R  R   s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _onclicku  s    c            sY     d k r&  j j | d |  n/    f d   }  j j | d | | |  d S(   sg  Bind fun to mouse-button-release event on turtle.
        fun must be a function with two arguments, the coordinates
        of the point on the canvas where mouse button is released.
        num, the number of the mouse-button defaults to 1

        If a turtle is clicked, first _onclick-event will be performed,
        then _onscreensclick-event.
        s   <Button%s-ButtonRelease>c            sK    j  j |  j   j  j  j |  j   j } }   | |  d  S(   N(   RP  R  R   RQ  R  R   RR  (   R/  R   R   (   R  R   (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    !N(   R   RP  R  R  (   R   Rh  R  R  R  R  (    (   R  R   s#   /usr/lib/python2.7/lib-tk/turtle.pyt
   _onrelease  s
    	c            sY     d k r&  j j | d |  n/    f d   }  j j | d | | |  d S(   sq  Bind fun to mouse-move-event (with pressed mouse button) on turtle.
        fun must be a function with two arguments, the coordinates of the
        actual mouse position on the canvas.
        num, the number of the mouse-button defaults to 1

        Every sequence of mouse-move-events on a turtle is preceded by a
        mouse-click event on that turtle.
        s   <Button%s-Motion>c            sc   yK  j  j |  j   j  j  j |  j   j } }   | |  Wn t k
 r^ n Xd  S(   N(   RP  R  R   RQ  R  R   RR  R   (   R/  R   R   (   R  R   (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    !N(   R   RP  R  R  (   R   Rh  R  R  R  R  (    (   R  R   s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _ondrag  s    	c            sS     d k r#  j j d |  n,    f d   }  j j d | | |  d S(   sG  Bind fun to mouse-click event on canvas.
        fun must be a function with two arguments, the coordinates
        of the clicked point on the canvas.
        num, the number of the mouse-button defaults to 1

        If a turtle is clicked, first _onclick-event will be performed,
        then _onscreensclick-event.
        s   <Button-%s>c            sK    j  j |  j   j  j  j |  j   j } }   | |  d  S(   N(   RP  R  R   RQ  R  R   RR  (   R/  R   R   (   R  R   (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    !N(   R   RP  R4  R"  (   R   R  R  R  R  (    (   R  R   s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _onscreenclick  s    	c            sP     d k r& |  j j d | d  n&   f d   } |  j j d | |  d S(   s`   Bind fun to key-release event of key.
        Canvas must have focus. See method listen
        s   <KeyRelease-%s>c            s       d  S(   N(    (   R/  (   R  (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    N(   R   RP  R4  R"  (   R   R  R   R  (    (   R  s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _onkey  s    c         C   s   |  j  j   d S(   s=   Set focus on canvas (in order to collect key-events)
        N(   RP  R5  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _listen  s    c         C   s6   | d k r |  j  j |  n |  j  j | |  d S(   s?   Install a timer, which calls fun after t milliseconds.
        i    N(   RP  t
   after_idleRk  (   R   R  t   t(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _ontimer  s    c         C   s   |  j  j d d d | S(   s0   Create and return image item on canvas.
        i    t   image(   RP  t   create_image(   R   R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _createimage  s    c         C   sN   | \ } } |  j  j | | |  j | |  j f  |  j  j | d | d S(   sZ   Configure image item as to draw image object
        at position (x,y) on canvas)
        R  N(   RP  RY  RQ  RR  t
   itemconfig(   R   Rh  RS   R  R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt
   _drawimage  s    (c         C   s*   |  j  j | d | |  j  j |  d S(   s   Configure image item as to draw image object
        at center of canvas. Set item to the first item
        in the displaylist, so it will be drawn below
        any other item .R  N(   RP  R  t	   tag_lower(   R   Rh  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   _setbgpic  s    c         C   s   |  j  j |  S(   sQ   Return 'line' or 'polygon' or 'image' depending on
        type of item.
        (   RP  R   (   R   Rh  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _type  s    c         C   sT   |  j  j |  } g  t d t |  d  D] } | | | | d f ^ q+ } | S(   s   returns list of coordinate-pairs of points of item
        Example (for insiders):
        >>> from turtle import *
        >>> getscreen()._pointlist(getturtle().turtle._item)
        [(0.0, 9.9999999999999982), (0.0, -9.9999999999999982),
        (9.9999999999999982, 0.0)]
        >>> i    i   i   (   RP  RY  t   ranget   len(   R   Rh  R_  t   it   pl(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt
   _pointlist  s    >c         C   s#   |  j  j d | | | | f  d  S(   NR%  (   RP  R&  (   R   t   srx1t   sry1t   srx2t   sry2(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _setscrollregion  s    c   	      C   s   |  j  j   } x | D]z } |  j  j |  } g  } xF | r| | d  \ } } | j | |  | j | |  | d } q7 W|  j  j | |  q Wd  S(   Ni   (   RP  t   find_allRY  RX  (	   R   t   xscalefactort   yscalefactorR   Rh  t   coordinatest   newcoordlistR   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _rescale   s    	c         C   s   t  |  j t  s" |  j |  j f S| | k oD | k oD d k n r_ |  j j |  j j f S| d k	 rw | |  _ n  | d k	 r | |  _ n  |  j j | | |  d S(   sa   Resize the canvas the turtles are drawing on. Does
        not alter the drawing window.
        N(   R   RP  R   R   R   R   RX   (   R   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _resize  s    'c         C   s`   |  j  j   } | d k r+ |  j  d } n  |  j  j   } | d k rV |  j  d } n  | | f S(   s;    Return the width and height of the turtle window.
        i   Rp   R   (   RP  R*  R+  (   R   Rp   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _window_size  s    N(#   R   R   R   t   staticmethodRM  RO  R  RW  R   R   R`  Rd  Rf  Ri  Rj  Rl  Rq  Rr  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRI    s@   							
												c           B   s   e  Z d  Z RS(   s   Will be raised in TurtleScreen.update, if _RUNNING becomes False.

    This stops execution of a turtle graphics script.
    Main purpose: use in the Demo-Viewer turtle.Demo.py.
    (   R   R   R   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   ,  s   t   TurtleGraphicsErrorc           B   s   e  Z d  Z RS(   s   Some TurtleGraphics Error
    (   R   R   R   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  5  s   c           B   s&   e  Z d  Z d d  Z d d  Z RS(   s   Data structure modeling shapes.

    attribute _type is one of "polygon", "image", "compound"
    attribute _data is - depending on _type a poygon-tuple,
    an image or a list constructed using the addcomponent method.
    c         C   s   | |  _  | d k r6 t | t  r t |  } q ny | d k r t | t  r | j   j d  r t |  r t j	 |  } q q n% | d k r g  } n t
 d |   | |  _ d  S(   Nt   polygonR  s   .gift   compounds   There is no shape type %s(   R  R   R   R   t
   basestringt   lowert   endswithR    R   RO  R  t   _data(   R   t   type_t   data(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  A  s    	!	c         C   sW   |  j  d k r% t d |  j    n  | d k r: | } n  |  j j | | | g  d S(   s-  Add component to a shape of type compound.

        Arguments: poly is a polygon, i. e. a tuple of number pairs.
        fill is the fillcolor of the component,
        outline is the outline color of the component.

        call (for a Shapeobject namend s):
        --   s.addcomponent(((0,0), (10,10), (-10,10)), "red", "blue")

        Example:
        >>> poly = ((0,0),(10,-5),(0,10),(-10,-5))
        >>> s = Shape("compound")
        >>> s.addcomponent(poly, "red", "blue")
        >>> # .. add more components and then use register_shape()
        R  s    Cannot add component to %s ShapeN(   R  R  R   R  RX  (   R   t   polyR:   RU  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   addcomponentQ  s    	N(   R   R   R   R   R  R  (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   :  s   t   Tbufferc           B   sJ   e  Z d  Z d d  Z d d  Z d   Z d   Z d   Z d   Z	 RS(	   s5   Ring buffer used as undobuffer for RawTurtle objects.i
   c         C   s2   | |  _  d  g g | |  _ d |  _ t |  _ d  S(   Ni(   t   bufsizeR   t   buffert   ptrR   t   cumulate(   R   R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  k  s    		c         C   sb   | d  k r9 xF t |  j  D] } d  g |  j | <q Wn | |  _ d  g g | |  _ d |  _ d  S(   Ni(   R   R  R  R  R  (   R   R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRX   p  s    	c         C   s`   |  j  d k r\ |  j sB |  j d |  j  |  _ | |  j |  j <q\ |  j |  j j |  n  d  S(   Ni    i   (   R  R  R  R  RX  (   R   Rh  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   pushx  s
    	c         C   sd   |  j  d k r` |  j |  j } | d  k r/ d  Sd  g |  j |  j <|  j d |  j  |  _ | Sn  d  S(   Ni    i   (   R  R  R  R   (   R   Rh  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   pop  s    c         C   s   |  j  |  j j d  g  S(   N(   R  R  t   countR   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   nr_of_items  s    c         C   s   t  |  j  d t  |  j  S(   Nt    (   t   strR  R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    N(
   R   R   R   R  R   RX   R  R  R  R   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  i  s   				c           B   sO  e  Z d  Z e Z e d e d e d d  Z d   Z d d  Z	 d   Z
 d d  Z d	   Z d
   Z d d  Z d   Z d   Z d   Z d d d  Z d d  Z d   Z d   Z d   Z d   Z d   Z d   Z d d d  Z d   Z d d d  Z d d  Z d d  Z d d d d  Z e Z  e Z! e Z" e Z# RS(    s   Provides screen oriented methods like setbg etc.

    Only relies upon the methods of TurtleScreenBase and NOT
    upon components of the underlying graphics toolkit -
    which is Tkinter in this case.
    R   R   R   c         C   s  i t  d d/ d0 d1 f  d 6t  d d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA dB dC dD dE dF dG dH dI f  d 6t  d dJ dK dL dM dN dO dP dQ dR dS dT dU dV dW dX dY dZ d[ d\ d] f  d$ 6t  d d^ d_ d` da f  d% 6t  d db dc dd f  d( 6t  d de df dg dh f  d) 6t  d* |  j    d+ 6|  _ i d, d- 6|  _ t j |  |  | |  _ | |  _ t d. |  _	 g  |  _
 |  j   d  S(i   NR  ii    i
   t   arrowi   ii   iii   ii	   ii   ii   i   iiii   i   i   R   gQ#@gQ@gGz. @gQ@gQgQgGz. gQ#g       g      $R-   t   squaregGzg'@t   triangleR   R  RK  R   t   nopicR   (   ii    (   i
   i    (   i    i
   (   i    i   (   ii   (   ii
   (   ii   (   ii	   (   ii   (   ii   (   ii   (   ii(   ii(   ii(   ii(   i    i(   i   i(   i   i(   i   i(   i   i(   i   i   (   i   i   (   i	   i   (   i   i	   (   i   i   (   i   i
   (   i   i   (   i
   i    (   gQ#@gQ@(   gGz. @gQ@(   gQ@gGz. @(   gQ@gQ#@(   i    i
   (   gQgQ#@(   gQgGz. @(   gGz. gQ@(   gQ#gQ@(   ii    (   gQ#gQ(   gGz. gQ(   gQgGz. (   gQgQ#(   g       g      $(   gQ@gQ#(   gQ@gGz. (   gGz. @gQ(   gQ#@gQ(   i
   i(   i
   i
   (   ii
   (   ii(   i
   gGz(   i    g'@(   igGz(   i    i    (   ii(   i    i(   i   i(   R   RM  t   _shapest   _bgpicsRI  R  t   _modet   _delayvalueR   t
   _colormodet   _keysR.   (   R   RP  R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s4    					c         C   s   t  d |  _ t  d |  _ |  j d  |  j d  |  _ d |  _ d |  _ d |  _ g  |  _	 |  j
 d  x d D] } |  j d |  qq Wx" |  j D] } |  j d |  q Wd t _ d S(   sq  Delete all drawings and all turtles from the TurtleScreen.

        Reset empty TurtleScreen to its initial state: white background,
        no backgroundimage, no eventbindings and tracing on.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.clear()

        Note: this method is not available as function.
        R   R   t   allR   R  i   i    R   i   i   N(   i   i   i   (   R   R  R  Ri  R  t   _bgpict
   _bgpicnamet   _tracingt   _updatecountert   _turtlesR   RJ   R   R  R   R	   t   _pen(   R   t   btnR   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR.     s    				c         C   s   | d k r |  j S| j   } | d k r> t d |   n  | |  _ | d	 k r |  j |  j d |  j d |  j d |  j d  d |  _ |  _ n  |  j	   d S(
   sh  Set turtle-mode ('standard', 'logo' or 'world') and perform reset.

        Optional argument:
        mode -- one of the strings 'standard', 'logo' or 'world'

        Mode 'standard' is compatible with turtle.py.
        Mode 'logo' is compatible with most Logo-Turtle-Graphics.
        Mode 'world' uses userdefined 'worldcoordinates'. *Attention*: in
        this mode angles appear distorted if x/y unit-ratio doesn't equal 1.
        If mode is not given, return the current mode.

             Mode      Initial turtle heading     positive angles
         ------------|-------------------------|-------------------
          'standard'    to the right (east)       counterclockwise
            'logo'        upward    (north)         clockwise

        Examples:
        >>> mode('logo')   # resets turtle heading to north
        >>> mode()
        'logo'
        R   t   logot   worlds   No turtle-graphics-mode %si   g      ?N(   R   R  R  (   R   R  (
   R   R  R  R  R  R   R   RQ  RR  RX   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    	c         C   s  |  j    d k r" |  j  d  n  t | |  } t | |  } |  j   \ } } |  j | d | d  |  j |  j }	 }
 |  j | |  _ |  j | |  _ | |  j } | |  j } |  j | } |  j | } |  j | | | |  |  j	 |  j |	 |  j |
  |  j
   d S(   ss  Set up a user defined coordinate-system.

        Arguments:
        llx -- a number, x-coordinate of lower left corner of canvas
        lly -- a number, y-coordinate of lower left corner of canvas
        urx -- a number, x-coordinate of upper right corner of canvas
        ury -- a number, y-coordinate of upper right corner of canvas

        Set up user coodinat-system and switch to mode 'world' if necessary.
        This performs a screen.reset. If mode 'world' is already active,
        all drawings are redrawn according to the new coordinates.

        But ATTENTION: in user-defined coordinatesystems angles may appear
        distorted. (see Screen.mode())

        Example (for a TurtleScreen instance named screen):
        >>> screen.setworldcoordinates(-10,-0.5,50,1.5)
        >>> for _ in range(36):
        ...     left(10)
        ...     forward(0.5)
        R  i   N(   R   R   R  R   RQ  RR  R   R   R  R  R%   (   R   t   llxt   llyt   urxt   uryt   xspant   yspant   wxt   wyt	   oldxscalet	   oldyscaleR  R  R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR!     s     c         C   s   | d k rO | j   j d  r< t d |  j |   } qp t d d   n! t | t  rp t d |  } n  | |  j | <d S(   s  Adds a turtle shape to TurtleScreen's shapelist.

        Arguments:
        (1) name is the name of a gif-file and shape is None.
            Installs the corresponding image shape.
            !! Image-shapes DO NOT rotate when turning the turtle,
            !! so they do not display the heading of the turtle!
        (2) name is an arbitrary string and shape is a tuple
            of pairs of coordinates. Installs the corresponding
            polygon shape
        (3) name is an arbitrary string and shape is a
            (compound) Shape object. Installs the corresponding
            compound shape.
        To use a shape, you have to issue the command shape(shapename).

        call: register_shape("turtle.gif")
        --or: register_shape("tri", ((0,0), (10,10), (-10,10)))

        Example (for a TurtleScreen instance named screen):
        >>> screen.register_shape("triangle", ((5,-3),(0,5),(-5,-3)))

        s   .gifR  s"   Bad arguments for register_shape.
s   Use  help(register_shape)R  N(	   R   R  R  R   RO  R  R   R   R  (   R   t   nameRc   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    c         C   sn  t  |  d k r | d } n  t | t  rf |  j |  sI | d k rM | St d t |    n  y | \ } } } Wn- t t f k
 r t d t |    n X|  j d k r g  | | | f D] } t	 d |  ^ q \ } } } n  d | k od k n oAd | k o#d k n oAd | k o?d k n s]t d	 t |    n  d
 | | | f S(   s  Return color string corresponding to args.

        Argument may be a string or a tuple of three
        numbers corresponding to actual colormode,
        i.e. in the range 0<=n<=colormode.

        If the argument doesn't represent a color,
        an error is raised.
        i   i    R   s   bad color string: %ss   bad color arguments: %sg      ?g     o@i   s   bad color sequence: %ss   #%02x%02x%02x(
   R  R   R  Rq  R  R  t	   TypeErrorR   R  t   round(   R   R2   R   t   gt   bR   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   _colorstrB  s    
8Tc         C   s   | j  d  s | St |  d k rU g  d D]  } t | | | d !d  ^ q, } nS t |  d k r g  | d D] } d t | | d  ^ qr } n t d	 |   t g  | D] } | |  j d
 ^ q  S(   NR   i   i   i   i   i   i   i   s   bad colorstring: %si   (   i   i   i   (   R   R  R   R  R   R  (   R   t   cstrR  R_  RT  R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _color]  s    01c         C   sS   | d k r |  j S| d k r1 t |  |  _ n | d k rO t |  |  _ n  d S(   sq  Return the colormode or set it to 1.0 or 255.

        Optional argument:
        cmode -- one of the values 1.0 or 255

        r, g, b values of colortriples have to be in range 0..cmode.

        Example (for a TurtleScreen instance named screen):
        >>> screen.colormode()
        1.0
        >>> screen.colormode(255)
        >>> pencolor(240,160,80)
        g      ?i   N(   R   R  R   R   (   R   t   cmode(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   h  s    c         C   s2   x+ |  j  D]  } | j |  j  | j   q
 Wd S(   s   Reset all Turtles on the Screen to their initial state.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.reset()
        N(   R  t   _setmodeR  RX   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRX   }  s    c         C   s   |  j  S(   s   Return the list of turtles on the screen.

        Example (for a TurtleScreen instance named screen):
        >>> screen.turtles()
        [<turtle.Turtle object at 0x00E11FB0>]
        (   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR$     s    c         G   sO   | r |  j  |  } n d } |  j |  } | d k	 rK |  j |  } n  | S(   s  Set or return backgroundcolor of the TurtleScreen.

        Arguments (if given): a color string or three numbers
        in the range 0..colormode or a 3-tuple of such numbers.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bgcolor("orange")
        >>> screen.bgcolor()
        'orange'
        >>> screen.bgcolor(0.5,0,0.5)
        >>> screen.bgcolor()
        '#800080'
        N(   R  R   Rr  R  (   R   R1  R2   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    c         C   sc   | d k r |  j St |  |  _ d |  _ | d k	 rI t |  |  _ n  |  j r_ |  j   n  d S(   se  Turns turtle animation on/off and set delay for update drawings.

        Optional arguments:
        n -- nonnegative  integer
        delay -- nonnegative  integer

        If n is given, only each n-th regular screen update is really performed.
        (Can be used to accelerate the drawing of complex graphics.)
        Second arguments sets delay value (see RawTurtle.delay())

        Example (for a TurtleScreen instance named screen):
        >>> screen.tracer(8, 25)
        >>> dist = 2
        >>> for i in range(200):
        ...     fd(dist)
        ...     rt(90)
        ...     dist += 2
        i    N(   R   R  R   R  R  R%   (   R   t   nR   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR#     s    		c         C   s&   | d k r |  j St |  |  _ d S(   s    Return or set the drawing delay in milliseconds.

        Optional argument:
        delay -- positive integer

        Example (for a TurtleScreen instance named screen):
        >>> screen.delay(15)
        >>> screen.delay()
        15
        N(   R   R  R   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    c         C   sR   t  j s t t  _ t  n  |  j d k rN |  j d 7_ |  j |  j ;_ n  d S(   s   Increment update counter.i    i   N(   R   t   _RUNNINGR   R   R  R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _incrementudc  s    			c         C   sT   |  j  } t |  _  x( |  j   D] } | j   | j   q W| |  _  |  j   d S(   s'   Perform a TurtleScreen update.
        N(   R  R   R$   t   _update_datat   _drawturtleRj  (   R   t   tracingR  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR%     s    		
	c         C   s   |  j    d S(   s    Return the width of the turtle window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_width()
        640
        i    (   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR'     s    c         C   s   |  j    d S(   s    Return the height of the turtle window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_height()
        480
        i   (   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR&     s    c         C   s   |  j  S(   s   Return the Canvas of this TurtleScreen.

        No argument.

        Example (for a Screen instance named screen):
        >>> cv = screen.getcanvas()
        >>> cv
        <turtle.ScrolledCanvas instance at 0x010742D8>
        (   RP  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    
c         C   s   t  |  j j    S(   s   Return a list of names of all currently available turtle shapes.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.getshapes()
        ['arrow', 'blank', 'circle', ... , 'turtle']
        (   t   sortedR  R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    	i   c         C   s   |  j  | | |  d S(   s  Bind fun to mouse-click event on canvas.

        Arguments:
        fun -- a function with two arguments, the coordinates of the
               clicked point on the canvas.
        num -- the number of the mouse-button, defaults to 1

        Example (for a TurtleScreen instance named screen
        and a Turtle instance named turtle):

        >>> screen.onclick(goto)
        >>> # Subsequently clicking into the TurtleScreen will
        >>> # make the turtle move to the clicked point.
        >>> screen.onclick(None)
        N(   R  (   R   R  R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRJ     s    c         C   sg   | d k r1 | |  j k rS |  j j |  qS n" | |  j k rS |  j j |  n  |  j | |  d S(   sm  Bind fun to key-release event of key.

        Arguments:
        fun -- a function with no arguments
        key -- a string: key (e.g. "a") or key-symbol (e.g. "space")

        In order to be able to register key-events, TurtleScreen
        must have focus. (See method listen.)

        Example (for a TurtleScreen instance named screen):

        >>> def f():
        ...     fd(50)
        ...     lt(60)
        ...
        >>> screen.onkey(f, "Up")
        >>> screen.listen()

        Subsequently the turtle can be moved by repeatedly pressing
        the up-arrow key, consequently drawing a hexagon

        N(   R   R  t   removeRX  R  (   R   R  R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   #  s    c         C   s   |  j    d S(   s  Set focus on TurtleScreen (in order to collect key-events)

        No arguments.
        Dummy arguments are provided in order
        to be able to pass listen to the onclick method.

        Example (for a TurtleScreen instance named screen):
        >>> screen.listen()
        N(   R  (   R   t   xdummyt   ydummy(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   A  s    
i    c         C   s   |  j  | |  d S(   s  Install a timer, which calls fun after t milliseconds.

        Arguments:
        fun -- a function with no arguments.
        t -- a number >= 0

        Example (for a TurtleScreen instance named screen):

        >>> running = True
        >>> def f():
        ...     if running:
        ...             fd(50)
        ...             lt(60)
        ...             screen.ontimer(f, 250)
        ...
        >>> f()   # makes the turtle marching around
        >>> running = False
        N(   R  (   R   R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   M  s    c         C   sb   | d k r |  j S| |  j k r; |  j |  |  j | <n  |  j |  j |  j |  | |  _ d S(   sF  Set background image or return name of current backgroundimage.

        Optional argument:
        picname -- a string, name of a gif-file or "nopic".

        If picname is a filename, set the corresponding image as background.
        If picname is "nopic", delete backgroundimage, if present.
        If picname is None, return the filename of the current backgroundimage.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bgpic()
        'nopic'
        >>> screen.bgpic("landscape.gif")
        >>> screen.bgpic()
        'landscape.gif'
        N(   R   R  R  RO  R  R  (   R   t   picname(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   b  s    c         C   s   |  j  | | |  S(   s  Resize the canvas the turtles are drawing on.

        Optional arguments:
        canvwidth -- positive integer, new width of canvas in pixels
        canvheight --  positive integer, new height of canvas in pixels
        bg -- colorstring or color-tuple, new backgroundcolor
        If no arguments are given, return current (canvaswidth, canvasheight)

        Do not alter the drawing window. To observe hidden parts of
        the canvas use the scrollbars. (Can make visible those parts
        of a drawing, which were outside the canvas before!)

        Example (for a Turtle instance named turtle):
        >>> turtle.screensize(2000,1500)
        >>> # e. g. to search for an erroneously escaped turtle ;-)
        (   R  (   R   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   z  s    N($   R   R   R   R   R  R   R  R.   R   R   R!   R   R  R  R   RX   R$   R   R#   R   R  R%   R'   R&   R   R   RJ   R   R   R   R   R   R   R   R   R   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s@   	"	'$																t
   TNavigatorc           B   s  e  Z d  Z i e d d  d 6e d d  d 6e d d  d 6Z d Z d Z d Z e d  Z d	   Z	 d% d
  Z d   Z d d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d% d  Z d   Z d   Z d   Z d% d  Z d% d  Z d   Z d    Z  d% d% d!  Z! d d"  Z" d% d% d#  Z# d% d$  Z$ e Z% e Z& e Z' e Z( e Z) e Z* e Z+ e Z, e  Z- RS(&   sR   Navigation part of the RawTurtle.
    Implements methods for turtle movement.
    g      ?g        R   R  R  i    i   c         C   s[   |  j  |  _ |  j |  _ | |  _ d  |  _ |  j   d  |  _ |  j |  t	 j
 |   d  S(   N(   t   DEFAULT_ANGLEOFFSETt   _angleOffsett   DEFAULT_ANGLEORIENTt   _angleOrientR  R   t
   undobufferR3   R  R  RX   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    		
	c         C   s)   t  d d  |  _ t j |  j |  _ d S(   sX   reset turtle to its initial values

        Will be overwritten by parent class
        g        N(   R   t	   _positionR  t   START_ORIENTATIONR  t   _orient(   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRX     s    c         C   sj   | d k r |  j S| d	 k r# d S| |  _ | d
 k rM d |  _ d |  _ n |  j d |  _ d |  _ d S(   s:   Set turtle-mode to 'standard', 'world' or 'logo'.
        R   R  R  Ni    i   g      @i(   R   R  R  (   R   R  (   R   R  R  R  t   _fullcircle(   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    		c         C   sB   | |  _  d | |  _ |  j d k r1 d |  _ n | d |  _ d S(   s+   Helper function for degrees() and radians()ih  R   i    g      @N(   R  t   _degreesPerAUR  R  (   R   t
   fullcircle(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _setDegreesPerAU  s
    	g     v@c         C   s   |  j  |  d S(   s>   Set angle measurement units to degrees.

        Optional argument:
        fullcircle -  a number

        Set angle measurement units, i. e. set number
        of 'degrees' for a full circle. Dafault value is
        360 degrees.

        Example (for a Turtle instance named turtle):
        >>> turtle.left(90)
        >>> turtle.heading()
        90

        Change angle measurement unit to grad (also known as gon,
        grade, or gradian and equals 1/100-th of the right angle.)
        >>> turtle.degrees(400.0)
        >>> turtle.heading()
        100

        N(   R  (   R   R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR3     s    c         C   s   |  j  d t j  d S(   s    Set the angle measurement units to radians.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        90
        >>> turtle.radians()
        >>> turtle.heading()
        1.5707963267948966
        i   N(   R  R   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRV     s    c         C   s%   |  j  |  j | } |  j |  d S(   s)   move turtle forward by specified distanceN(   R  R  t   _goto(   R   R4   t   ende(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _go  s    c         C   s&   | |  j  9} |  j j |  |  _ d S(   s=   Turn turtle counterclockwise by specified angle if angle > 0.N(   R   R  R   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _rotate  s    c         C   s   | |  _  d S(   s   move turtle to position end.N(   R  (   R   t   end(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    c         C   s   |  j  |  d S(   s  Move the turtle forward by the specified distance.

        Aliases: forward | fd

        Argument:
        distance -- a number (integer or float)

        Move the turtle forward by the specified distance, in the direction
        the turtle is headed.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 0.00)
        >>> turtle.forward(25)
        >>> turtle.position()
        (25.00,0.00)
        >>> turtle.forward(-75)
        >>> turtle.position()
        (-50.00,0.00)
        N(   R  (   R   R4   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR<     s    c         C   s   |  j  |  d S(   s  Move the turtle backward by distance.

        Aliases: back | backward | bk

        Argument:
        distance -- a number

        Move the turtle backward by distance ,opposite to the direction the
        turtle is headed. Do not change the turtle's heading.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 0.00)
        >>> turtle.backward(30)
        >>> turtle.position()
        (-30.00, 0.00)
        N(   R  (   R   R4   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR(     s    c         C   s   |  j  |  d S(   s  Turn turtle right by angle units.

        Aliases: right | rt

        Argument:
        angle -- a number (integer or float)

        Turn turtle right by angle units. (Units are by default degrees,
        but can be set via the degrees() and radians() functions.)
        Angle orientation depends on mode. (See this.)

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        22.0
        >>> turtle.right(45)
        >>> turtle.heading()
        337.0
        N(   R  (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRW   '  s    c         C   s   |  j  |  d S(   s  Turn turtle left by angle units.

        Aliases: left | lt

        Argument:
        angle -- a number (integer or float)

        Turn turtle left by angle units. (Units are by default degrees,
        but can be set via the degrees() and radians() functions.)
        Angle orientation depends on mode. (See this.)

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        22.0
        >>> turtle.left(45)
        >>> turtle.heading()
        67.0
        N(   R  (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRH   <  s    c         C   s   |  j  S(   s   Return the turtle's current location (x,y), as a Vec2D-vector.

        Aliases: pos | position

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (0.00, 240.00)
        (   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRS   Q  s    c         C   s   |  j  d S(   s    Return the turtle's x coordinate.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> reset()
        >>> turtle.left(60)
        >>> turtle.forward(100)
        >>> print turtle.xcor()
        50.0
        i    (   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRr   ^  s    c         C   s   |  j  d S(   s	   Return the turtle's y coordinate
        ---
        No arguments.

        Example (for a Turtle instance named turtle):
        >>> reset()
        >>> turtle.left(60)
        >>> turtle.forward(100)
        >>> print turtle.ycor()
        86.6025403784
        i   (   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRs   l  s    c         C   s<   | d k r" |  j t |    n |  j t | |   d S(   st  Move turtle to an absolute position.

        Aliases: setpos | setposition | goto:

        Arguments:
        x -- a number      or     a pair/vector of numbers
        y -- a number             None

        call: goto(x, y)         # two coordinates
        --or: goto((x, y))       # a pair (tuple) of coordinates
        --or: goto(vec)          # e.g. as returned by pos()

        Move turtle to an absolute position. If the pen is down,
        a line will be drawn. The turtle's orientation does not change.

        Example (for a Turtle instance named turtle):
        >>> tp = turtle.pos()
        >>> tp
        (0.00, 0.00)
        >>> turtle.setpos(60,30)
        >>> turtle.pos()
        (60.00,30.00)
        >>> turtle.setpos((20,80))
        >>> turtle.pos()
        (20.00,80.00)
        >>> turtle.setpos(tp)
        >>> turtle.pos()
        (0.00,0.00)
        N(   R   R  R   (   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRA   {  s    c         C   s!   |  j  d d  |  j d  d S(   s$  Move turtle to the origin - coordinates (0,0).

        No arguments.

        Move turtle to the origin - coordinates (0,0) and set its
        heading to its start-orientation (which depends on mode).

        Example (for a Turtle instance named turtle):
        >>> turtle.home()
        i    N(   RA   R\   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRD     s    c         C   s!   |  j  t | |  j d   d S(   s  Set the turtle's first coordinate to x

        Argument:
        x -- a number (integer or float)

        Set the turtle's first coordinate to x, leave second coordinate
        unchanged.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 240.00)
        >>> turtle.setx(10)
        >>> turtle.position()
        (10.00, 240.00)
        i   N(   R  R   R  (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRa     s    c         C   s!   |  j  t |  j d |   d S(   s  Set the turtle's second coordinate to y

        Argument:
        y -- a number (integer or float)

        Set the turtle's first coordinate to x, second coordinate remains
        unchanged.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 40.00)
        >>> turtle.sety(-10)
        >>> turtle.position()
        (0.00, -10.00)
        i    N(   R  R   R  (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRb     s    c         C   s   | d k	 r t | |  } n  t | t  r6 | } n9 t | t  rT t |   } n t | t  ro | j } n  t | |  j  S(   s  Return the distance from the turtle to (x,y) in turtle step units.

        Arguments:
        x -- a number   or  a pair/vector of numbers   or   a turtle instance
        y -- a number       None                            None

        call: distance(x, y)         # two coordinates
        --or: distance((x, y))       # a pair (tuple) of coordinates
        --or: distance(vec)          # e.g. as returned by pos()
        --or: distance(mypen)        # where mypen is another turtle

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (0.00, 0.00)
        >>> turtle.distance(30,40)
        50.0
        >>> pen = Turtle()
        >>> pen.forward(77)
        >>> turtle.distance(pen)
        77.0
        N(   R   R   R   R   R  R  t   abs(   R   R   R   RS   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR4     s    	c         C   s   | d k	 r t | |  } n  t | t  r6 | } n9 t | t  rT t |   } n t | t  ro | j } n  | |  j \ } } t t j | |  d t j	 d  d } | |  j
 :} |  j |  j | |  j S(   sC  Return the angle of the line from the turtle's position to (x, y).

        Arguments:
        x -- a number   or  a pair/vector of numbers   or   a turtle instance
        y -- a number       None                            None

        call: distance(x, y)         # two coordinates
        --or: distance((x, y))       # a pair (tuple) of coordinates
        --or: distance(vec)          # e.g. as returned by pos()
        --or: distance(mypen)        # where mypen is another turtle

        Return the angle, between the line from turtle-position to position
        specified by x, y and the turtle's start orientation. (Depends on
        modes - "standard" or "logo")

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (10.00, 10.00)
        >>> turtle.towards(0,0)
        225.0
        g     f@i
   g     v@N(   R   R   R   R   R  R  R  R   Rz   R   R   R  R  R  (   R   R   R   RS   t   result(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRk     s    	*c         C   s_   |  j  \ } } t t j | |  d t j d  d } | |  j :} |  j |  j | |  j S(   s    Return the turtle's current heading.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.left(67)
        >>> turtle.heading()
        67.0
        g     f@i
   g     v@(	   R  R  R   Rz   R   R   R  R  R  (   R   R   R   R	  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRB     s    
*c         C   sK   | |  j    |  j } |  j } | | d | | d } |  j |  d S(   s  Set the orientation of the turtle to to_angle.

        Aliases:  setheading | seth

        Argument:
        to_angle -- a number (integer or float)

        Set the orientation of the turtle to to_angle.
        Here are some common directions in degrees:

         standard - mode:          logo-mode:
        -------------------|--------------------
           0 - east                0 - north
          90 - north              90 - east
         180 - west              180 - south
         270 - south             270 - west

        Example (for a Turtle instance named turtle):
        >>> turtle.setheading(90)
        >>> turtle.heading()
        90
        g       @N(   RB   R  R  R  (   R   t   to_angleR   t   full(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR\   "  s    	c         C   s  |  j  r+ |  j  j d g  t |  j  _ n  |  j   } | d k rO |  j } n  | d k r t |  |  j } d t t	 d t |  d d  |  } n  d | | } d | } d | t
 j | t
 j d	 |  j  } | d
 k  r| | | } } } n  |  j   }	 |  j   }
 | d
 k r:|  j d
 d
  n |  j d
  |  j |  xH t |  D]: } |  j |  |  j |  |  j d
  |  j |  qaW|  j |  | d
 k r|  j |	 |
  n  |  j |  |  j  rt |  j  _ n  d S(   s   Draw a circle with given radius.

        Arguments:
        radius -- a number
        extent (optional) -- a number
        steps (optional) -- an integer

        Draw a circle with given radius. The center is radius units left
        of the turtle; extent - an angle - determines which part of the
        circle is drawn. If extent is not given, draw the entire circle.
        If extent is not a full circle, one endpoint of the arc is the
        current pen position. Draw the arc in counterclockwise direction
        if radius is positive, otherwise in clockwise direction. Finally
        the direction of the turtle is changed by the amount of extent.

        As the circle is approximated by an inscribed regular polygon,
        steps determines the number of steps to use. If not given,
        it will be calculated automatically. Maybe used to draw regular
        polygons.

        call: circle(radius)                  # full circle
        --or: circle(radius, extent)          # arc
        --or: circle(radius, extent, steps)
        --or: circle(radius, steps=6)         # 6-sided polygon

        Example (for a Turtle instance named turtle):
        >>> turtle.circle(50)
        >>> turtle.circle(120, 180)  # semicircle
        t   seqi   i   g      @g     M@g      ?g      ?g       @g     f@i    N(   R  R  R   R  Rf   R   R  R  R   t   minR   R   R   R   R#   Rl  R  R  R  R   (   R   t   radiust   extentt   stepsRf   t   fracRS  t   w2t   lt   trt   dlR  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR-   >  s>    	.
)	c         C   s   d S(   s/   dummy method - to be overwritten by child classN(    (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRf     s    c         C   s   d S(   s/   dummy method - to be overwritten by child classN(    (   R   t   aR  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR#     s    c         C   s   d S(   s/   dummy method - to be overwritten by child classN(    (   R   R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRl    s    N(.   R   R   R   R   R  t   DEFAULT_MODER  R  R  RX   R   R  R  R3   RV   R  R  R  R<   R(   RW   RH   RS   Rr   Rs   RA   RD   Ra   Rb   R4   Rk   RB   R\   R-   Rf   R#   Rl  R9   R,   R)   RZ   RI   RT   R]   R^   R[   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    sZ   
														#			 #		At   TPenc           B   s  e  Z d  Z e d d  Z e d e d d  Z d d  Z d d  Z d   Z	 d	   Z
 d
   Z d d  Z d   Z d   Z d   Z d   Z d   Z d   Z d d  Z e d  Z e e d  Z d   Z d   Z e Z e	 Z e	 Z e
 Z e
 Z e Z e Z  RS(   sF   Drawing part of the RawTurtle.
    Implements drawing properties.
    RY   c         C   s#   | |  _  d  |  _ t j |   d  S(   N(   t   _resizemodeR   R  R  t   _reset(   R   RY   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    		RO   R;   c         C   sU   d |  _  t |  _ | |  _ | |  _ t |  _ d |  _ d |  _ d |  _ d |  _	 d  S(   Ni   i   i    (   i   i   (
   t   _pensizeR   t   _shownt	   _pencolort
   _fillcolort   _drawingt   _speedt   _stretchfactort   _tiltt   _outlinewidth(   R   RO   R;   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    								c         C   sB   | d k r |  j S| j   } | d k r> |  j d |  n  d S(   sz  Set resizemode to one of the values: "auto", "user", "noresize".

        (Optional) Argument:
        rmode -- one of the strings "auto", "user", "noresize"

        Different resizemodes have the following effects:
          - "auto" adapts the appearance of the turtle
                   corresponding to the value of pensize.
          - "user" adapts the appearance of the turtle according to the
                   values of stretchfactor and outlinewidth (outline),
                   which are set by shapesize()
          - "noresize" no adaption of the turtle's appearance takes place.
        If no argument is given, return current resizemode.
        resizemode("user") is called by a call of shapesize with arguments.


        Examples (for a Turtle instance named turtle):
        >>> turtle.resizemode("noresize")
        >>> turtle.resizemode()
        'noresize'
        t   autot   userR   RY   N(   R$  R%  R   (   R   R  R  RN   (   R   t   rmode(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRY     s
    c         C   s'   | d k r |  j S|  j d |  d S(   s!  Set or return the line thickness.

        Aliases:  pensize | width

        Argument:
        width -- positive number

        Set the line thickness to width or return it. If resizemode is set
        to "auto" and turtleshape is a polygon, that polygon is drawn with
        the same line thickness. If no argument is given, current pensize
        is returned.

        Example (for a Turtle instance named turtle):
        >>> turtle.pensize()
        1
        >>> turtle.pensize(10)   # from here on lines of width 10 are drawn
        RQ   N(   R   R  RN   (   R   Rp   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRQ     s    c         C   s!   |  j  s d S|  j d t  d S(   s   Pull the pen up -- no drawing when moving.

        Aliases: penup | pu | up

        No argument

        Example (for a Turtle instance named turtle):
        >>> turtle.penup()
        NRP   (   R  RN   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRR     s    
	c         C   s!   |  j  r d S|  j d t  d S(   s   Pull the pen down -- drawing when moving.

        Aliases: pendown | pd | down

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.pendown()
        NRP   (   R  RN   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRP     s    
	c         C   s   |  j  S(   s  Return True if pen is down, False if it's up.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.penup()
        >>> turtle.isdown()
        False
        >>> turtle.pendown()
        >>> turtle.isdown()
        True
        (   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRF     s    c         C   s   i d d 6d d 6d d 6d d 6d	 d
 6} | d k r< |  j S| | k rU | | } n7 d | k  ol d k  n r t t |   } n d } |  j d |  d S(   s   Return or set the turtle's speed.

        Optional argument:
        speed -- an integer in the range 0..10 or a speedstring (see below)

        Set the turtle's speed to an integer value in the range 0 .. 10.
        If no argument is given: return current speed.

        If input is a number greater than 10 or smaller than 0.5,
        speed is set to 0.
        Speedstrings  are mapped to speedvalues in the following way:
            'fastest' :  0
            'fast'    :  10
            'normal'  :  6
            'slow'    :  3
            'slowest' :  1
        speeds from 1 to 10 enforce increasingly faster animation of
        line drawing and turtle turning.

        Attention:
        speed = 0 : *no* animation takes place. forward/back makes turtle jump
        and likewise left/right make the turtle turn instantly.

        Example (for a Turtle instance named turtle):
        >>> turtle.speed(3)
        i    t   fastesti
   t   fasti   t   normali   t   slowi   t   slowestg      ?g      %@Rf   N(   R   R   R   R  RN   (   R   Rf   t   speeds(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRf     s    )c         G   s   | r t  |  } | d k r/ | d } } n4 | d k rJ | \ } } n | d k rc | } } n  |  j |  } |  j |  } |  j d | d |  n" |  j |  j  |  j |  j  f Sd S(   s  Return or set the pencolor and fillcolor.

        Arguments:
        Several input formats are allowed.
        They use 0, 1, 2, or 3 arguments as follows:

        color()
            Return the current pencolor and the current fillcolor
            as a pair of color specification strings as are returned
            by pencolor and fillcolor.
        color(colorstring), color((r,g,b)), color(r,g,b)
            inputs as in pencolor, set both, fillcolor and pencolor,
            to the given value.
        color(colorstring1, colorstring2),
        color((r1,g1,b1), (r2,g2,b2))
            equivalent to pencolor(colorstring1) and fillcolor(colorstring2)
            and analogously, if the other input format is used.

        If turtleshape is a polygon, outline and interior of that polygon
        is drawn with the newly set colors.
        For mor info see: pencolor, fillcolor

        Example (for a Turtle instance named turtle):
        >>> turtle.color('red', 'green')
        >>> turtle.color()
        ('red', 'green')
        >>> colormode(255)
        >>> color((40, 80, 120), (160, 200, 240))
        >>> color()
        ('#285078', '#a0c8f0')
        i   i    i   i   RO   R;   N(   R  R  RN   R  R  R  (   R   R1  R  t   pcolort   fcolor(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR2   +  s     c         G   sO   | r; |  j  |  } | |  j k r( d S|  j d |  n |  j |  j  Sd S(   sZ   Return or set the pencolor.

        Arguments:
        Four input formats are allowed:
          - pencolor()
            Return the current pencolor as color specification string,
            possibly in hex-number format (see example).
            May be used as input to another color/pencolor/fillcolor call.
          - pencolor(colorstring)
            s is a Tk color specification string, such as "red" or "yellow"
          - pencolor((r, g, b))
            *a tuple* of r, g, and b, which represent, an RGB color,
            and each of r, g, and b are in the range 0..colormode,
            where colormode is either 1.0 or 255
          - pencolor(r, g, b)
            r, g, and b represent an RGB color, and each of r, g, and b
            are in the range 0..colormode

        If turtleshape is a polygon, the outline of that polygon is drawn
        with the newly set pencolor.

        Example (for a Turtle instance named turtle):
        >>> turtle.pencolor('brown')
        >>> tup = (0.2, 0.8, 0.55)
        >>> turtle.pencolor(tup)
        >>> turtle.pencolor()
        '#33cc8c'
        NRO   (   R  R  RN   R  (   R   R1  R2   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRO   Y  s    c         G   sO   | r; |  j  |  } | |  j k r( d S|  j d |  n |  j |  j  Sd S(   s]   Return or set the fillcolor.

        Arguments:
        Four input formats are allowed:
          - fillcolor()
            Return the current fillcolor as color specification string,
            possibly in hex-number format (see example).
            May be used as input to another color/pencolor/fillcolor call.
          - fillcolor(colorstring)
            s is a Tk color specification string, such as "red" or "yellow"
          - fillcolor((r, g, b))
            *a tuple* of r, g, and b, which represent, an RGB color,
            and each of r, g, and b are in the range 0..colormode,
            where colormode is either 1.0 or 255
          - fillcolor(r, g, b)
            r, g, and b represent an RGB color, and each of r, g, and b
            are in the range 0..colormode

        If turtleshape is a polygon, the interior of that polygon is drawn
        with the newly set fillcolor.

        Example (for a Turtle instance named turtle):
        >>> turtle.fillcolor('violet')
        >>> col = turtle.pencolor()
        >>> turtle.fillcolor(col)
        >>> turtle.fillcolor(0, .5, 0)
        NR;   (   R  R  RN   R  (   R   R1  R2   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR;   ~  s    c         C   s   |  j  d t  d S(   s   Makes the turtle visible.

        Aliases: showturtle | st

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        >>> turtle.showturtle()
        t   shownN(   RN   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRe     s    c         C   s   |  j  d t  d S(   sY  Makes the turtle invisible.

        Aliases: hideturtle | ht

        No argument.

        It's a good idea to do this while you're in the
        middle of a complicated drawing, because hiding
        the turtle speeds up the drawing observably.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        R/  N(   RN   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRC     s    c         C   s   |  j  S(   s   Return True if the Turtle is shown, False if it's hidden.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        >>> print turtle.isvisible():
        False
        (   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRG     s    
c   	      K   s6  i
 |  j  d 6|  j d 6|  j d 6|  j d 6|  j d 6|  j d 6|  j d 6|  j d 6|  j d	 6|  j	 d
 6} | ps | sz | St
 | t  r | } n i  } | j |  i  } x | D] } | | | | <q W|  j r |  j j d | f  n  t } d | k r|  j | d k rt } qn  d | k rxt
 | d t  rY|  j | d f  | d <n  |  j | d k rxt } qxn  d | k r|  j | d k rt } qn  | r|  j   n  d | k r| d |  _ n  d | k r| d |  _ n  d | k r
| d |  _ n  d | k rVt
 | d t  rF|  j | d f  | d <n  | d |  _ n  d | k rr| d |  _ n  d | k r| d |  _ n  d | k r| d } t
 | t t f  r| | f } n  | |  _ n  d	 | k r| d	 |  _ n  d | k r| d |  _  n  d
 | k r(| d
 |  _	 n  |  j   d S(   s  Return or set the pen's attributes.

        Arguments:
            pen -- a dictionary with some or all of the below listed keys.
            **pendict -- one or more keyword-arguments with the below
                         listed keys as keywords.

        Return or set the pen's attributes in a 'pen-dictionary'
        with the following key/value pairs:
           "shown"      :   True/False
           "pendown"    :   True/False
           "pencolor"   :   color-string or color-tuple
           "fillcolor"  :   color-string or color-tuple
           "pensize"    :   positive number
           "speed"      :   number in range 0..10
           "resizemode" :   "auto" or "user" or "noresize"
           "stretchfactor": (positive number, positive number)
           "outline"    :   positive number
           "tilt"       :   number

        This dictionary can be used as argument for a subsequent
        pen()-call to restore the former pen-state. Moreover one
        or more of these attributes can be provided as keyword-arguments.
        This can be used to set several pen attributes in one statement.


        Examples (for a Turtle instance named turtle):
        >>> turtle.pen(fillcolor="black", pencolor="red", pensize=10)
        >>> turtle.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',
        'stretchfactor': (1,1), 'speed': 3}
        >>> penstate=turtle.pen()
        >>> turtle.color("yellow","")
        >>> turtle.penup()
        >>> turtle.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',
        'stretchfactor': (1,1), 'speed': 3}
        >>> p.pen(penstate, fillcolor="green")
        >>> p.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',
        'stretchfactor': (1,1), 'speed': 3}
        R/  RP   RO   R;   RQ   Rf   RY   t   stretchfactorRU  Ri   RN   N(   R  R  R  R  R  R   R  R!  R#  R"  R   t   dictR%   R  R  R   R   R   R  t   _newLineR   R   Rj  (	   R   RN   t   pendictt   _pdt   pt   _p_bufR   t   newLinet   sf(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRN     sz    .







		
c         C   s   d S(   s/   dummy method - to be overwritten by child classN(    (   R   t   usePos(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR2  @	  s    c         C   s   d S(   s/   dummy method - to be overwritten by child classN(    (   R   R  t   forced(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRj  B	  s    c         C   s   d S(   s/   dummy method - to be overwritten by child classN(    (   R   R1  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  D	  s    c         C   s   d S(   s/   dummy method - to be overwritten by child classN(    (   R   R1  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  F	  s    N(!   R   R   R   R   R  R  R   RY   RQ   RR   RP   RF   Rf   R2   RO   R;   Re   RC   RG   RN   R   R2  R   Rj  R  R  Rp   Ro   RU   RM   R6   Rg   RE   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s8   			&	.	%	$			u		t   _TurtleImagec           B   s    e  Z d  Z d   Z d   Z RS(   s6   Helper class: Datatype to store Turtle attributes
    c         C   s#   | |  _  d  |  _ |  j |  d  S(   N(   R   R   R  t	   _setshape(   R   R   t
   shapeIndex(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  V	  s    		c         C   se  |  j  } | |  _ |  j d k o6 | j | j k n r? d  S|  j d k oc | j | j k n rl d  S|  j d k r | j |  j  n3 |  j d k r x! |  j D] } | j |  q Wn  | j | j |  _ |  j d k r | j   |  _ nl |  j d k r#| j | j d j  |  _ n> |  j d k rag  | j | j D] } | j   ^ qC|  _ n  d  S(   NR  R  R  RK  (   R  R  (	   R   R=  R  R  Ri  t   _itemRW  R  R  (   R   R=  R   Rh  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR<  [	  s&    		))(   R   R   R   R  R<  (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR;  R	  s   	c           B   s  e  Z d  Z g  Z d8 e d e d e d d  Z d   Z d   Z d   Z	 d   Z
 d	   Z d
   Z d   Z d8 d8 d  Z d   Z d   Z d   Z d   Z d8 d  Z d8 d8 d8 d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d8 d  Z d   Z d   Z d   Z  e! d  Z" d8 d   Z# d!   Z$ d"   Z% d8 d#  Z& d$   Z' e( d% d9 d)  Z) d*   Z* d+   Z+ d,   Z, d-   Z- d.   Z. e. Z/ d/   Z0 d0   Z1 d8 d1  Z2 d2 d8 d3  Z3 d2 d8 d4  Z4 d2 d8 d5  Z5 d6   Z6 d7   Z7 e Z8 RS(:   sv   Animation part of the RawTurtle.
    Puts RawTurtle upon a TurtleScreen and provides tools for
    its animation.
    Rc   R   R   c         C   s  t  | t  r | |  _ n t  | t  rX | t j k rL t j j |  n  | |  _ nz t  | t t f  r xb t j D]" } | j	 | k rw | |  _ Pqw qw Wt |  |  _ t j j |  j  n t
 d |   |  j } t j |  | j    t j |   | j j |   | j   |  _ t | |  |  _ d  |  _ t |  _ d  |  _ |  _ | |  _ t |  _ | j   |  _ |  j g |  _ |  j g |  _ g  |  _  | |  _! t" |  |  _# |  j$   d  S(   Ns   bad canvas argument %s(%   R   t   _ScreenR   R   R   t   screensRX  R   R  RP  R  R  R  R   R  R  Rd  t   drawingLineItemR;  R   R   t   _polyR   t   _creatingPolyt	   _fillitemt	   _fillpathR  t   _hidden_from_screent   currentLineItemR  t   currentLineR   t
   stampItemst   _undobuffersizeR  R  Rj  (   R   t   canvasRc   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  x	  s@    								c         C   s<   t  j |   t j |   |  j   |  j   |  j   d S(   s  Delete the turtle's drawings and restore its default values.

        No argument.
,
        Delete the turtle's drawings from the screen, re-center the turtle
        and set variables to the default values.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00,-22.00)
        >>> turtle.heading()
        100.0
        >>> turtle.reset()
        >>> turtle.position()
        (0.00,0.00)
        >>> turtle.heading()
        0.0
        N(   R  RX   R  R  t   _clearR  Rj  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRX   	  s
    

c         C   s7   | d k s | d k r$ d |  _ n t |  |  _ d S(   s  Set or disable undobuffer.

        Argument:
        size -- an integer or None

        If size is an integer an empty undobuffer of given size is installed.
        Size gives the maximum number of turtle-actions that can be undone
        by the undo() function.
        If size is None, no undobuffer is present.

        Example (for a Turtle instance named turtle):
        >>> turtle.setundobuffer(42)
        i    N(   R   R  R  (   R   t   size(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR`   	  s    c         C   s    |  j  d k r d S|  j  j   S(   s   Return count of entries in the undobuffer.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> while undobufferentries():
        ...     undo()
        i    N(   R  R   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRn   	  s    	c         C   s   d |  _ |  _ x! |  j D] } |  j j |  q W|  j j   |  _ g  |  _ |  j	 rn |  j j
 |  j  n  |  j g |  _ |  j   |  j |  j  d S(   s   Delete all of pen's drawingsN(   R   RD  RE  R   R   Ri  Rd  RG  RH  R  RX  R  R0   R`   RJ  (   R   Rh  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRL  	  s    		
c         C   s   |  j    |  j   d S(   sg  Delete the turtle's drawings from the screen. Do not move turtle.

        No arguments.

        Delete the turtle's drawings from the screen. Do not move turtle.
        State and position of the turtle as well as drawings of other
        turtles are not affected.

        Examples (for a Turtle instance named turtle):
        >>> turtle.clear()
        N(   RL  Rj  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR.   	  s    
c         C   sd   |  j  j   |  j  j d k r# d  St |  j  d k r` |  j  j |  j |  j |  j |  j  n  d  S(   Ni    i   (	   R   R  R  R  RH  Rf  RG  R  R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  	  s    c         C   s   |  j  } | j d k r d S| j d k r\ |  j   |  j   | j   | j | j  nG |  j   | j d k r x | j   D] } | j   q W| j   n  d S(   s&   Perform a Turtle-data update.
        i    Ni   (	   R   R  R  R  Rj  Rl  R  R  R$   (   R   R   R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRj  	  s    	



c         C   s   |  j  j | |  S(   sm  Turns turtle animation on/off and set delay for update drawings.

        Optional arguments:
        n -- nonnegative  integer
        delay -- nonnegative  integer

        If n is given, only each n-th regular screen update is really performed.
        (Can be used to accelerate the drawing of complex graphics.)
        Second arguments sets delay value (see RawTurtle.delay())

        Example (for a Turtle instance named turtle):
        >>> turtle.tracer(8, 25)
        >>> dist = 2
        >>> for i in range(200):
        ...     turtle.fd(dist)
        ...     turtle.rt(90)
        ...     dist += 2
        (   R   R#   (   R   t   flagR   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR#   
  s    c         C   s   |  j  j |  S(   N(   R   R  (   R   R1  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  %
  s    c         C   s   |  j  j |  S(   N(   R   R  (   R   R1  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  (
  s    c         C   s  t  | t  r | Sy | \ } } } Wn- t t f k
 rU t d t |    n X|  j j d k r g  | | | f D] } t d |  ^ qx \ } } } n  d | k o d k n o d | k o d k n o d | k o d k n st d t |    n  d | | | f S(   s,   Convert colortriples to hexstrings.
        s   bad color arguments: %sg      ?g     o@i    i   s   bad color sequence: %ss   #%02x%02x%02x(	   R   R  R  R   R  R  R   R  R  (   R   R1  R   R  R  R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _cc+
  s    8Tc         C   sI  |  j  } |  j |  j  |  j } d |  _  d |  _ t |   } | |  _  | |  _ | | _  t | |  j j  | _ | j j	 |  | j
 |  j j j } | d k r | j   | j _ nr | d k r | j | j
 d j  | j _ nD | d k r,g  | j
 |  j j j D] } | j   ^ q| j _ n  | j   | _ | j   | S(   s  Create and return a clone of the turtle.

        No argument.

        Create and return a clone of the turtle with same position, heading
        and turtle properties.

        Example (for a Turtle instance named mick):
        mick = Turtle()
        joe = mick.clone()
        R  R  RK  R  N(   R   R2  R  R   R   R   R;  R=  R  RX  R  R  RW  R>  R  R  Rd  RG  Rj  (   R   R   R   t   qt   ttypeRh  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR1   :
  s,    							"5
c         C   s\   | d k r |  j j S| |  j j   k r> t d |   n  |  j j |  |  j   d S(   s  Set turtle shape to shape with given name / return current shapename.

        Optional argument:
        name -- a string, which is a valid shapename

        Set turtle shape to shape with given name or, if name is not given,
        return name of current shape.
        Shape with name must exist in the TurtleScreen's shape dictionary.
        Initially there are the following polygon shapes:
        'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.
        To learn about how to deal with shapes see Screen-method register_shape.

        Example (for a Turtle instance named turtle):
        >>> turtle.shape()
        'arrow'
        >>> turtle.shape("turtle")
        >>> turtle.shape()
        'turtle'
        s   There is no shape named %sN(   R   R   R=  R   R   R  R<  Rj  (   R   R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRc   b
  s    
c         C   s   | | k o" | k o" d k n rF |  j \ } } | | |  j f S| d k	 r| | d k rm | | f } q | | f } n+ | d k	 r |  j d | f } n	 |  j } | d k r |  j } n  |  j d d d | d |  d S(   sO  Set/return turtle's stretchfactors/outline. Set resizemode to "user".

        Optional arguments:
           stretch_wid : positive number
           stretch_len : positive number
           outline  : positive number

        Return or set the pen's attributes x/y-stretchfactors and/or outline.
        Set resizemode to "user".
        If and only if resizemode is set to "user", the turtle will be displayed
        stretched according to its stretchfactors:
        stretch_wid is stretchfactor perpendicular to orientation
        stretch_len is stretchfactor in direction of turtles orientation.
        outline determines the width of the shapes's outline.

        Examples (for a Turtle instance named turtle):
        >>> turtle.resizemode("user")
        >>> turtle.shapesize(5, 5, 12)
        >>> turtle.shapesize(outline=8)
        i    RY   R%  R0  RU  N(   R   R!  R#  RN   (   R   t   stretch_widt   stretch_lenRU  R0  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRd   }
  s    '	c         C   sK   | |  j  |  j } | t j d d t j } |  j d d d |  d S(   sZ  Rotate the turtleshape to point in the specified direction

        Optional argument:
        angle -- number

        Rotate the turtleshape to point in the direction specified by angle,
        regardless of its current tilt-angle. DO NOT change the turtle's
        heading (direction of movement).


        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.settiltangle(45)
        >>> stamp()
        >>> turtle.fd(50)
        >>> turtle.settiltangle(-45)
        >>> stamp()
        >>> turtle.fd(50)
        g     f@i   RY   R%  Ri   N(   R   R  R   R   RN   (   R   R   Ri   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR_   
  s    c         C   s.   |  j  d t j |  j } | |  j |  j S(   s  Return the current tilt-angle.

        No argument.

        Return the current tilt-angle, i. e. the angle between the
        orientation of the turtleshape and the heading of the turtle
        (its direction of movement).

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.tilt(45)
        >>> turtle.tiltangle()
        g     f@(   R"  R   R   R  R   R  (   R   Ri   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRj   
  s    c         C   s   |  j  | |  j    d S(   s  Rotate the turtleshape by angle.

        Argument:
        angle - a number

        Rotate the turtleshape by angle from its current tilt-angle,
        but do NOT change the turtle's heading (direction of movement).

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.tilt(30)
        >>> turtle.fd(50)
        >>> turtle.tilt(30)
        >>> turtle.fd(50)
        N(   R_   Rj   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRi   
  s    c   
      C   s   |  j  } |  j \ } } |  j \ } } t | | | j | j  } d t |  | \ } } g  | D]G \ } }	 | | | | |	 | j | | | | |	 | j f ^ qe S(   sl   Computes transformed polygon shapes from a shape
        according to current position and heading.
        g      ?(   R   R  R  R   RR  RQ  R  (
   R   R  R   t   p0t   p1t   e0t   e1R~   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt
   _polytrafo
  s    	c         C   s}  |  j  } | j |  j j } | j } |  j j } |  j r| j d k r| j d k rt	 |  _
 | j } | d k r|  j d k r d } | } n |  j d k r t d |  j d  } } |  j } d }	 n3 |  j d k r|  j \ } } |  j } |  j }	 n  g  | D]  \ }
 } | |
 | | f ^ q	} t j |	  t j |	  } } g  | D]1 \ }
 } | |
 | | | |
 | | f ^ qU} |  j |  } |  j |  j } } | j | | d | d	 | d
 | d t qy| d k r| j | |  j |  qy| d k ry|  j \ } } |  j } x t | |  D] \ } \ } } } g  | D]  \ }
 } | |
 | | f ^ qN} |  j |  } | j | | d |  j |  d	 |  j |  d
 | d t q2Wqyn |  j
 rd S| d k r| j | d d d f d d  nn | d k r1| j | |  j | j d j  n? | d k rpx0 | D]% } | j | d d d f d d  qDWn  t |  _
 d S(   sp   Manages the correct rendering of the turtle with respect to
        its shape, resizemode, stretch and tilt etc.i    R  R   i   R$  g      @R%  R:   RU  Rp   R^  R  R  NR   RK  (   i    i    (   i    i    (   i    i    (   i    i    (   i    i    (   i    i    (   R   R  R   R=  R  R>  R  R  R  R   RF  R  R  t   maxR  R!  R#  R"  R   R   R|   RX  R  R  R`  R   R  R  t   zipRO  (   R   R   Rc   RQ  t   titemt   tshapeRS  t   lxt   lyRj   R   R   t   t0t   t1t   fct   ocRh  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  
  s^    		'						->	%-&	"&c         C   s	  |  j  } | j |  j j } | j } | j } | d k r| j   } |  j d k rd d } | } n |  j d k r t d |  j	 d  } } |  j	 } d }	 n3 |  j d k r |  j
 \ } } |  j } |  j }	 n  g  | D]  \ }
 } | |
 | | f ^ q } t j |	  t j |	  } } g  | D]1 \ }
 } | |
 | | | |
 | | f ^ q%} |  j |  } |  j |  j } } | j | | d | d	 | d
 | d t n6| d k r| j d  } | j | |  j |  n| d k rg  } x' | D] } | j   } | j |  qWt |  } |  j
 \ } } |  j } x t | |  D] \ } \ } } } g  | D]  \ }
 } | |
 | | f ^ qi} |  j |  } | j | | d |  j |  d	 |  j |  d
 | d t qMWn  |  j j |  |  j j d | f  | S(   s  Stamp a copy of the turtleshape onto the canvas and return its id.

        No argument.

        Stamp a copy of the turtle shape onto the canvas at the current
        turtle position. Return a stamp_id for that stamp, which can be
        used to delete it by calling clearstamp(stamp_id).

        Example (for a Turtle instance named turtle):
        >>> turtle.color("blue")
        >>> turtle.stamp()
        13
        >>> turtle.fd(50)
        R  R   i   R$  g      @i    R%  R:   RU  Rp   R^  R  R   R  Rh   (   R   R  R   R=  R  R  RW  R  RY  R  R!  R#  R"  R   R   R|   RX  R  R  R`  R   R  R  R  RX  R   RZ  RO  RI  R  R  (   R   R   Rc   RQ  R\  t   stitemRS  R]  R^  Rj   R   R   R_  R`  Ra  Rb  t   elementRh  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRh   $  sV    							->	%-#c         C   s   | |  j  k re t | t  rB x1 | D] } |  j j |  q% Wn |  j j |  |  j  j |  n  d | f } |  j } | | j k r d S| j j |  } | j j |  | | j	 k r | j	 d | j
 | _	 n  | j j | j	 d | j
 d g  d S(   s9   does the work for clearstamp() and clearstamps()
        Rh   Ni   (   RI  R   R   R   Ri  R  R  R  t   indexR  R  t   insertR   (   R   t   stampidt   subitemRh  t   bufRe  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _clearstamp`  s    	c         C   s   |  j  |  |  j   d S(   sD  Delete stamp with given stampid

        Argument:
        stampid - an integer, must be return value of previous stamp() call.

        Example (for a Turtle instance named turtle):
        >>> turtle.color("blue")
        >>> astamp = turtle.stamp()
        >>> turtle.fd(50)
        >>> turtle.clearstamp(astamp)
        N(   Rj  Rj  (   R   Rg  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR/   v  s    c         C   sn   | d k r |  j } n) | d k r5 |  j |  } n |  j | } x | D] } |  j |  qI W|  j   d S(   s  Delete all or first/last n of turtle's stamps.

        Optional argument:
        n -- an integer

        If n is None, delete all of pen's stamps,
        else if n > 0 delete first n stamps
        else if n < 0 delete last n stamps.

        Example (for a Turtle instance named turtle):
        >>> for i in range(8):
        ...     turtle.stamp(); turtle.fd(30)
        ...
        >>> turtle.clearstamps(2)
        >>> turtle.clearstamps(-2)
        >>> turtle.clearstamps()
        i    N(   R   RI  Rj  Rj  (   R   R  t   toDeleteRh  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR0     s    c         C   sf  |  j  |  j |  j t |  j t  f } |  j } d |  j | | |  j |  j	 | j
 |  j  |  j f f } |  j r |  j j |  n  |  j } |  j r| j d k r| | } | d | j d | d | j d } d t | d d d |  j |  j  } | d | }	 x t d |  D]s }
 |
 d k r=t } n t } | |	 |
 |  _ |  j  r| j |  j | |  j f |  j |  j |  n  |  j   q"W|  j  r| j |  j d d f d	 d
 d |  j qn  |  j  r|  j	 j |  n  t |  j t  r|  j j |  n  | |  _ |  j r6|  j j |  n  t |  j	  d k rX|  j   n  |  j   d S(   s   Move the pen to the point end, thereby drawing a line
        if pen is down. All other methods for turtle movement depend
        on this one.
        t   goi   i    i   g      ?i   g?g      ?R:   R   Rp   i*   N(   i    i    (   i    i    (   R  R  R  R   RE  R   R   R  RG  RH  R  R   R  R  R   R  RQ  RR  R   R  R   R   Rf  RA  Rj  RX  RC  RB  R  R2  (   R   R  t   go_modesR   t
   undo_entryt   startt   difft   diffsqt   nhopst   deltaR  R^  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    sR    			
(*						c         C   s  | \ } } } } | \ } } } }	 | \ }
 } } } |  j  } t |  j |  d k r` d GHn  |
 |  _ | |  _ | d d g k r d } n | } | j |
 | d | d | g  |  j D]- } | | k r | j |  d k r | ^ q } x+ | D]# } | j |  |  j j	 |  q W| } |  j
 rQ| j d k rQ| | } | d | j d	 | d | j d	 } d t | d d
 d |  j
 |  j
  } | d | } x{ t d |  D]j } | d k rt } n t } | | | |  _ | r| j |  j | |  j f | | |  n  |  j   qW| rQ| j |  j d d f d d d | qQn  | |  _ |  j rt |  j  d k r|  j j   n  |  j g  k rt |  _ d |  _ qn  |	 r|  j g  k rd |  _ d GHq|  j d k	 r|  j j   qn  |  j   d S(   s)   Reverse a _goto. Used for undo()
        g      ?s$   undogoto: HALLO-DA-STIMMT-WAS-NICHT!i    R   R:   Rp   R   i   i   i   g?g      ?s   Unwahrscheinlich in _undogoto!N(   i    i    (   i    i    (   i    i    (   i    i    (   R   R  R  RG  RH  Rf  R   R  Ri  R  R   R  RQ  RR  R   R  R   R   RA  Rj  RC  R  RB  R  R   RE  (   R   t   entryt   oldt   newRm  t   coodatat   drawingt   pct   pst   fillingt   cLIt   cLR  R   R   t   usepcR  t   todeleteRo  Rp  Rq  Rr  Rs  R  R^  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   _undogoto  sd    				!
(*					c         C   s   |  j  r( |  j  j d | |  j f  n  | |  j 9} |  j j |  } |  j j } | d k r |  j d k r d |  j } d t t	 |  |  } d | | } x6 t
 |  D]% } |  j j |  |  _ |  j   q Wn  | |  _ |  j   d S(   s&   Turns pen clockwise by angle.
        t   roti   i    g      @g      ?N(   R  R  R   R  R   R   R  R   R   R  R  Rj  (   R   R   t	   neworientR  t   anglevelR  Rs  R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    		c         C   s   t  |  j  d k rb |  j j |  j |  j |  j |  j  |  j j   |  _ |  j j	 |  j  n |  j j |  j d t
 g  |  _ | r |  j g |  _ n  d S(   s   Closes current line item and starts a new one.
           Remark: if current line became too long, animation
           performance (via _drawline) slowed down considerably.
        i   R^  N(   R  RH  R   Rf  RG  R  R  Rd  R   RX  R   R  (   R   R9  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR2  )  s    	c         C   sm  t  |  j t  } | d k r" | S|  j } d } } | r t |  j  d k r |  j j |  j |  j d |  j d |  j f } q n  | r |  j j	   |  _ |  j
 j |  j  |  j g |  _ d |  j f } |  j   n d |  _ |  _ |  j r_| d k r$| d	 k r\|  j j |  q\q_| d
 k rC|  j j |  q_|  j j d | | g  n  |  j   d S(   s  Call fill(True) before drawing a shape to fill, fill(False) when done.

        Optional argument:
        flag -- True/False (or 1/0 respectively)

        Call fill(True) before drawing the shape you want to fill,
        and  fill(False) when done.
        When used without argument: return fillstate (True if filling,
        False else)

        Example (for a Turtle instance named turtle):
        >>> turtle.fill(True)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.fill(False)
        i   R:   t   dofillt	   beginfillR  N(    (    (    (    (   R   RE  R   R   R   R  R`  RD  R  RW  R   RX  R  R2  R  R  Rj  (   R   RN  R{  R   t   entry1t   entry2(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR:   9  s2    	

	c         C   s   |  j  t  d S(   s  Called just before drawing a shape to be filled.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.begin_fill()
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.end_fill()
        N(   R:   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR*   l  s    c         C   s   |  j  t  d S(   s  Fill the shape drawn after the call begin_fill().

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.begin_fill()
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.left(90)
        >>> turtle.forward(100)
        >>> turtle.end_fill()
        N(   R:   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR7   ~  s    c         G   s  | st t  | t t f  rF |  j |  } |  j t |  j d  } q |  j } | s |  j t |  j d  } q n7 | d k r |  j t |  j d  } n  |  j |  } t |  j	 d  r|  j	 j
 |  j | |  } |  j j |  |  j r|  j j d | f  qn |  j   } |  j rD|  j j d g  t |  j _ n  zT |  j   d k rf|  j   n  |  j   |  j |  |  j |  |  j d  Wd |  j |  X|  j rt |  j _ n  d S(   s  Draw a dot with diameter size, using color.

        Optional arguments:
        size -- an integer >= 1 (if given)
        color -- a colorstring or a numeric color tuple

        Draw a circular dot with diameter size, using color.
        If size is not given, the maximum of pensize+4 and 2*pensize is used.

        Example (for a Turtle instance named turtle):
        >>> turtle.dot()
        >>> turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)
        i   t   _dotR5   R  R$  i    N(   R   R  R   R  R  RY  R  R   t   hasattrR   R  R  R   RX  R  R  RN   R   R  RY   RE   RP   RQ   RO   R<   R   (   R   RM  R2   Rh  RN   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR5     s:    			
	c         C   s`   |  j  j |  j | | | |  j  \ } } |  j j |  |  j r\ |  j j d | f  n  | S(   s)   Performs the writing for write()
        t   wri(   R   R  R  R  R   RX  R  R  (   R   Rz  R{  Rx  Rh  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    	RH   t   Ariali   R)  c         C   s   |  j  r+ |  j  j d g  t |  j  _ n  |  j t |  | j   |  } | rw |  j   \ } } |  j | |  n  |  j  r t	 |  j  _ n  d S(   s  Write text at the current turtle position.

        Arguments:
        arg -- info, which is to be written to the TurtleScreen
        move (optional) -- True/False
        align (optional) -- one of the strings "left", "center" or right"
        font (optional) -- a triple (fontname, fontsize, fonttype)

        Write text - the string representation of arg - at the current
        turtle position according to align ("left", "center" or right")
        and with the given font.
        If move is True, the pen is moved to the bottom-right corner
        of the text. By default, move is False.

        Example (for a Turtle instance named turtle):
        >>> turtle.write('Home = ', True, align="center")
        >>> turtle.write((0,0), True)
        R  N(
   R  R  R   R  R  R  R  RS   R]   R   (   R   t   argt   moveR{  Rx  R  R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRq     s    	!	c         C   s   |  j  g |  _ t |  _ d S(   s  Start recording the vertices of a polygon.

        No argument.

        Start recording the vertices of a polygon. Current turtle position
        is first point of polygon.

        Example (for a Turtle instance named turtle):
        >>> turtle.begin_poly()
        N(   R  RB  R   RC  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR+     s    c         C   s   t  |  _ d S(   s7  Stop recording the vertices of a polygon.

        No argument.

        Stop recording the vertices of a polygon. Current turtle position is
        last point of polygon. This will be connected with the first point.

        Example (for a Turtle instance named turtle):
        >>> turtle.end_poly()
        N(   R   RC  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR8     s    c         C   s    |  j  d k	 r t |  j   Sd S(   s   Return the lastly recorded polygon.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> p = turtle.get_poly()
        >>> turtle.register_shape("myFavouriteShape", p)
        N(   RB  R   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR=     s    
c         C   s   |  j  S(   s  Return the TurtleScreen object, the turtle is drawing  on.

        No argument.

        Return the TurtleScreen object, the turtle is drawing  on.
        So TurtleScreen-methods can be called for that object.

        Example (for a Turtle instance named turtle):
        >>> ts = turtle.getscreen()
        >>> ts
        <turtle.TurtleScreen object at 0x0106B770>
        >>> ts.bgcolor("pink")
        (   R   (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR?     s    c         C   s   |  S(   sU  Return the Turtleobject itself.

        No argument.

        Only reasonable use: as a function to return the 'anonymous turtle':

        Example:
        >>> pet = getturtle()
        >>> pet.fd(50)
        >>> pet
        <turtle.Turtle object at 0x0187D810>
        >>> turtles()
        [<turtle.Turtle object at 0x0187D810>]
        (    (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR@   "  s    c         C   s   |  j  j   d S(   s    Returns the width of the turtle window.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_width()
        640
        i    (   R   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR'   :  s    	c         C   s   |  j  j   d S(   s    Return the height of the turtle window.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_height()
        480
        i   (   R   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR&   E  s    	c         C   s   |  j  j |  S(   sD   Set delay value which determines speed of turtle animation.
        (   R   R   (   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRl  P  s    i   c         C   s-   |  j  j |  j j | | |  |  j   d S(   s  Bind fun to mouse-click event on this turtle on canvas.

        Arguments:
        fun --  a function with two arguments, to which will be assigned
                the coordinates of the clicked point on the canvas.
        num --  number of the mouse-button defaults to 1 (left mouse button).
        add --  True or False. If True, new binding will be added, otherwise
                it will replace a former binding.

        Example for the anonymous turtle, i. e. the procedural way:

        >>> def turn(x, y):
        ...     left(360)
        ...
        >>> onclick(turn)  # Now clicking into the turtle will turn it.
        >>> onclick(None)  # event-binding will be removed
        N(   R   R  R   R>  Rj  (   R   R  R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRJ   W  s    c         C   s-   |  j  j |  j j | | |  |  j   d S(   s  Bind fun to mouse-button-release event on this turtle on canvas.

        Arguments:
        fun -- a function with two arguments, to which will be assigned
                the coordinates of the clicked point on the canvas.
        num --  number of the mouse-button defaults to 1 (left mouse button).

        Example (for a MyTurtle instance named joe):
        >>> class MyTurtle(Turtle):
        ...     def glow(self,x,y):
        ...             self.fillcolor("red")
        ...     def unglow(self,x,y):
        ...             self.fillcolor("")
        ...
        >>> joe = MyTurtle()
        >>> joe.onclick(joe.glow)
        >>> joe.onrelease(joe.unglow)

        Clicking on joe turns fillcolor red, unclicking turns it to
        transparent.
        N(   R   R  R   R>  Rj  (   R   R  R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRL   l  s    c         C   s#   |  j  j |  j j | | |  d S(   s  Bind fun to mouse-move event on this turtle on canvas.

        Arguments:
        fun -- a function with two arguments, to which will be assigned
               the coordinates of the clicked point on the canvas.
        num -- number of the mouse-button defaults to 1 (left mouse button).

        Every sequence of mouse-move-events on a turtle is preceded by a
        mouse-click event on that turtle.

        Example (for a Turtle instance named turtle):
        >>> turtle.ondrag(turtle.goto)

        Subsequently clicking and dragging a Turtle will move it
        across the screen thereby producing handdrawings (if pen is
        down).
        N(   R   R  R   R>  (   R   R  R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRK     s    c         C   s  |  j  d k r d S| d k rV | \ } } |  j | | |  j  |  j  j   } n5| d k r| | d } |  j |  n| d k r |  j |  n | d k r | d } |  j j |  |  j	 j
 |  n | d k r| d } |  j j | d d d f d	 d
 d d
 ny | d k r[| d } d |  _ |  _ |  j j |  |  j	 j
 |  n0 | d k rt j |  | d  |  j  j   n  d S(   s2   Does the main part of the work for undo()
        NR  Rh   i    Rl  R  R5   R  R:   R   RU  R  RN   (   R  R5   (   i    i    (   i    i    (   i    i    (   R  R   R  R   R  R/   R  R   Ri  R   R  R`  RD  RE  R  RN   (   R   t   actionR  R   t   degPAUt   dummyRc  Rh  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _undo  s6    



c         C   s   |  j  d k r d S|  j  j   } | d } | d } | d k rv xA | rr | j   } |  j | d | d  qE Wn |  j | |  d S(   s  undo (repeatedly) the last turtle action.

        No argument.

        undo (repeatedly) the last turtle action.
        Number of available undo actions is determined by the size of
        the undobuffer.

        Example (for a Turtle instance named turtle):
        >>> for i in range(4):
        ...     turtle.fd(50); turtle.lt(80)
        ...
        >>> for i in range(8):
        ...     turtle.undo()
        ...
        Ni    i   R  (   R  R   R  R  (   R   Rh  R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRm     s    

	N(   R  i   R)  (9   R   R   R   R@  R   R   R  RX   R`   Rn   RL  R.   R  Rj  R#   R  R  RO  R1   Rc   Rd   R_   Rj   Ri   RX  R  Rh   Rj  R/   R0   R  R  R  R   R2  R:   R*   R7   R5   R  R   Rq   R+   R8   R=   R?   R@   R>   R'   R&   Rl  RJ   RL   RK   R  Rm   Rl   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   q	  sl   %											(&					7	<			5	A	3		3	
									c           C   s%   t  j d k r t   t  _ n  t  j S(   s   Return the singleton screen object.
    If none exists at the moment, create a new one and return it,
    else return the existing one.N(   R	   t   _screenR   R?  (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR     s    R?  c           B   sp   e  Z d Z d Z e d  Z d   Z e d e d e d e d d  Z d   Z	 d   Z
 d	   Z d
   Z RS(   R"   c         C   s   t  j d  k rK t   t  _ |  _ |  j j t  j  |  j j |  j  n  t  j d  k r t	 d } t	 d } t	 d } t	 d } t	 d } t	 d } |  j j
 | | | |  |  j j   t  _ t j |  t  j  |  j | | | |  n  d  S(   NRp   R   R   R   R   R   (   R?  t   _rootR   R6  R"   t   _titleRD  t   _destroyR  R   R;  R<  R   R  R    (   R   Rp   R   R   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    





Rp   R   R   R   c         C   s  t  |  j d  s d S|  j j   } |  j j   } t | t  rl d | k oZ d k n rl | | } n  | d k r | | d } n  t | t  r d | k o d k n r | | } n  | d k r | | d } n  |  j j | | | |  |  j   d S(   s   Set the size and position of the main window.

        Arguments:
        width: as integer a size in pixels, as float a fraction of the screen.
          Default is 50% of screen.
        height: as integer the height in pixels, as float a fraction of the
          screen. Default is 75% of screen.
        startx: if positive, starting position in pixels from the left
          edge of the screen, if negative from the right edge
          Default, startx=None is to center window horizontally.
        starty: if positive, starting position in pixels from the top
          edge of the screen, if negative from the bottom edge
          Default, starty=None is to center window vertically.

        Examples (for a Screen instance named screen):
        >>> screen.setup (width=200, height=200, startx=0, starty=0)

        sets window to 200x200 pixels, in upper left of screen

        >>> screen.setup(width=.75, height=0.5, startx=None, starty=None)

        sets window to 75% of screen by 50% of screen and centers
        R@  Ni    i   i   (	   R  R  RF  RH  R   R   R   R@  R%   (   R   Rp   R   R>  R?  Rs  t   sh(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR       s    ++c         C   s/   t  j d k	 r" t  j j |  n  | t  _ d S(   sq  Set title of turtle-window

        Argument:
        titlestring -- a string, to appear in the titlebar of the
                       turtle graphics window.

        This is a method of Screen-class. Not available for TurtleScreen-
        objects.

        Example (for a Screen instance named screen):
        >>> screen.title("Welcome to the turtle-zoo!")
        N(   R?  R  R   R"   R  (   R   t   titlestring(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR"   (  s    c         C   sV   |  j  } | t j  k r? d  t _ d  t _ d  t _  d  t _ n  t t _	 | j
   d  S(   N(   R  R?  R   R	   R  R  R  R   R   R  RC  (   R   t   root(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  9  s    					c         C   s   |  j    d S(   s~   Shut the turtlegraphics window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bye()
        N(   R  (   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR   C  s    c            sW     f d   }   j  |  t d r* d Sy t   Wn t k
 rR t d  n Xd S(   sl  Go into mainloop until the mouse is clicked.

        No arguments.

        Bind bye() method to mouseclick on TurtleScreen.
        If "using_IDLE" - value in configuration dictionary is False
        (default value), enter mainloop.
        If IDLE with -n switch (no subprocess) is used, this value should be
        set to True in turtle.cfg. In this case IDLE's mainloop
        is active also for the client script.

        This is a method of the Screen-class and not available for
        TurtleScreen instances.

        Example (for a Screen instance named screen):
        >>> screen.exitonclick()

        c            s     j    d S(   s&   Screen.bye() with two dummy-parametersN(   R   (   R   R   (   R   (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   exitGracefully^  s    R   Ni    (   RJ   R   Rv   t   AttributeErrort   exit(   R   R  (    (   R   s#   /usr/lib/python2.7/lib-tk/turtle.pyR   K  s    
N(   R   R   R   R  R  R   R  R  R    R"   R  R   R   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR?    s   
	'		
	c           B   s8   e  Z d  Z d Z d Z e d e d e d d  Z RS(   s   RawTurtle auto-creating (scrolled) canvas.

    When a Turtle object is created or a function derived from some
    Turtle method is called a TurtleScreen object is automatically created.
    Rc   R   R   c      	   C   sG   t  j d  k r t   t  _ n  t j |  t  j d | d | d | d  S(   NRc   R   R   (   R	   R  R   R   R   R  (   R   Rc   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR  r  s    N(   R   R   R   R   R  R  R   R  (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR	   i  s   t   turtle_docstringdictc         C   sR  i  } x+ t  D]# } d | } t |  j | | <q Wx+ t D]# } d | } t |  j | | <q; Wt d |  d  } t g  | j   D]% } | j d  d t k r | ^ q  } | j	 d  x> | d  D]2 } | j	 d	 t
 |   | j	 d
 | |  q W| d } | j	 d	 t
 |   | j	 d | |  | j	 d  | j   d S(   s  Create and write docstring-dictionary to file.

    Optional argument:
    filename -- a string, used as filename
                default value is turtle_docstringdict

    Has to be called explicitly, (not used by the turtle-graphics classes)
    The docstring dictionary will be written to the Python script <filname>.py
    It is intended to serve as a template for translation of the docstrings
    into different languages.
    s   _Screen.s   Turtle.s   %s.pyRS  R   i   s   docsdict = {

is   %s :
s           """%s
""",

s           """%s
"""

s   }
N(   t   _tg_screen_functionsR   R   t   _tg_turtle_functionsR   R  R   R   t   _alias_listRq   t   reprR   (   R   t   docsdictt
   methodnameR   R   R   R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyRt     s&    

(
c         C   sx   d i |  j    d 6} t |  } | j } xE | D]= } y | | t |  j _ Wq3 t k
 ro d | GHq3 Xq3 Wd S(   s   Read in docstrings from lang-specific docstring dictionary.

    Transfer docstrings, translated to lang, from a dictionary-file
    to the methods of classes Screen and Turtle and - in revised form -
    to the corresponding functions.
    s!   turtle_docstringdict_%(language)sR   s   Bad docstring-entry: %sN(   R  t
   __import__R  R   t   im_funcR   R   (   t   langt   modnamet   moduleR  R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   read_docstrings  s    	s   Cannot find docsdict fors;   Unknown Error when trying to import %s-docstring-dictionaryc   
      C   s  d } } t  |   t j k r1 |  j } d } n |  } d } t  |  t j t j g k ryg| j j } t | j j	 | | ! } | j j	 | | !} | j
 p g  } t t d   |   } d g t |  t |  | } t d   | |  }	 | j j d @rF|	 j d | j j	 |  | j d | j j	 |  | d 7} n  | j j d @r|	 j d	 | j j	 |  | j d	 | j j	 |  n  d
 j |	  } d | } d
 j |  } d | } WqqXn  | | f S(   s9   Get strings describing the arguments for the given objectR   i   i    c         S   s   d t  |   S(   Ns   =%s(   R  (   R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   <lambda>  s    c         S   s   |  | S(   N(    (   R  t   dflt(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyR    s    i   R   i   s   **s   , s   (%s)(   R   R   t
   MethodTypeR  R   t
   LambdaTypet	   func_codet   co_argcountR   t   co_varnamest   func_defaultst   mapR  t   co_flagsRX  R   (
   t   obt   argText1t   argText2t   fobt	   argOffsett   countert   items2t   realArgst   defaultst   items1(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   getmethparlist  s:    
		!
c         C   se   d d l  } |  d k r d St d } |  j d | d  } | j d |  } | j d |  } | S(   s<   To reduce docstrings from RawTurtle class for functions
    iNR   s   %s.R   s    \(.+ %s\):t   :(   t   reR   R   t   replacet   compilet   sub(   t   docstrR  t
   turtlenamet	   newdocstrt   parexp(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _turtle_docrevise  s    
c         C   se   d d l  } |  d k r d St d } |  j d | d  } | j d |  } | j d |  } | S(   s?   To reduce docstrings from TurtleScreen class for functions
    iNR   s   %s.R   s    \(.+ %s\):R  (   R  R   R   R  R  R  (   R  R  t
   screennameR  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _screen_docrevise  s    
sr  def {name}{paramslist}:
    if {obj} is None:
        if not TurtleScreen._RUNNING:
            TurtleScreen._RUNNING = True
            raise Terminator
        {obj} = {init}
    try:
        return {obj}.{name}{argslist}
    except TK.TclError:
        if not TurtleScreen._RUNNING:
            TurtleScreen._RUNNING = True
            raise Terminator
        raise
c   
      B   s   x |  D] } e  | |  } e |  \ } } | d k rM d G| G| GHq n  e j d | d | d | d | d |  }	 |	 e   U| | j  e   | _ q Wd  S(   NR   s   >>>>>>t   objt   initR  t
   paramslistt   argslist(   t   getattrR  t   __func_bodyt   formatt   globalsR   (
   t	   functionsR   R  R  t	   docreviseR  R   t   pl1t   pl2t   defstr(    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   _make_global_funcs  s    s   Turtle._screens   Screen()s   Turtle._pens   Turtle()t   __main__c           C   s   t    r t   n t   d  S(   N(   RF   RU   RM   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt	   switchpen#  s    	
c          C   s  t    t t  t   t d  t   t d  x t d  D] }  |  d k r_ t d  n  x( t d  D] } t	 d  t
 d  ql W|  d k r t d  t d	  n  t   t	 d
  t   q@ Wt d  t d  t t  t   t d  t	 d  t d  t	 d  t d  t   t d d  t d d  t d  x< t d  D]. }  t	 d  t
 d  t	 d  t d  qXWt t  t d  x< t d  D]. }  t	 d  t
 d  t	 d  t d  qWt d	  d S(   s   Demo of old turtle.py - moduleid   i   i   i   i   i   iZ   t   marooni    i   R   i   t
   startstartu   startt   redi   N(   RX   R#   R   Ro   R)   R6   Rp   R  R:   R<   RH   R2   R   RW   Rq   (   R  R   (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   demo1)  sX    






















c          C   sO  t  d  t   t d  t t d d   t d d  d }  t d  x( t d  D] } t   t	 |  d  qX Wt
 d  x t   r t   q Wt   t d  t d	  d } t d
  t d  t d  x t d d  D] } | d k rt   t d	 d | d d |  n  x( t d  D] } t |  t d  q+W| d 7} t d  t  t    d d  q Wt   t d  t   t d  t d  t   t d d  t  d  t d  x? t d  D]1 } t	 d d  t d  t d  t d  qWt d  t d  t   t d  t   t d  t   } | j d  t   } | j d  | j d  | j   | j d  | j  d  | j   | j d d  | j d  | j    | j  d  | j d d  | j d  | j  d  t t |   d } x | j |  d k r| j d   | j d!  | j | j |   | j d  | d" d k r| j!   | j!   t   n  | d 7} q W| j
 d# d$ d/ d' d( | j d)  | j d*  d+   } t" j# d  x! t   r| j   | j   qW| j d  | j
 d, d$ d0 | j$ | d  d. S(1   s   Demo of some new features.i   i   i    g       @iZ   i   i
   s   wait a moment...i   t   greeni   ii   i   ix   i   iF   i   R  t   yellowi   i2   R   R$  u   autoi  i(   i   t   blueu   orangei   g      @g333333?i   s   CAUGHT! Rx  R  t   boldR{  u   rightR   u   redc         S   s   t    t   d  S(   N(   R   R   (   R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   baba  s    s     Click me!t   CourierN(   R  i   R  (   R  i   R  (%   Rf   Rg   RQ   R\   Rk   R4   RZ   R  R  R-   Rq   Rn   Rm   RX   RI   R   RO   R*   R;   R9   R7   RU   RM   R2   R:   Rc   R@   RY   R	   RH   Ro   RA   R6   Rh   t   timet   sleepRJ   (   R  R   t   laengeR  t   triR   R  R  (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   demo2^  s    






















		





	
(H   R   t   _vert   TkinterR  R   R   R  t   ost   os.pathR    R   R   t   copyR   t   _tg_classesR  R  t   _tg_utilitiest   _math_functionst   __all__R  R   R   R   R   R   R   R   R   R   R   R   R   R   R  R   R  R7  R6  t   objectRI  t	   ExceptionR   R  R   R  R   R  R  R;  R   R
   R   R?  R	   R   Rt   R  t	   _LANGUAGEt   ImportErrorR  R  R  R  R  Rv   Ru   R   R  R  R  R   (    (    (    s#   /usr/lib/python2.7/lib-tk/turtle.pyt   <module>e   s   
	!

		%	4	
	c	 K	/&         k	"	

	$							5	b                                                                                                                                                                  import sys
from .main import main

sys.exit(main("lib2to3.fixes"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
[c           @   s3   d  d l  Z  d d l m Z e  j e d   d S(   iNi   (   t   mains   lib2to3.fixes(   t   sysR    t   exit(    (    (    s&   /usr/lib/python2.7/lib2to3/__main__.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   """A bottom-up tree matching algorithm implementation meant to speed
up 2to3's matching process. After the tree patterns are reduced to
their rarest linear path, a linear Aho-Corasick automaton is
created. The linear automaton traverses the linear paths from the
leaves to the root of the AST and returns a set of nodes for further
matching. This reduces significantly the number of candidate nodes."""

__author__ = "George Boutsioukis <gboutsioukis@gmail.com>"

import logging
import itertools
from collections import defaultdict

from . import pytree
from .btm_utils import reduce_tree

class BMNode(object):
    """Class for a node of the Aho-Corasick automaton used in matching"""
    count = itertools.count()
    def __init__(self):
        self.transition_table = {}
        self.fixers = []
        self.id = next(BMNode.count)
        self.content = ''

class BottomMatcher(object):
    """The main matcher class. After instantiating the patterns should
    be added using the add_fixer method"""

    def __init__(self):
        self.match = set()
        self.root = BMNode()
        self.nodes = [self.root]
        self.fixers = []
        self.logger = logging.getLogger("RefactoringTool")

    def add_fixer(self, fixer):
        """Reduces a fixer's pattern tree to a linear path and adds it
        to the matcher(a common Aho-Corasick automaton). The fixer is
        appended on the matching states and called when they are
        reached"""
        self.fixers.append(fixer)
        tree = reduce_tree(fixer.pattern_tree)
        linear = tree.get_linear_subpattern()
        match_nodes = self.add(linear, start=self.root)
        for match_node in match_nodes:
            match_node.fixers.append(fixer)

    def add(self, pattern, start):
        "Recursively adds a linear pattern to the AC automaton"
        #print("adding pattern", pattern, "to", start)
        if not pattern:
            #print("empty pattern")
            return [start]
        if isinstance(pattern[0], tuple):
            #alternatives
            #print("alternatives")
            match_nodes = []
            for alternative in pattern[0]:
                #add all alternatives, and add the rest of the pattern
                #to each end node
                end_nodes = self.add(alternative, start=start)
                for end in end_nodes:
                    match_nodes.extend(self.add(pattern[1:], end))
            return match_nodes
        else:
            #single token
            #not last
            if pattern[0] not in start.transition_table:
                #transition did not exist, create new
                next_node = BMNode()
                start.transition_table[pattern[0]] = next_node
            else:
                #transition exists already, follow
                next_node = start.transition_table[pattern[0]]

            if pattern[1:]:
                end_nodes = self.add(pattern[1:], start=next_node)
            else:
                end_nodes = [next_node]
            return end_nodes

    def run(self, leaves):
        """The main interface with the bottom matcher. The tree is
        traversed from the bottom using the constructed
        automaton. Nodes are only checked once as the tree is
        retraversed. When the automaton fails, we give it one more
        shot(in case the above tree matches as a whole with the
        rejected leaf), then we break for the next leaf. There is the
        special case of multiple arguments(see code comments) where we
        recheck the nodes

        Args:
           The leaves of the AST tree to be matched

        Returns:
           A dictionary of node matches with fixers as the keys
        """
        current_ac_node = self.root
        results = defaultdict(list)
        for leaf in leaves:
            current_ast_node = leaf
            while current_ast_node:
                current_ast_node.was_checked = True
                for child in current_ast_node.children:
                    # multiple statements, recheck
                    if isinstance(child, pytree.Leaf) and child.value == u";":
                        current_ast_node.was_checked = False
                        break
                if current_ast_node.type == 1:
                    #name
                    node_token = current_ast_node.value
                else:
                    node_token = current_ast_node.type

                if node_token in current_ac_node.transition_table:
                    #token matches
                    current_ac_node = current_ac_node.transition_table[node_token]
                    for fixer in current_ac_node.fixers:
                        if not fixer in results:
                            results[fixer] = []
                        results[fixer].append(current_ast_node)

                else:
                    #matching failed, reset automaton
                    current_ac_node = self.root
                    if (current_ast_node.parent is not None
                        and current_ast_node.parent.was_checked):
                        #the rest of the tree upwards has been checked, next leaf
                        break

                    #recheck the rejected node once from the root
                    if node_token in current_ac_node.transition_table:
                        #token matches
                        current_ac_node = current_ac_node.transition_table[node_token]
                        for fixer in current_ac_node.fixers:
                            if not fixer in results.keys():
                                results[fixer] = []
                            results[fixer].append(current_ast_node)

                current_ast_node = current_ast_node.parent
        return results

    def print_ac(self):
        "Prints a graphviz diagram of the BM automaton(for debugging)"
        print("digraph g{")
        def print_node(node):
            for subnode_key in node.transition_table.keys():
                subnode = node.transition_table[subnode_key]
                print("%d -> %d [label=%s] //%s" %
                      (node.id, subnode.id, type_repr(subnode_key), str(subnode.fixers)))
                if subnode_key == 1:
                    print(subnode.content)
                print_node(subnode)
        print_node(self.root)
        print("}")

# taken from pytree.py for debugging; only used by print_ac
_type_reprs = {}
def type_repr(type_num):
    global _type_reprs
    if not _type_reprs:
        from .pygram import python_symbols
        # printing tokens is possible but not as useful
        # from .pgen2 import token // token.__dict__.items():
        for name, val in python_symbols.__dict__.items():
            if type(val) == int: _type_reprs[val] = name
    return _type_reprs.setdefault(type_num, type_num)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Base class for fixers (optional, but recommended)."""

# Python imports
import logging
import itertools

# Local imports
from .patcomp import PatternCompiler
from . import pygram
from .fixer_util import does_tree_import

class BaseFix(object):

    """Optional base class for fixers.

    The subclass name must be FixFooBar where FooBar is the result of
    removing underscores and capitalizing the words of the fix name.
    For example, the class name for a fixer named 'has_key' should be
    FixHasKey.
    """

    PATTERN = None  # Most subclasses should override with a string literal
    pattern = None  # Compiled pattern, set by compile_pattern()
    pattern_tree = None # Tree representation of the pattern
    options = None  # Options object passed to initializer
    filename = None # The filename (set by set_filename)
    logger = None   # A logger (set by set_filename)
    numbers = itertools.count(1) # For new_name()
    used_names = set() # A set of all used NAMEs
    order = "post" # Does the fixer prefer pre- or post-order traversal
    explicit = False # Is this ignored by refactor.py -f all?
    run_order = 5   # Fixers will be sorted by run order before execution
                    # Lower numbers will be run first.
    _accept_type = None # [Advanced and not public] This tells RefactoringTool
                        # which node type to accept when there's not a pattern.

    keep_line_order = False # For the bottom matcher: match with the
                            # original line order
    BM_compatible = False # Compatibility with the bottom matching
                          # module; every fixer should set this
                          # manually

    # Shortcut for access to Python grammar symbols
    syms = pygram.python_symbols

    def __init__(self, options, log):
        """Initializer.  Subclass may override.

        Args:
            options: a dict containing the options passed to RefactoringTool
            that could be used to customize the fixer through the command line.
            log: a list to append warnings and other messages to.
        """
        self.options = options
        self.log = log
        self.compile_pattern()

    def compile_pattern(self):
        """Compiles self.PATTERN into self.pattern.

        Subclass may override if it doesn't want to use
        self.{pattern,PATTERN} in .match().
        """
        if self.PATTERN is not None:
            PC = PatternCompiler()
            self.pattern, self.pattern_tree = PC.compile_pattern(self.PATTERN,
                                                                 with_tree=True)

    def set_filename(self, filename):
        """Set the filename, and a logger derived from it.

        The main refactoring tool should call this.
        """
        self.filename = filename
        self.logger = logging.getLogger(filename)

    def match(self, node):
        """Returns match for a given parse tree node.

        Should return a true or false object (not necessarily a bool).
        It may return a non-empty dict of matching sub-nodes as
        returned by a matching pattern.

        Subclass may override.
        """
        results = {"node": node}
        return self.pattern.match(node, results) and results

    def transform(self, node, results):
        """Returns the transformation for a given parse tree node.

        Args:
          node: the root of the parse tree that matched the fixer.
          results: a dict mapping symbolic names to part of the match.

        Returns:
          None, or a node that is a modified copy of the
          argument node.  The node argument may also be modified in-place to
          effect the same change.

        Subclass *must* override.
        """
        raise NotImplementedError()

    def new_name(self, template=u"xxx_todo_changeme"):
        """Return a string suitable for use as an identifier

        The new name is guaranteed not to conflict with other identifiers.
        """
        name = template
        while name in self.used_names:
            name = template + unicode(self.numbers.next())
        self.used_names.add(name)
        return name

    def log_message(self, message):
        if self.first_log:
            self.first_log = False
            self.log.append("### In file %s ###" % self.filename)
        self.log.append(message)

    def cannot_convert(self, node, reason=None):
        """Warn the user that a given chunk of code is not valid Python 3,
        but that it cannot be converted automatically.

        First argument is the top-level node for the code in question.
        Optional second argument is why it can't be converted.
        """
        lineno = node.get_lineno()
        for_output = node.clone()
        for_output.prefix = u""
        msg = "Line %d: could not convert: %s"
        self.log_message(msg % (lineno, for_output))
        if reason:
            self.log_message(reason)

    def warning(self, node, reason):
        """Used for warning the user about possible uncertainty in the
        translation.

        First argument is the top-level node for the code in question.
        Optional second argument is why it can't be converted.
        """
        lineno = node.get_lineno()
        self.log_message("Line %d: %s" % (lineno, reason))

    def start_tree(self, tree, filename):
        """Some fixers need to maintain tree-wide state.
        This method is called once, at the start of tree fix-up.

        tree - the root node of the tree to be processed.
        filename - the name of the file the tree came from.
        """
        self.used_names = tree.used_names
        self.set_filename(filename)
        self.numbers = itertools.count(1)
        self.first_log = True

    def finish_tree(self, tree, filename):
        """Some fixers need to maintain tree-wide state.
        This method is called once, at the conclusion of tree fix-up.

        tree - the root node of the tree to be processed.
        filename - the name of the file the tree came from.
        """
        pass


class ConditionalFix(BaseFix):
    """ Base class for fixers which not execute if an import is found. """

    # This is the name of the import which, if found, will cause the test to be skipped
    skip_on = None

    def start_tree(self, *args):
        super(ConditionalFix, self).start_tree(*args)
        self._should_skip = None

    def should_skip(self, node):
        if self._should_skip is not None:
            return self._should_skip
        pkg = self.skip_on.split(".")
        name = pkg[-1]
        pkg = ".".join(pkg[:-1])
        self._should_skip = does_tree_import(pkg, name, node)
        return self._should_skip
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
[c           @   s~   d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z d e	 f d     YZ
 d	 e
 f d
     YZ d S(   s2   Base class for fixers (optional, but recommended).iNi   (   t   PatternCompiler(   t   pygram(   t   does_tree_importt   BaseFixc           B   s   e  Z d  Z d Z d Z d Z d Z d Z d Z	 e
 j d  Z e   Z d Z e Z d Z d Z e Z e Z e j Z d   Z d   Z d   Z d   Z d   Z d	 d
  Z d   Z d d  Z  d   Z! d   Z" d   Z# RS(   s  Optional base class for fixers.

    The subclass name must be FixFooBar where FooBar is the result of
    removing underscores and capitalizing the words of the fix name.
    For example, the class name for a fixer named 'has_key' should be
    FixHasKey.
    i   t   posti   c         C   s    | |  _  | |  _ |  j   d S(   s  Initializer.  Subclass may override.

        Args:
            options: a dict containing the options passed to RefactoringTool
            that could be used to customize the fixer through the command line.
            log: a list to append warnings and other messages to.
        N(   t   optionst   logt   compile_pattern(   t   selfR   R   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   __init__1   s    		c         C   sC   |  j  d k	 r? t   } | j |  j  d t \ |  _ |  _ n  d S(   s   Compiles self.PATTERN into self.pattern.

        Subclass may override if it doesn't want to use
        self.{pattern,PATTERN} in .match().
        t	   with_treeN(   t   PATTERNt   NoneR    R   t   Truet   patternt   pattern_tree(   R   t   PC(    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyR   =   s    	c         C   s   | |  _  t j |  |  _ d S(   sm   Set the filename, and a logger derived from it.

        The main refactoring tool should call this.
        N(   t   filenamet   loggingt	   getLoggert   logger(   R   R   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   set_filenameH   s    	c         C   s&   i | d 6} |  j  j | |  o% | S(   s  Returns match for a given parse tree node.

        Should return a true or false object (not necessarily a bool).
        It may return a non-empty dict of matching sub-nodes as
        returned by a matching pattern.

        Subclass may override.
        t   node(   R   t   match(   R   R   t   results(    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyR   P   s    	c         C   s   t     d S(   s  Returns the transformation for a given parse tree node.

        Args:
          node: the root of the parse tree that matched the fixer.
          results: a dict mapping symbolic names to part of the match.

        Returns:
          None, or a node that is a modified copy of the
          argument node.  The node argument may also be modified in-place to
          effect the same change.

        Subclass *must* override.
        N(   t   NotImplementedError(   R   R   R   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt	   transform\   s    u   xxx_todo_changemec         C   sI   | } x, | |  j  k r4 | t |  j j    } q	 W|  j  j |  | S(   s   Return a string suitable for use as an identifier

        The new name is guaranteed not to conflict with other identifiers.
        (   t
   used_namest   unicodet   numberst   nextt   add(   R   t   templatet   name(    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   new_namel   s
    c         C   s@   |  j  r, t |  _  |  j j d |  j  n  |  j j |  d  S(   Ns   ### In file %s ###(   t	   first_logt   FalseR   t   appendR   (   R   t   message(    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   log_messagew   s    		c         C   sX   | j    } | j   } d | _ d } |  j | | | f  | rT |  j |  n  d S(   s  Warn the user that a given chunk of code is not valid Python 3,
        but that it cannot be converted automatically.

        First argument is the top-level node for the code in question.
        Optional second argument is why it can't be converted.
        u    s   Line %d: could not convert: %sN(   t
   get_linenot   clonet   prefixR'   (   R   R   t   reasont   linenot
   for_outputt   msg(    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   cannot_convert}   s    	c         C   s'   | j    } |  j d | | f  d S(   s   Used for warning the user about possible uncertainty in the
        translation.

        First argument is the top-level node for the code in question.
        Optional second argument is why it can't be converted.
        s   Line %d: %sN(   R(   R'   (   R   R   R+   R,   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   warning   s    c         C   s8   | j  |  _  |  j |  t j d  |  _ t |  _ d S(   s   Some fixers need to maintain tree-wide state.
        This method is called once, at the start of tree fix-up.

        tree - the root node of the tree to be processed.
        filename - the name of the file the tree came from.
        i   N(   R   R   t	   itertoolst   countR   R   R#   (   R   t   treeR   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt
   start_tree   s    c         C   s   d S(   s   Some fixers need to maintain tree-wide state.
        This method is called once, at the conclusion of tree fix-up.

        tree - the root node of the tree to be processed.
        filename - the name of the file the tree came from.
        N(    (   R   R3   R   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   finish_tree   s    N($   t   __name__t
   __module__t   __doc__R   R   R   R   R   R   R   R1   R2   R   t   setR   t   orderR$   t   explicitt	   run_ordert   _accept_typet   keep_line_ordert   BM_compatibleR   t   python_symbolst   symsR	   R   R   R   R   R"   R'   R/   R0   R4   R5   (    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyR      s6   									
	t   ConditionalFixc           B   s&   e  Z d  Z d Z d   Z d   Z RS(   s@    Base class for fixers which not execute if an import is found. c         G   s#   t  t |   j |   d  |  _ d  S(   N(   t   superRB   R4   R   t   _should_skip(   R   t   args(    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyR4      s    c         C   sa   |  j  d  k	 r |  j  S|  j j d  } | d } d j | d   } t | | |  |  _  |  j  S(   Nt   .i(   RD   R   t   skip_ont   splitt   joinR   (   R   R   t   pkgR!   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   should_skip   s    
N(   R6   R7   R8   R   RG   R4   RK   (    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyRB      s   	(   R8   R   R1   t   patcompR    t    R   t
   fixer_utilR   t   objectR   RB   (    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_base.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """Utility functions, node construction macros, etc."""
# Author: Collin Winter

from itertools import islice

# Local imports
from .pgen2 import token
from .pytree import Leaf, Node
from .pygram import python_symbols as syms
from . import patcomp


###########################################################
### Common node-construction "macros"
###########################################################

def KeywordArg(keyword, value):
    return Node(syms.argument,
                [keyword, Leaf(token.EQUAL, u"="), value])

def LParen():
    return Leaf(token.LPAR, u"(")

def RParen():
    return Leaf(token.RPAR, u")")

def Assign(target, source):
    """Build an assignment statement"""
    if not isinstance(target, list):
        target = [target]
    if not isinstance(source, list):
        source.prefix = u" "
        source = [source]

    return Node(syms.atom,
                target + [Leaf(token.EQUAL, u"=", prefix=u" ")] + source)

def Name(name, prefix=None):
    """Return a NAME leaf"""
    return Leaf(token.NAME, name, prefix=prefix)

def Attr(obj, attr):
    """A node tuple for obj.attr"""
    return [obj, Node(syms.trailer, [Dot(), attr])]

def Comma():
    """A comma leaf"""
    return Leaf(token.COMMA, u",")

def Dot():
    """A period (.) leaf"""
    return Leaf(token.DOT, u".")

def ArgList(args, lparen=LParen(), rparen=RParen()):
    """A parenthesised argument list, used by Call()"""
    node = Node(syms.trailer, [lparen.clone(), rparen.clone()])
    if args:
        node.insert_child(1, Node(syms.arglist, args))
    return node

def Call(func_name, args=None, prefix=None):
    """A function call"""
    node = Node(syms.power, [func_name, ArgList(args)])
    if prefix is not None:
        node.prefix = prefix
    return node

def Newline():
    """A newline literal"""
    return Leaf(token.NEWLINE, u"\n")

def BlankLine():
    """A blank line"""
    return Leaf(token.NEWLINE, u"")

def Number(n, prefix=None):
    return Leaf(token.NUMBER, n, prefix=prefix)

def Subscript(index_node):
    """A numeric or string subscript"""
    return Node(syms.trailer, [Leaf(token.LBRACE, u"["),
                               index_node,
                               Leaf(token.RBRACE, u"]")])

def String(string, prefix=None):
    """A string leaf"""
    return Leaf(token.STRING, string, prefix=prefix)

def ListComp(xp, fp, it, test=None):
    """A list comprehension of the form [xp for fp in it if test].

    If test is None, the "if test" part is omitted.
    """
    xp.prefix = u""
    fp.prefix = u" "
    it.prefix = u" "
    for_leaf = Leaf(token.NAME, u"for")
    for_leaf.prefix = u" "
    in_leaf = Leaf(token.NAME, u"in")
    in_leaf.prefix = u" "
    inner_args = [for_leaf, fp, in_leaf, it]
    if test:
        test.prefix = u" "
        if_leaf = Leaf(token.NAME, u"if")
        if_leaf.prefix = u" "
        inner_args.append(Node(syms.comp_if, [if_leaf, test]))
    inner = Node(syms.listmaker, [xp, Node(syms.comp_for, inner_args)])
    return Node(syms.atom,
                       [Leaf(token.LBRACE, u"["),
                        inner,
                        Leaf(token.RBRACE, u"]")])

def FromImport(package_name, name_leafs):
    """ Return an import statement in the form:
        from package import name_leafs"""
    # XXX: May not handle dotted imports properly (eg, package_name='foo.bar')
    #assert package_name == '.' or '.' not in package_name, "FromImport has "\
    #       "not been tested with dotted package names -- use at your own "\
    #       "peril!"

    for leaf in name_leafs:
        # Pull the leaves out of their old tree
        leaf.remove()

    children = [Leaf(token.NAME, u"from"),
                Leaf(token.NAME, package_name, prefix=u" "),
                Leaf(token.NAME, u"import", prefix=u" "),
                Node(syms.import_as_names, name_leafs)]
    imp = Node(syms.import_from, children)
    return imp


###########################################################
### Determine whether a node represents a given literal
###########################################################

def is_tuple(node):
    """Does the node represent a tuple literal?"""
    if isinstance(node, Node) and node.children == [LParen(), RParen()]:
        return True
    return (isinstance(node, Node)
            and len(node.children) == 3
            and isinstance(node.children[0], Leaf)
            and isinstance(node.children[1], Node)
            and isinstance(node.children[2], Leaf)
            and node.children[0].value == u"("
            and node.children[2].value == u")")

def is_list(node):
    """Does the node represent a list literal?"""
    return (isinstance(node, Node)
            and len(node.children) > 1
            and isinstance(node.children[0], Leaf)
            and isinstance(node.children[-1], Leaf)
            and node.children[0].value == u"["
            and node.children[-1].value == u"]")


###########################################################
### Misc
###########################################################

def parenthesize(node):
    return Node(syms.atom, [LParen(), node, RParen()])


consuming_calls = set(["sorted", "list", "set", "any", "all", "tuple", "sum",
                       "min", "max", "enumerate"])

def attr_chain(obj, attr):
    """Follow an attribute chain.

    If you have a chain of objects where a.foo -> b, b.foo-> c, etc,
    use this to iterate over all objects in the chain. Iteration is
    terminated by getattr(x, attr) is None.

    Args:
        obj: the starting object
        attr: the name of the chaining attribute

    Yields:
        Each successive object in the chain.
    """
    next = getattr(obj, attr)
    while next:
        yield next
        next = getattr(next, attr)

p0 = """for_stmt< 'for' any 'in' node=any ':' any* >
        | comp_for< 'for' any 'in' node=any any* >
     """
p1 = """
power<
    ( 'iter' | 'list' | 'tuple' | 'sorted' | 'set' | 'sum' |
      'any' | 'all' | 'enumerate' | (any* trailer< '.' 'join' >) )
    trailer< '(' node=any ')' >
    any*
>
"""
p2 = """
power<
    ( 'sorted' | 'enumerate' )
    trailer< '(' arglist<node=any any*> ')' >
    any*
>
"""
pats_built = False
def in_special_context(node):
    """ Returns true if node is in an environment where all that is required
        of it is being iterable (ie, it doesn't matter if it returns a list
        or an iterator).
        See test_map_nochange in test_fixers.py for some examples and tests.
        """
    global p0, p1, p2, pats_built
    if not pats_built:
        p0 = patcomp.compile_pattern(p0)
        p1 = patcomp.compile_pattern(p1)
        p2 = patcomp.compile_pattern(p2)
        pats_built = True
    patterns = [p0, p1, p2]
    for pattern, parent in zip(patterns, attr_chain(node, "parent")):
        results = {}
        if pattern.match(parent, results) and results["node"] is node:
            return True
    return False

def is_probably_builtin(node):
    """
    Check that something isn't an attribute or function name etc.
    """
    prev = node.prev_sibling
    if prev is not None and prev.type == token.DOT:
        # Attribute lookup.
        return False
    parent = node.parent
    if parent.type in (syms.funcdef, syms.classdef):
        return False
    if parent.type == syms.expr_stmt and parent.children[0] is node:
        # Assignment.
        return False
    if parent.type == syms.parameters or \
            (parent.type == syms.typedargslist and (
            (prev is not None and prev.type == token.COMMA) or
            parent.children[0] is node
            )):
        # The name of an argument.
        return False
    return True

def find_indentation(node):
    """Find the indentation of *node*."""
    while node is not None:
        if node.type == syms.suite and len(node.children) > 2:
            indent = node.children[1]
            if indent.type == token.INDENT:
                return indent.value
        node = node.parent
    return u""

###########################################################
### The following functions are to find bindings in a suite
###########################################################

def make_suite(node):
    if node.type == syms.suite:
        return node
    node = node.clone()
    parent, node.parent = node.parent, None
    suite = Node(syms.suite, [node])
    suite.parent = parent
    return suite

def find_root(node):
    """Find the top level namespace."""
    # Scamper up to the top level namespace
    while node.type != syms.file_input:
        node = node.parent
        if not node:
            raise ValueError("root found before file_input node was found.")
    return node

def does_tree_import(package, name, node):
    """ Returns true if name is imported from package at the
        top level of the tree which node belongs to.
        To cover the case of an import like 'import foo', use
        None for the package and 'foo' for the name. """
    binding = find_binding(name, find_root(node), package)
    return bool(binding)

def is_import(node):
    """Returns true if the node is an import statement."""
    return node.type in (syms.import_name, syms.import_from)

def touch_import(package, name, node):
    """ Works like `does_tree_import` but adds an import statement
        if it was not imported. """
    def is_import_stmt(node):
        return (node.type == syms.simple_stmt and node.children and
                is_import(node.children[0]))

    root = find_root(node)

    if does_tree_import(package, name, root):
        return

    # figure out where to insert the new import.  First try to find
    # the first import and then skip to the last one.
    insert_pos = offset = 0
    for idx, node in enumerate(root.children):
        if not is_import_stmt(node):
            continue
        for offset, node2 in enumerate(root.children[idx:]):
            if not is_import_stmt(node2):
                break
        insert_pos = idx + offset
        break

    # if there are no imports where we can insert, find the docstring.
    # if that also fails, we stick to the beginning of the file
    if insert_pos == 0:
        for idx, node in enumerate(root.children):
            if (node.type == syms.simple_stmt and node.children and
               node.children[0].type == token.STRING):
                insert_pos = idx + 1
                break

    if package is None:
        import_ = Node(syms.import_name, [
            Leaf(token.NAME, u"import"),
            Leaf(token.NAME, name, prefix=u" ")
        ])
    else:
        import_ = FromImport(package, [Leaf(token.NAME, name, prefix=u" ")])

    children = [import_, Newline()]
    root.insert_child(insert_pos, Node(syms.simple_stmt, children))


_def_syms = set([syms.classdef, syms.funcdef])
def find_binding(name, node, package=None):
    """ Returns the node which binds variable name, otherwise None.
        If optional argument package is supplied, only imports will
        be returned.
        See test cases for examples."""
    for child in node.children:
        ret = None
        if child.type == syms.for_stmt:
            if _find(name, child.children[1]):
                return child
            n = find_binding(name, make_suite(child.children[-1]), package)
            if n: ret = n
        elif child.type in (syms.if_stmt, syms.while_stmt):
            n = find_binding(name, make_suite(child.children[-1]), package)
            if n: ret = n
        elif child.type == syms.try_stmt:
            n = find_binding(name, make_suite(child.children[2]), package)
            if n:
                ret = n
            else:
                for i, kid in enumerate(child.children[3:]):
                    if kid.type == token.COLON and kid.value == ":":
                        # i+3 is the colon, i+4 is the suite
                        n = find_binding(name, make_suite(child.children[i+4]), package)
                        if n: ret = n
        elif child.type in _def_syms and child.children[1].value == name:
            ret = child
        elif _is_import_binding(child, name, package):
            ret = child
        elif child.type == syms.simple_stmt:
            ret = find_binding(name, child, package)
        elif child.type == syms.expr_stmt:
            if _find(name, child.children[0]):
                ret = child

        if ret:
            if not package:
                return ret
            if is_import(ret):
                return ret
    return None

_block_syms = set([syms.funcdef, syms.classdef, syms.trailer])
def _find(name, node):
    nodes = [node]
    while nodes:
        node = nodes.pop()
        if node.type > 256 and node.type not in _block_syms:
            nodes.extend(node.children)
        elif node.type == token.NAME and node.value == name:
            return node
    return None

def _is_import_binding(node, name, package=None):
    """ Will reuturn node if node will import name, or node
        will import * from package.  None is returned otherwise.
        See test cases for examples. """

    if node.type == syms.import_name and not package:
        imp = node.children[1]
        if imp.type == syms.dotted_as_names:
            for child in imp.children:
                if child.type == syms.dotted_as_name:
                    if child.children[2].value == name:
                        return node
                elif child.type == token.NAME and child.value == name:
                    return node
        elif imp.type == syms.dotted_as_name:
            last = imp.children[-1]
            if last.type == token.NAME and last.value == name:
                return node
        elif imp.type == token.NAME and imp.value == name:
            return node
    elif node.type == syms.import_from:
        # unicode(...) is used to make life easier here, because
        # from a.b import parses to ['import', ['a', '.', 'b'], ...]
        if package and unicode(node.children[1]).strip() != package:
            return None
        n = node.children[3]
        if package and _find(u"as", n):
            # See test_from_import_as for explanation
            return None
        elif n.type == syms.import_as_names and _find(name, n):
            return node
        elif n.type == syms.import_as_name:
            child = n.children[2]
            if child.type == token.NAME and child.value == name:
                return node
        elif n.type == token.NAME and n.value == name:
            return node
        elif package and n.type == token.STAR:
            return node
    return None
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
[c           @   s  d  Z  d d l m Z d d l m Z d d l m Z m Z d d l m	 Z
 d d l m Z d   Z d	   Z d
   Z d   Z d5 d  Z d   Z d   Z d   Z e   e   d  Z d5 d5 d  Z d   Z d   Z d5 d  Z d   Z d5 d  Z d5 d  Z d   Z d   Z d   Z  d   Z! e" d d d d d  d! d" d# d$ d% g
  Z# d&   Z$ d' a% d( a& d) a' e( a) d*   Z* d+   Z+ d,   Z, d-   Z- d.   Z. d/   Z/ d0   Z0 d1   Z1 e" e
 j2 e
 j3 g  Z4 d5 d2  Z5 e" e
 j3 e
 j2 e
 j6 g  Z7 d3   Z8 d5 d4  Z9 d5 S(6   s1   Utility functions, node construction macros, etc.i(   t   islicei   (   t   token(   t   Leaft   Node(   t   python_symbols(   t   patcompc         C   s%   t  t j |  t t j d  | g  S(   Nu   =(   R   t   symst   argumentR   R   t   EQUAL(   t   keywordt   value(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt
   KeywordArg   s    	c           C   s   t  t j d  S(   Nu   ((   R   R   t   LPAR(    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   LParen   s    c           C   s   t  t j d  S(   Nu   )(   R   R   t   RPAR(    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   RParen   s    c         C   sl   t  |  t  s |  g }  n  t  | t  s? d | _ | g } n  t t j |  t t j d d d g |  S(   s   Build an assignment statementu    u   =t   prefix(	   t
   isinstancet   listR   R   R   t   atomR   R   R   (   t   targett   source(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   Assign   s    		c         C   s   t  t j |  d | S(   s   Return a NAME leafR   (   R   R   t   NAME(   t   nameR   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   Name&   s    c         C   s   |  t  t j t   | g  g S(   s   A node tuple for obj.attr(   R   R   t   trailert   Dot(   t   objt   attr(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   Attr*   s    c           C   s   t  t j d  S(   s   A comma leafu   ,(   R   R   t   COMMA(    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   Comma.   s    c           C   s   t  t j d  S(   s   A period (.) leafu   .(   R   R   t   DOT(    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyR   2   s    c         C   sM   t  t j | j   | j   g  } |  rI | j d t  t j |    n  | S(   s-   A parenthesised argument list, used by Call()i   (   R   R   R   t   clonet   insert_childt   arglist(   t   argst   lparent   rparent   node(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   ArgList6   s    $c         C   s:   t  t j |  t |  g  } | d k	 r6 | | _ n  | S(   s   A function callN(   R   R   t   powerR)   t   NoneR   (   t	   func_nameR%   R   R(   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   Call=   s    c           C   s   t  t j d  S(   s   A newline literalu   
(   R   R   t   NEWLINE(    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   NewlineD   s    c           C   s   t  t j d  S(   s   A blank lineu    (   R   R   R.   (    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt	   BlankLineH   s    c         C   s   t  t j |  d | S(   NR   (   R   R   t   NUMBER(   t   nR   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   NumberL   s    c         C   s1   t  t j t t j d  |  t t j d  g  S(   s   A numeric or string subscriptu   [u   ](   R   R   R   R   R   t   LBRACEt   RBRACE(   t
   index_node(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt	   SubscriptO   s    c         C   s   t  t j |  d | S(   s   A string leafR   (   R   R   t   STRING(   t   stringR   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   StringU   s    c   	      C   s  d |  _  d | _  d | _  t t j d  } d | _  t t j d  } d | _  | | | | g } | r d | _  t t j d  } d | _  | j t t j | | g   n  t t j |  t t j	 |  g  } t t j
 t t j d  | t t j d  g  S(   su   A list comprehension of the form [xp for fp in it if test].

    If test is None, the "if test" part is omitted.
    u    u    u   foru   inu   ifu   [u   ](   R   R   R   R   t   appendR   R   t   comp_ift	   listmakert   comp_forR   R4   R5   (	   t   xpt   fpt   itt   testt   for_leaft   in_leaft
   inner_argst   if_leaft   inner(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   ListCompY   s$    							"$	c         C   s   x | D] } | j    q Wt t j d  t t j |  d d t t j d d d t t j |  g } t t j |  } | S(   sO    Return an import statement in the form:
        from package import name_leafsu   fromR   u    u   import(   t   removeR   R   R   R   R   t   import_as_namest   import_from(   t   package_namet
   name_leafst   leaft   childrent   imp(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt
   FromImportq   s    c         C   s   t  |  t  r. |  j t   t   g k r. t St  |  t  o t |  j  d k o t  |  j d t  o t  |  j d t  o t  |  j d t  o |  j d j d k o |  j d j d k S(   s(   Does the node represent a tuple literal?i   i    i   i   u   (u   )(	   R   R   RO   R   R   t   Truet   lenR   R
   (   R(   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   is_tuple   s    *c         C   sz   t  |  t  oy t |  j  d k oy t  |  j d t  oy t  |  j d t  oy |  j d j d k oy |  j d j d k S(   s'   Does the node represent a list literal?i   i    iu   [u   ](   R   R   RS   RO   R   R
   (   R(   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   is_list   s    c         C   s   t  t j t   |  t   g  S(   N(   R   R   R   R   R   (   R(   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   parenthesize   s    t   sortedR   t   sett   anyt   allt   tuplet   sumt   mint   maxt	   enumeratec         c   s4   t  |  |  } x | r/ | Vt  | |  } q Wd S(   sl  Follow an attribute chain.

    If you have a chain of objects where a.foo -> b, b.foo-> c, etc,
    use this to iterate over all objects in the chain. Iteration is
    terminated by getattr(x, attr) is None.

    Args:
        obj: the starting object
        attr: the name of the chaining attribute

    Yields:
        Each successive object in the chain.
    N(   t   getattr(   R   R   t   next(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt
   attr_chain   s    	se   for_stmt< 'for' any 'in' node=any ':' any* >
        | comp_for< 'for' any 'in' node=any any* >
     s   
power<
    ( 'iter' | 'list' | 'tuple' | 'sorted' | 'set' | 'sum' |
      'any' | 'all' | 'enumerate' | (any* trailer< '.' 'join' >) )
    trailer< '(' node=any ')' >
    any*
>
s`   
power<
    ( 'sorted' | 'enumerate' )
    trailer< '(' arglist<node=any any*> ')' >
    any*
>
c         C   s   t  s< t j t  a t j t  a t j t  a t a  n  t t t g } xR t | t |  d   D]8 \ } } i  } | j	 | |  rd | d |  k rd t Sqd Wt
 S(   s    Returns true if node is in an environment where all that is required
        of it is being iterable (ie, it doesn't matter if it returns a list
        or an iterator).
        See test_map_nochange in test_fixers.py for some examples and tests.
        t   parentR(   (   t
   pats_builtR   t   compile_patternt   p0t   p1t   p2RR   t   zipRb   t   matcht   False(   R(   t   patternst   patternRc   t   results(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   in_special_context   s    	%"c         C   s   |  j  } | d k	 r+ | j t j k r+ t S|  j } | j t j t j	 f k rS t S| j t j
 k r| | j d |  k r| t S| j t j k s | j t j k r | d k	 r | j t j k s | j d |  k r t St S(   sG   
    Check that something isn't an attribute or function name etc.
    i    N(   t   prev_siblingR+   t   typeR   R!   Rk   Rc   R   t   funcdeft   classdeft	   expr_stmtRO   t
   parameterst   typedargslistR   RR   (   R(   t   prevRc   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   is_probably_builtin   s    		%c         C   sp   xi |  d k	 rk |  j t j k r_ t |  j  d k r_ |  j d } | j t j k r_ | j Sn  |  j	 }  q Wd S(   s   Find the indentation of *node*.i   i   u    N(
   R+   Rq   R   t   suiteRS   RO   R   t   INDENTR
   Rc   (   R(   t   indent(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   find_indentation   s    '
c         C   sW   |  j  t j k r |  S|  j   }  |  j d  } |  _ t t j |  g  } | | _ | S(   N(   Rq   R   Ry   R"   Rc   R+   R   (   R(   Rc   Ry   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt
   make_suite  s    	c         C   s;   x4 |  j  t j k r6 |  j }  |  s t d   q q W|  S(   s   Find the top level namespace.s,   root found before file_input node was found.(   Rq   R   t
   file_inputRc   t
   ValueError(   R(   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt	   find_root  s
    	c         C   s"   t  | t |  |   } t |  S(   s    Returns true if name is imported from package at the
        top level of the tree which node belongs to.
        To cover the case of an import like 'import foo', use
        None for the package and 'foo' for the name. (   t   find_bindingR   t   bool(   t   packageR   R(   t   binding(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   does_tree_import  s    c         C   s   |  j  t j t j f k S(   s0   Returns true if the node is an import statement.(   Rq   R   t   import_nameRK   (   R(   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt	   is_import"  s    c         C   s  d   } t  |  } t |  | |  r+ d Sd } } xn t | j  D]] \ } } | |  sc qE n  x1 t | j |  D] \ } } | |  sw Pqw qw W| | } PqE W| d k rxb t | j  D]N \ } } | j t j k r | j r | j d j t j k r | d } Pq q Wn  |  d k r\t
 t j t t j d  t t j | d d g  }	 n$ t |  t t j | d d g  }	 |	 t   g }
 | j | t
 t j |
   d S(   s\    Works like `does_tree_import` but adds an import statement
        if it was not imported. c         S   s,   |  j  t j k o+ |  j o+ t |  j d  S(   Ni    (   Rq   R   t   simple_stmtRO   R   (   R(   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   is_import_stmt)  s    Ni    i   u   importR   u    (   R   R   R_   RO   Rq   R   R   R   R8   R+   R   R   R   R   RQ   R/   R#   (   R   R   R(   R   t   roott
   insert_post   offsett   idxt   node2t   import_RO   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   touch_import&  s4    	
 

	!$c         C   sK  xD| j  D]9} d } | j t j k rs t |  | j  d  rB | St |  t | j  d  |  } | r | } q n| j t j t j	 f k r t |  t | j  d  |  } | r | } q na| j t j
 k r|t |  t | j  d  |  } | r | } q xt | j  d  D]b \ } } | j t j k r| j d k rt |  t | j  | d  |  } | ru| } quqqWn | j t k r| j  d j |  k r| } nv t | |  |  r| } n[ | j t j k rt |  | |  } n4 | j t j k r t |  | j  d  r | } q n  | r
 | s0| St |  rC| Sq
 q
 Wd S(	   s    Returns the node which binds variable name, otherwise None.
        If optional argument package is supplied, only imports will
        be returned.
        See test cases for examples.i   ii   i   t   :i   i    N(   RO   R+   Rq   R   t   for_stmtt   _findR   R}   t   if_stmtt
   while_stmtt   try_stmtR_   R   t   COLONR
   t	   _def_symst   _is_import_bindingR   Rt   R   (   R   R(   R   t   childt   retR2   t   it   kid(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyR   T  sH      	 !# %		c         C   s|   | g } xl | rw | j    } | j d k rO | j t k rO | j | j  q | j t j k r | j |  k r | Sq Wd  S(   Ni   (	   t   popRq   t   _block_symst   extendRO   R   R   R
   R+   (   R   R(   t   nodes(    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyR     s    		!c         C   s'  |  j  t j k r| r|  j d } | j  t j k r x | j D]Z } | j  t j k rw | j d j | k r |  SqB | j  t j k rB | j | k rB |  SqB Wq#| j  t j k r | j d } | j  t j k r| j | k r|  Sq#| j  t j k r#| j | k r#|  Sn|  j  t j	 k r#| rMt
 |  j d  j   | k rMd S|  j d } | rst d |  rsd S| j  t j k rt | |  r|  S| j  t j k r| j d } | j  t j k r | j | k r |  Sq#| j  t j k r| j | k r|  S| r#| j  t j k r#|  Sn  d S(   s    Will reuturn node if node will import name, or node
        will import * from package.  None is returned otherwise.
        See test cases for examples. i   i   ii   u   asN(   Rq   R   R   RO   t   dotted_as_namest   dotted_as_nameR
   R   R   RK   t   unicodet   stripR+   R   RJ   t   import_as_namet   STAR(   R(   R   R   RP   R   t   lastR2   (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyR     s@    !!!%!!!N(:   t   __doc__t	   itertoolsR    t   pgen2R   t   pytreeR   R   t   pygramR   R   t    R   R   R   R   R   R+   R   R   R    R   R)   R-   R/   R0   R3   R7   R:   RH   RQ   RT   RU   RV   RX   t   consuming_callsRb   Rf   Rg   Rh   Rk   Rd   Ro   Rx   R|   R}   R   R   R   R   Rs   Rr   R   R   R   R   R   R   (    (    (    s(   /usr/lib/python2.7/lib2to3/fixer_util.pyt   <module>   sZ   																									-*	
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """
Main program for 2to3.
"""

from __future__ import with_statement

import sys
import os
import difflib
import logging
import shutil
import optparse

from . import refactor


def diff_texts(a, b, filename):
    """Return a unified diff of two strings."""
    a = a.splitlines()
    b = b.splitlines()
    return difflib.unified_diff(a, b, filename, filename,
                                "(original)", "(refactored)",
                                lineterm="")


class StdoutRefactoringTool(refactor.MultiprocessRefactoringTool):
    """
    A refactoring tool that can avoid overwriting its input files.
    Prints output to stdout.

    Output files can optionally be written to a different directory and or
    have an extra file suffix appended to their name for use in situations
    where you do not want to replace the input files.
    """

    def __init__(self, fixers, options, explicit, nobackups, show_diffs,
                 input_base_dir='', output_dir='', append_suffix=''):
        """
        Args:
            fixers: A list of fixers to import.
            options: A dict with RefactoringTool configuration.
            explicit: A list of fixers to run even if they are explicit.
            nobackups: If true no backup '.bak' files will be created for those
                files that are being refactored.
            show_diffs: Should diffs of the refactoring be printed to stdout?
            input_base_dir: The base directory for all input files.  This class
                will strip this path prefix off of filenames before substituting
                it with output_dir.  Only meaningful if output_dir is supplied.
                All files processed by refactor() must start with this path.
            output_dir: If supplied, all converted files will be written into
                this directory tree instead of input_base_dir.
            append_suffix: If supplied, all files output by this tool will have
                this appended to their filename.  Useful for changing .py to
                .py3 for example by passing append_suffix='3'.
        """
        self.nobackups = nobackups
        self.show_diffs = show_diffs
        if input_base_dir and not input_base_dir.endswith(os.sep):
            input_base_dir += os.sep
        self._input_base_dir = input_base_dir
        self._output_dir = output_dir
        self._append_suffix = append_suffix
        super(StdoutRefactoringTool, self).__init__(fixers, options, explicit)

    def log_error(self, msg, *args, **kwargs):
        self.errors.append((msg, args, kwargs))
        self.logger.error(msg, *args, **kwargs)

    def write_file(self, new_text, filename, old_text, encoding):
        orig_filename = filename
        if self._output_dir:
            if filename.startswith(self._input_base_dir):
                filename = os.path.join(self._output_dir,
                                        filename[len(self._input_base_dir):])
            else:
                raise ValueError('filename %s does not start with the '
                                 'input_base_dir %s' % (
                                         filename, self._input_base_dir))
        if self._append_suffix:
            filename += self._append_suffix
        if orig_filename != filename:
            output_dir = os.path.dirname(filename)
            if not os.path.isdir(output_dir):
                os.makedirs(output_dir)
            self.log_message('Writing converted %s to %s.', orig_filename,
                             filename)
        if not self.nobackups:
            # Make backup
            backup = filename + ".bak"
            if os.path.lexists(backup):
                try:
                    os.remove(backup)
                except os.error, err:
                    self.log_message("Can't remove backup %s", backup)
            try:
                os.rename(filename, backup)
            except os.error, err:
                self.log_message("Can't rename %s to %s", filename, backup)
        # Actually write the new file
        write = super(StdoutRefactoringTool, self).write_file
        write(new_text, filename, old_text, encoding)
        if not self.nobackups:
            shutil.copymode(backup, filename)
        if orig_filename != filename:
            # Preserve the file mode in the new output directory.
            shutil.copymode(orig_filename, filename)

    def print_output(self, old, new, filename, equal):
        if equal:
            self.log_message("No changes to %s", filename)
        else:
            self.log_message("Refactored %s", filename)
            if self.show_diffs:
                diff_lines = diff_texts(old, new, filename)
                try:
                    if self.output_lock is not None:
                        with self.output_lock:
                            for line in diff_lines:
                                print line
                            sys.stdout.flush()
                    else:
                        for line in diff_lines:
                            print line
                except UnicodeEncodeError:
                    warn("couldn't encode %s's diff for your terminal" %
                         (filename,))
                    return


def warn(msg):
    print >> sys.stderr, "WARNING: %s" % (msg,)


def main(fixer_pkg, args=None):
    """Main program.

    Args:
        fixer_pkg: the name of a package where the fixers are located.
        args: optional; a list of command line arguments. If omitted,
              sys.argv[1:] is used.

    Returns a suggested exit status (0, 1, 2).
    """
    # Set up option parser
    parser = optparse.OptionParser(usage="2to3 [options] file|dir ...")
    parser.add_option("-d", "--doctests_only", action="store_true",
                      help="Fix up doctests only")
    parser.add_option("-f", "--fix", action="append", default=[],
                      help="Each FIX specifies a transformation; default: all")
    parser.add_option("-j", "--processes", action="store", default=1,
                      type="int", help="Run 2to3 concurrently")
    parser.add_option("-x", "--nofix", action="append", default=[],
                      help="Prevent a transformation from being run")
    parser.add_option("-l", "--list-fixes", action="store_true",
                      help="List available transformations")
    parser.add_option("-p", "--print-function", action="store_true",
                      help="Modify the grammar so that print() is a function")
    parser.add_option("-v", "--verbose", action="store_true",
                      help="More verbose logging")
    parser.add_option("--no-diffs", action="store_true",
                      help="Don't show diffs of the refactoring")
    parser.add_option("-w", "--write", action="store_true",
                      help="Write back modified files")
    parser.add_option("-n", "--nobackups", action="store_true", default=False,
                      help="Don't write backups for modified files")
    parser.add_option("-o", "--output-dir", action="store", type="str",
                      default="", help="Put output files in this directory "
                      "instead of overwriting the input files.  Requires -n.")
    parser.add_option("-W", "--write-unchanged-files", action="store_true",
                      help="Also write files even if no changes were required"
                      " (useful with --output-dir); implies -w.")
    parser.add_option("--add-suffix", action="store", type="str", default="",
                      help="Append this string to all output filenames."
                      " Requires -n if non-empty.  "
                      "ex: --add-suffix='3' will generate .py3 files.")

    # Parse command line arguments
    refactor_stdin = False
    flags = {}
    options, args = parser.parse_args(args)
    if options.write_unchanged_files:
        flags["write_unchanged_files"] = True
        if not options.write:
            warn("--write-unchanged-files/-W implies -w.")
        options.write = True
    # If we allowed these, the original files would be renamed to backup names
    # but not replaced.
    if options.output_dir and not options.nobackups:
        parser.error("Can't use --output-dir/-o without -n.")
    if options.add_suffix and not options.nobackups:
        parser.error("Can't use --add-suffix without -n.")

    if not options.write and options.no_diffs:
        warn("not writing files and not printing diffs; that's not very useful")
    if not options.write and options.nobackups:
        parser.error("Can't use -n without -w")
    if options.list_fixes:
        print "Available transformations for the -f/--fix option:"
        for fixname in refactor.get_all_fix_names(fixer_pkg):
            print fixname
        if not args:
            return 0
    if not args:
        print >> sys.stderr, "At least one file or directory argument required."
        print >> sys.stderr, "Use --help to show usage."
        return 2
    if "-" in args:
        refactor_stdin = True
        if options.write:
            print >> sys.stderr, "Can't write to stdin."
            return 2
    if options.print_function:
        flags["print_function"] = True

    # Set up logging handler
    level = logging.DEBUG if options.verbose else logging.INFO
    logging.basicConfig(format='%(name)s: %(message)s', level=level)
    logger = logging.getLogger('lib2to3.main')

    # Initialize the refactoring tool
    avail_fixes = set(refactor.get_fixers_from_package(fixer_pkg))
    unwanted_fixes = set(fixer_pkg + ".fix_" + fix for fix in options.nofix)
    explicit = set()
    if options.fix:
        all_present = False
        for fix in options.fix:
            if fix == "all":
                all_present = True
            else:
                explicit.add(fixer_pkg + ".fix_" + fix)
        requested = avail_fixes.union(explicit) if all_present else explicit
    else:
        requested = avail_fixes.union(explicit)
    fixer_names = requested.difference(unwanted_fixes)
    input_base_dir = os.path.commonprefix(args)
    if (input_base_dir and not input_base_dir.endswith(os.sep)
        and not os.path.isdir(input_base_dir)):
        # One or more similar names were passed, their directory is the base.
        # os.path.commonprefix() is ignorant of path elements, this corrects
        # for that weird API.
        input_base_dir = os.path.dirname(input_base_dir)
    if options.output_dir:
        input_base_dir = input_base_dir.rstrip(os.sep)
        logger.info('Output in %r will mirror the input directory %r layout.',
                    options.output_dir, input_base_dir)
    rt = StdoutRefactoringTool(
            sorted(fixer_names), flags, sorted(explicit),
            options.nobackups, not options.no_diffs,
            input_base_dir=input_base_dir,
            output_dir=options.output_dir,
            append_suffix=options.add_suffix)

    # Refactor all files and directories passed as arguments
    if not rt.errors:
        if refactor_stdin:
            rt.refactor_stdin()
        else:
            try:
                rt.refactor(args, options.write, options.doctests_only,
                            options.processes)
            except refactor.MultiprocessingUnsupported:
                assert options.processes > 1
                print >> sys.stderr, "Sorry, -j isn't " \
                    "supported on this platform."
                return 1
        rt.summarize()

    # Return error status (0 if rt.errors is zero)
    return int(bool(rt.errors))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
[c           @  s   d  Z  d d l m Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 m
 Z
 d   Z d e
 j f d     YZ d	   Z d d
  Z d S(   s   
Main program for 2to3.
i(   t   with_statementNi   (   t   refactorc      	   C  s:   |  j    }  | j    } t j |  | | | d d d d S(   s%   Return a unified diff of two strings.s
   (original)s   (refactored)t   linetermt    (   t
   splitlinest   difflibt   unified_diff(   t   at   bt   filename(    (    s"   /usr/lib/python2.7/lib2to3/main.pyt
   diff_texts   s
    	t   StdoutRefactoringToolc           B  s;   e  Z d  Z d d d d  Z d   Z d   Z d   Z RS(   s2  
    A refactoring tool that can avoid overwriting its input files.
    Prints output to stdout.

    Output files can optionally be written to a different directory and or
    have an extra file suffix appended to their name for use in situations
    where you do not want to replace the input files.
    R   c	   	      C  sv   | |  _  | |  _ | r; | j t j  r; | t j 7} n  | |  _ | |  _ | |  _ t t	 |   j
 | | |  d S(   sF  
        Args:
            fixers: A list of fixers to import.
            options: A dict with RefactoringTool configuration.
            explicit: A list of fixers to run even if they are explicit.
            nobackups: If true no backup '.bak' files will be created for those
                files that are being refactored.
            show_diffs: Should diffs of the refactoring be printed to stdout?
            input_base_dir: The base directory for all input files.  This class
                will strip this path prefix off of filenames before substituting
                it with output_dir.  Only meaningful if output_dir is supplied.
                All files processed by refactor() must start with this path.
            output_dir: If supplied, all converted files will be written into
                this directory tree instead of input_base_dir.
            append_suffix: If supplied, all files output by this tool will have
                this appended to their filename.  Useful for changing .py to
                .py3 for example by passing append_suffix='3'.
        N(   t	   nobackupst
   show_diffst   endswitht   ost   sept   _input_base_dirt   _output_dirt   _append_suffixt   superR   t   __init__(	   t   selft   fixerst   optionst   explicitR   R   t   input_base_dirt
   output_dirt   append_suffix(    (    s"   /usr/lib/python2.7/lib2to3/main.pyR   $   s    					c         O  s3   |  j  j | | | f  |  j j | | |  d  S(   N(   t   errorst   appendt   loggert   error(   R   t   msgt   argst   kwargs(    (    s"   /usr/lib/python2.7/lib2to3/main.pyt	   log_errorA   s    c   
      C  s  | } |  j  re | j |  j  rI t j j |  j  | t |  j   } qe t d | |  j f   n  |  j r~ | |  j 7} n  | | k r t j j	 |  } t j j
 |  s t j |  n  |  j d | |  n  |  j sy| d } t j j |  r6y t j |  Wq6t j k
 r2} |  j d |  q6Xn  y t j | |  Wqyt j k
 ru} |  j d | |  qyXn  t t |   j }	 |	 | | | |  |  j st j | |  n  | | k rt j | |  n  d  S(   Ns5   filename %s does not start with the input_base_dir %ss   Writing converted %s to %s.s   .baks   Can't remove backup %ss   Can't rename %s to %s(   R   t
   startswithR   R   t   patht   joint   lent
   ValueErrorR   t   dirnamet   isdirt   makedirst   log_messageR   t   lexistst   removeR    t   renameR   R   t
   write_filet   shutilt   copymode(
   R   t   new_textR	   t   old_textt   encodingt   orig_filenameR   t   backupt   errt   write(    (    s"   /usr/lib/python2.7/lib2to3/main.pyR1   E   s@    		
	
	c         C  s   | r |  j  d |  n |  j  d |  |  j r t | | |  } y_ |  j d  k	 r |  j ( x | D] } | GHqg Wt j j   Wd  QXn x | D] } | GHq WWq t k
 r t	 d | f  d  SXn  d  S(   Ns   No changes to %ss   Refactored %ss+   couldn't encode %s's diff for your terminal(
   R-   R   R
   t   output_lockt   Nonet   syst   stdoutt   flusht   UnicodeEncodeErrort   warn(   R   t   oldt   newR	   t   equalt
   diff_linest   line(    (    s"   /usr/lib/python2.7/lib2to3/main.pyt   print_outputl   s"    	
	(   t   __name__t
   __module__t   __doc__R   R$   R1   RG   (    (    (    s"   /usr/lib/python2.7/lib2to3/main.pyR      s
   		'c         C  s   t  j d |  f IJd  S(   Ns   WARNING: %s(   R=   t   stderr(   R!   (    (    s"   /usr/lib/python2.7/lib2to3/main.pyRA      s    c           s  t  j d d  } | j d d d d d d | j d	 d
 d d d g  d d | j d d d d d d d d d d | j d d d d d g  d d | j d d d d d d | j d d d d d d | j d d d d d d  | j d! d d d d" | j d# d$ d d d d% | j d& d' d d d t d d( | j d) d* d d d d+ d d, d d- | j d. d/ d d d d0 | j d1 d d d d+ d d, d d2 t } i  } | j |  \ } } | j rt | d3 <| j st d4  n  t | _ n  | j	 r'| j
 r'| j d5  n  | j rJ| j
 rJ| j d6  n  | j rj| j rjt d7  n  | j r| j
 r| j d8  n  | j rd9 GHx t j    D] } | GHqW| sd: Sn  | st j d; IJt j d< IJd= Sd> | k rt } | j rt j d? IJd= Sn  | j r0t | d@ <n  | j rBt j n t j } t j dA dB dC |  t j dD  } t t j     }	 t   f dE   | j D  }
 t   } | j rt } x; | j D]0 } | dF k rt } q| j   dG |  qW| r|	 j |  n | } n |	 j |  } | j  |
  } t! j" j# |  } | r| j$ t! j%  rt! j" j& |  rt! j" j' |  } n  | j	 r| j( t! j%  } | j) dH | j	 |  n  t* t+ |  | t+ |  | j
 | j dI | dJ | j	 dK | j } | j, s| r| j-   n] y# | j | | j | j. | j/  Wn7 t j0 k
 rx| j/ d k sgt1  t j dL IJd SX| j2   n  t3 t4 | j,   S(M   s   Main program.

    Args:
        fixer_pkg: the name of a package where the fixers are located.
        args: optional; a list of command line arguments. If omitted,
              sys.argv[1:] is used.

    Returns a suggested exit status (0, 1, 2).
    t   usages   2to3 [options] file|dir ...s   -ds   --doctests_onlyt   actiont
   store_truet   helps   Fix up doctests onlys   -fs   --fixR   t   defaults1   Each FIX specifies a transformation; default: alls   -js   --processest   storei   t   typet   ints   Run 2to3 concurrentlys   -xs   --nofixs'   Prevent a transformation from being runs   -ls   --list-fixess   List available transformationss   -ps   --print-functions0   Modify the grammar so that print() is a functions   -vs	   --verboses   More verbose loggings
   --no-diffss#   Don't show diffs of the refactorings   -ws   --writes   Write back modified filess   -ns   --nobackupss&   Don't write backups for modified filess   -os   --output-dirt   strR   sX   Put output files in this directory instead of overwriting the input files.  Requires -n.s   -Ws   --write-unchanged-filessY   Also write files even if no changes were required (useful with --output-dir); implies -w.s   --add-suffixsu   Append this string to all output filenames. Requires -n if non-empty.  ex: --add-suffix='3' will generate .py3 files.t   write_unchanged_filess&   --write-unchanged-files/-W implies -w.s%   Can't use --output-dir/-o without -n.s"   Can't use --add-suffix without -n.s@   not writing files and not printing diffs; that's not very usefuls   Can't use -n without -ws2   Available transformations for the -f/--fix option:i    s1   At least one file or directory argument required.s   Use --help to show usage.i   t   -s   Can't write to stdin.t   print_functiont   formats   %(name)s: %(message)st   levels   lib2to3.mainc         3  s   |  ] }   d  | Vq d S(   s   .fix_N(    (   t   .0t   fix(   t	   fixer_pkg(    s"   /usr/lib/python2.7/lib2to3/main.pys	   <genexpr>   s    t   alls   .fix_s7   Output in %r will mirror the input directory %r layout.R   R   R   s+   Sorry, -j isn't supported on this platform.(5   t   optparset   OptionParsert
   add_optiont   Falset
   parse_argsRU   t   TrueR:   RA   R   R   R    t
   add_suffixt   no_diffst
   list_fixesR   t   get_all_fix_namesR=   RK   RW   t   verboset   loggingt   DEBUGt   INFOt   basicConfigt	   getLoggert   sett   get_fixers_from_packaget   nofixR[   t   addt   uniont
   differenceR   R&   t   commonprefixR   R   R+   R*   t   rstript   infoR   t   sortedR   t   refactor_stdint   doctests_onlyt	   processest   MultiprocessingUnsupportedt   AssertionErrort	   summarizeRS   t   bool(   R\   R"   t   parserRx   t   flagsR   t   fixnameRY   R   t   avail_fixest   unwanted_fixesR   t   all_presentR[   t	   requestedt   fixer_namesR   t   rt(    (   R\   s"   /usr/lib/python2.7/lib2to3/main.pyt   main   s    	
												(   RJ   t
   __future__R    R=   R   R   Ri   R2   R^   R   R   R
   t   MultiprocessRefactoringToolR   RA   R<   R   (    (    (    s"   /usr/lib/python2.7/lib2to3/main.pyt   <module>   s   		h	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Pattern compiler.

The grammar is taken from PatternGrammar.txt.

The compiler compiles a pattern to a pytree.*Pattern instance.
"""

__author__ = "Guido van Rossum <guido@python.org>"

# Python imports
import os
import StringIO

# Fairly local imports
from .pgen2 import driver, literals, token, tokenize, parse, grammar

# Really local imports
from . import pytree
from . import pygram

# The pattern grammar file
_PATTERN_GRAMMAR_FILE = os.path.join(os.path.dirname(__file__),
                                     "PatternGrammar.txt")


class PatternSyntaxError(Exception):
    pass


def tokenize_wrapper(input):
    """Tokenizes a string suppressing significant whitespace."""
    skip = set((token.NEWLINE, token.INDENT, token.DEDENT))
    tokens = tokenize.generate_tokens(StringIO.StringIO(input).readline)
    for quintuple in tokens:
        type, value, start, end, line_text = quintuple
        if type not in skip:
            yield quintuple


class PatternCompiler(object):

    def __init__(self, grammar_file=_PATTERN_GRAMMAR_FILE):
        """Initializer.

        Takes an optional alternative filename for the pattern grammar.
        """
        self.grammar = driver.load_grammar(grammar_file)
        self.syms = pygram.Symbols(self.grammar)
        self.pygrammar = pygram.python_grammar
        self.pysyms = pygram.python_symbols
        self.driver = driver.Driver(self.grammar, convert=pattern_convert)

    def compile_pattern(self, input, debug=False, with_tree=False):
        """Compiles a pattern string to a nested pytree.*Pattern object."""
        tokens = tokenize_wrapper(input)
        try:
            root = self.driver.parse_tokens(tokens, debug=debug)
        except parse.ParseError as e:
            raise PatternSyntaxError(str(e))
        if with_tree:
            return self.compile_node(root), root
        else:
            return self.compile_node(root)

    def compile_node(self, node):
        """Compiles a node, recursively.

        This is one big switch on the node type.
        """
        # XXX Optimize certain Wildcard-containing-Wildcard patterns
        # that can be merged
        if node.type == self.syms.Matcher:
            node = node.children[0] # Avoid unneeded recursion

        if node.type == self.syms.Alternatives:
            # Skip the odd children since they are just '|' tokens
            alts = [self.compile_node(ch) for ch in node.children[::2]]
            if len(alts) == 1:
                return alts[0]
            p = pytree.WildcardPattern([[a] for a in alts], min=1, max=1)
            return p.optimize()

        if node.type == self.syms.Alternative:
            units = [self.compile_node(ch) for ch in node.children]
            if len(units) == 1:
                return units[0]
            p = pytree.WildcardPattern([units], min=1, max=1)
            return p.optimize()

        if node.type == self.syms.NegatedUnit:
            pattern = self.compile_basic(node.children[1:])
            p = pytree.NegatedPattern(pattern)
            return p.optimize()

        assert node.type == self.syms.Unit

        name = None
        nodes = node.children
        if len(nodes) >= 3 and nodes[1].type == token.EQUAL:
            name = nodes[0].value
            nodes = nodes[2:]
        repeat = None
        if len(nodes) >= 2 and nodes[-1].type == self.syms.Repeater:
            repeat = nodes[-1]
            nodes = nodes[:-1]

        # Now we've reduced it to: STRING | NAME [Details] | (...) | [...]
        pattern = self.compile_basic(nodes, repeat)

        if repeat is not None:
            assert repeat.type == self.syms.Repeater
            children = repeat.children
            child = children[0]
            if child.type == token.STAR:
                min = 0
                max = pytree.HUGE
            elif child.type == token.PLUS:
                min = 1
                max = pytree.HUGE
            elif child.type == token.LBRACE:
                assert children[-1].type == token.RBRACE
                assert  len(children) in (3, 5)
                min = max = self.get_int(children[1])
                if len(children) == 5:
                    max = self.get_int(children[3])
            else:
                assert False
            if min != 1 or max != 1:
                pattern = pattern.optimize()
                pattern = pytree.WildcardPattern([[pattern]], min=min, max=max)

        if name is not None:
            pattern.name = name
        return pattern.optimize()

    def compile_basic(self, nodes, repeat=None):
        # Compile STRING | NAME [Details] | (...) | [...]
        assert len(nodes) >= 1
        node = nodes[0]
        if node.type == token.STRING:
            value = unicode(literals.evalString(node.value))
            return pytree.LeafPattern(_type_of_literal(value), value)
        elif node.type == token.NAME:
            value = node.value
            if value.isupper():
                if value not in TOKEN_MAP:
                    raise PatternSyntaxError("Invalid token: %r" % value)
                if nodes[1:]:
                    raise PatternSyntaxError("Can't have details for token")
                return pytree.LeafPattern(TOKEN_MAP[value])
            else:
                if value == "any":
                    type = None
                elif not value.startswith("_"):
                    type = getattr(self.pysyms, value, None)
                    if type is None:
                        raise PatternSyntaxError("Invalid symbol: %r" % value)
                if nodes[1:]: # Details present
                    content = [self.compile_node(nodes[1].children[1])]
                else:
                    content = None
                return pytree.NodePattern(type, content)
        elif node.value == "(":
            return self.compile_node(nodes[1])
        elif node.value == "[":
            assert repeat is None
            subpattern = self.compile_node(nodes[1])
            return pytree.WildcardPattern([[subpattern]], min=0, max=1)
        assert False, node

    def get_int(self, node):
        assert node.type == token.NUMBER
        return int(node.value)


# Map named tokens to the type value for a LeafPattern
TOKEN_MAP = {"NAME": token.NAME,
             "STRING": token.STRING,
             "NUMBER": token.NUMBER,
             "TOKEN": None}


def _type_of_literal(value):
    if value[0].isalpha():
        return token.NAME
    elif value in grammar.opmap:
        return grammar.opmap[value]
    else:
        return None


def pattern_convert(grammar, raw_node_info):
    """Converts raw node information to a Node or Leaf instance."""
    type, value, context, children = raw_node_info
    if children or type in grammar.number2symbol:
        return pytree.Node(type, children, context=context)
    else:
        return pytree.Leaf(type, value, context=context)


def compile_pattern(pattern):
    return PatternCompiler().compile_pattern(pattern)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
[c           @   s  d  Z  d Z d d l Z d d l Z d d l m Z m Z m Z m Z m	 Z	 m
 Z
 d d l m Z d d l m Z e j j e j j e  d  Z d	 e f d
     YZ d   Z d e f d     YZ i e j d 6e j d 6e j d 6d d 6Z d   Z d   Z d   Z d S(   s   Pattern compiler.

The grammar is taken from PatternGrammar.txt.

The compiler compiles a pattern to a pytree.*Pattern instance.
s#   Guido van Rossum <guido@python.org>iNi   (   t   drivert   literalst   tokent   tokenizet   parset   grammar(   t   pytree(   t   pygrams   PatternGrammar.txtt   PatternSyntaxErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyR      s   c   	      c   sw   t  t j t j t j f  } t j t j |   j  } x7 | D]/ } | \ } } } } } | | k r@ | Vq@ q@ Wd S(   s6   Tokenizes a string suppressing significant whitespace.N(	   t   setR   t   NEWLINEt   INDENTt   DEDENTR   t   generate_tokenst   StringIOt   readline(	   t   inputt   skipt   tokenst	   quintuplet   typet   valuet   startt   endt	   line_text(    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyt   tokenize_wrapper!   s    t   PatternCompilerc           B   sA   e  Z e d   Z e e d  Z d   Z d d  Z d   Z	 RS(   c         C   s^   t  j |  |  _ t j |  j  |  _ t j |  _ t j |  _	 t  j
 |  j d t |  _  d S(   s^   Initializer.

        Takes an optional alternative filename for the pattern grammar.
        t   convertN(   R    t   load_grammarR   R   t   Symbolst   symst   python_grammart	   pygrammart   python_symbolst   pysymst   Drivert   pattern_convert(   t   selft   grammar_file(    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyt   __init__-   s
    c         C   s}   t  |  } y |  j j | d | } Wn( t j k
 rR } t t |    n X| rl |  j |  | f S|  j |  Sd S(   s=   Compiles a pattern string to a nested pytree.*Pattern object.t   debugN(   R   R    t   parse_tokensR   t
   ParseErrorR   t   strt   compile_node(   R'   R   R*   t	   with_treeR   t   roott   e(    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyt   compile_pattern8   s    c         C   s  | j  |  j j k r% | j d } n  | j  |  j j k r g  | j d d d  D] } |  j |  ^ qQ } t |  d k r | d St j g  | D] } | g ^ q d d d d } | j	   S| j  |  j j
 k r=g  | j D] } |  j |  ^ q } t |  d k r| d St j | g d d d d } | j	   S| j  |  j j k r|  j | j d  } t j |  } | j	   S| j  |  j j k st  d } | j }	 t |	  d k r|	 d j  t j k r|	 d j } |	 d }	 n  d }
 t |	  d k r5|	 d j  |  j j k r5|	 d }
 |	 d  }	 n  |  j |	 |
  } |
 d k	 r|
 j  |  j j k snt  |
 j } | d } | j  t j k rd } t j } n | j  t j k rd } t j } n | j  t j k rQ| d j  t j k st  t |  d
 k st  |  j | d  } } t |  d	 k r]|  j | d  } q]n t s]t  | d k su| d k r| j	   } t j | g g d | d | } qn  | d k	 r| | _ n  | j	   S(   sX   Compiles a node, recursively.

        This is one big switch on the node type.
        i    Ni   i   t   mint   maxi   ii   (   i   i   (   R   R    t   Matchert   childrent   AlternativesR.   t   lenR   t   WildcardPatternt   optimizet   Alternativet   NegatedUnitt   compile_basict   NegatedPatternt   Unitt   AssertionErrort   NoneR   t   EQUALR   t   Repeatert   STARt   HUGEt   PLUSt   LBRACEt   RBRACEt   get_intt   Falset   name(   R'   t   nodet   cht   altst   at   pt   unitst   patternRK   t   nodest   repeatR6   t   childR3   R4   (    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyR.   D   sh    21
%

	(+
	
'c         C   s  t  |  d k s t  | d } | j t j k rb t t j | j   } t	 j
 t |  |  S| j t j k rp| j } | j   r | t k r t d |   n  | d r t d   n  t	 j
 t |  S| d k r d  } nF | j d  s-t |  j | d   } | d  k r-t d |   q-n  | d rW|  j | d j d  g } n d  } t	 j | |  Sns | j d k r|  j | d  S| j d	 k r| d  k st  |  j | d  } t	 j | g g d
 d d d St st |   d  S(   Ni   i    s   Invalid token: %rs   Can't have details for tokent   anyt   _s   Invalid symbol: %rt   (t   [R3   R4   (   R8   R@   R   R   t   STRINGt   unicodeR   t
   evalStringR   R   t   LeafPatternt   _type_of_literalt   NAMEt   isuppert	   TOKEN_MAPR   RA   t
   startswitht   getattrR$   R.   R6   t   NodePatternR9   RJ   (   R'   RS   RT   RL   R   R   t   contentt
   subpattern(    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyR=      s<    
	
	
 c         C   s%   | j  t j k s t  t | j  S(   N(   R   R   t   NUMBERR@   t   intR   (   R'   RL   (    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyRI      s    N(
   R	   R
   t   _PATTERN_GRAMMAR_FILER)   RJ   R2   R.   RA   R=   RI   (    (    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyR   +   s
   	G#R_   RZ   Rg   t   TOKENc         C   s9   |  d j    r t j S|  t j k r1 t j |  Sd  Sd  S(   Ni    (   t   isalphaR   R_   R   t   opmapRA   (   R   (    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyR^      s
    c         C   sW   | \ } } } } | s' | |  j  k r= t j | | d | St j | | d | Sd S(   s9   Converts raw node information to a Node or Leaf instance.t   contextN(   t   number2symbolR   t   Nodet   Leaf(   R   t   raw_node_infoR   R   Rm   R6   (    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyR&      s    c         C   s   t    j |   S(   N(   R   R2   (   RR   (    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyR2      s    (    t   __doc__t
   __author__t   osR   t   pgen2R    R   R   R   R   R   t    R   R   t   patht   joint   dirnamet   __file__Ri   t	   ExceptionR   R   t   objectR   R_   RZ   Rg   RA   Ra   R^   R&   R2   (    (    (    s%   /usr/lib/python2.7/lib2to3/patcomp.pyt   <module>	   s$   .		



				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
[c           @   s   d  Z  d d l Z d d l m Z d d l m Z d d l m Z e j j e j j	 e
  d  Z e j j e j j	 e
  d  Z d	 e f d
     YZ e j e  Z e e  Z e j   Z e j d =e j e  Z e e  Z d S(   s&   Export the Python grammar and symbols.iNi   (   t   token(   t   driver(   t   pytrees   Grammar.txts   PatternGrammar.txtt   Symbolsc           B   s   e  Z d    Z RS(   c         C   s4   x- | j  j   D] \ } } t |  | |  q Wd S(   s   Initializer.

        Creates an attribute for each grammar symbol (nonterminal),
        whose value is the symbol's type (an int >= 256).
        N(   t   symbol2numbert	   iteritemst   setattr(   t   selft   grammart   namet   symbol(    (    s$   /usr/lib/python2.7/lib2to3/pygram.pyt   __init__   s    (   t   __name__t
   __module__R   (    (    (    s$   /usr/lib/python2.7/lib2to3/pygram.pyR      s   t   print(   t   __doc__t   ost   pgen2R    R   t    R   t   patht   joint   dirnamet   __file__t   _GRAMMAR_FILEt   _PATTERN_GRAMMAR_FILEt   objectR   t   load_grammart   python_grammart   python_symbolst   copyt!   python_grammar_no_print_statementt   keywordst   pattern_grammart   pattern_symbols(    (    (    s$   /usr/lib/python2.7/lib2to3/pygram.pyt   <module>   s   !	
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Dummy file to make this directory a package.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""
Python parse tree definitions.

This is a very concrete parse tree; we need to keep every token and
even the comments and whitespace between tokens.

There's also a pattern matching implementation here.
"""

__author__ = "Guido van Rossum <guido@python.org>"

import sys
import warnings
from StringIO import StringIO

HUGE = 0x7FFFFFFF  # maximum repeat count, default max

_type_reprs = {}
def type_repr(type_num):
    global _type_reprs
    if not _type_reprs:
        from .pygram import python_symbols
        # printing tokens is possible but not as useful
        # from .pgen2 import token // token.__dict__.items():
        for name, val in python_symbols.__dict__.items():
            if type(val) == int: _type_reprs[val] = name
    return _type_reprs.setdefault(type_num, type_num)

class Base(object):

    """
    Abstract base class for Node and Leaf.

    This provides some default functionality and boilerplate using the
    template pattern.

    A node may be a subnode of at most one parent.
    """

    # Default values for instance variables
    type = None    # int: token number (< 256) or symbol number (>= 256)
    parent = None  # Parent node pointer, or None
    children = ()  # Tuple of subnodes
    was_changed = False
    was_checked = False

    def __new__(cls, *args, **kwds):
        """Constructor that prevents Base from being instantiated."""
        assert cls is not Base, "Cannot instantiate Base"
        return object.__new__(cls)

    def __eq__(self, other):
        """
        Compare two nodes for equality.

        This calls the method _eq().
        """
        if self.__class__ is not other.__class__:
            return NotImplemented
        return self._eq(other)

    __hash__ = None # For Py3 compatibility.

    def __ne__(self, other):
        """
        Compare two nodes for inequality.

        This calls the method _eq().
        """
        if self.__class__ is not other.__class__:
            return NotImplemented
        return not self._eq(other)

    def _eq(self, other):
        """
        Compare two nodes for equality.

        This is called by __eq__ and __ne__.  It is only called if the two nodes
        have the same type.  This must be implemented by the concrete subclass.
        Nodes should be considered equal if they have the same structure,
        ignoring the prefix string and other context information.
        """
        raise NotImplementedError

    def clone(self):
        """
        Return a cloned (deep) copy of self.

        This must be implemented by the concrete subclass.
        """
        raise NotImplementedError

    def post_order(self):
        """
        Return a post-order iterator for the tree.

        This must be implemented by the concrete subclass.
        """
        raise NotImplementedError

    def pre_order(self):
        """
        Return a pre-order iterator for the tree.

        This must be implemented by the concrete subclass.
        """
        raise NotImplementedError

    def set_prefix(self, prefix):
        """
        Set the prefix for the node (see Leaf class).

        DEPRECATED; use the prefix property directly.
        """
        warnings.warn("set_prefix() is deprecated; use the prefix property",
                      DeprecationWarning, stacklevel=2)
        self.prefix = prefix

    def get_prefix(self):
        """
        Return the prefix for the node (see Leaf class).

        DEPRECATED; use the prefix property directly.
        """
        warnings.warn("get_prefix() is deprecated; use the prefix property",
                      DeprecationWarning, stacklevel=2)
        return self.prefix

    def replace(self, new):
        """Replace this node with a new one in the parent."""
        assert self.parent is not None, str(self)
        assert new is not None
        if not isinstance(new, list):
            new = [new]
        l_children = []
        found = False
        for ch in self.parent.children:
            if ch is self:
                assert not found, (self.parent.children, self, new)
                if new is not None:
                    l_children.extend(new)
                found = True
            else:
                l_children.append(ch)
        assert found, (self.children, self, new)
        self.parent.changed()
        self.parent.children = l_children
        for x in new:
            x.parent = self.parent
        self.parent = None

    def get_lineno(self):
        """Return the line number which generated the invocant node."""
        node = self
        while not isinstance(node, Leaf):
            if not node.children:
                return
            node = node.children[0]
        return node.lineno

    def changed(self):
        if self.parent:
            self.parent.changed()
        self.was_changed = True

    def remove(self):
        """
        Remove the node from the tree. Returns the position of the node in its
        parent's children before it was removed.
        """
        if self.parent:
            for i, node in enumerate(self.parent.children):
                if node is self:
                    self.parent.changed()
                    del self.parent.children[i]
                    self.parent = None
                    return i

    @property
    def next_sibling(self):
        """
        The node immediately following the invocant in their parent's children
        list. If the invocant does not have a next sibling, it is None
        """
        if self.parent is None:
            return None

        # Can't use index(); we need to test by identity
        for i, child in enumerate(self.parent.children):
            if child is self:
                try:
                    return self.parent.children[i+1]
                except IndexError:
                    return None

    @property
    def prev_sibling(self):
        """
        The node immediately preceding the invocant in their parent's children
        list. If the invocant does not have a previous sibling, it is None.
        """
        if self.parent is None:
            return None

        # Can't use index(); we need to test by identity
        for i, child in enumerate(self.parent.children):
            if child is self:
                if i == 0:
                    return None
                return self.parent.children[i-1]

    def leaves(self):
        for child in self.children:
            for x in child.leaves():
                yield x

    def depth(self):
        if self.parent is None:
            return 0
        return 1 + self.parent.depth()

    def get_suffix(self):
        """
        Return the string immediately following the invocant node. This is
        effectively equivalent to node.next_sibling.prefix
        """
        next_sib = self.next_sibling
        if next_sib is None:
            return u""
        return next_sib.prefix

    if sys.version_info < (3, 0):
        def __str__(self):
            return unicode(self).encode("ascii")

class Node(Base):

    """Concrete implementation for interior nodes."""

    def __init__(self,type, children,
                 context=None,
                 prefix=None,
                 fixers_applied=None):
        """
        Initializer.

        Takes a type constant (a symbol number >= 256), a sequence of
        child nodes, and an optional context keyword argument.

        As a side effect, the parent pointers of the children are updated.
        """
        assert type >= 256, type
        self.type = type
        self.children = list(children)
        for ch in self.children:
            assert ch.parent is None, repr(ch)
            ch.parent = self
        if prefix is not None:
            self.prefix = prefix
        if fixers_applied:
            self.fixers_applied = fixers_applied[:]
        else:
            self.fixers_applied = None

    def __repr__(self):
        """Return a canonical string representation."""
        return "%s(%s, %r)" % (self.__class__.__name__,
                               type_repr(self.type),
                               self.children)

    def __unicode__(self):
        """
        Return a pretty string representation.

        This reproduces the input source exactly.
        """
        return u"".join(map(unicode, self.children))

    if sys.version_info > (3, 0):
        __str__ = __unicode__

    def _eq(self, other):
        """Compare two nodes for equality."""
        return (self.type, self.children) == (other.type, other.children)

    def clone(self):
        """Return a cloned (deep) copy of self."""
        return Node(self.type, [ch.clone() for ch in self.children],
                    fixers_applied=self.fixers_applied)

    def post_order(self):
        """Return a post-order iterator for the tree."""
        for child in self.children:
            for node in child.post_order():
                yield node
        yield self

    def pre_order(self):
        """Return a pre-order iterator for the tree."""
        yield self
        for child in self.children:
            for node in child.pre_order():
                yield node

    def _prefix_getter(self):
        """
        The whitespace and comments preceding this node in the input.
        """
        if not self.children:
            return ""
        return self.children[0].prefix

    def _prefix_setter(self, prefix):
        if self.children:
            self.children[0].prefix = prefix

    prefix = property(_prefix_getter, _prefix_setter)

    def set_child(self, i, child):
        """
        Equivalent to 'node.children[i] = child'. This method also sets the
        child's parent attribute appropriately.
        """
        child.parent = self
        self.children[i].parent = None
        self.children[i] = child
        self.changed()

    def insert_child(self, i, child):
        """
        Equivalent to 'node.children.insert(i, child)'. This method also sets
        the child's parent attribute appropriately.
        """
        child.parent = self
        self.children.insert(i, child)
        self.changed()

    def append_child(self, child):
        """
        Equivalent to 'node.children.append(child)'. This method also sets the
        child's parent attribute appropriately.
        """
        child.parent = self
        self.children.append(child)
        self.changed()


class Leaf(Base):

    """Concrete implementation for leaf nodes."""

    # Default values for instance variables
    _prefix = ""  # Whitespace and comments preceding this token in the input
    lineno = 0    # Line where this token starts in the input
    column = 0    # Column where this token tarts in the input

    def __init__(self, type, value,
                 context=None,
                 prefix=None,
                 fixers_applied=[]):
        """
        Initializer.

        Takes a type constant (a token number < 256), a string value, and an
        optional context keyword argument.
        """
        assert 0 <= type < 256, type
        if context is not None:
            self._prefix, (self.lineno, self.column) = context
        self.type = type
        self.value = value
        if prefix is not None:
            self._prefix = prefix
        self.fixers_applied = fixers_applied[:]

    def __repr__(self):
        """Return a canonical string representation."""
        return "%s(%r, %r)" % (self.__class__.__name__,
                               self.type,
                               self.value)

    def __unicode__(self):
        """
        Return a pretty string representation.

        This reproduces the input source exactly.
        """
        return self.prefix + unicode(self.value)

    if sys.version_info > (3, 0):
        __str__ = __unicode__

    def _eq(self, other):
        """Compare two nodes for equality."""
        return (self.type, self.value) == (other.type, other.value)

    def clone(self):
        """Return a cloned (deep) copy of self."""
        return Leaf(self.type, self.value,
                    (self.prefix, (self.lineno, self.column)),
                    fixers_applied=self.fixers_applied)

    def leaves(self):
        yield self

    def post_order(self):
        """Return a post-order iterator for the tree."""
        yield self

    def pre_order(self):
        """Return a pre-order iterator for the tree."""
        yield self

    def _prefix_getter(self):
        """
        The whitespace and comments preceding this token in the input.
        """
        return self._prefix

    def _prefix_setter(self, prefix):
        self.changed()
        self._prefix = prefix

    prefix = property(_prefix_getter, _prefix_setter)

def convert(gr, raw_node):
    """
    Convert raw node information to a Node or Leaf instance.

    This is passed to the parser driver which calls it whenever a reduction of a
    grammar rule produces a new complete node, so that the tree is build
    strictly bottom-up.
    """
    type, value, context, children = raw_node
    if children or type in gr.number2symbol:
        # If there's exactly one child, return that child instead of
        # creating a new node.
        if len(children) == 1:
            return children[0]
        return Node(type, children, context=context)
    else:
        return Leaf(type, value, context=context)


class BasePattern(object):

    """
    A pattern is a tree matching pattern.

    It looks for a specific node type (token or symbol), and
    optionally for a specific content.

    This is an abstract base class.  There are three concrete
    subclasses:

    - LeafPattern matches a single leaf node;
    - NodePattern matches a single node (usually non-leaf);
    - WildcardPattern matches a sequence of nodes of variable length.
    """

    # Defaults for instance variables
    type = None     # Node type (token if < 256, symbol if >= 256)
    content = None  # Optional content matching pattern
    name = None     # Optional name used to store match in results dict

    def __new__(cls, *args, **kwds):
        """Constructor that prevents BasePattern from being instantiated."""
        assert cls is not BasePattern, "Cannot instantiate BasePattern"
        return object.__new__(cls)

    def __repr__(self):
        args = [type_repr(self.type), self.content, self.name]
        while args and args[-1] is None:
            del args[-1]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(map(repr, args)))

    def optimize(self):
        """
        A subclass can define this as a hook for optimizations.

        Returns either self or another node with the same effect.
        """
        return self

    def match(self, node, results=None):
        """
        Does this pattern exactly match a node?

        Returns True if it matches, False if not.

        If results is not None, it must be a dict which will be
        updated with the nodes matching named subpatterns.

        Default implementation for non-wildcard patterns.
        """
        if self.type is not None and node.type != self.type:
            return False
        if self.content is not None:
            r = None
            if results is not None:
                r = {}
            if not self._submatch(node, r):
                return False
            if r:
                results.update(r)
        if results is not None and self.name:
            results[self.name] = node
        return True

    def match_seq(self, nodes, results=None):
        """
        Does this pattern exactly match a sequence of nodes?

        Default implementation for non-wildcard patterns.
        """
        if len(nodes) != 1:
            return False
        return self.match(nodes[0], results)

    def generate_matches(self, nodes):
        """
        Generator yielding all matches for this pattern.

        Default implementation for non-wildcard patterns.
        """
        r = {}
        if nodes and self.match(nodes[0], r):
            yield 1, r


class LeafPattern(BasePattern):

    def __init__(self, type=None, content=None, name=None):
        """
        Initializer.  Takes optional type, content, and name.

        The type, if given must be a token type (< 256).  If not given,
        this matches any *leaf* node; the content may still be required.

        The content, if given, must be a string.

        If a name is given, the matching node is stored in the results
        dict under that key.
        """
        if type is not None:
            assert 0 <= type < 256, type
        if content is not None:
            assert isinstance(content, basestring), repr(content)
        self.type = type
        self.content = content
        self.name = name

    def match(self, node, results=None):
        """Override match() to insist on a leaf node."""
        if not isinstance(node, Leaf):
            return False
        return BasePattern.match(self, node, results)

    def _submatch(self, node, results=None):
        """
        Match the pattern's content to the node's children.

        This assumes the node type matches and self.content is not None.

        Returns True if it matches, False if not.

        If results is not None, it must be a dict which will be
        updated with the nodes matching named subpatterns.

        When returning False, the results dict may still be updated.
        """
        return self.content == node.value


class NodePattern(BasePattern):

    wildcards = False

    def __init__(self, type=None, content=None, name=None):
        """
        Initializer.  Takes optional type, content, and name.

        The type, if given, must be a symbol type (>= 256).  If the
        type is None this matches *any* single node (leaf or not),
        except if content is not None, in which it only matches
        non-leaf nodes that also match the content pattern.

        The content, if not None, must be a sequence of Patterns that
        must match the node's children exactly.  If the content is
        given, the type must not be None.

        If a name is given, the matching node is stored in the results
        dict under that key.
        """
        if type is not None:
            assert type >= 256, type
        if content is not None:
            assert not isinstance(content, basestring), repr(content)
            content = list(content)
            for i, item in enumerate(content):
                assert isinstance(item, BasePattern), (i, item)
                if isinstance(item, WildcardPattern):
                    self.wildcards = True
        self.type = type
        self.content = content
        self.name = name

    def _submatch(self, node, results=None):
        """
        Match the pattern's content to the node's children.

        This assumes the node type matches and self.content is not None.

        Returns True if it matches, False if not.

        If results is not None, it must be a dict which will be
        updated with the nodes matching named subpatterns.

        When returning False, the results dict may still be updated.
        """
        if self.wildcards:
            for c, r in generate_matches(self.content, node.children):
                if c == len(node.children):
                    if results is not None:
                        results.update(r)
                    return True
            return False
        if len(self.content) != len(node.children):
            return False
        for subpattern, child in zip(self.content, node.children):
            if not subpattern.match(child, results):
                return False
        return True


class WildcardPattern(BasePattern):

    """
    A wildcard pattern can match zero or more nodes.

    This has all the flexibility needed to implement patterns like:

    .*      .+      .?      .{m,n}
    (a b c | d e | f)
    (...)*  (...)+  (...)?  (...){m,n}

    except it always uses non-greedy matching.
    """

    def __init__(self, content=None, min=0, max=HUGE, name=None):
        """
        Initializer.

        Args:
            content: optional sequence of subsequences of patterns;
                     if absent, matches one node;
                     if present, each subsequence is an alternative [*]
            min: optional minimum number of times to match, default 0
            max: optional maximum number of times to match, default HUGE
            name: optional name assigned to this match

        [*] Thus, if content is [[a, b, c], [d, e], [f, g, h]] this is
            equivalent to (a b c | d e | f g h); if content is None,
            this is equivalent to '.' in regular expression terms.
            The min and max parameters work as follows:
                min=0, max=maxint: .*
                min=1, max=maxint: .+
                min=0, max=1: .?
                min=1, max=1: .
            If content is not None, replace the dot with the parenthesized
            list of alternatives, e.g. (a b c | d e | f g h)*
        """
        assert 0 <= min <= max <= HUGE, (min, max)
        if content is not None:
            content = tuple(map(tuple, content))  # Protect against alterations
            # Check sanity of alternatives
            assert len(content), repr(content)  # Can't have zero alternatives
            for alt in content:
                assert len(alt), repr(alt) # Can have empty alternatives
        self.content = content
        self.min = min
        self.max = max
        self.name = name

    def optimize(self):
        """Optimize certain stacked wildcard patterns."""
        subpattern = None
        if (self.content is not None and
            len(self.content) == 1 and len(self.content[0]) == 1):
            subpattern = self.content[0][0]
        if self.min == 1 and self.max == 1:
            if self.content is None:
                return NodePattern(name=self.name)
            if subpattern is not None and  self.name == subpattern.name:
                return subpattern.optimize()
        if (self.min <= 1 and isinstance(subpattern, WildcardPattern) and
            subpattern.min <= 1 and self.name == subpattern.name):
            return WildcardPattern(subpattern.content,
                                   self.min*subpattern.min,
                                   self.max*subpattern.max,
                                   subpattern.name)
        return self

    def match(self, node, results=None):
        """Does this pattern exactly match a node?"""
        return self.match_seq([node], results)

    def match_seq(self, nodes, results=None):
        """Does this pattern exactly match a sequence of nodes?"""
        for c, r in self.generate_matches(nodes):
            if c == len(nodes):
                if results is not None:
                    results.update(r)
                    if self.name:
                        results[self.name] = list(nodes)
                return True
        return False

    def generate_matches(self, nodes):
        """
        Generator yielding matches for a sequence of nodes.

        Args:
            nodes: sequence of nodes

        Yields:
            (count, results) tuples where:
            count: the match comprises nodes[:count];
            results: dict containing named submatches.
        """
        if self.content is None:
            # Shortcut for special case (see __init__.__doc__)
            for count in xrange(self.min, 1 + min(len(nodes), self.max)):
                r = {}
                if self.name:
                    r[self.name] = nodes[:count]
                yield count, r
        elif self.name == "bare_name":
            yield self._bare_name_matches(nodes)
        else:
            # The reason for this is that hitting the recursion limit usually
            # results in some ugly messages about how RuntimeErrors are being
            # ignored. We don't do this on non-CPython implementation because
            # they don't have this problem.
            if hasattr(sys, "getrefcount"):
                save_stderr = sys.stderr
                sys.stderr = StringIO()
            try:
                for count, r in self._recursive_matches(nodes, 0):
                    if self.name:
                        r[self.name] = nodes[:count]
                    yield count, r
            except RuntimeError:
                # We fall back to the iterative pattern matching scheme if the recursive
                # scheme hits the recursion limit.
                for count, r in self._iterative_matches(nodes):
                    if self.name:
                        r[self.name] = nodes[:count]
                    yield count, r
            finally:
                if hasattr(sys, "getrefcount"):
                    sys.stderr = save_stderr

    def _iterative_matches(self, nodes):
        """Helper to iteratively yield the matches."""
        nodelen = len(nodes)
        if 0 >= self.min:
            yield 0, {}

        results = []
        # generate matches that use just one alt from self.content
        for alt in self.content:
            for c, r in generate_matches(alt, nodes):
                yield c, r
                results.append((c, r))

        # for each match, iterate down the nodes
        while results:
            new_results = []
            for c0, r0 in results:
                # stop if the entire set of nodes has been matched
                if c0 < nodelen and c0 <= self.max:
                    for alt in self.content:
                        for c1, r1 in generate_matches(alt, nodes[c0:]):
                            if c1 > 0:
                                r = {}
                                r.update(r0)
                                r.update(r1)
                                yield c0 + c1, r
                                new_results.append((c0 + c1, r))
            results = new_results

    def _bare_name_matches(self, nodes):
        """Special optimized matcher for bare_name."""
        count = 0
        r = {}
        done = False
        max = len(nodes)
        while not done and count < max:
            done = True
            for leaf in self.content:
                if leaf[0].match(nodes[count], r):
                    count += 1
                    done = False
                    break
        r[self.name] = nodes[:count]
        return count, r

    def _recursive_matches(self, nodes, count):
        """Helper to recursively yield the matches."""
        assert self.content is not None
        if count >= self.min:
            yield 0, {}
        if count < self.max:
            for alt in self.content:
                for c0, r0 in generate_matches(alt, nodes):
                    for c1, r1 in self._recursive_matches(nodes[c0:], count+1):
                        r = {}
                        r.update(r0)
                        r.update(r1)
                        yield c0 + c1, r


class NegatedPattern(BasePattern):

    def __init__(self, content=None):
        """
        Initializer.

        The argument is either a pattern or None.  If it is None, this
        only matches an empty sequence (effectively '$' in regex
        lingo).  If it is not None, this matches whenever the argument
        pattern doesn't have any matches.
        """
        if content is not None:
            assert isinstance(content, BasePattern), repr(content)
        self.content = content

    def match(self, node):
        # We never match a node in its entirety
        return False

    def match_seq(self, nodes):
        # We only match an empty sequence of nodes in its entirety
        return len(nodes) == 0

    def generate_matches(self, nodes):
        if self.content is None:
            # Return a match if there is an empty sequence
            if len(nodes) == 0:
                yield 0, {}
        else:
            # Return a match if the argument pattern has no matches
            for c, r in self.content.generate_matches(nodes):
                return
            yield 0, {}


def generate_matches(patterns, nodes):
    """
    Generator yielding matches for a sequence of patterns and nodes.

    Args:
        patterns: a sequence of patterns
        nodes: a sequence of nodes

    Yields:
        (count, results) tuples where:
        count: the entire sequence of patterns matches nodes[:count];
        results: dict containing named submatches.
        """
    if not patterns:
        yield 0, {}
    else:
        p, rest = patterns[0], patterns[1:]
        for c0, r0 in p.generate_matches(nodes):
            if not rest:
                yield c0, r0
            else:
                for c1, r1 in generate_matches(rest, nodes[c0:]):
                    r = {}
                    r.update(r0)
                    r.update(r1)
                    yield c0 + c1, r
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
[c           @   s  d  Z  d Z d d l Z d d l Z d d l m Z d Z i  a d   Z d e f d     YZ	 d	 e	 f d
     YZ
 d e	 f d     YZ d   Z d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d   Z d S(   s   
Python parse tree definitions.

This is a very concrete parse tree; we need to keep every token and
even the comments and whitespace between tokens.

There's also a pattern matching implementation here.
s#   Guido van Rossum <guido@python.org>iN(   t   StringIOic         C   sh   t  sX d d l m } x? | j j   D]+ \ } } t |  t k r& | t  | <q& q& Wn  t  j |  |   S(   Ni   (   t   python_symbols(   t   _type_reprst   pygramR   t   __dict__t   itemst   typet   intt
   setdefault(   t   type_numR   t   namet   val(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt	   type_repr   s     t   Basec           B   s   e  Z d  Z d Z d Z d Z e Z e Z	 d   Z
 d   Z d Z d   Z d   Z d   Z d   Z d   Z d   Z d	   Z d
   Z d   Z d   Z d   Z e d    Z e d    Z d   Z d   Z d   Z e j d k  r d   Z  n  RS(   s   
    Abstract base class for Node and Leaf.

    This provides some default functionality and boilerplate using the
    template pattern.

    A node may be a subnode of at most one parent.
    c         O   s%   |  t  k	 s t d   t j |   S(   s7   Constructor that prevents Base from being instantiated.s   Cannot instantiate Base(   R   t   AssertionErrort   objectt   __new__(   t   clst   argst   kwds(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR   2   s    c         C   s#   |  j  | j  k	 r t S|  j |  S(   sW   
        Compare two nodes for equality.

        This calls the method _eq().
        (   t	   __class__t   NotImplementedt   _eq(   t   selft   other(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   __eq__7   s    c         C   s$   |  j  | j  k	 r t S|  j |  S(   sY   
        Compare two nodes for inequality.

        This calls the method _eq().
        (   R   R   R   (   R   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   __ne__C   s    c         C   s
   t   d S(   s_  
        Compare two nodes for equality.

        This is called by __eq__ and __ne__.  It is only called if the two nodes
        have the same type.  This must be implemented by the concrete subclass.
        Nodes should be considered equal if they have the same structure,
        ignoring the prefix string and other context information.
        N(   t   NotImplementedError(   R   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR   M   s    	c         C   s
   t   d S(   sr   
        Return a cloned (deep) copy of self.

        This must be implemented by the concrete subclass.
        N(   R   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   cloneX   s    c         C   s
   t   d S(   sx   
        Return a post-order iterator for the tree.

        This must be implemented by the concrete subclass.
        N(   R   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt
   post_order`   s    c         C   s
   t   d S(   sw   
        Return a pre-order iterator for the tree.

        This must be implemented by the concrete subclass.
        N(   R   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt	   pre_orderh   s    c         C   s#   t  j d t d d | |  _ d S(   sv   
        Set the prefix for the node (see Leaf class).

        DEPRECATED; use the prefix property directly.
        s3   set_prefix() is deprecated; use the prefix propertyt
   stackleveli   N(   t   warningst   warnt   DeprecationWarningt   prefix(   R   R#   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt
   set_prefixp   s    	c         C   s   t  j d t d d |  j S(   sy   
        Return the prefix for the node (see Leaf class).

        DEPRECATED; use the prefix property directly.
        s3   get_prefix() is deprecated; use the prefix propertyR   i   (   R    R!   R"   R#   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt
   get_prefixz   s    	c         C   s2  |  j  d k	 s! t t |     | d k	 s3 t  t | t  sN | g } n  g  } t } xt |  j  j D]f } | |  k r | s t |  j  j |  | f   | d k	 r | j |  n  t	 } qg | j
 |  qg W| s t |  j |  | f   |  j  j   | |  j  _ x | D] } |  j  | _  qWd |  _  d S(   s/   Replace this node with a new one in the parent.N(   t   parentt   NoneR   t   strt
   isinstancet   listt   Falset   childrent   extendt   Truet   appendt   changed(   R   t   newt
   l_childrent   foundt   cht   x(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   replace   s&    !"	c         C   s=   |  } x- t  | t  s5 | j s% d S| j d } q	 W| j S(   s9   Return the line number which generated the invocant node.Ni    (   R)   t   LeafR,   t   lineno(   R   t   node(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt
   get_lineno   s    	c         C   s&   |  j  r |  j  j   n  t |  _ d  S(   N(   R&   R0   R.   t   was_changed(   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR0      s    	c         C   sf   |  j  rb xV t |  j  j  D]? \ } } | |  k r |  j  j   |  j  j | =d |  _  | Sq Wn  d S(   s   
        Remove the node from the tree. Returns the position of the node in its
        parent's children before it was removed.
        N(   R&   t	   enumerateR,   R0   R'   (   R   t   iR9   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   remove   s    		c         C   st   |  j  d k r d SxZ t |  j  j  D]F \ } } | |  k r& y |  j  j | d SWql t k
 rh d SXq& q& Wd S(   s   
        The node immediately following the invocant in their parent's children
        list. If the invocant does not have a next sibling, it is None
        i   N(   R&   R'   R<   R,   t
   IndexError(   R   R=   t   child(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   next_sibling   s    c         C   sh   |  j  d k r d SxN t |  j  j  D]: \ } } | |  k r& | d k rN d S|  j  j | d Sq& Wd S(   s   
        The node immediately preceding the invocant in their parent's children
        list. If the invocant does not have a previous sibling, it is None.
        i    i   N(   R&   R'   R<   R,   (   R   R=   R@   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   prev_sibling   s    c         c   s4   x- |  j  D]" } x | j   D] } | Vq Wq
 Wd  S(   N(   R,   t   leaves(   R   R@   R5   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRC      s    c         C   s$   |  j  d  k r d Sd |  j  j   S(   Ni    i   (   R&   R'   t   depth(   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRD      s    c         C   s    |  j  } | d k r d S| j S(   s   
        Return the string immediately following the invocant node. This is
        effectively equivalent to node.next_sibling.prefix
        u    N(   RA   R'   R#   (   R   t   next_sib(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt
   get_suffix   s    	i   i    c         C   s   t  |   j d  S(   Nt   ascii(   t   unicodet   encode(   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   __str__   s    N(    (   i   i    (!   t   __name__t
   __module__t   __doc__R'   R   R&   R,   R+   R;   t   was_checkedR   R   t   __hash__R   R   R   R   R   R$   R%   R6   R:   R0   R>   t   propertyRA   RB   RC   RD   RF   t   syst   version_infoRJ   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR       s6   			
	
					
	
								
t   Nodec           B   s   e  Z d  Z d d d d  Z d   Z d   Z e j d k rH e Z	 n  d   Z
 d   Z d   Z d	   Z d
   Z d   Z e e e  Z d   Z d   Z d   Z RS(   s+   Concrete implementation for interior nodes.c         C   s   | d k s t  |   | |  _ t |  |  _ x; |  j D]0 } | j d k sa t  t |    |  | _ q: W| d k	 r | |  _ n  | r | |  _ n	 d |  _ d S(   s   
        Initializer.

        Takes a type constant (a symbol number >= 256), a sequence of
        child nodes, and an optional context keyword argument.

        As a side effect, the parent pointers of the children are updated.
        i   N(	   R   R   R*   R,   R&   R'   t   reprR#   t   fixers_applied(   R   R   R,   t   contextR#   RU   R4   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   __init__   s    	!c         C   s#   d |  j  j t |  j  |  j f S(   s)   Return a canonical string representation.s
   %s(%s, %r)(   R   RK   R   R   R,   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   __repr__  s    c         C   s   d j  t t |  j   S(   sk   
        Return a pretty string representation.

        This reproduces the input source exactly.
        u    (   t   joint   mapRH   R,   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   __unicode__  s    i   i    c         C   s"   |  j  |  j f | j  | j f k S(   s   Compare two nodes for equality.(   R   R,   (   R   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR     s    c         C   s5   t  |  j g  |  j D] } | j   ^ q d |  j S(   s$   Return a cloned (deep) copy of self.RU   (   RS   R   R,   R   RU   (   R   R4   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR   !  s    +c         c   s9   x- |  j  D]" } x | j   D] } | Vq Wq
 W|  Vd S(   s*   Return a post-order iterator for the tree.N(   R,   R   (   R   R@   R9   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR   &  s    c         c   s9   |  Vx- |  j  D]" } x | j   D] } | Vq" Wq Wd S(   s)   Return a pre-order iterator for the tree.N(   R,   R   (   R   R@   R9   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR   -  s    c         C   s   |  j  s d S|  j  d j S(   sO   
        The whitespace and comments preceding this node in the input.
        t    i    (   R,   R#   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   _prefix_getter4  s    	c         C   s    |  j  r | |  j  d _ n  d  S(   Ni    (   R,   R#   (   R   R#   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   _prefix_setter<  s    	c         C   s4   |  | _  d |  j | _  | |  j | <|  j   d S(   s   
        Equivalent to 'node.children[i] = child'. This method also sets the
        child's parent attribute appropriately.
        N(   R&   R'   R,   R0   (   R   R=   R@   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt	   set_childB  s    	c         C   s*   |  | _  |  j j | |  |  j   d S(   s   
        Equivalent to 'node.children.insert(i, child)'. This method also sets
        the child's parent attribute appropriately.
        N(   R&   R,   t   insertR0   (   R   R=   R@   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   insert_childL  s    	c         C   s'   |  | _  |  j j |  |  j   d S(   s   
        Equivalent to 'node.children.append(child)'. This method also sets the
        child's parent attribute appropriately.
        N(   R&   R,   R/   R0   (   R   R@   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   append_childU  s    	N(   i   i    (   RK   RL   RM   R'   RW   RX   R[   RQ   RR   RJ   R   R   R   R   R]   R^   RP   R#   R_   Ra   Rb   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRS      s$   										
		R7   c           B   s   e  Z d  Z d Z d Z d Z d d g  d  Z d   Z d   Z	 e
 j d k rZ e	 Z n  d   Z d   Z d	   Z d
   Z d   Z d   Z d   Z e e e  Z RS(   s'   Concrete implementation for leaf nodes.R\   i    c         C   s   d | k o d k  n s( t  |   | d k	 rR | \ |  _ \ |  _ |  _ n  | |  _ | |  _ | d k	 r| | |  _ n  | |  _ d S(   s   
        Initializer.

        Takes a type constant (a token number < 256), a string value, and an
        optional context keyword argument.
        i    i   N(   R   R'   t   _prefixR8   t   columnR   t   valueRU   (   R   R   Re   RV   R#   RU   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRW   h  s    
(		c         C   s   d |  j  j |  j |  j f S(   s)   Return a canonical string representation.s
   %s(%r, %r)(   R   RK   R   Re   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRX   {  s    c         C   s   |  j  t |  j  S(   sk   
        Return a pretty string representation.

        This reproduces the input source exactly.
        (   R#   RH   Re   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR[     s    i   c         C   s"   |  j  |  j f | j  | j f k S(   s   Compare two nodes for equality.(   R   Re   (   R   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR     s    c         C   s4   t  |  j |  j |  j |  j |  j f f d |  j S(   s$   Return a cloned (deep) copy of self.RU   (   R7   R   Re   R#   R8   Rd   RU   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR     s    c         c   s	   |  Vd  S(   N(    (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRC     s    c         c   s	   |  Vd S(   s*   Return a post-order iterator for the tree.N(    (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR     s    c         c   s	   |  Vd S(   s)   Return a pre-order iterator for the tree.N(    (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR     s    c         C   s   |  j  S(   sP   
        The whitespace and comments preceding this token in the input.
        (   Rc   (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR]     s    c         C   s   |  j    | |  _ d  S(   N(   R0   Rc   (   R   R#   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR^     s    
N(   i   i    (   RK   RL   RM   Rc   R8   Rd   R'   RW   RX   R[   RQ   RR   RJ   R   R   RC   R   R   R]   R^   RP   R#   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR7   _  s&   										c         C   sk   | \ } } } } | s' | |  j  k rT t |  d k rA | d St | | d | St | | d | Sd S(   s   
    Convert raw node information to a Node or Leaf instance.

    This is passed to the parser driver which calls it whenever a reduction of a
    grammar rule produces a new complete node, so that the tree is build
    strictly bottom-up.
    i   i    RV   N(   t   number2symbolt   lenRS   R7   (   t   grt   raw_nodeR   Re   RV   R,   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   convert  s    t   BasePatternc           B   s\   e  Z d  Z d Z d Z d Z d   Z d   Z d   Z	 d d  Z
 d d  Z d   Z RS(   s  
    A pattern is a tree matching pattern.

    It looks for a specific node type (token or symbol), and
    optionally for a specific content.

    This is an abstract base class.  There are three concrete
    subclasses:

    - LeafPattern matches a single leaf node;
    - NodePattern matches a single node (usually non-leaf);
    - WildcardPattern matches a sequence of nodes of variable length.
    c         O   s%   |  t  k	 s t d   t j |   S(   s>   Constructor that prevents BasePattern from being instantiated.s   Cannot instantiate BasePattern(   Rk   R   R   R   (   R   R   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR     s    c         C   sh   t  |  j  |  j |  j g } x! | rA | d d  k rA | d =q! Wd |  j j d j t t	 |   f S(   Nis   %s(%s)s   , (
   R   R   t   contentR
   R'   R   RK   RY   RZ   RT   (   R   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRX     s    c         C   s   |  S(   s   
        A subclass can define this as a hook for optimizations.

        Returns either self or another node with the same effect.
        (    (   R   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   optimize  s    c         C   s   |  j  d k	 r% | j  |  j  k r% t S|  j d k	 r~ d } | d k	 rO i  } n  |  j | |  se t S| r~ | j |  q~ n  | d k	 r |  j r | | |  j <n  t S(   s#  
        Does this pattern exactly match a node?

        Returns True if it matches, False if not.

        If results is not None, it must be a dict which will be
        updated with the nodes matching named subpatterns.

        Default implementation for non-wildcard patterns.
        N(   R   R'   R+   Rl   t	   _submatcht   updateR
   R.   (   R   R9   t   resultst   r(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   match  s    !	c         C   s*   t  |  d k r t S|  j | d |  S(   s   
        Does this pattern exactly match a sequence of nodes?

        Default implementation for non-wildcard patterns.
        i   i    (   Rg   R+   Rr   (   R   t   nodesRp   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt	   match_seq  s    c         c   s4   i  } | r0 |  j  | d |  r0 d | f Vn  d S(   s}   
        Generator yielding all matches for this pattern.

        Default implementation for non-wildcard patterns.
        i    i   N(   Rr   (   R   Rs   Rq   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   generate_matches  s    N(   RK   RL   RM   R'   R   Rl   R
   R   RX   Rm   Rr   Rt   Ru   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRk     s   			
t   LeafPatternc           B   s2   e  Z d d d d   Z d d  Z d d  Z RS(   c         C   s   | d k	 r7 d | k o# d k  n s7 t |   n  | d k	 rg t | t  sg t t |    n  | |  _ | |  _ | |  _ d S(   sp  
        Initializer.  Takes optional type, content, and name.

        The type, if given must be a token type (< 256).  If not given,
        this matches any *leaf* node; the content may still be required.

        The content, if given, must be a string.

        If a name is given, the matching node is stored in the results
        dict under that key.
        i    i   N(   R'   R   R)   t
   basestringRT   R   Rl   R
   (   R   R   Rl   R
   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRW     s    +$		c         C   s&   t  | t  s t St j |  | |  S(   s*   Override match() to insist on a leaf node.(   R)   R7   R+   Rk   Rr   (   R   R9   Rp   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRr   ,  s    c         C   s   |  j  | j k S(   s  
        Match the pattern's content to the node's children.

        This assumes the node type matches and self.content is not None.

        Returns True if it matches, False if not.

        If results is not None, it must be a dict which will be
        updated with the nodes matching named subpatterns.

        When returning False, the results dict may still be updated.
        (   Rl   Re   (   R   R9   Rp   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRn   2  s    N(   RK   RL   R'   RW   Rr   Rn   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRv     s   t   NodePatternc           B   s,   e  Z e Z d d d d   Z d d  Z RS(   c         C   s   | d k	 r' | d k s' t |   n  | d k	 r t | t  sU t t |    t |  } xY t |  D]H \ } } t | t  s t | | f   t | t  rn t	 |  _
 qn qn Wn  | |  _ | |  _ | |  _ d S(   sd  
        Initializer.  Takes optional type, content, and name.

        The type, if given, must be a symbol type (>= 256).  If the
        type is None this matches *any* single node (leaf or not),
        except if content is not None, in which it only matches
        non-leaf nodes that also match the content pattern.

        The content, if not None, must be a sequence of Patterns that
        must match the node's children exactly.  If the content is
        given, the type must not be None.

        If a name is given, the matching node is stored in the results
        dict under that key.
        i   N(   R'   R   R)   Rw   RT   R*   R<   Rk   t   WildcardPatternR.   t	   wildcardsR   Rl   R
   (   R   R   Rl   R
   R=   t   item(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRW   F  s    "!		c         C   s   |  j  rh xX t |  j | j  D]A \ } } | t | j  k r | d k	 r\ | j |  n  t Sq Wt St |  j  t | j  k r t Sx9 t	 |  j | j  D]" \ } } | j
 | |  s t Sq Wt S(   s  
        Match the pattern's content to the node's children.

        This assumes the node type matches and self.content is not None.

        Returns True if it matches, False if not.

        If results is not None, it must be a dict which will be
        updated with the nodes matching named subpatterns.

        When returning False, the results dict may still be updated.
        N(   Rz   Ru   Rl   R,   Rg   R'   Ro   R.   R+   t   zipRr   (   R   R9   Rp   t   cRq   t
   subpatternR@   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRn   c  s    	""N(   RK   RL   R+   Rz   R'   RW   Rn   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRx   B  s   Ry   c           B   sh   e  Z d  Z d
 d e d
 d  Z d   Z d
 d  Z d
 d  Z d   Z	 d   Z
 d   Z d	   Z RS(   s  
    A wildcard pattern can match zero or more nodes.

    This has all the flexibility needed to implement patterns like:

    .*      .+      .?      .{m,n}
    (a b c | d e | f)
    (...)*  (...)+  (...)?  (...){m,n}

    except it always uses non-greedy matching.
    i    c         C   s   d | k o" | k o" t  k n s9 t | | f   | d k	 r t t t |   } t |  sx t t |    x/ | D]$ } t |  s t t |    q Wn  | |  _ | |  _ | |  _	 | |  _
 d S(   s  
        Initializer.

        Args:
            content: optional sequence of subsequences of patterns;
                     if absent, matches one node;
                     if present, each subsequence is an alternative [*]
            min: optional minimum number of times to match, default 0
            max: optional maximum number of times to match, default HUGE
            name: optional name assigned to this match

        [*] Thus, if content is [[a, b, c], [d, e], [f, g, h]] this is
            equivalent to (a b c | d e | f g h); if content is None,
            this is equivalent to '.' in regular expression terms.
            The min and max parameters work as follows:
                min=0, max=maxint: .*
                min=1, max=maxint: .+
                min=0, max=1: .?
                min=1, max=1: .
            If content is not None, replace the dot with the parenthesized
            list of alternatives, e.g. (a b c | d e | f g h)*
        i    N(   t   HUGER   R'   t   tupleRZ   Rg   RT   Rl   t   mint   maxR
   (   R   Rl   R   R   R
   t   alt(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRW     s    9%			c         C   s/  d } |  j d k	 rW t |  j  d k rW t |  j d  d k rW |  j d d } n  |  j d k r |  j d k r |  j d k r t d |  j  S| d k	 r |  j | j k r | j   Sn  |  j d k r+t | t	  r+| j d k r+|  j | j k r+t	 | j |  j | j |  j | j | j  S|  S(   s+   Optimize certain stacked wildcard patterns.i   i    R
   N(
   R'   Rl   Rg   R   R   Rx   R
   Rm   R)   Ry   (   R   R~   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRm     s     .!	
c         C   s   |  j  | g |  S(   s'   Does this pattern exactly match a node?(   Rt   (   R   R9   Rp   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRr     s    c         C   su   xn |  j  |  D]] \ } } | t |  k r | d k	 ri | j |  |  j ri t |  | |  j <qi n  t Sq Wt S(   s4   Does this pattern exactly match a sequence of nodes?N(   Ru   Rg   R'   Ro   R
   R*   R.   R+   (   R   Rs   Rp   R}   Rq   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRt     s    	c         c   s  |  j  d k rs xvt |  j d t t |  |  j   D]4 } i  } |  j ra | |  | |  j <n  | | f Vq8 Wn|  j d k r |  j |  Vn t t	 d  r t	 j
 } t   t	 _
 n  z yO xH |  j | d  D]4 \ } } |  j r | |  | |  j <n  | | f Vq WWnY t k
 rgxI |  j |  D]4 \ } } |  j rU| |  | |  j <n  | | f Vq,Wn XWd t t	 d  r| t	 _
 n  Xd S(   s"  
        Generator yielding matches for a sequence of nodes.

        Args:
            nodes: sequence of nodes

        Yields:
            (count, results) tuples where:
            count: the match comprises nodes[:count];
            results: dict containing named submatches.
        i   t	   bare_namet   getrefcounti    N(   Rl   R'   t   xrangeR   Rg   R   R
   t   _bare_name_matchest   hasattrRQ   t   stderrR    t   _recursive_matchest   RuntimeErrort   _iterative_matches(   R   Rs   t   countRq   t   save_stderr(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRu     s0    /		 		c         c   s`  t  |  } d |  j k r) d i  f Vn  g  } xO |  j D]D } x; t | |  D]* \ } } | | f V| j | | f  qO Wq9 Wx | r[g  } x | D] \ } }	 | | k  r | |  j k r x |  j D] } xv t | | |  D]a \ }
 } |
 d k r i  } | j |	  | j |  | |
 | f V| j | |
 | f  q q Wq Wq q W| } q Wd S(   s(   Helper to iteratively yield the matches.i    N(   Rg   R   Rl   Ru   R/   R   Ro   (   R   Rs   t   nodelenRp   R   R}   Rq   t   new_resultst   c0t   r0t   c1t   r1(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR     s*    	 )c         C   s   d } i  } t  } t |  } x_ | r | | k  r t } x? |  j D]4 } | d j | | |  rD | d 7} t  } PqD qD Wq! W| |  | |  j <| | f S(   s(   Special optimized matcher for bare_name.i    i   (   R+   Rg   R.   Rl   Rr   R
   (   R   Rs   R   Rq   t   doneR   t   leaf(    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR     s    
c   	      c   s   |  j  d k	 s t  | |  j k r2 d i  f Vn  | |  j k  r x |  j  D] } xw t | |  D]f \ } } xW |  j | | | d  D]; \ } } i  } | j |  | j |  | | | f Vq Wqa WqK Wn  d S(   s(   Helper to recursively yield the matches.i    i   N(   Rl   R'   R   R   R   Ru   R   Ro   (	   R   Rs   R   R   R   R   R   R   Rq   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR   ,  s    'N(   RK   RL   RM   R'   R   RW   Rm   Rr   Rt   Ru   R   R   R   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRy     s   #		-		t   NegatedPatternc           B   s/   e  Z d d   Z d   Z d   Z d   Z RS(   c         C   s=   | d k	 r0 t | t  s0 t t |    n  | |  _ d S(   s  
        Initializer.

        The argument is either a pattern or None.  If it is None, this
        only matches an empty sequence (effectively '$' in regex
        lingo).  If it is not None, this matches whenever the argument
        pattern doesn't have any matches.
        N(   R'   R)   Rk   R   RT   Rl   (   R   Rl   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRW   =  s    	$c         C   s   t  S(   N(   R+   (   R   R9   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRr   J  s    c         C   s   t  |  d k S(   Ni    (   Rg   (   R   Rs   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRt   N  s    c         c   se   |  j  d  k r2 t |  d k ra d i  f Vqa n/ x! |  j  j |  D] \ } } d  SWd i  f Vd  S(   Ni    (   Rl   R'   Rg   Ru   (   R   Rs   R}   Rq   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRu   R  s    N(   RK   RL   R'   RW   Rr   Rt   Ru   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyR   ;  s   		c   	      c   s   |  s d i  f Vn |  d |  d } } x | j  |  D]s \ } } | sY | | f Vq9 xP t  | | |  D]; \ } } i  } | j |  | j |  | | | f Vqm Wq9 Wd S(   sR  
    Generator yielding matches for a sequence of patterns and nodes.

    Args:
        patterns: a sequence of patterns
        nodes: a sequence of nodes

    Yields:
        (count, results) tuples where:
        count: the entire sequence of patterns matches nodes[:count];
        results: dict containing named submatches.
        i    i   N(   Ru   Ro   (	   t   patternsRs   t   pt   restR   R   R   R   Rq   (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyRu   ^  s     (   RM   t
   __author__RQ   R    R    R   R   R   R   R   RS   R7   Rj   Rk   Rv   Rx   Ry   R   Ru   (    (    (    s$   /usr/lib/python2.7/lib2to3/pytree.pyt   <module>   s"   	
pN	V,=#                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         