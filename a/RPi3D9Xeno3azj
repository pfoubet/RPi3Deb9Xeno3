"""A parser for HTML and XHTML."""

# This file is based on sgmllib.py, but the API is slightly different.

# XXX There should be a way to distinguish between PCDATA (parsed
# character data -- the normal case), RCDATA (replaceable character
# data -- only char and entity references and end tags are special)
# and CDATA (character data -- only end tags are special).


import markupbase
import re

# Regular expressions used for parsing

interesting_normal = re.compile('[&<]')
incomplete = re.compile('&[a-zA-Z#]')

entityref = re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')
charref = re.compile('&#(?:[0-9]+|[xX][0-9a-fA-F]+)[^0-9a-fA-F]')

starttagopen = re.compile('<[a-zA-Z]')
piclose = re.compile('>')
commentclose = re.compile(r'--\s*>')

# see http://www.w3.org/TR/html5/tokenization.html#tag-open-state
# and http://www.w3.org/TR/html5/tokenization.html#tag-name-state
# note: if you change tagfind/attrfind remember to update locatestarttagend too
tagfind = re.compile('([a-zA-Z][^\t\n\r\f />\x00]*)(?:\s|/(?!>))*')
# this regex is currently unused, but left for backward compatibility
tagfind_tolerant = re.compile('[a-zA-Z][^\t\n\r\f />\x00]*')

attrfind = re.compile(
    r'((?<=[\'"\s/])[^\s/>][^\s/=>]*)(\s*=+\s*'
    r'(\'[^\']*\'|"[^"]*"|(?![\'"])[^>\s]*))?(?:\s|/(?!>))*')

locatestarttagend = re.compile(r"""
  <[a-zA-Z][^\t\n\r\f />\x00]*       # tag name
  (?:[\s/]*                          # optional whitespace before attribute name
    (?:(?<=['"\s/])[^\s/>][^\s/=>]*  # attribute name
      (?:\s*=+\s*                    # value indicator
        (?:'[^']*'                   # LITA-enclosed value
          |"[^"]*"                   # LIT-enclosed value
          |(?!['"])[^>\s]*           # bare value
         )
       )?(?:\s|/(?!>))*
     )*
   )?
  \s*                                # trailing whitespace
""", re.VERBOSE)
endendtag = re.compile('>')
# the HTML 5 spec, section 8.1.2.2, doesn't allow spaces between
# </ and the tag name, so maybe this should be fixed
endtagfind = re.compile('</\s*([a-zA-Z][-.a-zA-Z0-9:_]*)\s*>')


class HTMLParseError(Exception):
    """Exception raised for all parse errors."""

    def __init__(self, msg, position=(None, None)):
        assert msg
        self.msg = msg
        self.lineno = position[0]
        self.offset = position[1]

    def __str__(self):
        result = self.msg
        if self.lineno is not None:
            result = result + ", at line %d" % self.lineno
        if self.offset is not None:
            result = result + ", column %d" % (self.offset + 1)
        return result


class HTMLParser(markupbase.ParserBase):
    """Find tags and other markup and call handler functions.

    Usage:
        p = HTMLParser()
        p.feed(data)
        ...
        p.close()

    Start tags are handled by calling self.handle_starttag() or
    self.handle_startendtag(); end tags by self.handle_endtag().  The
    data between tags is passed from the parser to the derived class
    by calling self.handle_data() with the data as argument (the data
    may be split up in arbitrary chunks).  Entity references are
    passed by calling self.handle_entityref() with the entity
    reference as the argument.  Numeric character references are
    passed to self.handle_charref() with the string containing the
    reference as the argument.
    """

    CDATA_CONTENT_ELEMENTS = ("script", "style")


    def __init__(self):
        """Initialize and reset this instance."""
        self.reset()

    def reset(self):
        """Reset this instance.  Loses all unprocessed data."""
        self.rawdata = ''
        self.lasttag = '???'
        self.interesting = interesting_normal
        self.cdata_elem = None
        markupbase.ParserBase.reset(self)

    def feed(self, data):
        r"""Feed data to the parser.

        Call this as often as you want, with as little or as much text
        as you want (may include '\n').
        """
        self.rawdata = self.rawdata + data
        self.goahead(0)

    def close(self):
        """Handle any buffered data."""
        self.goahead(1)

    def error(self, message):
        raise HTMLParseError(message, self.getpos())

    __starttag_text = None

    def get_starttag_text(self):
        """Return full source of start tag: '<...>'."""
        return self.__starttag_text

    def set_cdata_mode(self, elem):
        self.cdata_elem = elem.lower()
        self.interesting = re.compile(r'</\s*%s\s*>' % self.cdata_elem, re.I)

    def clear_cdata_mode(self):
        self.interesting = interesting_normal
        self.cdata_elem = None

    # Internal -- handle data as far as reasonable.  May leave state
    # and data to be processed by a subsequent call.  If 'end' is
    # true, force handling all data as if followed by EOF marker.
    def goahead(self, end):
        rawdata = self.rawdata
        i = 0
        n = len(rawdata)
        while i < n:
            match = self.interesting.search(rawdata, i) # < or &
            if match:
                j = match.start()
            else:
                if self.cdata_elem:
                    break
                j = n
            if i < j: self.handle_data(rawdata[i:j])
            i = self.updatepos(i, j)
            if i == n: break
            startswith = rawdata.startswith
            if startswith('<', i):
                if starttagopen.match(rawdata, i): # < + letter
                    k = self.parse_starttag(i)
                elif startswith("</", i):
                    k = self.parse_endtag(i)
                elif startswith("<!--", i):
                    k = self.parse_comment(i)
                elif startswith("<?", i):
                    k = self.parse_pi(i)
                elif startswith("<!", i):
                    k = self.parse_html_declaration(i)
                elif (i + 1) < n:
                    self.handle_data("<")
                    k = i + 1
                else:
                    break
                if k < 0:
                    if not end:
                        break
                    k = rawdata.find('>', i + 1)
                    if k < 0:
                        k = rawdata.find('<', i + 1)
                        if k < 0:
                            k = i + 1
                    else:
                        k += 1
                    self.handle_data(rawdata[i:k])
                i = self.updatepos(i, k)
            elif startswith("&#", i):
                match = charref.match(rawdata, i)
                if match:
                    name = match.group()[2:-1]
                    self.handle_charref(name)
                    k = match.end()
                    if not startswith(';', k-1):
                        k = k - 1
                    i = self.updatepos(i, k)
                    continue
                else:
                    if ";" in rawdata[i:]:  # bail by consuming '&#'
                        self.handle_data(rawdata[i:i+2])
                        i = self.updatepos(i, i+2)
                    break
            elif startswith('&', i):
                match = entityref.match(rawdata, i)
                if match:
                    name = match.group(1)
                    self.handle_entityref(name)
                    k = match.end()
                    if not startswith(';', k-1):
                        k = k - 1
                    i = self.updatepos(i, k)
                    continue
                match = incomplete.match(rawdata, i)
                if match:
                    # match.group() will contain at least 2 chars
                    if end and match.group() == rawdata[i:]:
                        self.error("EOF in middle of entity or char ref")
                    # incomplete
                    break
                elif (i + 1) < n:
                    # not the end of the buffer, and can't be confused
                    # with some other construct
                    self.handle_data("&")
                    i = self.updatepos(i, i + 1)
                else:
                    break
            else:
                assert 0, "interesting.search() lied"
        # end while
        if end and i < n and not self.cdata_elem:
            self.handle_data(rawdata[i:n])
            i = self.updatepos(i, n)
        self.rawdata = rawdata[i:]

    # Internal -- parse html declarations, return length or -1 if not terminated
    # See w3.org/TR/html5/tokenization.html#markup-declaration-open-state
    # See also parse_declaration in _markupbase
    def parse_html_declaration(self, i):
        rawdata = self.rawdata
        if rawdata[i:i+2] != '<!':
            self.error('unexpected call to parse_html_declaration()')
        if rawdata[i:i+4] == '<!--':
            # this case is actually already handled in goahead()
            return self.parse_comment(i)
        elif rawdata[i:i+3] == '<![':
            return self.parse_marked_section(i)
        elif rawdata[i:i+9].lower() == '<!doctype':
            # find the closing >
            gtpos = rawdata.find('>', i+9)
            if gtpos == -1:
                return -1
            self.handle_decl(rawdata[i+2:gtpos])
            return gtpos+1
        else:
            return self.parse_bogus_comment(i)

    # Internal -- parse bogus comment, return length or -1 if not terminated
    # see http://www.w3.org/TR/html5/tokenization.html#bogus-comment-state
    def parse_bogus_comment(self, i, report=1):
        rawdata = self.rawdata
        if rawdata[i:i+2] not in ('<!', '</'):
            self.error('unexpected call to parse_comment()')
        pos = rawdata.find('>', i+2)
        if pos == -1:
            return -1
        if report:
            self.handle_comment(rawdata[i+2:pos])
        return pos + 1

    # Internal -- parse processing instr, return end or -1 if not terminated
    def parse_pi(self, i):
        rawdata = self.rawdata
        assert rawdata[i:i+2] == '<?', 'unexpected call to parse_pi()'
        match = piclose.search(rawdata, i+2) # >
        if not match:
            return -1
        j = match.start()
        self.handle_pi(rawdata[i+2: j])
        j = match.end()
        return j

    # Internal -- handle starttag, return end or -1 if not terminated
    def parse_starttag(self, i):
        self.__starttag_text = None
        endpos = self.check_for_whole_start_tag(i)
        if endpos < 0:
            return endpos
        rawdata = self.rawdata
        self.__starttag_text = rawdata[i:endpos]

        # Now parse the data between i+1 and j into a tag and attrs
        attrs = []
        match = tagfind.match(rawdata, i+1)
        assert match, 'unexpected call to parse_starttag()'
        k = match.end()
        self.lasttag = tag = match.group(1).lower()

        while k < endpos:
            m = attrfind.match(rawdata, k)
            if not m:
                break
            attrname, rest, attrvalue = m.group(1, 2, 3)
            if not rest:
                attrvalue = None
            elif attrvalue[:1] == '\'' == attrvalue[-1:] or \
                 attrvalue[:1] == '"' == attrvalue[-1:]:
                attrvalue = attrvalue[1:-1]
            if attrvalue:
                attrvalue = self.unescape(attrvalue)
            attrs.append((attrname.lower(), attrvalue))
            k = m.end()

        end = rawdata[k:endpos].strip()
        if end not in (">", "/>"):
            lineno, offset = self.getpos()
            if "\n" in self.__starttag_text:
                lineno = lineno + self.__starttag_text.count("\n")
                offset = len(self.__starttag_text) \
                         - self.__starttag_text.rfind("\n")
            else:
                offset = offset + len(self.__starttag_text)
            self.handle_data(rawdata[i:endpos])
            return endpos
        if end.endswith('/>'):
            # XHTML-style empty tag: <span attr="value" />
            self.handle_startendtag(tag, attrs)
        else:
            self.handle_starttag(tag, attrs)
            if tag in self.CDATA_CONTENT_ELEMENTS:
                self.set_cdata_mode(tag)
        return endpos

    # Internal -- check to see if we have a complete starttag; return end
    # or -1 if incomplete.
    def check_for_whole_start_tag(self, i):
        rawdata = self.rawdata
        m = locatestarttagend.match(rawdata, i)
        if m:
            j = m.end()
            next = rawdata[j:j+1]
            if next == ">":
                return j + 1
            if next == "/":
                if rawdata.startswith("/>", j):
                    return j + 2
                if rawdata.startswith("/", j):
                    # buffer boundary
                    return -1
                # else bogus input
                self.updatepos(i, j + 1)
                self.error("malformed empty start tag")
            if next == "":
                # end of input
                return -1
            if next in ("abcdefghijklmnopqrstuvwxyz=/"
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
                # end of input in or before attribute value, or we have the
                # '/' from a '/>' ending
                return -1
            if j > i:
                return j
            else:
                return i + 1
        raise AssertionError("we should not get here!")

    # Internal -- parse endtag, return end or -1 if incomplete
    def parse_endtag(self, i):
        rawdata = self.rawdata
        assert rawdata[i:i+2] == "</", "unexpected call to parse_endtag"
        match = endendtag.search(rawdata, i+1) # >
        if not match:
            return -1
        gtpos = match.end()
        match = endtagfind.match(rawdata, i) # </ + tag + >
        if not match:
            if self.cdata_elem is not None:
                self.handle_data(rawdata[i:gtpos])
                return gtpos
            # find the name: w3.org/TR/html5/tokenization.html#tag-name-state
            namematch = tagfind.match(rawdata, i+2)
            if not namematch:
                # w3.org/TR/html5/tokenization.html#end-tag-open-state
                if rawdata[i:i+3] == '</>':
                    return i+3
                else:
                    return self.parse_bogus_comment(i)
            tagname = namematch.group(1).lower()
            # consume and ignore other stuff between the name and the >
            # Note: this is not 100% correct, since we might have things like
            # </tag attr=">">, but looking for > after tha name should cover
            # most of the cases and is much simpler
            gtpos = rawdata.find('>', namematch.end())
            self.handle_endtag(tagname)
            return gtpos+1

        elem = match.group(1).lower() # script or style
        if self.cdata_elem is not None:
            if elem != self.cdata_elem:
                self.handle_data(rawdata[i:gtpos])
                return gtpos

        self.handle_endtag(elem)
        self.clear_cdata_mode()
        return gtpos

    # Overridable -- finish processing of start+end tag: <tag.../>
    def handle_startendtag(self, tag, attrs):
        self.handle_starttag(tag, attrs)
        self.handle_endtag(tag)

    # Overridable -- handle start tag
    def handle_starttag(self, tag, attrs):
        pass

    # Overridable -- handle end tag
    def handle_endtag(self, tag):
        pass

    # Overridable -- handle character reference
    def handle_charref(self, name):
        pass

    # Overridable -- handle entity reference
    def handle_entityref(self, name):
        pass

    # Overridable -- handle data
    def handle_data(self, data):
        pass

    # Overridable -- handle comment
    def handle_comment(self, data):
        pass

    # Overridable -- handle declaration
    def handle_decl(self, decl):
        pass

    # Overridable -- handle processing instruction
    def handle_pi(self, data):
        pass

    def unknown_decl(self, data):
        pass

    # Internal -- helper to remove special character quoting
    entitydefs = None
    def unescape(self, s):
        if '&' not in s:
            return s
        def replaceEntities(s):
            s = s.groups()[0]
            try:
                if s[0] == "#":
                    s = s[1:]
                    if s[0] in ['x','X']:
                        c = int(s[1:], 16)
                    else:
                        c = int(s)
                    return unichr(c)
            except ValueError:
                return '&#'+s+';'
            else:
                # Cannot use name2codepoint directly, because HTMLParser supports apos,
                # which is not part of HTML 4
                import htmlentitydefs
                if HTMLParser.entitydefs is None:
                    entitydefs = HTMLParser.entitydefs = {'apos':u"'"}
                    for k, v in htmlentitydefs.name2codepoint.iteritems():
                        entitydefs[k] = unichr(v)
                try:
                    return self.entitydefs[s]
                except KeyError:
                    return '&'+s+';'

        return re.sub(r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));", replaceEntities, s)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """A more or less complete user-defined wrapper around list objects."""

import collections

class UserList(collections.MutableSequence):
    def __init__(self, initlist=None):
        self.data = []
        if initlist is not None:
            # XXX should this accept an arbitrary sequence?
            if type(initlist) == type(self.data):
                self.data[:] = initlist
            elif isinstance(initlist, UserList):
                self.data[:] = initlist.data[:]
            else:
                self.data = list(initlist)
    def __repr__(self): return repr(self.data)
    def __lt__(self, other): return self.data <  self.__cast(other)
    def __le__(self, other): return self.data <= self.__cast(other)
    def __eq__(self, other): return self.data == self.__cast(other)
    def __ne__(self, other): return self.data != self.__cast(other)
    def __gt__(self, other): return self.data >  self.__cast(other)
    def __ge__(self, other): return self.data >= self.__cast(other)
    def __cast(self, other):
        if isinstance(other, UserList): return other.data
        else: return other
    def __cmp__(self, other):
        return cmp(self.data, self.__cast(other))
    __hash__ = None # Mutable sequence, so not hashable
    def __contains__(self, item): return item in self.data
    def __len__(self): return len(self.data)
    def __getitem__(self, i): return self.data[i]
    def __setitem__(self, i, item): self.data[i] = item
    def __delitem__(self, i): del self.data[i]
    def __getslice__(self, i, j):
        i = max(i, 0); j = max(j, 0)
        return self.__class__(self.data[i:j])
    def __setslice__(self, i, j, other):
        i = max(i, 0); j = max(j, 0)
        if isinstance(other, UserList):
            self.data[i:j] = other.data
        elif isinstance(other, type(self.data)):
            self.data[i:j] = other
        else:
            self.data[i:j] = list(other)
    def __delslice__(self, i, j):
        i = max(i, 0); j = max(j, 0)
        del self.data[i:j]
    def __add__(self, other):
        if isinstance(other, UserList):
            return self.__class__(self.data + other.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(self.data + other)
        else:
            return self.__class__(self.data + list(other))
    def __radd__(self, other):
        if isinstance(other, UserList):
            return self.__class__(other.data + self.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(other + self.data)
        else:
            return self.__class__(list(other) + self.data)
    def __iadd__(self, other):
        if isinstance(other, UserList):
            self.data += other.data
        elif isinstance(other, type(self.data)):
            self.data += other
        else:
            self.data += list(other)
        return self
    def __mul__(self, n):
        return self.__class__(self.data*n)
    __rmul__ = __mul__
    def __imul__(self, n):
        self.data *= n
        return self
    def append(self, item): self.data.append(item)
    def insert(self, i, item): self.data.insert(i, item)
    def pop(self, i=-1): return self.data.pop(i)
    def remove(self, item): self.data.remove(item)
    def count(self, item): return self.data.count(item)
    def index(self, item, *args): return self.data.index(item, *args)
    def reverse(self): self.data.reverse()
    def sort(self, *args, **kwds): self.data.sort(*args, **kwds)
    def extend(self, other):
        if isinstance(other, UserList):
            self.data.extend(other.data)
        else:
            self.data.extend(other)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """Generic MIME writer.

This module defines the class MimeWriter.  The MimeWriter class implements
a basic formatter for creating MIME multi-part files.  It doesn't seek around
the output file nor does it use large amounts of buffer space. You must write
the parts out in the order that they should occur in the final file.
MimeWriter does buffer the headers you add, allowing you to rearrange their
order.

"""


import mimetools

__all__ = ["MimeWriter"]

import warnings

warnings.warn("the MimeWriter module is deprecated; use the email package instead",
                DeprecationWarning, 2)

class MimeWriter:

    """Generic MIME writer.

    Methods:

    __init__()
    addheader()
    flushheaders()
    startbody()
    startmultipartbody()
    nextpart()
    lastpart()

    A MIME writer is much more primitive than a MIME parser.  It
    doesn't seek around on the output file, and it doesn't use large
    amounts of buffer space, so you have to write the parts in the
    order they should occur on the output file.  It does buffer the
    headers you add, allowing you to rearrange their order.

    General usage is:

    f = <open the output file>
    w = MimeWriter(f)
    ...call w.addheader(key, value) 0 or more times...

    followed by either:

    f = w.startbody(content_type)
    ...call f.write(data) for body data...

    or:

    w.startmultipartbody(subtype)
    for each part:
        subwriter = w.nextpart()
        ...use the subwriter's methods to create the subpart...
    w.lastpart()

    The subwriter is another MimeWriter instance, and should be
    treated in the same way as the toplevel MimeWriter.  This way,
    writing recursive body parts is easy.

    Warning: don't forget to call lastpart()!

    XXX There should be more state so calls made in the wrong order
    are detected.

    Some special cases:

    - startbody() just returns the file passed to the constructor;
      but don't use this knowledge, as it may be changed.

    - startmultipartbody() actually returns a file as well;
      this can be used to write the initial 'if you can read this your
      mailer is not MIME-aware' message.

    - If you call flushheaders(), the headers accumulated so far are
      written out (and forgotten); this is useful if you don't need a
      body part at all, e.g. for a subpart of type message/rfc822
      that's (mis)used to store some header-like information.

    - Passing a keyword argument 'prefix=<flag>' to addheader(),
      start*body() affects where the header is inserted; 0 means
      append at the end, 1 means insert at the start; default is
      append for addheader(), but insert for start*body(), which use
      it to determine where the Content-Type header goes.

    """

    def __init__(self, fp):
        self._fp = fp
        self._headers = []

    def addheader(self, key, value, prefix=0):
        """Add a header line to the MIME message.

        The key is the name of the header, where the value obviously provides
        the value of the header. The optional argument prefix determines
        where the header is inserted; 0 means append at the end, 1 means
        insert at the start. The default is to append.

        """
        lines = value.split("\n")
        while lines and not lines[-1]: del lines[-1]
        while lines and not lines[0]: del lines[0]
        for i in range(1, len(lines)):
            lines[i] = "    " + lines[i].strip()
        value = "\n".join(lines) + "\n"
        line = key + ": " + value
        if prefix:
            self._headers.insert(0, line)
        else:
            self._headers.append(line)

    def flushheaders(self):
        """Writes out and forgets all headers accumulated so far.

        This is useful if you don't need a body part at all; for example,
        for a subpart of type message/rfc822 that's (mis)used to store some
        header-like information.

        """
        self._fp.writelines(self._headers)
        self._headers = []

    def startbody(self, ctype, plist=[], prefix=1):
        """Returns a file-like object for writing the body of the message.

        The content-type is set to the provided ctype, and the optional
        parameter, plist, provides additional parameters for the
        content-type declaration.  The optional argument prefix determines
        where the header is inserted; 0 means append at the end, 1 means
        insert at the start. The default is to insert at the start.

        """
        for name, value in plist:
            ctype = ctype + ';\n %s=\"%s\"' % (name, value)
        self.addheader("Content-Type", ctype, prefix=prefix)
        self.flushheaders()
        self._fp.write("\n")
        return self._fp

    def startmultipartbody(self, subtype, boundary=None, plist=[], prefix=1):
        """Returns a file-like object for writing the body of the message.

        Additionally, this method initializes the multi-part code, where the
        subtype parameter provides the multipart subtype, the boundary
        parameter may provide a user-defined boundary specification, and the
        plist parameter provides optional parameters for the subtype.  The
        optional argument, prefix, determines where the header is inserted;
        0 means append at the end, 1 means insert at the start. The default
        is to insert at the start.  Subparts should be created using the
        nextpart() method.

        """
        self._boundary = boundary or mimetools.choose_boundary()
        return self.startbody("multipart/" + subtype,
                              [("boundary", self._boundary)] + plist,
                              prefix=prefix)

    def nextpart(self):
        """Returns a new instance of MimeWriter which represents an
        individual part in a multipart message.

        This may be used to write the part as well as used for creating
        recursively complex multipart messages. The message must first be
        initialized with the startmultipartbody() method before using the
        nextpart() method.

        """
        self._fp.write("\n--" + self._boundary + "\n")
        return self.__class__(self._fp)

    def lastpart(self):
        """This is used to designate the last part of a multipart message.

        It should always be used when writing multipart messages.

        """
        self._fp.write("\n--" + self._boundary + "--\n")


if __name__ == '__main__':
    import test.test_MimeWriter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   s  d  Z  d d l Z d d l Z e j d É Z e j d É Z e j d É Z e j d É Z e j d É Z e j d É Z	 e j d	 É Z
 e j d
 É Z e j d É Z e j d É Z e j d e j É Z e j d É Z e j d É Z d e f d Ñ  É  YZ d e j f d Ñ  É  YZ d S(   s   A parser for HTML and XHTML.iˇˇˇˇNs   [&<]s
   &[a-zA-Z#]s%   &([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]s)   &#(?:[0-9]+|[xX][0-9a-fA-F]+)[^0-9a-fA-F]s	   <[a-zA-Z]t   >s   --\s*>s$   ([a-zA-Z][^	
 /> ]*)(?:\s|/(?!>))*s   [a-zA-Z][^	
 /> ]*s]   ((?<=[\'"\s/])[^\s/>][^\s/=>]*)(\s*=+\s*(\'[^\']*\'|"[^"]*"|(?![\'"])[^>\s]*))?(?:\s|/(?!>))*s  
  <[a-zA-Z][^\t\n\r\f />\x00]*       # tag name
  (?:[\s/]*                          # optional whitespace before attribute name
    (?:(?<=['"\s/])[^\s/>][^\s/=>]*  # attribute name
      (?:\s*=+\s*                    # value indicator
        (?:'[^']*'                   # LITA-enclosed value
          |"[^"]*"                   # LIT-enclosed value
          |(?!['"])[^>\s]*           # bare value
         )
       )?(?:\s|/(?!>))*
     )*
   )?
  \s*                                # trailing whitespace
s#   </\s*([a-zA-Z][-.a-zA-Z0-9:_]*)\s*>t   HTMLParseErrorc           B   s#   e  Z d  Z d d Ñ Z d Ñ  Z RS(   s&   Exception raised for all parse errors.c         C   s3   | s t  Ç | |  _ | d |  _ | d |  _ d  S(   Ni    i   (   t   AssertionErrort   msgt   linenot   offset(   t   selfR   t   position(    (    s    /usr/lib/python2.7/HTMLParser.pyt   __init__<   s    	c         C   sW   |  j  } |  j d  k	 r, | d |  j } n  |  j d  k	 rS | d |  j d } n  | S(   Ns   , at line %ds   , column %di   (   R   R   t   NoneR   (   R   t   result(    (    s    /usr/lib/python2.7/HTMLParser.pyt   __str__B   s    	N(   NN(   t   __name__t
   __module__t   __doc__R	   R   R   (    (    (    s    /usr/lib/python2.7/HTMLParser.pyR   9   s   t
   HTMLParserc           B   s  e  Z d  Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Z d Ñ  Z  RS(    s«  Find tags and other markup and call handler functions.

    Usage:
        p = HTMLParser()
        p.feed(data)
        ...
        p.close()

    Start tags are handled by calling self.handle_starttag() or
    self.handle_startendtag(); end tags by self.handle_endtag().  The
    data between tags is passed from the parser to the derived class
    by calling self.handle_data() with the data as argument (the data
    may be split up in arbitrary chunks).  Entity references are
    passed by calling self.handle_entityref() with the entity
    reference as the argument.  Numeric character references are
    passed to self.handle_charref() with the string containing the
    reference as the argument.
    t   scriptt   stylec         C   s   |  j  É  d S(   s#   Initialize and reset this instance.N(   t   reset(   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyR   b   s    c         C   s8   d |  _  d |  _ t |  _ d |  _ t j j |  É d S(   s1   Reset this instance.  Loses all unprocessed data.t    s   ???N(	   t   rawdatat   lasttagt   interesting_normalt   interestingR	   t
   cdata_elemt
   markupbaset
   ParserBaseR   (   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyR   f   s
    				c         C   s!   |  j  | |  _  |  j d É d S(   së   Feed data to the parser.

        Call this as often as you want, with as little or as much text
        as you want (may include '\n').
        i    N(   R   t   goahead(   R   t   data(    (    s    /usr/lib/python2.7/HTMLParser.pyt   feedn   s    c         C   s   |  j  d É d S(   s   Handle any buffered data.i   N(   R   (   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyt   closew   s    c         C   s   t  | |  j É  É Ç d  S(   N(   R   t   getpos(   R   t   message(    (    s    /usr/lib/python2.7/HTMLParser.pyt   error{   s    c         C   s   |  j  S(   s)   Return full source of start tag: '<...>'.(   t   _HTMLParser__starttag_text(   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyt   get_starttag_textÄ   s    c         C   s2   | j  É  |  _ t j d |  j t j É |  _ d  S(   Ns   </\s*%s\s*>(   t   lowerR   t   ret   compilet   IR   (   R   t   elem(    (    s    /usr/lib/python2.7/HTMLParser.pyt   set_cdata_modeÑ   s    c         C   s   t  |  _ d  |  _ d  S(   N(   R   R   R	   R   (   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyt   clear_cdata_modeà   s    	c   
      C   s|  |  j  } d } t | É } x| | k  r%|  j j | | É } | rT | j É  } n |  j ra Pn  | } | | k  rä |  j | | | !É n  |  j | | É } | | k r¨ Pn  | j } | d | É r7t	 j
 | | É rË |  j | É } nØ | d | É r	|  j | É } né | d | É r*|  j | É } nm | d | É rK|  j | É } nL | d | É rl|  j | É } n+ | d | k  rñ|  j d É | d } n P| d k  r"| s≠Pn  | j d | d É } | d k  r| j d | d É } | d k  r| d } qn
 | d 7} |  j | | | !É n  |  j | | É } q | d	 | É rt j
 | | É } | r¬| j É  d
 d !}	 |  j |	 É | j É  } | d | d É s™| d } n  |  j | | É } q q"d | | k r|  j | | | d
 !É |  j | | d
 É } n  Pq | d | É rt j
 | | É } | ré| j d É }	 |  j |	 É | j É  } | d | d É sv| d } n  |  j | | É } q n  t j
 | | É } | r÷| r“| j É  | | k r“|  j d É n  Pq"| d | k  r|  j d É |  j | | d É } q"Pq d s t d É Ç q W| rk| | k  rk|  j rk|  j | | | !É |  j | | É } n  | | |  _  d  S(   Ni    t   <s   </s   <!--s   <?s   <!i   R    s   &#i   iˇˇˇˇt   ;t   &s#   EOF in middle of entity or char refs   interesting.search() lied(   R   t   lenR   t   searcht   startR   t   handle_datat	   updatepost
   startswitht   starttagopent   matcht   parse_starttagt   parse_endtagt   parse_commentt   parse_pit   parse_html_declarationt   findt   charreft   groupt   handle_charreft   endt	   entityreft   handle_entityreft
   incompleteR!   R   (
   R   R?   R   t   it   nR5   t   jR3   t   kt   name(    (    s    /usr/lib/python2.7/HTMLParser.pyR   è   s†    		  	
c         C   sÏ   |  j  } | | | d !d k r0 |  j d É n  | | | d !d k rT |  j | É S| | | d !d k rx |  j | É S| | | d !j É  d	 k r€ | j d
 | d É } | d k rª d S|  j | | d | !É | d S|  j | É Sd  S(   Ni   s   <!s+   unexpected call to parse_html_declaration()i   s   <!--i   s   <![i	   s	   <!doctypeR    iˇˇˇˇi   (   R   R!   R8   t   parse_marked_sectionR$   R;   t   handle_declt   parse_bogus_comment(   R   RC   R   t   gtpos(    (    s    /usr/lib/python2.7/HTMLParser.pyR:   Ì   s    	i   c         C   s   |  j  } | | | d !d k r0 |  j d É n  | j d | d É } | d k rV d S| rw |  j | | d | !É n  | d S(	   Ni   s   <!s   </s"   unexpected call to parse_comment()R    iˇˇˇˇi   (   s   <!s   </(   R   R!   R;   t   handle_comment(   R   RC   t   reportR   t   pos(    (    s    /usr/lib/python2.7/HTMLParser.pyRJ     s    	c         C   sÄ   |  j  } | | | d !d k s, t d É Ç t j | | d É } | sL d S| j É  } |  j | | d | !É | j É  } | S(   Ni   s   <?s   unexpected call to parse_pi()iˇˇˇˇ(   R   R   t   picloseR/   R0   t	   handle_piR?   (   R   RC   R   R5   RE   (    (    s    /usr/lib/python2.7/HTMLParser.pyR9     s    	#c         C   sÄ  d  |  _ |  j | É } | d k  r( | S|  j } | | | !|  _ g  } t j | | d É } | so t d É Ç | j É  } | j d É j	 É  |  _
 } xÓ | | k  rát j | | É } | s¬ Pn  | j d d d É \ }	 }
 } |
 sÔ d  } nX | d  d k o| d k n s7| d  d k o2| d k n rG| d d !} n  | r_|  j | É } n  | j |	 j	 É  | f É | j É  } qö W| | | !j É  } | d k r+|  j É  \ } } d |  j k r | |  j j d É } t |  j É |  j j d É } n | t |  j É } |  j | | | !É | S| j d
 É rM|  j | | É n/ |  j | | É | |  j k r||  j | É n  | S(   Ni    i   s#   unexpected call to parse_starttag()i   i   s   'iˇˇˇˇt   "R    s   />s   
(   R    s   />(   R	   R"   t   check_for_whole_start_tagR   t   tagfindR5   R   R?   R=   R$   R   t   attrfindt   unescapet   appendt   stripR   t   countR.   t   rfindR1   t   endswitht   handle_startendtagt   handle_starttagt   CDATA_CONTENT_ELEMENTSR)   (   R   RC   t   endposR   t   attrsR5   RF   t   tagt   mt   attrnamet   restt	   attrvalueR?   R   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyR6     sR    			$$c         C   s˝   |  j  } t j | | É } | rÌ | j É  } | | | d !} | d k rR | d S| d k r≤ | j d | É rx | d S| j d | É ré d S|  j | | d É |  j d É n  | d k r¬ d S| d	 k r“ d S| | k r‚ | S| d Sn  t d
 É Ç d  S(   Ni   R    t   /s   />i   iˇˇˇˇs   malformed empty start tagR   s6   abcdefghijklmnopqrstuvwxyz=/ABCDEFGHIJKLMNOPQRSTUVWXYZs   we should not get here!(   R   t   locatestarttagendR5   R?   R3   R2   R!   R   (   R   RC   R   Ra   RE   t   next(    (    s    /usr/lib/python2.7/HTMLParser.pyRR   N  s,    	c         C   sç  |  j  } | | | d !d k s, t d É Ç t j | | d É } | sL d S| j É  } t j | | É } | s$|  j d  k	 ró |  j	 | | | !É | St
 j | | d É } | s‚ | | | d !d k r“ | d S|  j | É Sn  | j d É j É  } | j d | j É  É } |  j | É | d S| j d É j É  } |  j d  k	 rr| |  j k rr|  j	 | | | !É | Sn  |  j | É |  j É  | S(	   Ni   s   </s   unexpected call to parse_endtagi   iˇˇˇˇi   s   </>R    (   R   R   t	   endendtagR/   R?   t
   endtagfindR5   R   R	   R1   RS   RJ   R=   R$   R;   t   handle_endtagR*   (   R   RC   R   R5   RK   t	   namematcht   tagnameR(   (    (    s    /usr/lib/python2.7/HTMLParser.pyR7   n  s8    	#
c         C   s!   |  j  | | É |  j | É d  S(   N(   R\   Rj   (   R   R`   R_   (    (    s    /usr/lib/python2.7/HTMLParser.pyR[   ñ  s    c         C   s   d  S(   N(    (   R   R`   R_   (    (    s    /usr/lib/python2.7/HTMLParser.pyR\   õ  s    c         C   s   d  S(   N(    (   R   R`   (    (    s    /usr/lib/python2.7/HTMLParser.pyRj   ü  s    c         C   s   d  S(   N(    (   R   RG   (    (    s    /usr/lib/python2.7/HTMLParser.pyR>   £  s    c         C   s   d  S(   N(    (   R   RG   (    (    s    /usr/lib/python2.7/HTMLParser.pyRA   ß  s    c         C   s   d  S(   N(    (   R   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyR1   ´  s    c         C   s   d  S(   N(    (   R   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyRL   Ø  s    c         C   s   d  S(   N(    (   R   t   decl(    (    s    /usr/lib/python2.7/HTMLParser.pyRI   ≥  s    c         C   s   d  S(   N(    (   R   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyRP   ∑  s    c         C   s   d  S(   N(    (   R   R   (    (    s    /usr/lib/python2.7/HTMLParser.pyt   unknown_decl∫  s    c            s2   d | k r | Sá  f d Ü  } t  j d | | É S(   NR-   c            s  |  j  É  d }  yZ |  d d k ri |  d }  |  d d k rS t |  d d É } n t |  É } t | É SWn t k
 rÜ d |  d SXd	 d  l } t j d  k rÈ i d
 d 6} t _ x0 | j j	 É  D] \ } } t | É | | <q∆ Wn  y à  j |  SWn t
 k
 rd |  d SXd  S(   Ni    t   #i   t   xt   Xi   s   &#R,   iˇˇˇˇu   't   aposR-   (   Rp   Rq   (   t   groupst   intt   unichrt
   ValueErrort   htmlentitydefsR   t
   entitydefsR	   t   name2codepointt	   iteritemst   KeyError(   t   st   cRw   Rx   RF   t   v(   R   (    s    /usr/lib/python2.7/HTMLParser.pyt   replaceEntities¬  s&    
s#   &(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));(   R%   t   sub(   R   R|   R   (    (   R   s    /usr/lib/python2.7/HTMLParser.pyRU   ø  s    (   R   R   N(!   R   R   R   R]   R   R   R   R   R!   R	   R"   R#   R)   R*   R   R:   RJ   R9   R6   RR   R7   R[   R\   Rj   R>   RA   R1   RL   RI   RP   Rn   Rx   RU   (    (    (    s    /usr/lib/python2.7/HTMLParser.pyR   K   s<   										^			4	 	(										(   R   R   R%   R&   R   RB   R@   R<   R4   RO   t   commentcloseRS   t   tagfind_tolerantRT   t   VERBOSERf   Rh   Ri   t	   ExceptionR   R   R   (    (    (    s    /usr/lib/python2.7/HTMLParser.pyt   <module>   s&   
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     A. HISTORY OF THE SOFTWARE
==========================

Python was created in the early 1990s by Guido van Rossum at Stichting
Mathematisch Centrum (CWI, see http://www.cwi.nl) in the Netherlands
as a successor of a language called ABC.  Guido remains Python's
principal author, although it includes many contributions from others.

In 1995, Guido continued his work on Python at the Corporation for
National Research Initiatives (CNRI, see http://www.cnri.reston.va.us)
in Reston, Virginia where he released several versions of the
software.

In May 2000, Guido and the Python core development team moved to
BeOpen.com to form the BeOpen PythonLabs team.  In October of the same
year, the PythonLabs team moved to Digital Creations (now Zope
Corporation, see http://www.zope.com).  In 2001, the Python Software
Foundation (PSF, see http://www.python.org/psf/) was formed, a
non-profit organization created specifically to own Python-related
Intellectual Property.  Zope Corporation is a sponsoring member of
the PSF.

All Python releases are Open Source (see http://www.opensource.org for
the Open Source Definition).  Historically, most, but not all, Python
releases have also been GPL-compatible; the table below summarizes
the various releases.

    Release         Derived     Year        Owner       GPL-
                    from                                compatible? (1)

    0.9.0 thru 1.2              1991-1995   CWI         yes
    1.3 thru 1.5.2  1.2         1995-1999   CNRI        yes
    1.6             1.5.2       2000        CNRI        no
    2.0             1.6         2000        BeOpen.com  no
    1.6.1           1.6         2001        CNRI        yes (2)
    2.1             2.0+1.6.1   2001        PSF         no
    2.0.1           2.0+1.6.1   2001        PSF         yes
    2.1.1           2.1+2.0.1   2001        PSF         yes
    2.1.2           2.1.1       2002        PSF         yes
    2.1.3           2.1.2       2002        PSF         yes
    2.2 and above   2.1.1       2001-now    PSF         yes

Footnotes:

(1) GPL-compatible doesn't mean that we're distributing Python under
    the GPL.  All Python licenses, unlike the GPL, let you distribute
    a modified version without making your changes open source.  The
    GPL-compatible licenses make it possible to combine Python with
    other software that is released under the GPL; the others don't.

(2) According to Richard Stallman, 1.6.1 is not GPL-compatible,
    because its license has a choice of law clause.  According to
    CNRI, however, Stallman's lawyer has told CNRI's lawyer that 1.6.1
    is "not incompatible" with the GPL.

Thanks to the many outside volunteers who have worked under Guido's
direction to make these releases possible.


B. TERMS AND CONDITIONS FOR ACCESSING OR OTHERWISE USING PYTHON
===============================================================

PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2
--------------------------------------------

1. This LICENSE AGREEMENT is between the Python Software Foundation
("PSF"), and the Individual or Organization ("Licensee") accessing and
otherwise using this software ("Python") in source or binary form and
its associated documentation.

2. Subject to the terms and conditions of this License Agreement, PSF hereby
grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
analyze, test, perform and/or display publicly, prepare derivative works,
distribute, and otherwise use Python alone or in any derivative version,
provided, however, that PSF's License Agreement and PSF's notice of copyright,
i.e., "Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014, 2015, 2016 Python Software Foundation; All Rights
Reserved" are retained in Python alone or in any derivative version prepared by
Licensee.

3. In the event Licensee prepares a derivative work that is based on
or incorporates Python or any part thereof, and wants to make
the derivative work available to others as provided herein, then
Licensee hereby agrees to include in any such work a brief summary of
the changes made to Python.

4. PSF is making Python available to Licensee on an "AS IS"
basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,
OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

7. Nothing in this License Agreement shall be deemed to create any
relationship of agency, partnership, or joint venture between PSF and
Licensee.  This License Agreement does not grant permission to use PSF
trademarks or trade name in a trademark sense to endorse or promote
products or services of Licensee, or any third party.

8. By copying, installing or otherwise using Python, Licensee
agrees to be bound by the terms and conditions of this License
Agreement.


BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0
-------------------------------------------

BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1

1. This LICENSE AGREEMENT is between BeOpen.com ("BeOpen"), having an
office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the
Individual or Organization ("Licensee") accessing and otherwise using
this software in source or binary form and its associated
documentation ("the Software").

2. Subject to the terms and conditions of this BeOpen Python License
Agreement, BeOpen hereby grants Licensee a non-exclusive,
royalty-free, world-wide license to reproduce, analyze, test, perform
and/or display publicly, prepare derivative works, distribute, and
otherwise use the Software alone or in any derivative version,
provided, however, that the BeOpen Python License is retained in the
Software, alone or in any derivative version prepared by Licensee.

3. BeOpen is making the Software available to Licensee on an "AS IS"
basis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE
SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS
AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE, OR ANY
DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

5. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

6. This License Agreement shall be governed by and interpreted in all
respects by the law of the State of California, excluding conflict of
law provisions.  Nothing in this License Agreement shall be deemed to
create any relationship of agency, partnership, or joint venture
between BeOpen and Licensee.  This License Agreement does not grant
permission to use BeOpen trademarks or trade names in a trademark
sense to endorse or promote products or services of Licensee, or any
third party.  As an exception, the "BeOpen Python" logos available at
http://www.pythonlabs.com/logos.html may be used according to the
permissions granted on that web page.

7. By copying, installing or otherwise using the software, Licensee
agrees to be bound by the terms and conditions of this License
Agreement.


CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1
---------------------------------------

1. This LICENSE AGREEMENT is between the Corporation for National
Research Initiatives, having an office at 1895 Preston White Drive,
Reston, VA 20191 ("CNRI"), and the Individual or Organization
("Licensee") accessing and otherwise using Python 1.6.1 software in
source or binary form and its associated documentation.

2. Subject to the terms and conditions of this License Agreement, CNRI
hereby grants Licensee a nonexclusive, royalty-free, world-wide
license to reproduce, analyze, test, perform and/or display publicly,
prepare derivative works, distribute, and otherwise use Python 1.6.1
alone or in any derivative version, provided, however, that CNRI's
License Agreement and CNRI's notice of copyright, i.e., "Copyright (c)
1995-2001 Corporation for National Research Initiatives; All Rights
Reserved" are retained in Python 1.6.1 alone or in any derivative
version prepared by Licensee.  Alternately, in lieu of CNRI's License
Agreement, Licensee may substitute the following text (omitting the
quotes): "Python 1.6.1 is made available subject to the terms and
conditions in CNRI's License Agreement.  This Agreement together with
Python 1.6.1 may be located on the Internet using the following
unique, persistent identifier (known as a handle): 1895.22/1013.  This
Agreement may also be obtained from a proxy server on the Internet
using the following URL: http://hdl.handle.net/1895.22/1013".

3. In the event Licensee prepares a derivative work that is based on
or incorporates Python 1.6.1 or any part thereof, and wants to make
the derivative work available to others as provided herein, then
Licensee hereby agrees to include in any such work a brief summary of
the changes made to Python 1.6.1.

4. CNRI is making Python 1.6.1 available to Licensee on an "AS IS"
basis.  CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1 WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 1.6.1,
OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

7. This License Agreement shall be governed by the federal
intellectual property law of the United States, including without
limitation the federal copyright law, and, to the extent such
U.S. federal law does not apply, by the law of the Commonwealth of
Virginia, excluding Virginia's conflict of law provisions.
Notwithstanding the foregoing, with regard to derivative works based
on Python 1.6.1 that incorporate non-separable material that was
previously distributed under the GNU General Public License (GPL), the
law of the Commonwealth of Virginia shall govern this License
Agreement only as to issues arising under or with respect to
Paragraphs 4, 5, and 7 of this License Agreement.  Nothing in this
License Agreement shall be deemed to create any relationship of
agency, partnership, or joint venture between CNRI and Licensee.  This
License Agreement does not grant permission to use CNRI trademarks or
trade name in a trademark sense to endorse or promote products or
services of Licensee, or any third party.

8. By clicking on the "ACCEPT" button where indicated, or by copying,
installing or otherwise using Python 1.6.1, Licensee agrees to be
bound by the terms and conditions of this License Agreement.

        ACCEPT


CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2
--------------------------------------------------

Copyright (c) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam,
The Netherlands.  All rights reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Û
”´[c           @   sl   d  Z  d d l Z d g Z d d l Z e j d e d É d d d Ñ  É  YZ e d k rh d d l Z	 n  d S(	   sñ  Generic MIME writer.

This module defines the class MimeWriter.  The MimeWriter class implements
a basic formatter for creating MIME multi-part files.  It doesn't seek around
the output file nor does it use large amounts of buffer space. You must write
the parts out in the order that they should occur in the final file.
MimeWriter does buffer the headers you add, allowing you to rearrange their
order.

iˇˇˇˇNt
   MimeWritersB   the MimeWriter module is deprecated; use the email package insteadi   c           B   s_   e  Z d  Z d Ñ  Z d d Ñ Z d Ñ  Z g  d d Ñ Z d
 g  d d Ñ Z d Ñ  Z	 d	 Ñ  Z
 RS(   sO  Generic MIME writer.

    Methods:

    __init__()
    addheader()
    flushheaders()
    startbody()
    startmultipartbody()
    nextpart()
    lastpart()

    A MIME writer is much more primitive than a MIME parser.  It
    doesn't seek around on the output file, and it doesn't use large
    amounts of buffer space, so you have to write the parts in the
    order they should occur on the output file.  It does buffer the
    headers you add, allowing you to rearrange their order.

    General usage is:

    f = <open the output file>
    w = MimeWriter(f)
    ...call w.addheader(key, value) 0 or more times...

    followed by either:

    f = w.startbody(content_type)
    ...call f.write(data) for body data...

    or:

    w.startmultipartbody(subtype)
    for each part:
        subwriter = w.nextpart()
        ...use the subwriter's methods to create the subpart...
    w.lastpart()

    The subwriter is another MimeWriter instance, and should be
    treated in the same way as the toplevel MimeWriter.  This way,
    writing recursive body parts is easy.

    Warning: don't forget to call lastpart()!

    XXX There should be more state so calls made in the wrong order
    are detected.

    Some special cases:

    - startbody() just returns the file passed to the constructor;
      but don't use this knowledge, as it may be changed.

    - startmultipartbody() actually returns a file as well;
      this can be used to write the initial 'if you can read this your
      mailer is not MIME-aware' message.

    - If you call flushheaders(), the headers accumulated so far are
      written out (and forgotten); this is useful if you don't need a
      body part at all, e.g. for a subpart of type message/rfc822
      that's (mis)used to store some header-like information.

    - Passing a keyword argument 'prefix=<flag>' to addheader(),
      start*body() affects where the header is inserted; 0 means
      append at the end, 1 means insert at the start; default is
      append for addheader(), but insert for start*body(), which use
      it to determine where the Content-Type header goes.

    c         C   s   | |  _  g  |  _ d  S(   N(   t   _fpt   _headers(   t   selft   fp(    (    s    /usr/lib/python2.7/MimeWriter.pyt   __init__\   s    	i    c         C   s÷   | j  d É } x | r- | d r- | d =q Wx | rL | d rL | d =q1 Wx5 t d t | É É D] } d | | j É  | | <qc Wd j | É d } | d | } | r¬ |  j j d | É n |  j j | É d S(   sH  Add a header line to the MIME message.

        The key is the name of the header, where the value obviously provides
        the value of the header. The optional argument prefix determines
        where the header is inserted; 0 means append at the end, 1 means
        insert at the start. The default is to append.

        s   
iˇˇˇˇi    i   s       s   : N(   t   splitt   ranget   lent   stript   joinR   t   insertt   append(   R   t   keyt   valuet   prefixt   linest   it   line(    (    s    /usr/lib/python2.7/MimeWriter.pyt	   addheader`   s    	  c         C   s    |  j  j |  j É g  |  _ d S(   s¯   Writes out and forgets all headers accumulated so far.

        This is useful if you don't need a body part at all; for example,
        for a subpart of type message/rfc822 that's (mis)used to store some
        header-like information.

        N(   R   t
   writelinesR   (   R   (    (    s    /usr/lib/python2.7/MimeWriter.pyt   flushheadersu   s    i   c         C   sb   x( | D]  \ } } | d | | f } q W|  j  d | d | É|  j É  |  j j d É |  j S(   s´  Returns a file-like object for writing the body of the message.

        The content-type is set to the provided ctype, and the optional
        parameter, plist, provides additional parameters for the
        content-type declaration.  The optional argument prefix determines
        where the header is inserted; 0 means append at the end, 1 means
        insert at the start. The default is to insert at the start.

        s
   ;
 %s="%s"s   Content-TypeR   s   
(   R   R   R   t   write(   R   t   ctypet   plistR   t   nameR   (    (    s    /usr/lib/python2.7/MimeWriter.pyt	   startbodyÄ   s    

c         C   s?   | p t  j É  |  _ |  j d | d |  j f g | d | ÉS(   sr  Returns a file-like object for writing the body of the message.

        Additionally, this method initializes the multi-part code, where the
        subtype parameter provides the multipart subtype, the boundary
        parameter may provide a user-defined boundary specification, and the
        plist parameter provides optional parameters for the subtype.  The
        optional argument, prefix, determines where the header is inserted;
        0 means append at the end, 1 means insert at the start. The default
        is to insert at the start.  Subparts should be created using the
        nextpart() method.

        s
   multipart/t   boundaryR   (   t	   mimetoolst   choose_boundaryt	   _boundaryR   (   R   t   subtypeR   R   R   (    (    s    /usr/lib/python2.7/MimeWriter.pyt   startmultipartbodyë   s    c         C   s+   |  j  j d |  j d É |  j |  j  É S(   sj  Returns a new instance of MimeWriter which represents an
        individual part in a multipart message.

        This may be used to write the part as well as used for creating
        recursively complex multipart messages. The message must first be
        initialized with the startmultipartbody() method before using the
        nextpart() method.

        s   
--s   
(   R   R   R   t	   __class__(   R   (    (    s    /usr/lib/python2.7/MimeWriter.pyt   nextpart£   s    
c         C   s   |  j  j d |  j d É d S(   så   This is used to designate the last part of a multipart message.

        It should always be used when writing multipart messages.

        s   
--s   --
N(   R   R   R   (   R   (    (    s    /usr/lib/python2.7/MimeWriter.pyt   lastpart∞   s    N(   t   __name__t
   __module__t   __doc__R   R   R   R   t   NoneR    R"   R#   (    (    (    s    /usr/lib/python2.7/MimeWriter.pyR       s   D			t   __main__(    (
   R&   R   t   __all__t   warningst   warnt   DeprecationWarningR    R$   t   test.test_MimeWritert   test(    (    (    s    /usr/lib/python2.7/MimeWriter.pyt   <module>
   s   		
£                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              """A multi-producer, multi-consumer queue."""

from time import time as _time
try:
    import threading as _threading
except ImportError:
    import dummy_threading as _threading
from collections import deque
import heapq

__all__ = ['Empty', 'Full', 'Queue', 'PriorityQueue', 'LifoQueue']

class Empty(Exception):
    "Exception raised by Queue.get(block=0)/get_nowait()."
    pass

class Full(Exception):
    "Exception raised by Queue.put(block=0)/put_nowait()."
    pass

class Queue:
    """Create a queue object with a given maximum size.

    If maxsize is <= 0, the queue size is infinite.
    """
    def __init__(self, maxsize=0):
        self.maxsize = maxsize
        self._init(maxsize)
        # mutex must be held whenever the queue is mutating.  All methods
        # that acquire mutex must release it before returning.  mutex
        # is shared between the three conditions, so acquiring and
        # releasing the conditions also acquires and releases mutex.
        self.mutex = _threading.Lock()
        # Notify not_empty whenever an item is added to the queue; a
        # thread waiting to get is notified then.
        self.not_empty = _threading.Condition(self.mutex)
        # Notify not_full whenever an item is removed from the queue;
        # a thread waiting to put is notified then.
        self.not_full = _threading.Condition(self.mutex)
        # Notify all_tasks_done whenever the number of unfinished tasks
        # drops to zero; thread waiting to join() is notified to resume
        self.all_tasks_done = _threading.Condition(self.mutex)
        self.unfinished_tasks = 0

    def task_done(self):
        """Indicate that a formerly enqueued task is complete.

        Used by Queue consumer threads.  For each get() used to fetch a task,
        a subsequent call to task_done() tells the queue that the processing
        on the task is complete.

        If a join() is currently blocking, it will resume when all items
        have been processed (meaning that a task_done() call was received
        for every item that had been put() into the queue).

        Raises a ValueError if called more times than there were items
        placed in the queue.
        """
        self.all_tasks_done.acquire()
        try:
            unfinished = self.unfinished_tasks - 1
            if unfinished <= 0:
                if unfinished < 0:
                    raise ValueError('task_done() called too many times')
                self.all_tasks_done.notify_all()
            self.unfinished_tasks = unfinished
        finally:
            self.all_tasks_done.release()

    def join(self):
        """Blocks until all items in the Queue have been gotten and processed.

        The count of unfinished tasks goes up whenever an item is added to the
        queue. The count goes down whenever a consumer thread calls task_done()
        to indicate the item was retrieved and all work on it is complete.

        When the count of unfinished tasks drops to zero, join() unblocks.
        """
        self.all_tasks_done.acquire()
        try:
            while self.unfinished_tasks:
                self.all_tasks_done.wait()
        finally:
            self.all_tasks_done.release()

    def qsize(self):
        """Return the approximate size of the queue (not reliable!)."""
        self.mutex.acquire()
        n = self._qsize()
        self.mutex.release()
        return n

    def empty(self):
        """Return True if the queue is empty, False otherwise (not reliable!)."""
        self.mutex.acquire()
        n = not self._qsize()
        self.mutex.release()
        return n

    def full(self):
        """Return True if the queue is full, False otherwise (not reliable!)."""
        self.mutex.acquire()
        n = 0 < self.maxsize == self._qsize()
        self.mutex.release()
        return n

    def put(self, item, block=True, timeout=None):
        """Put an item into the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until a free slot is available. If 'timeout' is
        a non-negative number, it blocks at most 'timeout' seconds and raises
        the Full exception if no free slot was available within that time.
        Otherwise ('block' is false), put an item on the queue if a free slot
        is immediately available, else raise the Full exception ('timeout'
        is ignored in that case).
        """
        self.not_full.acquire()
        try:
            if self.maxsize > 0:
                if not block:
                    if self._qsize() == self.maxsize:
                        raise Full
                elif timeout is None:
                    while self._qsize() == self.maxsize:
                        self.not_full.wait()
                elif timeout < 0:
                    raise ValueError("'timeout' must be a non-negative number")
                else:
                    endtime = _time() + timeout
                    while self._qsize() == self.maxsize:
                        remaining = endtime - _time()
                        if remaining <= 0.0:
                            raise Full
                        self.not_full.wait(remaining)
            self._put(item)
            self.unfinished_tasks += 1
            self.not_empty.notify()
        finally:
            self.not_full.release()

    def put_nowait(self, item):
        """Put an item into the queue without blocking.

        Only enqueue the item if a free slot is immediately available.
        Otherwise raise the Full exception.
        """
        return self.put(item, False)

    def get(self, block=True, timeout=None):
        """Remove and return an item from the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until an item is available. If 'timeout' is
        a non-negative number, it blocks at most 'timeout' seconds and raises
        the Empty exception if no item was available within that time.
        Otherwise ('block' is false), return an item if one is immediately
        available, else raise the Empty exception ('timeout' is ignored
        in that case).
        """
        self.not_empty.acquire()
        try:
            if not block:
                if not self._qsize():
                    raise Empty
            elif timeout is None:
                while not self._qsize():
                    self.not_empty.wait()
            elif timeout < 0:
                raise ValueError("'timeout' must be a non-negative number")
            else:
                endtime = _time() + timeout
                while not self._qsize():
                    remaining = endtime - _time()
                    if remaining <= 0.0:
                        raise Empty
                    self.not_empty.wait(remaining)
            item = self._get()
            self.not_full.notify()
            return item
        finally:
            self.not_empty.release()

    def get_nowait(self):
        """Remove and return an item from the queue without blocking.

        Only get an item if one is immediately available. Otherwise
        raise the Empty exception.
        """
        return self.get(False)

    # Override these methods to implement other queue organizations
    # (e.g. stack or priority queue).
    # These will only be called with appropriate locks held

    # Initialize the queue representation
    def _init(self, maxsize):
        self.queue = deque()

    def _qsize(self, len=len):
        return len(self.queue)

    # Put a new item in the queue
    def _put(self, item):
        self.queue.append(item)

    # Get an item from the queue
    def _get(self):
        return self.queue.popleft()


class PriorityQueue(Queue):
    '''Variant of Queue that retrieves open entries in priority order (lowest first).

    Entries are typically tuples of the form:  (priority number, data).
    '''

    def _init(self, maxsize):
        self.queue = []

    def _qsize(self, len=len):
        return len(self.queue)

    def _put(self, item, heappush=heapq.heappush):
        heappush(self.queue, item)

    def _get(self, heappop=heapq.heappop):
        return heappop(self.queue)


class LifoQueue(Queue):
    '''Variant of Queue that retrieves most recently added entries first.'''

    def _init(self, maxsize):
        self.queue = []

    def _qsize(self, len=len):
        return len(self.queue)

    def _put(self, item):
        self.queue.append(item)

    def _get(self):
        return self.queue.pop()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   sÊ   d  Z  d d l m Z y d d l Z Wn e k
 rE d d l Z n Xd d l m Z d d l	 Z	 d d d d d	 g Z
 d e f d
 Ñ  É  YZ d e f d Ñ  É  YZ d d d Ñ  É  YZ d e f d Ñ  É  YZ d	 e f d Ñ  É  YZ d S(   s'   A multi-producer, multi-consumer queue.iˇˇˇˇ(   t   timeN(   t   dequet   Emptyt   Fullt   Queuet   PriorityQueuet	   LifoQueuec           B   s   e  Z d  Z RS(   s4   Exception raised by Queue.get(block=0)/get_nowait().(   t   __name__t
   __module__t   __doc__(    (    (    s   /usr/lib/python2.7/Queue.pyR      s   c           B   s   e  Z d  Z RS(   s4   Exception raised by Queue.put(block=0)/put_nowait().(   R   R   R	   (    (    (    s   /usr/lib/python2.7/Queue.pyR      s   c           B   sû   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e	 d d Ñ Z d	 Ñ  Z e	 d d
 Ñ Z d Ñ  Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z RS(   sj   Create a queue object with a given maximum size.

    If maxsize is <= 0, the queue size is infinite.
    i    c         C   sq   | |  _  |  j | É t j É  |  _ t j |  j É |  _ t j |  j É |  _ t j |  j É |  _ d |  _	 d  S(   Ni    (
   t   maxsizet   _initt
   _threadingt   Lockt   mutext	   Conditiont	   not_emptyt   not_fullt   all_tasks_donet   unfinished_tasks(   t   selfR
   (    (    s   /usr/lib/python2.7/Queue.pyt   __init__   s    	c         C   ss   |  j  j É  zQ |  j d } | d k rT | d k  rD t d É Ç n  |  j  j É  n  | |  _ Wd |  j  j É  Xd S(   s.  Indicate that a formerly enqueued task is complete.

        Used by Queue consumer threads.  For each get() used to fetch a task,
        a subsequent call to task_done() tells the queue that the processing
        on the task is complete.

        If a join() is currently blocking, it will resume when all items
        have been processed (meaning that a task_done() call was received
        for every item that had been put() into the queue).

        Raises a ValueError if called more times than there were items
        placed in the queue.
        i   i    s!   task_done() called too many timesN(   R   t   acquireR   t
   ValueErrort
   notify_allt   release(   R   t
   unfinished(    (    s   /usr/lib/python2.7/Queue.pyt	   task_done-   s    c         C   sC   |  j  j É  z! x |  j r, |  j  j É  q WWd |  j  j É  Xd S(   sÉ  Blocks until all items in the Queue have been gotten and processed.

        The count of unfinished tasks goes up whenever an item is added to the
        queue. The count goes down whenever a consumer thread calls task_done()
        to indicate the item was retrieved and all work on it is complete.

        When the count of unfinished tasks drops to zero, join() unblocks.
        N(   R   R   R   t   waitR   (   R   (    (    s   /usr/lib/python2.7/Queue.pyt   joinF   s
    	c         C   s*   |  j  j É  |  j É  } |  j  j É  | S(   s9   Return the approximate size of the queue (not reliable!).(   R   R   t   _qsizeR   (   R   t   n(    (    s   /usr/lib/python2.7/Queue.pyt   qsizeV   s    c         C   s+   |  j  j É  |  j É  } |  j  j É  | S(   sC   Return True if the queue is empty, False otherwise (not reliable!).(   R   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/Queue.pyt   empty]   s    c         C   sC   |  j  j É  d |  j k  o- |  j É  k n } |  j  j É  | S(   sB   Return True if the queue is full, False otherwise (not reliable!).i    (   R   R   R
   R   R   (   R   R   (    (    s   /usr/lib/python2.7/Queue.pyt   fulld   s    %c         C   s6  |  j  j É  z|  j d k r˜ | sF |  j É  |  j k rÙ t Ç qÙ q˜ | d k r~ xü |  j É  |  j k rz |  j  j É  qU Wq˜ | d k  rô t d É Ç q˜ t É  | } xN |  j É  |  j k rÛ | t É  } | d k r‡ t Ç n  |  j  j | É q© Wn  |  j	 | É |  j
 d 7_
 |  j j É  Wd |  j  j É  Xd S(   s  Put an item into the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until a free slot is available. If 'timeout' is
        a non-negative number, it blocks at most 'timeout' seconds and raises
        the Full exception if no free slot was available within that time.
        Otherwise ('block' is false), put an item on the queue if a free slot
        is immediately available, else raise the Full exception ('timeout'
        is ignored in that case).
        i    s'   'timeout' must be a non-negative numberg        i   N(   R   R   R
   R   R   t   NoneR   R   t   _timet   _putR   R   t   notifyR   (   R   t   itemt   blockt   timeoutt   endtimet	   remaining(    (    s   /usr/lib/python2.7/Queue.pyt   putk   s*    	c         C   s   |  j  | t É S(   s©   Put an item into the queue without blocking.

        Only enqueue the item if a free slot is immediately available.
        Otherwise raise the Full exception.
        (   R,   t   False(   R   R'   (    (    s   /usr/lib/python2.7/Queue.pyt
   put_nowaité   s    c         C   s˝   |  j  j É  z€ | s. |  j É  s  t Ç q  nú | d k r] xç |  j É  sY |  j  j É  q= Wnm | d k  rx t d É Ç nR t É  | } xB |  j É  s… | t É  } | d k r∂ t Ç n  |  j  j | É qà W|  j É  } |  j	 j
 É  | SWd |  j  j É  Xd S(   s  Remove and return an item from the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until an item is available. If 'timeout' is
        a non-negative number, it blocks at most 'timeout' seconds and raises
        the Empty exception if no item was available within that time.
        Otherwise ('block' is false), return an item if one is immediately
        available, else raise the Empty exception ('timeout' is ignored
        in that case).
        i    s'   'timeout' must be a non-negative numberg        N(   R   R   R   R   R#   R   R   R$   t   _getR   R&   R   (   R   R(   R)   R*   R+   R'   (    (    s   /usr/lib/python2.7/Queue.pyt   getñ   s(    	c         C   s   |  j  t É S(   s´   Remove and return an item from the queue without blocking.

        Only get an item if one is immediately available. Otherwise
        raise the Empty exception.
        (   R0   R-   (   R   (    (    s   /usr/lib/python2.7/Queue.pyt
   get_nowait∏   s    c         C   s   t  É  |  _ d  S(   N(   R   t   queue(   R   R
   (    (    s   /usr/lib/python2.7/Queue.pyR   ≈   s    c         C   s   | |  j  É S(   N(   R2   (   R   t   len(    (    s   /usr/lib/python2.7/Queue.pyR   »   s    c         C   s   |  j  j | É d  S(   N(   R2   t   append(   R   R'   (    (    s   /usr/lib/python2.7/Queue.pyR%   Ã   s    c         C   s   |  j  j É  S(   N(   R2   t   popleft(   R   (    (    s   /usr/lib/python2.7/Queue.pyR/   –   s    N(   R   R   R	   R   R   R   R    R!   R"   t   TrueR#   R,   R.   R0   R1   R   R3   R   R%   R/   (    (    (    s   /usr/lib/python2.7/Queue.pyR      s   					#	"			c           B   sA   e  Z d  Z d Ñ  Z e d Ñ Z e j d Ñ Z e j	 d Ñ Z
 RS(   sú   Variant of Queue that retrieves open entries in priority order (lowest first).

    Entries are typically tuples of the form:  (priority number, data).
    c         C   s   g  |  _  d  S(   N(   R2   (   R   R
   (    (    s   /usr/lib/python2.7/Queue.pyR   ⁄   s    c         C   s   | |  j  É S(   N(   R2   (   R   R3   (    (    s   /usr/lib/python2.7/Queue.pyR   ›   s    c         C   s   | |  j  | É d  S(   N(   R2   (   R   R'   t   heappush(    (    s   /usr/lib/python2.7/Queue.pyR%   ‡   s    c         C   s   | |  j  É S(   N(   R2   (   R   t   heappop(    (    s   /usr/lib/python2.7/Queue.pyR/   „   s    (   R   R   R	   R   R3   R   t   heapqR7   R%   R8   R/   (    (    (    s   /usr/lib/python2.7/Queue.pyR   ‘   s
   	c           B   s5   e  Z d  Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z RS(   sB   Variant of Queue that retrieves most recently added entries first.c         C   s   g  |  _  d  S(   N(   R2   (   R   R
   (    (    s   /usr/lib/python2.7/Queue.pyR   Í   s    c         C   s   | |  j  É S(   N(   R2   (   R   R3   (    (    s   /usr/lib/python2.7/Queue.pyR   Ì   s    c         C   s   |  j  j | É d  S(   N(   R2   R4   (   R   R'   (    (    s   /usr/lib/python2.7/Queue.pyR%      s    c         C   s   |  j  j É  S(   N(   R2   t   pop(   R   (    (    s   /usr/lib/python2.7/Queue.pyR/   Û   s    (   R   R   R	   R   R3   R   R%   R/   (    (    (    s   /usr/lib/python2.7/Queue.pyR   Á   s
   		(    (   R	   R    R$   t	   threadingR   t   ImportErrort   dummy_threadingt   collectionsR   R9   t   __all__t	   ExceptionR   R   R   R   R   (    (    (    s   /usr/lib/python2.7/Queue.pyt   <module>   s   ø                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """Simple HTTP Server.

This module builds on BaseHTTPServer by implementing the standard GET
and HEAD requests in a fairly straightforward manner.

"""


__version__ = "0.6"

__all__ = ["SimpleHTTPRequestHandler"]

import os
import posixpath
import BaseHTTPServer
import urllib
import urlparse
import cgi
import sys
import shutil
import mimetypes
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


class SimpleHTTPRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    """Simple HTTP request handler with GET and HEAD commands.

    This serves files from the current directory and any of its
    subdirectories.  The MIME type for files is determined by
    calling the .guess_type() method.

    The GET and HEAD requests are identical except that the HEAD
    request omits the actual contents of the file.

    """

    server_version = "SimpleHTTP/" + __version__

    def do_GET(self):
        """Serve a GET request."""
        f = self.send_head()
        if f:
            try:
                self.copyfile(f, self.wfile)
            finally:
                f.close()

    def do_HEAD(self):
        """Serve a HEAD request."""
        f = self.send_head()
        if f:
            f.close()

    def send_head(self):
        """Common code for GET and HEAD commands.

        This sends the response code and MIME headers.

        Return value is either a file object (which has to be copied
        to the outputfile by the caller unless the command was HEAD,
        and must be closed by the caller under all circumstances), or
        None, in which case the caller has nothing further to do.

        """
        path = self.translate_path(self.path)
        f = None
        if os.path.isdir(path):
            parts = urlparse.urlsplit(self.path)
            if not parts.path.endswith('/'):
                # redirect browser - doing basically what apache does
                self.send_response(301)
                new_parts = (parts[0], parts[1], parts[2] + '/',
                             parts[3], parts[4])
                new_url = urlparse.urlunsplit(new_parts)
                self.send_header("Location", new_url)
                self.end_headers()
                return None
            for index in "index.html", "index.htm":
                index = os.path.join(path, index)
                if os.path.exists(index):
                    path = index
                    break
            else:
                return self.list_directory(path)
        ctype = self.guess_type(path)
        try:
            # Always read in binary mode. Opening files in text mode may cause
            # newline translations, making the actual size of the content
            # transmitted *less* than the content-length!
            f = open(path, 'rb')
        except IOError:
            self.send_error(404, "File not found")
            return None
        try:
            self.send_response(200)
            self.send_header("Content-type", ctype)
            fs = os.fstat(f.fileno())
            self.send_header("Content-Length", str(fs[6]))
            self.send_header("Last-Modified", self.date_time_string(fs.st_mtime))
            self.end_headers()
            return f
        except:
            f.close()
            raise

    def list_directory(self, path):
        """Helper to produce a directory listing (absent index.html).

        Return value is either a file object, or None (indicating an
        error).  In either case, the headers are sent, making the
        interface the same as for send_head().

        """
        try:
            list = os.listdir(path)
        except os.error:
            self.send_error(404, "No permission to list directory")
            return None
        list.sort(key=lambda a: a.lower())
        f = StringIO()
        displaypath = cgi.escape(urllib.unquote(self.path))
        f.write('<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">')
        f.write("<html>\n<title>Directory listing for %s</title>\n" % displaypath)
        f.write("<body>\n<h2>Directory listing for %s</h2>\n" % displaypath)
        f.write("<hr>\n<ul>\n")
        for name in list:
            fullname = os.path.join(path, name)
            displayname = linkname = name
            # Append / for directories or @ for symbolic links
            if os.path.isdir(fullname):
                displayname = name + "/"
                linkname = name + "/"
            if os.path.islink(fullname):
                displayname = name + "@"
                # Note: a link to a directory displays with @ and links with /
            f.write('<li><a href="%s">%s</a>\n'
                    % (urllib.quote(linkname), cgi.escape(displayname)))
        f.write("</ul>\n<hr>\n</body>\n</html>\n")
        length = f.tell()
        f.seek(0)
        self.send_response(200)
        encoding = sys.getfilesystemencoding()
        self.send_header("Content-type", "text/html; charset=%s" % encoding)
        self.send_header("Content-Length", str(length))
        self.end_headers()
        return f

    def translate_path(self, path):
        """Translate a /-separated PATH to the local filename syntax.

        Components that mean special things to the local file system
        (e.g. drive or directory names) are ignored.  (XXX They should
        probably be diagnosed.)

        """
        # abandon query parameters
        path = path.split('?',1)[0]
        path = path.split('#',1)[0]
        # Don't forget explicit trailing slash when normalizing. Issue17324
        trailing_slash = path.rstrip().endswith('/')
        path = posixpath.normpath(urllib.unquote(path))
        words = path.split('/')
        words = filter(None, words)
        path = os.getcwd()
        for word in words:
            if os.path.dirname(word) or word in (os.curdir, os.pardir):
                # Ignore components that are not a simple file/directory name
                continue
            path = os.path.join(path, word)
        if trailing_slash:
            path += '/'
        return path

    def copyfile(self, source, outputfile):
        """Copy all data between two file objects.

        The SOURCE argument is a file object open for reading
        (or anything with a read() method) and the DESTINATION
        argument is a file object open for writing (or
        anything with a write() method).

        The only reason for overriding this would be to change
        the block size or perhaps to replace newlines by CRLF
        -- note however that this the default server uses this
        to copy binary data as well.

        """
        shutil.copyfileobj(source, outputfile)

    def guess_type(self, path):
        """Guess the type of a file.

        Argument is a PATH (a filename).

        Return value is a string of the form type/subtype,
        usable for a MIME Content-type header.

        The default implementation looks the file's extension
        up in the table self.extensions_map, using application/octet-stream
        as a default; however it would be permissible (if
        slow) to look inside the data to make a better guess.

        """

        base, ext = posixpath.splitext(path)
        if ext in self.extensions_map:
            return self.extensions_map[ext]
        ext = ext.lower()
        if ext in self.extensions_map:
            return self.extensions_map[ext]
        else:
            return self.extensions_map['']

    if not mimetypes.inited:
        mimetypes.init() # try to read system mime.types
    extensions_map = mimetypes.types_map.copy()
    extensions_map.update({
        '': 'application/octet-stream', # Default
        '.py': 'text/plain',
        '.c': 'text/plain',
        '.h': 'text/plain',
        })


def test(HandlerClass = SimpleHTTPRequestHandler,
         ServerClass = BaseHTTPServer.HTTPServer):
    BaseHTTPServer.test(HandlerClass, ServerClass)


if __name__ == '__main__':
    test()
                                                                                                                                                                                                   Û
”´[c           @   s˛   d  Z  d Z d g Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z y d d l m Z Wn! e k
 r∏ d d l m Z n Xd e j f d Ñ  É  YZ e e j d Ñ Z e d k r˙ e É  n  d S(	   sí   Simple HTTP Server.

This module builds on BaseHTTPServer by implementing the standard GET
and HEAD requests in a fairly straightforward manner.

s   0.6t   SimpleHTTPRequestHandleriˇˇˇˇN(   t   StringIOc           B   s•   e  Z d  Z d e Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z e j sk e j É  n  e j j É  Z e j i d	 d
 6d d 6d d 6d d 6É RS(   sW  Simple HTTP request handler with GET and HEAD commands.

    This serves files from the current directory and any of its
    subdirectories.  The MIME type for files is determined by
    calling the .guess_type() method.

    The GET and HEAD requests are identical except that the HEAD
    request omits the actual contents of the file.

    s   SimpleHTTP/c         C   s>   |  j  É  } | r: z |  j | |  j É Wd | j É  Xn  d S(   s   Serve a GET request.N(   t	   send_headt   copyfilet   wfilet   close(   t   selft   f(    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyt   do_GET+   s
    c         C   s#   |  j  É  } | r | j É  n  d S(   s   Serve a HEAD request.N(   R   R   (   R   R   (    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyt   do_HEAD4   s    c   	      C   s„  |  j  |  j É } d } t j j | É rt j |  j É } | j j d É sµ |  j d É | d | d | d d | d | d f } t j	 | É } |  j
 d | É |  j É  d SxO d D]7 } t j j | | É } t j j | É rº | } Pqº qº W|  j | É Sn  |  j | É } y t | d É } Wn" t k
 rM|  j d d É d SXyz |  j d É |  j
 d | É t j | j É  É } |  j
 d t | d É É |  j
 d |  j | j É É |  j É  | SWn | j É  Ç  n Xd S(   s{  Common code for GET and HEAD commands.

        This sends the response code and MIME headers.

        Return value is either a file object (which has to be copied
        to the outputfile by the caller unless the command was HEAD,
        and must be closed by the caller under all circumstances), or
        None, in which case the caller has nothing further to do.

        t   /i-  i    i   i   i   i   t   Locations
   index.htmls	   index.htmt   rbiî  s   File not foundi»   s   Content-types   Content-Lengthi   s   Last-ModifiedN(   s
   index.htmls	   index.htm(   t   translate_patht   patht   Nonet   ost   isdirt   urlparset   urlsplitt   endswitht   send_responset
   urlunsplitt   send_headert   end_headerst   joint   existst   list_directoryt
   guess_typet   opent   IOErrort
   send_errort   fstatt   filenot   strt   date_time_stringt   st_mtimeR   (	   R   R   R   t   partst	   new_partst   new_urlt   indext   ctypet   fs(    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyR   :   sF    


c         C   s∆  y t  j | É } Wn% t  j k
 r: |  j d d É d SX| j d d Ñ  É t É  } t j t	 j
 |  j É É } | j d É | j d | É | j d | É | j d É xû | D]ñ } t  j j | | É } | } } t  j j | É r| d	 } | d	 } n  t  j j | É r"| d
 } n  | j d t	 j | É t j | É f É qµ W| j d É | j É  }	 | j d É |  j d É t j É  }
 |  j d d |
 É |  j d t |	 É É |  j É  | S(   s˚   Helper to produce a directory listing (absent index.html).

        Return value is either a file object, or None (indicating an
        error).  In either case, the headers are sent, making the
        interface the same as for send_head().

        iî  s   No permission to list directoryt   keyc         S   s
   |  j  É  S(   N(   t   lower(   t   a(    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyt   <lambda>{   s    s7   <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">s/   <html>
<title>Directory listing for %s</title>
s)   <body>
<h2>Directory listing for %s</h2>
s
   <hr>
<ul>
R
   t   @s   <li><a href="%s">%s</a>
s   </ul>
<hr>
</body>
</html>
i    i»   s   Content-types   text/html; charset=%ss   Content-LengthN(   R   t   listdirt   errorR   R   t   sortR   t   cgit   escapet   urllibt   unquoteR   t   writeR   R   t   islinkt   quotet   tellt   seekR   t   syst   getfilesystemencodingR   R"   R   (   R   R   t   listR   t   displaypatht   namet   fullnamet   displaynamet   linknamet   lengtht   encoding(    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyR   n   s>    	

	$
c         C   s   | j  d d É d } | j  d d É d } | j É  j d É } t j t j | É É } | j  d É } t d | É } t	 j
 É  } xS | D]K } t	 j j | É sä | t	 j t	 j f k r¿ qä n  t	 j j | | É } qä W| rÏ | d 7} n  | S(   sÒ   Translate a /-separated PATH to the local filename syntax.

        Components that mean special things to the local file system
        (e.g. drive or directory names) are ignored.  (XXX They should
        probably be diagnosed.)

        t   ?i   i    t   #R
   N(   t   splitt   rstripR   t	   posixpatht   normpathR5   R6   t   filterR   R   t   getcwdR   t   dirnamet   curdirt   pardirR   (   R   R   t   trailing_slasht   wordst   word(    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyR   ò   s    	*c         C   s   t  j | | É d S(   sÒ  Copy all data between two file objects.

        The SOURCE argument is a file object open for reading
        (or anything with a read() method) and the DESTINATION
        argument is a file object open for writing (or
        anything with a write() method).

        The only reason for overriding this would be to change
        the block size or perhaps to replace newlines by CRLF
        -- note however that this the default server uses this
        to copy binary data as well.

        N(   t   shutilt   copyfileobj(   R   t   sourcet
   outputfile(    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyR   ≤   s    c         C   sd   t  j | É \ } } | |  j k r/ |  j | S| j É  } | |  j k rU |  j | S|  j d Sd S(   sª  Guess the type of a file.

        Argument is a PATH (a filename).

        Return value is a string of the form type/subtype,
        usable for a MIME Content-type header.

        The default implementation looks the file's extension
        up in the table self.extensions_map, using application/octet-stream
        as a default; however it would be permissible (if
        slow) to look inside the data to make a better guess.

        t    N(   RJ   t   splitextt   extensions_mapR,   (   R   R   t   baset   ext(    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyR   ¬   s    s   application/octet-streamRX   s
   text/plains   .pys   .cs   .h(   t   __name__t
   __module__t   __doc__t   __version__t   server_versionR   R	   R   R   R   R   R   t	   mimetypest   initedt   initt	   types_mapt   copyRZ   t   update(    (    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyR       s"   
				4	*					c         C   s   t  j |  | É d  S(   N(   t   BaseHTTPServert   test(   t   HandlerClasst   ServerClass(    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyRi   Â   s    t   __main__(   R_   R`   t   __all__R   RJ   Rh   R5   R   R3   R<   RT   Rb   t	   cStringIOR   t   ImportErrort   BaseHTTPRequestHandlerR    t
   HTTPServerRi   R]   (    (    (    s&   /usr/lib/python2.7/SimpleHTTPServer.pyt   <module>   s(   	…                                                                                                                                                                                                            r"""Simple XML-RPC Server.

This module can be used to create simple XML-RPC servers
by creating a server and either installing functions, a
class instance, or by extending the SimpleXMLRPCServer
class.

It can also be used to handle XML-RPC requests in a CGI
environment using CGIXMLRPCRequestHandler.

A list of possible usage patterns follows:

1. Install functions:

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_function(pow)
server.register_function(lambda x,y: x+y, 'add')
server.serve_forever()

2. Install an instance:

class MyFuncs:
    def __init__(self):
        # make all of the string functions available through
        # string.func_name
        import string
        self.string = string
    def _listMethods(self):
        # implement this method so that system.listMethods
        # knows to advertise the strings methods
        return list_public_methods(self) + \
                ['string.' + method for method in list_public_methods(self.string)]
    def pow(self, x, y): return pow(x, y)
    def add(self, x, y) : return x + y

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_introspection_functions()
server.register_instance(MyFuncs())
server.serve_forever()

3. Install an instance with custom dispatch method:

class Math:
    def _listMethods(self):
        # this method must be present for system.listMethods
        # to work
        return ['add', 'pow']
    def _methodHelp(self, method):
        # this method must be present for system.methodHelp
        # to work
        if method == 'add':
            return "add(2,3) => 5"
        elif method == 'pow':
            return "pow(x, y[, z]) => number"
        else:
            # By convention, return empty
            # string if no help is available
            return ""
    def _dispatch(self, method, params):
        if method == 'pow':
            return pow(*params)
        elif method == 'add':
            return params[0] + params[1]
        else:
            raise 'bad method'

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_introspection_functions()
server.register_instance(Math())
server.serve_forever()

4. Subclass SimpleXMLRPCServer:

class MathServer(SimpleXMLRPCServer):
    def _dispatch(self, method, params):
        try:
            # We are forcing the 'export_' prefix on methods that are
            # callable through XML-RPC to prevent potential security
            # problems
            func = getattr(self, 'export_' + method)
        except AttributeError:
            raise Exception('method "%s" is not supported' % method)
        else:
            return func(*params)

    def export_add(self, x, y):
        return x + y

server = MathServer(("localhost", 8000))
server.serve_forever()

5. CGI script:

server = CGIXMLRPCRequestHandler()
server.register_function(pow)
server.handle_request()
"""

# Written by Brian Quinlan (brian@sweetapp.com).
# Based on code written by Fredrik Lundh.

import xmlrpclib
from xmlrpclib import Fault
import SocketServer
import BaseHTTPServer
import sys
import os
import traceback
import re
try:
    import fcntl
except ImportError:
    fcntl = None

def resolve_dotted_attribute(obj, attr, allow_dotted_names=True):
    """resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d

    Resolves a dotted attribute name to an object.  Raises
    an AttributeError if any attribute in the chain starts with a '_'.

    If the optional allow_dotted_names argument is false, dots are not
    supported and this function operates similar to getattr(obj, attr).
    """

    if allow_dotted_names:
        attrs = attr.split('.')
    else:
        attrs = [attr]

    for i in attrs:
        if i.startswith('_'):
            raise AttributeError(
                'attempt to access private attribute "%s"' % i
                )
        else:
            obj = getattr(obj,i)
    return obj

def list_public_methods(obj):
    """Returns a list of attribute strings, found in the specified
    object, which represent callable attributes"""

    return [member for member in dir(obj)
                if not member.startswith('_') and
                    hasattr(getattr(obj, member), '__call__')]

def remove_duplicates(lst):
    """remove_duplicates([2,2,2,1,3,3]) => [3,1,2]

    Returns a copy of a list without duplicates. Every list
    item must be hashable and the order of the items in the
    resulting list is not defined.
    """
    u = {}
    for x in lst:
        u[x] = 1

    return u.keys()

class SimpleXMLRPCDispatcher:
    """Mix-in class that dispatches XML-RPC requests.

    This class is used to register XML-RPC method handlers
    and then to dispatch them. This class doesn't need to be
    instanced directly when used by SimpleXMLRPCServer but it
    can be instanced when used by the MultiPathXMLRPCServer.
    """

    def __init__(self, allow_none=False, encoding=None):
        self.funcs = {}
        self.instance = None
        self.allow_none = allow_none
        self.encoding = encoding

    def register_instance(self, instance, allow_dotted_names=False):
        """Registers an instance to respond to XML-RPC requests.

        Only one instance can be installed at a time.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called. Methods beginning with an '_'
        are considered private and will not be called by
        SimpleXMLRPCServer.

        If a registered function matches an XML-RPC request, then it
        will be called instead of the registered instance.

        If the optional allow_dotted_names argument is true and the
        instance does not have a _dispatch method, method names
        containing dots are supported and resolved, as long as none of
        the name segments start with an '_'.

            *** SECURITY WARNING: ***

            Enabling the allow_dotted_names options allows intruders
            to access your module's global variables and may allow
            intruders to execute arbitrary code on your machine.  Only
            use this option on a secure, closed network.

        """

        self.instance = instance
        self.allow_dotted_names = allow_dotted_names

    def register_function(self, function, name = None):
        """Registers a function to respond to XML-RPC requests.

        The optional name argument can be used to set a Unicode name
        for the function.
        """

        if name is None:
            name = function.__name__
        self.funcs[name] = function

    def register_introspection_functions(self):
        """Registers the XML-RPC introspection methods in the system
        namespace.

        see http://xmlrpc.usefulinc.com/doc/reserved.html
        """

        self.funcs.update({'system.listMethods' : self.system_listMethods,
                      'system.methodSignature' : self.system_methodSignature,
                      'system.methodHelp' : self.system_methodHelp})

    def register_multicall_functions(self):
        """Registers the XML-RPC multicall method in the system
        namespace.

        see http://www.xmlrpc.com/discuss/msgReader$1208"""

        self.funcs.update({'system.multicall' : self.system_multicall})

    def _marshaled_dispatch(self, data, dispatch_method = None, path = None):
        """Dispatches an XML-RPC method from marshalled (XML) data.

        XML-RPC methods are dispatched from the marshalled (XML) data
        using the _dispatch method and the result is returned as
        marshalled data. For backwards compatibility, a dispatch
        function can be provided as an argument (see comment in
        SimpleXMLRPCRequestHandler.do_POST) but overriding the
        existing method through subclassing is the preferred means
        of changing method dispatch behavior.
        """

        try:
            params, method = xmlrpclib.loads(data)

            # generate response
            if dispatch_method is not None:
                response = dispatch_method(method, params)
            else:
                response = self._dispatch(method, params)
            # wrap response in a singleton tuple
            response = (response,)
            response = xmlrpclib.dumps(response, methodresponse=1,
                                       allow_none=self.allow_none, encoding=self.encoding)
        except Fault, fault:
            response = xmlrpclib.dumps(fault, allow_none=self.allow_none,
                                       encoding=self.encoding)
        except:
            # report exception back to server
            exc_type, exc_value, exc_tb = sys.exc_info()
            response = xmlrpclib.dumps(
                xmlrpclib.Fault(1, "%s:%s" % (exc_type, exc_value)),
                encoding=self.encoding, allow_none=self.allow_none,
                )

        return response

    def system_listMethods(self):
        """system.listMethods() => ['add', 'subtract', 'multiple']

        Returns a list of the methods supported by the server."""

        methods = self.funcs.keys()
        if self.instance is not None:
            # Instance can implement _listMethod to return a list of
            # methods
            if hasattr(self.instance, '_listMethods'):
                methods = remove_duplicates(
                        methods + self.instance._listMethods()
                    )
            # if the instance has a _dispatch method then we
            # don't have enough information to provide a list
            # of methods
            elif not hasattr(self.instance, '_dispatch'):
                methods = remove_duplicates(
                        methods + list_public_methods(self.instance)
                    )
        methods.sort()
        return methods

    def system_methodSignature(self, method_name):
        """system.methodSignature('add') => [double, int, int]

        Returns a list describing the signature of the method. In the
        above example, the add method takes two integers as arguments
        and returns a double result.

        This server does NOT support system.methodSignature."""

        # See http://xmlrpc.usefulinc.com/doc/sysmethodsig.html

        return 'signatures not supported'

    def system_methodHelp(self, method_name):
        """system.methodHelp('add') => "Adds two integers together"

        Returns a string containing documentation for the specified method."""

        method = None
        if method_name in self.funcs:
            method = self.funcs[method_name]
        elif self.instance is not None:
            # Instance can implement _methodHelp to return help for a method
            if hasattr(self.instance, '_methodHelp'):
                return self.instance._methodHelp(method_name)
            # if the instance has a _dispatch method then we
            # don't have enough information to provide help
            elif not hasattr(self.instance, '_dispatch'):
                try:
                    method = resolve_dotted_attribute(
                                self.instance,
                                method_name,
                                self.allow_dotted_names
                                )
                except AttributeError:
                    pass

        # Note that we aren't checking that the method actually
        # be a callable object of some kind
        if method is None:
            return ""
        else:
            import pydoc
            return pydoc.getdoc(method)

    def system_multicall(self, call_list):
        """system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => \
[[4], ...]

        Allows the caller to package multiple XML-RPC calls into a single
        request.

        See http://www.xmlrpc.com/discuss/msgReader$1208
        """

        results = []
        for call in call_list:
            method_name = call['methodName']
            params = call['params']

            try:
                # XXX A marshalling error in any response will fail the entire
                # multicall. If someone cares they should fix this.
                results.append([self._dispatch(method_name, params)])
            except Fault, fault:
                results.append(
                    {'faultCode' : fault.faultCode,
                     'faultString' : fault.faultString}
                    )
            except:
                exc_type, exc_value, exc_tb = sys.exc_info()
                results.append(
                    {'faultCode' : 1,
                     'faultString' : "%s:%s" % (exc_type, exc_value)}
                    )
        return results

    def _dispatch(self, method, params):
        """Dispatches the XML-RPC method.

        XML-RPC calls are forwarded to a registered function that
        matches the called XML-RPC method name. If no such function
        exists then the call is forwarded to the registered instance,
        if available.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called.

        Methods beginning with an '_' are considered private and will
        not be called.
        """

        func = None
        try:
            # check to see if a matching function has been registered
            func = self.funcs[method]
        except KeyError:
            if self.instance is not None:
                # check for a _dispatch method
                if hasattr(self.instance, '_dispatch'):
                    return self.instance._dispatch(method, params)
                else:
                    # call instance method directly
                    try:
                        func = resolve_dotted_attribute(
                            self.instance,
                            method,
                            self.allow_dotted_names
                            )
                    except AttributeError:
                        pass

        if func is not None:
            return func(*params)
        else:
            raise Exception('method "%s" is not supported' % method)

class SimpleXMLRPCRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    """Simple XML-RPC request handler class.

    Handles all HTTP POST requests and attempts to decode them as
    XML-RPC requests.
    """

    # Class attribute listing the accessible path components;
    # paths not on this list will result in a 404 error.
    rpc_paths = ('/', '/RPC2')

    #if not None, encode responses larger than this, if possible
    encode_threshold = 1400 #a common MTU

    #Override form StreamRequestHandler: full buffering of output
    #and no Nagle.
    wbufsize = -1
    disable_nagle_algorithm = True

    # a re to match a gzip Accept-Encoding
    aepattern = re.compile(r"""
                            \s* ([^\s;]+) \s*            #content-coding
                            (;\s* q \s*=\s* ([0-9\.]+))? #q
                            """, re.VERBOSE | re.IGNORECASE)

    def accept_encodings(self):
        r = {}
        ae = self.headers.get("Accept-Encoding", "")
        for e in ae.split(","):
            match = self.aepattern.match(e)
            if match:
                v = match.group(3)
                v = float(v) if v else 1.0
                r[match.group(1)] = v
        return r

    def is_rpc_path_valid(self):
        if self.rpc_paths:
            return self.path in self.rpc_paths
        else:
            # If .rpc_paths is empty, just assume all paths are legal
            return True

    def do_POST(self):
        """Handles the HTTP POST request.

        Attempts to interpret all HTTP POST requests as XML-RPC calls,
        which are forwarded to the server's _dispatch method for handling.
        """

        # Check that the path is legal
        if not self.is_rpc_path_valid():
            self.report_404()
            return

        try:
            # Get arguments by reading body of request.
            # We read this in chunks to avoid straining
            # socket.read(); around the 10 or 15Mb mark, some platforms
            # begin to have problems (bug #792570).
            max_chunk_size = 10*1024*1024
            size_remaining = int(self.headers["content-length"])
            L = []
            while size_remaining:
                chunk_size = min(size_remaining, max_chunk_size)
                chunk = self.rfile.read(chunk_size)
                if not chunk:
                    break
                L.append(chunk)
                size_remaining -= len(L[-1])
            data = ''.join(L)

            data = self.decode_request_content(data)
            if data is None:
                return #response has been sent

            # In previous versions of SimpleXMLRPCServer, _dispatch
            # could be overridden in this class, instead of in
            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,
            # check to see if a subclass implements _dispatch and dispatch
            # using that method if present.
            response = self.server._marshaled_dispatch(
                    data, getattr(self, '_dispatch', None), self.path
                )
        except Exception, e: # This should only happen if the module is buggy
            # internal error, report as HTTP server error
            self.send_response(500)

            # Send information about the exception if requested
            if hasattr(self.server, '_send_traceback_header') and \
                    self.server._send_traceback_header:
                self.send_header("X-exception", str(e))
                self.send_header("X-traceback", traceback.format_exc())

            self.send_header("Content-length", "0")
            self.end_headers()
        else:
            # got a valid XML RPC response
            self.send_response(200)
            self.send_header("Content-type", "text/xml")
            if self.encode_threshold is not None:
                if len(response) > self.encode_threshold:
                    q = self.accept_encodings().get("gzip", 0)
                    if q:
                        try:
                            response = xmlrpclib.gzip_encode(response)
                            self.send_header("Content-Encoding", "gzip")
                        except NotImplementedError:
                            pass
            self.send_header("Content-length", str(len(response)))
            self.end_headers()
            self.wfile.write(response)

    def decode_request_content(self, data):
        #support gzip encoding of request
        encoding = self.headers.get("content-encoding", "identity").lower()
        if encoding == "identity":
            return data
        if encoding == "gzip":
            try:
                return xmlrpclib.gzip_decode(data)
            except NotImplementedError:
                self.send_response(501, "encoding %r not supported" % encoding)
            except ValueError:
                self.send_response(400, "error decoding gzip content")
        else:
            self.send_response(501, "encoding %r not supported" % encoding)
        self.send_header("Content-length", "0")
        self.end_headers()

    def report_404 (self):
            # Report a 404 error
        self.send_response(404)
        response = 'No such page'
        self.send_header("Content-type", "text/plain")
        self.send_header("Content-length", str(len(response)))
        self.end_headers()
        self.wfile.write(response)

    def log_request(self, code='-', size='-'):
        """Selectively log an accepted request."""

        if self.server.logRequests:
            BaseHTTPServer.BaseHTTPRequestHandler.log_request(self, code, size)

class SimpleXMLRPCServer(SocketServer.TCPServer,
                         SimpleXMLRPCDispatcher):
    """Simple XML-RPC server.

    Simple XML-RPC server that allows functions and a single instance
    to be installed to handle requests. The default implementation
    attempts to dispatch XML-RPC calls to the functions or instance
    installed in the server. Override the _dispatch method inhereted
    from SimpleXMLRPCDispatcher to change this behavior.
    """

    allow_reuse_address = True

    # Warning: this is for debugging purposes only! Never set this to True in
    # production code, as will be sending out sensitive information (exception
    # and stack trace details) when exceptions are raised inside
    # SimpleXMLRPCRequestHandler.do_POST
    _send_traceback_header = False

    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None, bind_and_activate=True):
        self.logRequests = logRequests

        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)
        SocketServer.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)

        # [Bug #1222790] If possible, set close-on-exec flag; if a
        # method spawns a subprocess, the subprocess shouldn't have
        # the listening socket open.
        if fcntl is not None and hasattr(fcntl, 'FD_CLOEXEC'):
            flags = fcntl.fcntl(self.fileno(), fcntl.F_GETFD)
            flags |= fcntl.FD_CLOEXEC
            fcntl.fcntl(self.fileno(), fcntl.F_SETFD, flags)

class MultiPathXMLRPCServer(SimpleXMLRPCServer):
    """Multipath XML-RPC Server
    This specialization of SimpleXMLRPCServer allows the user to create
    multiple Dispatcher instances and assign them to different
    HTTP request paths.  This makes it possible to run two or more
    'virtual XML-RPC servers' at the same port.
    Make sure that the requestHandler accepts the paths in question.
    """
    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None, bind_and_activate=True):

        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests, allow_none,
                                    encoding, bind_and_activate)
        self.dispatchers = {}
        self.allow_none = allow_none
        self.encoding = encoding

    def add_dispatcher(self, path, dispatcher):
        self.dispatchers[path] = dispatcher
        return dispatcher

    def get_dispatcher(self, path):
        return self.dispatchers[path]

    def _marshaled_dispatch(self, data, dispatch_method = None, path = None):
        try:
            response = self.dispatchers[path]._marshaled_dispatch(
               data, dispatch_method, path)
        except:
            # report low level exception back to server
            # (each dispatcher should have handled their own
            # exceptions)
            exc_type, exc_value = sys.exc_info()[:2]
            response = xmlrpclib.dumps(
                xmlrpclib.Fault(1, "%s:%s" % (exc_type, exc_value)),
                encoding=self.encoding, allow_none=self.allow_none)
        return response

class CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher):
    """Simple handler for XML-RPC data passed through CGI."""

    def __init__(self, allow_none=False, encoding=None):
        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)

    def handle_xmlrpc(self, request_text):
        """Handle a single XML-RPC request"""

        response = self._marshaled_dispatch(request_text)

        print 'Content-Type: text/xml'
        print 'Content-Length: %d' % len(response)
        print
        sys.stdout.write(response)

    def handle_get(self):
        """Handle a single HTTP GET request.

        Default implementation indicates an error because
        XML-RPC uses the POST method.
        """

        code = 400
        message, explain = \
                 BaseHTTPServer.BaseHTTPRequestHandler.responses[code]

        response = BaseHTTPServer.DEFAULT_ERROR_MESSAGE % \
            {
             'code' : code,
             'message' : message,
             'explain' : explain
            }
        print 'Status: %d %s' % (code, message)
        print 'Content-Type: %s' % BaseHTTPServer.DEFAULT_ERROR_CONTENT_TYPE
        print 'Content-Length: %d' % len(response)
        print
        sys.stdout.write(response)

    def handle_request(self, request_text = None):
        """Handle a single XML-RPC request passed through a CGI post method.

        If no XML data is given then it is read from stdin. The resulting
        XML-RPC response is printed to stdout along with the correct HTTP
        headers.
        """

        if request_text is None and \
            os.environ.get('REQUEST_METHOD', None) == 'GET':
            self.handle_get()
        else:
            # POST data is normally available through stdin
            try:
                length = int(os.environ.get('CONTENT_LENGTH', None))
            except (TypeError, ValueError):
                length = -1
            if request_text is None:
                request_text = sys.stdin.read(length)

            self.handle_xmlrpc(request_text)

if __name__ == '__main__':
    print 'Running XML-RPC server on port 8000'
    server = SimpleXMLRPCServer(("localhost", 8000))
    server.register_function(pow)
    server.register_function(lambda x,y: x+y, 'add')
    server.register_multicall_functions()
    server.serve_forever()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   sÑ  d  Z  d d l Z d d l m Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z y d d l	 Z	 Wn e
 k
 rì e Z	 n Xe d Ñ Z d Ñ  Z d Ñ  Z d f  d Ñ  É  YZ d	 e j f d
 Ñ  É  YZ d e j e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ e d k rÄd GHe d d f É Z e j e É e j d Ñ  d É e j É  e j É  n  d S(   s;  Simple XML-RPC Server.

This module can be used to create simple XML-RPC servers
by creating a server and either installing functions, a
class instance, or by extending the SimpleXMLRPCServer
class.

It can also be used to handle XML-RPC requests in a CGI
environment using CGIXMLRPCRequestHandler.

A list of possible usage patterns follows:

1. Install functions:

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_function(pow)
server.register_function(lambda x,y: x+y, 'add')
server.serve_forever()

2. Install an instance:

class MyFuncs:
    def __init__(self):
        # make all of the string functions available through
        # string.func_name
        import string
        self.string = string
    def _listMethods(self):
        # implement this method so that system.listMethods
        # knows to advertise the strings methods
        return list_public_methods(self) + \
                ['string.' + method for method in list_public_methods(self.string)]
    def pow(self, x, y): return pow(x, y)
    def add(self, x, y) : return x + y

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_introspection_functions()
server.register_instance(MyFuncs())
server.serve_forever()

3. Install an instance with custom dispatch method:

class Math:
    def _listMethods(self):
        # this method must be present for system.listMethods
        # to work
        return ['add', 'pow']
    def _methodHelp(self, method):
        # this method must be present for system.methodHelp
        # to work
        if method == 'add':
            return "add(2,3) => 5"
        elif method == 'pow':
            return "pow(x, y[, z]) => number"
        else:
            # By convention, return empty
            # string if no help is available
            return ""
    def _dispatch(self, method, params):
        if method == 'pow':
            return pow(*params)
        elif method == 'add':
            return params[0] + params[1]
        else:
            raise 'bad method'

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_introspection_functions()
server.register_instance(Math())
server.serve_forever()

4. Subclass SimpleXMLRPCServer:

class MathServer(SimpleXMLRPCServer):
    def _dispatch(self, method, params):
        try:
            # We are forcing the 'export_' prefix on methods that are
            # callable through XML-RPC to prevent potential security
            # problems
            func = getattr(self, 'export_' + method)
        except AttributeError:
            raise Exception('method "%s" is not supported' % method)
        else:
            return func(*params)

    def export_add(self, x, y):
        return x + y

server = MathServer(("localhost", 8000))
server.serve_forever()

5. CGI script:

server = CGIXMLRPCRequestHandler()
server.register_function(pow)
server.handle_request()
iˇˇˇˇN(   t   Faultc         C   sg   | r | j  d É } n	 | g } x? | D]7 } | j d É rP t d | É Ç q( t |  | É }  q( W|  S(   sG  resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d

    Resolves a dotted attribute name to an object.  Raises
    an AttributeError if any attribute in the chain starts with a '_'.

    If the optional allow_dotted_names argument is false, dots are not
    supported and this function operates similar to getattr(obj, attr).
    t   .t   _s(   attempt to access private attribute "%s"(   t   splitt
   startswitht   AttributeErrort   getattr(   t   objt   attrt   allow_dotted_namest   attrst   i(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   resolve_dotted_attributes   s    
	c         C   sE   g  t  |  É D]4 } | j d É r t t |  | É d É r | ^ q S(   sk   Returns a list of attribute strings, found in the specified
    object, which represent callable attributesR   t   __call__(   t   dirR   t   hasattrR   (   R   t   member(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   list_public_methodsã   s    c         C   s+   i  } x |  D] } d | | <q W| j  É  S(   sÃ   remove_duplicates([2,2,2,1,3,3]) => [3,1,2]

    Returns a copy of a list without duplicates. Every list
    item must be hashable and the order of the items in the
    resulting list is not defined.
    i   (   t   keys(   t   lstt   ut   x(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   remove_duplicatesì   s    t   SimpleXMLRPCDispatcherc           B   sÉ   e  Z d  Z e d d Ñ Z e d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z	 d d d Ñ Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z RS(   s'  Mix-in class that dispatches XML-RPC requests.

    This class is used to register XML-RPC method handlers
    and then to dispatch them. This class doesn't need to be
    instanced directly when used by SimpleXMLRPCServer but it
    can be instanced when used by the MultiPathXMLRPCServer.
    c         C   s(   i  |  _  d  |  _ | |  _ | |  _ d  S(   N(   t   funcst   Nonet   instancet
   allow_nonet   encoding(   t   selfR   R   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   __init__©   s    			c         C   s   | |  _  | |  _ d S(   s  Registers an instance to respond to XML-RPC requests.

        Only one instance can be installed at a time.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called. Methods beginning with an '_'
        are considered private and will not be called by
        SimpleXMLRPCServer.

        If a registered function matches an XML-RPC request, then it
        will be called instead of the registered instance.

        If the optional allow_dotted_names argument is true and the
        instance does not have a _dispatch method, method names
        containing dots are supported and resolved, as long as none of
        the name segments start with an '_'.

            *** SECURITY WARNING: ***

            Enabling the allow_dotted_names options allows intruders
            to access your module's global variables and may allow
            intruders to execute arbitrary code on your machine.  Only
            use this option on a secure, closed network.

        N(   R   R	   (   R   R   R	   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   register_instanceØ   s    !	c         C   s)   | d k r | j } n  | |  j | <d S(   sù   Registers a function to respond to XML-RPC requests.

        The optional name argument can be used to set a Unicode name
        for the function.
        N(   R   t   __name__R   (   R   t   functiont   name(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   register_function”   s    c         C   s2   |  j  j i |  j d 6|  j d 6|  j d 6É d S(   sê   Registers the XML-RPC introspection methods in the system
        namespace.

        see http://xmlrpc.usefulinc.com/doc/reserved.html
        s   system.listMethodss   system.methodSignatures   system.methodHelpN(   R   t   updatet   system_listMethodst   system_methodSignaturet   system_methodHelp(   R   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt    register_introspection_functionsﬁ   s    
c         C   s   |  j  j i |  j d 6É d S(   sÅ   Registers the XML-RPC multicall method in the system
        namespace.

        see http://www.xmlrpc.com/discuss/msgReader$1208s   system.multicallN(   R   R$   t   system_multicall(   R   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   register_multicall_functionsÈ   s    c         C   s  yy t  j | É \ } } | d k	 r6 | | | É } n |  j | | É } | f } t  j | d d d |  j d |  j É} WnÜ t k
 rØ } t  j | d |  j d |  j É} nS t j	 É  \ } }	 }
 t  j t  j d d | |	 f É d |  j d |  j É} n X| S(   s˙  Dispatches an XML-RPC method from marshalled (XML) data.

        XML-RPC methods are dispatched from the marshalled (XML) data
        using the _dispatch method and the result is returned as
        marshalled data. For backwards compatibility, a dispatch
        function can be provided as an argument (see comment in
        SimpleXMLRPCRequestHandler.do_POST) but overriding the
        existing method through subclassing is the preferred means
        of changing method dispatch behavior.
        t   methodresponsei   R   R   s   %s:%sN(
   t	   xmlrpclibt   loadsR   t	   _dispatcht   dumpsR   R   R    t   syst   exc_info(   R   t   datat   dispatch_methodt   patht   paramst   methodt   responset   faultt   exc_typet	   exc_valuet   exc_tb(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   _marshaled_dispatchÒ   s"    	c         C   sã   |  j  j É  } |  j d k	 r} t |  j d É rL t | |  j j É  É } q} t |  j d É s} t | t |  j É É } q} n  | j É  | S(   sw   system.listMethods() => ['add', 'subtract', 'multiple']

        Returns a list of the methods supported by the server.t   _listMethodsR.   N(	   R   R   R   R   R   R   R=   R   t   sort(   R   t   methods(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR%     s    
c         C   s   d S(   s#  system.methodSignature('add') => [double, int, int]

        Returns a list describing the signature of the method. In the
        above example, the add method takes two integers as arguments
        and returns a double result.

        This server does NOT support system.methodSignature.s   signatures not supported(    (   R   t   method_name(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR&   -  s    c         C   sÀ   d } | |  j k r% |  j | } ny |  j d k	 rû t |  j d É rV |  j j | É St |  j d É sû y t |  j | |  j É } Wqõ t k
 ró qõ Xqû n  | d k rÆ d Sd d l } | j	 | É Sd S(   sÖ   system.methodHelp('add') => "Adds two integers together"

        Returns a string containing documentation for the specified method.t   _methodHelpR.   t    iˇˇˇˇN(
   R   R   R   R   RA   R   R	   R   t   pydoct   getdoc(   R   R@   R6   RC   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR'   :  s$    
c   
      C   s∆   g  } xπ | D]± } | d } | d } y  | j  |  j | | É g É Wq t k
 r} } | j  i | j d 6| j d 6É q t j É  \ } } }	 | j  i d d 6d | | f d 6É q Xq W| S(   sÌ   system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => [[4], ...]

        Allows the caller to package multiple XML-RPC calls into a single
        request.

        See http://www.xmlrpc.com/discuss/msgReader$1208
        t
   methodNameR5   t	   faultCodet   faultStringi   s   %s:%s(   t   appendR.   R    RF   RG   R0   R1   (
   R   t	   call_listt   resultst   callR@   R5   R8   R9   R:   R;   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR)   Z  s     


 
c         C   sº   d } y |  j | } Wnx t k
 rë |  j d k	 rí t |  j d É r[ |  j j | | É Sy t |  j | |  j É } Wqé t k
 rä qé Xqí n X| d k	 r® | | å  St	 d | É Ç d S(   sÛ  Dispatches the XML-RPC method.

        XML-RPC calls are forwarded to a registered function that
        matches the called XML-RPC method name. If no such function
        exists then the call is forwarded to the registered instance,
        if available.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called.

        Methods beginning with an '_' are considered private and will
        not be called.
        R.   s   method "%s" is not supportedN(
   R   R   t   KeyErrorR   R   R.   R   R	   R   t	   Exception(   R   R6   R5   t   func(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR.   z  s"    
N(   R    t
   __module__t   __doc__t   FalseR   R   R   R#   R(   R*   R<   R%   R&   R'   R)   R.   (    (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR   †   s   $		%			 	 t   SimpleXMLRPCRequestHandlerc           B   s~   e  Z d  Z d Z d Z d Z e Z e j	 d e j
 e j BÉ Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d d d Ñ Z RS(   sÉ   Simple XML-RPC request handler class.

    Handles all HTTP POST requests and attempts to decode them as
    XML-RPC requests.
    t   /s   /RPC2ix  iˇˇˇˇs¢   
                            \s* ([^\s;]+) \s*            #content-coding
                            (;\s* q \s*=\s* ([0-9\.]+))? #q
                            c         C   sé   i  } |  j  j d d É } xl | j d É D][ } |  j j | É } | r+ | j d É } | rj t | É n d } | | | j d É <q+ q+ W| S(   Ns   Accept-EncodingRB   t   ,i   g      ?i   (   t   headerst   getR   t	   aepatternt   matcht   groupt   float(   R   t   rt   aet   eRX   t   v(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   accept_encodings¡  s    c         C   s!   |  j  r |  j |  j  k St Sd  S(   N(   t	   rpc_pathsR4   t   True(   R   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   is_rpc_path_validÃ  s    	c   
      C   sN  |  j  É  s |  j É  d Sy— d } t |  j d É } g  } xV | rî t | | É } |  j j | É } | sp Pn  | j | É | t | d É 8} q? Wd j	 | É } |  j
 | É } | d k r√ d S|  j j | t |  d d É |  j É } Wná t k
 rt} |  j d É t |  j d	 É rW|  j j rW|  j d
 t | É É |  j d t j É  É n  |  j d d É |  j É  n÷ X|  j d É |  j d d É |  j d k	 rt | É |  j k r|  j É  j d d É }	 |	 ry# t j | É } |  j d d É Wqt k
 r
qXqqn  |  j d t t | É É É |  j É  |  j j  | É d S(   s∫   Handles the HTTP POST request.

        Attempts to interpret all HTTP POST requests as XML-RPC calls,
        which are forwarded to the server's _dispatch method for handling.
        Ni
   i   s   content-lengthiˇˇˇˇRB   R.   iÙ  t   _send_traceback_headers   X-exceptions   X-tracebacks   Content-lengtht   0i»   s   Content-types   text/xmlt   gzipi    s   Content-Encodingi (  i  † (!   Rb   t
   report_404t   intRU   t   mint   rfilet   readRH   t   lent   joint   decode_request_contentR   t   serverR<   R   R4   RM   t   send_responseR   Rc   t   send_headert   strt	   tracebackt
   format_exct   end_headerst   encode_thresholdR_   RV   R,   t   gzip_encodet   NotImplementedErrort   wfilet   write(
   R   t   max_chunk_sizet   size_remainingt   Lt
   chunk_sizet   chunkR2   R7   R]   t   q(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   do_POST”  sT    
		"
c         C   s≈   |  j  j d d É j É  } | d k r+ | S| d k rì y t j | É SWqß t k
 ro |  j d d | É qß t k
 rè |  j d d É qß Xn |  j d d | É |  j d d	 É |  j	 É  d  S(
   Ns   content-encodingt   identityRe   iı  s   encoding %r not supportediê  s   error decoding gzip contents   Content-lengthRd   (
   RU   RV   t   lowerR,   t   gzip_decodeRw   Ro   t
   ValueErrorRp   Rt   (   R   R2   R   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyRm     s    c         C   s]   |  j  d É d } |  j d d É |  j d t t | É É É |  j É  |  j j | É d  S(   Niî  s   No such pages   Content-types
   text/plains   Content-length(   Ro   Rp   Rq   Rk   Rt   Rx   Ry   (   R   R7   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyRf   *  s    
t   -c         C   s)   |  j  j r% t j j |  | | É n  d S(   s$   Selectively log an accepted request.N(   Rn   t   logRequestst   BaseHTTPServert   BaseHTTPRequestHandlert   log_request(   R   t   codet   size(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyRâ   3  s    (   RS   s   /RPC2(   R    RO   RP   R`   Ru   t   wbufsizeRa   t   disable_nagle_algorithmt   ret   compilet   VERBOSEt
   IGNORECASERW   R_   Rb   RÄ   Rm   Rf   Râ   (    (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyRR   ®  s   			F			t   SimpleXMLRPCServerc           B   s2   e  Z d  Z e Z e Z e e e d e d Ñ Z	 RS(   sg  Simple XML-RPC server.

    Simple XML-RPC server that allows functions and a single instance
    to be installed to handle requests. The default implementation
    attempts to dispatch XML-RPC calls to the functions or instance
    installed in the server. Override the _dispatch method inhereted
    from SimpleXMLRPCDispatcher to change this behavior.
    c         C   sõ   | |  _  t j |  | | É t j j |  | | | É t d  k	 ró t t d É ró t j |  j É  t j	 É } | t j
 O} t j |  j É  t j | É n  d  S(   Nt
   FD_CLOEXEC(   RÜ   R   R   t   SocketServert	   TCPServert   fcntlR   R   t   filenot   F_GETFDRì   t   F_SETFD(   R   t   addrt   requestHandlerRÜ   R   R   t   bind_and_activatet   flags(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR   L  s    	N(
   R    RO   RP   Ra   t   allow_reuse_addressRQ   Rc   RR   R   R   (    (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyRí   9  s
   	t   MultiPathXMLRPCServerc           B   sG   e  Z d  Z e e e d e d Ñ Z d Ñ  Z d Ñ  Z	 d d d Ñ Z
 RS(   s\  Multipath XML-RPC Server
    This specialization of SimpleXMLRPCServer allows the user to create
    multiple Dispatcher instances and assign them to different
    HTTP request paths.  This makes it possible to run two or more
    'virtual XML-RPC servers' at the same port.
    Make sure that the requestHandler accepts the paths in question.
    c         C   s>   t  j |  | | | | | | É i  |  _ | |  _ | |  _ d  S(   N(   Rí   R   t   dispatchersR   R   (   R   Rö   Rõ   RÜ   R   R   Rú   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR   c  s
    
		c         C   s   | |  j  | <| S(   N(   R†   (   R   R4   t
   dispatcher(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   add_dispatcherl  s    c         C   s   |  j  | S(   N(   R†   (   R   R4   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   get_dispatcherp  s    c         C   s{   y  |  j  | j | | | É } WnT t j É  d  \ } } t j t j d d | | f É d |  j d |  j É} n X| S(   Ni   i   s   %s:%sR   R   (	   R†   R<   R0   R1   R,   R/   R    R   R   (   R   R2   R3   R4   R7   R9   R:   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR<   s  s    N(   R    RO   RP   RR   Ra   RQ   R   R   R¢   R£   R<   (    (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyRü   [  s   		t   CGIXMLRPCRequestHandlerc           B   s;   e  Z d  Z e d d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z RS(   s3   Simple handler for XML-RPC data passed through CGI.c         C   s   t  j |  | | É d  S(   N(   R   R   (   R   R   R   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR   Ñ  s    c         C   s8   |  j  | É } d GHd t | É GHHt j j | É d S(   s   Handle a single XML-RPC requests   Content-Type: text/xmls   Content-Length: %dN(   R<   Rk   R0   t   stdoutRy   (   R   t   request_textR7   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   handle_xmlrpcá  s
    c         C   s}   d } t  j j | \ } } t  j i | d 6| d 6| d 6} d | | f GHd t  j GHd t | É GHHt j j | É d S(	   sã   Handle a single HTTP GET request.

        Default implementation indicates an error because
        XML-RPC uses the POST method.
        iê  Rä   t   messaget   explains   Status: %d %ss   Content-Type: %ss   Content-Length: %dN(	   Rá   Rà   t	   responsest   DEFAULT_ERROR_MESSAGEt   DEFAULT_ERROR_CONTENT_TYPERk   R0   R•   Ry   (   R   Rä   R®   R©   R7   (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt
   handle_getë  s    c         C   s•   | d k r4 t j j d d É d k r4 |  j É  nm y t t j j d d É É } Wn t t f k
 rr d } n X| d k rî t j	 j
 | É } n  |  j | É d S(   s   Handle a single XML-RPC request passed through a CGI post method.

        If no XML data is given then it is read from stdin. The resulting
        XML-RPC response is printed to stdout along with the correct HTTP
        headers.
        t   REQUEST_METHODt   GETt   CONTENT_LENGTHiˇˇˇˇN(   R   t   ost   environRV   R≠   Rg   t	   TypeErrorRÑ   R0   t   stdinRj   Rß   (   R   R¶   t   length(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   handle_request®  s    
N(	   R    RO   RP   RQ   R   R   Rß   R≠   R∂   (    (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyR§   Å  s
   	
	t   __main__s#   Running XML-RPC server on port 8000t	   localhosti@  c         C   s   |  | S(   N(    (   R   t   y(    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   <lambda>¬  s    t   add(   RP   R,   R    Rî   Rá   R0   R±   Rr   Ré   Rñ   t   ImportErrorR   Ra   R   R   R   R   Rà   RR   Rï   Rí   Rü   R§   R    Rn   R#   t   powR*   t   serve_forever(    (    (    s(   /usr/lib/python2.7/SimpleXMLRPCServer.pyt   <module>a   s:   
		ˇ 	ë	!&=
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """Generic socket server classes.

This module tries to capture the various aspects of defining a server:

For socket-based servers:

- address family:
        - AF_INET{,6}: IP (Internet Protocol) sockets (default)
        - AF_UNIX: Unix domain sockets
        - others, e.g. AF_DECNET are conceivable (see <socket.h>
- socket type:
        - SOCK_STREAM (reliable stream, e.g. TCP)
        - SOCK_DGRAM (datagrams, e.g. UDP)

For request-based servers (including socket-based):

- client address verification before further looking at the request
        (This is actually a hook for any processing that needs to look
         at the request before anything else, e.g. logging)
- how to handle multiple requests:
        - synchronous (one request is handled at a time)
        - forking (each request is handled by a new process)
        - threading (each request is handled by a new thread)

The classes in this module favor the server type that is simplest to
write: a synchronous TCP/IP server.  This is bad class design, but
save some typing.  (There's also the issue that a deep class hierarchy
slows down method lookups.)

There are five classes in an inheritance diagram, four of which represent
synchronous servers of four types:

        +------------+
        | BaseServer |
        +------------+
              |
              v
        +-----------+        +------------------+
        | TCPServer |------->| UnixStreamServer |
        +-----------+        +------------------+
              |
              v
        +-----------+        +--------------------+
        | UDPServer |------->| UnixDatagramServer |
        +-----------+        +--------------------+

Note that UnixDatagramServer derives from UDPServer, not from
UnixStreamServer -- the only difference between an IP and a Unix
stream server is the address family, which is simply repeated in both
unix server classes.

Forking and threading versions of each type of server can be created
using the ForkingMixIn and ThreadingMixIn mix-in classes.  For
instance, a threading UDP server class is created as follows:

        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass

The Mix-in class must come first, since it overrides a method defined
in UDPServer! Setting the various member variables also changes
the behavior of the underlying server mechanism.

To implement a service, you must derive a class from
BaseRequestHandler and redefine its handle() method.  You can then run
various versions of the service by combining one of the server classes
with your request handler class.

The request handler class must be different for datagram or stream
services.  This can be hidden by using the request handler
subclasses StreamRequestHandler or DatagramRequestHandler.

Of course, you still have to use your head!

For instance, it makes no sense to use a forking server if the service
contains state in memory that can be modified by requests (since the
modifications in the child process would never reach the initial state
kept in the parent process and passed to each child).  In this case,
you can use a threading server, but you will probably have to use
locks to avoid two requests that come in nearly simultaneous to apply
conflicting changes to the server state.

On the other hand, if you are building e.g. an HTTP server, where all
data is stored externally (e.g. in the file system), a synchronous
class will essentially render the service "deaf" while one request is
being handled -- which may be for a very long time if a client is slow
to read all the data it has requested.  Here a threading or forking
server is appropriate.

In some cases, it may be appropriate to process part of a request
synchronously, but to finish processing in a forked child depending on
the request data.  This can be implemented by using a synchronous
server and doing an explicit fork in the request handler class
handle() method.

Another approach to handling multiple simultaneous requests in an
environment that supports neither threads nor fork (or where these are
too expensive or inappropriate for the service) is to maintain an
explicit table of partially finished requests and to use select() to
decide which request to work on next (or whether to handle a new
incoming request).  This is particularly important for stream services
where each client can potentially be connected for a long time (if
threads or subprocesses cannot be used).

Future work:
- Standard classes for Sun RPC (which uses either UDP or TCP)
- Standard mix-in classes to implement various authentication
  and encryption schemes
- Standard framework for select-based multiplexing

XXX Open problems:
- What to do with out-of-band data?

BaseServer:
- split generic "request" functionality out into BaseServer class.
  Copyright (C) 2000  Luke Kenneth Casson Leighton <lkcl@samba.org>

  example: read entries from a SQL database (requires overriding
  get_request() to return a table entry from the database).
  entry is processed by a RequestHandlerClass.

"""

# Author of the BaseServer patch: Luke Kenneth Casson Leighton

__version__ = "0.4"


import socket
import select
import sys
import os
import errno
try:
    import threading
except ImportError:
    import dummy_threading as threading

__all__ = ["TCPServer","UDPServer","ForkingUDPServer","ForkingTCPServer",
           "ThreadingUDPServer","ThreadingTCPServer","BaseRequestHandler",
           "StreamRequestHandler","DatagramRequestHandler",
           "ThreadingMixIn", "ForkingMixIn"]
if hasattr(socket, "AF_UNIX"):
    __all__.extend(["UnixStreamServer","UnixDatagramServer",
                    "ThreadingUnixStreamServer",
                    "ThreadingUnixDatagramServer"])

def _eintr_retry(func, *args):
    """restart a system call interrupted by EINTR"""
    while True:
        try:
            return func(*args)
        except (OSError, select.error) as e:
            if e.args[0] != errno.EINTR:
                raise

class BaseServer:

    """Base class for server classes.

    Methods for the caller:

    - __init__(server_address, RequestHandlerClass)
    - serve_forever(poll_interval=0.5)
    - shutdown()
    - handle_request()  # if you do not use serve_forever()
    - fileno() -> int   # for select()

    Methods that may be overridden:

    - server_bind()
    - server_activate()
    - get_request() -> request, client_address
    - handle_timeout()
    - verify_request(request, client_address)
    - server_close()
    - process_request(request, client_address)
    - shutdown_request(request)
    - close_request(request)
    - handle_error()

    Methods for derived classes:

    - finish_request(request, client_address)

    Class variables that may be overridden by derived classes or
    instances:

    - timeout
    - address_family
    - socket_type
    - allow_reuse_address

    Instance variables:

    - RequestHandlerClass
    - socket

    """

    timeout = None

    def __init__(self, server_address, RequestHandlerClass):
        """Constructor.  May be extended, do not override."""
        self.server_address = server_address
        self.RequestHandlerClass = RequestHandlerClass
        self.__is_shut_down = threading.Event()
        self.__shutdown_request = False

    def server_activate(self):
        """Called by constructor to activate the server.

        May be overridden.

        """
        pass

    def serve_forever(self, poll_interval=0.5):
        """Handle one request at a time until shutdown.

        Polls for shutdown every poll_interval seconds. Ignores
        self.timeout. If you need to do periodic tasks, do them in
        another thread.
        """
        self.__is_shut_down.clear()
        try:
            while not self.__shutdown_request:
                # XXX: Consider using another file descriptor or
                # connecting to the socket to wake this up instead of
                # polling. Polling reduces our responsiveness to a
                # shutdown request and wastes cpu at all other times.
                r, w, e = _eintr_retry(select.select, [self], [], [],
                                       poll_interval)
                if self in r:
                    self._handle_request_noblock()
        finally:
            self.__shutdown_request = False
            self.__is_shut_down.set()

    def shutdown(self):
        """Stops the serve_forever loop.

        Blocks until the loop has finished. This must be called while
        serve_forever() is running in another thread, or it will
        deadlock.
        """
        self.__shutdown_request = True
        self.__is_shut_down.wait()

    # The distinction between handling, getting, processing and
    # finishing a request is fairly arbitrary.  Remember:
    #
    # - handle_request() is the top-level call.  It calls
    #   select, get_request(), verify_request() and process_request()
    # - get_request() is different for stream or datagram sockets
    # - process_request() is the place that may fork a new process
    #   or create a new thread to finish the request
    # - finish_request() instantiates the request handler class;
    #   this constructor will handle the request all by itself

    def handle_request(self):
        """Handle one request, possibly blocking.

        Respects self.timeout.
        """
        # Support people who used socket.settimeout() to escape
        # handle_request before self.timeout was available.
        timeout = self.socket.gettimeout()
        if timeout is None:
            timeout = self.timeout
        elif self.timeout is not None:
            timeout = min(timeout, self.timeout)
        fd_sets = _eintr_retry(select.select, [self], [], [], timeout)
        if not fd_sets[0]:
            self.handle_timeout()
            return
        self._handle_request_noblock()

    def _handle_request_noblock(self):
        """Handle one request, without blocking.

        I assume that select.select has returned that the socket is
        readable before this function was called, so there should be
        no risk of blocking in get_request().
        """
        try:
            request, client_address = self.get_request()
        except socket.error:
            return
        if self.verify_request(request, client_address):
            try:
                self.process_request(request, client_address)
            except:
                self.handle_error(request, client_address)
                self.shutdown_request(request)
        else:
            self.shutdown_request(request)

    def handle_timeout(self):
        """Called if no new request arrives within self.timeout.

        Overridden by ForkingMixIn.
        """
        pass

    def verify_request(self, request, client_address):
        """Verify the request.  May be overridden.

        Return True if we should proceed with this request.

        """
        return True

    def process_request(self, request, client_address):
        """Call finish_request.

        Overridden by ForkingMixIn and ThreadingMixIn.

        """
        self.finish_request(request, client_address)
        self.shutdown_request(request)

    def server_close(self):
        """Called to clean-up the server.

        May be overridden.

        """
        pass

    def finish_request(self, request, client_address):
        """Finish one request by instantiating RequestHandlerClass."""
        self.RequestHandlerClass(request, client_address, self)

    def shutdown_request(self, request):
        """Called to shutdown and close an individual request."""
        self.close_request(request)

    def close_request(self, request):
        """Called to clean up an individual request."""
        pass

    def handle_error(self, request, client_address):
        """Handle an error gracefully.  May be overridden.

        The default is to print a traceback and continue.

        """
        print '-'*40
        print 'Exception happened during processing of request from',
        print client_address
        import traceback
        traceback.print_exc() # XXX But this goes to stderr!
        print '-'*40


class TCPServer(BaseServer):

    """Base class for various socket-based server classes.

    Defaults to synchronous IP stream (i.e., TCP).

    Methods for the caller:

    - __init__(server_address, RequestHandlerClass, bind_and_activate=True)
    - serve_forever(poll_interval=0.5)
    - shutdown()
    - handle_request()  # if you don't use serve_forever()
    - fileno() -> int   # for select()

    Methods that may be overridden:

    - server_bind()
    - server_activate()
    - get_request() -> request, client_address
    - handle_timeout()
    - verify_request(request, client_address)
    - process_request(request, client_address)
    - shutdown_request(request)
    - close_request(request)
    - handle_error()

    Methods for derived classes:

    - finish_request(request, client_address)

    Class variables that may be overridden by derived classes or
    instances:

    - timeout
    - address_family
    - socket_type
    - request_queue_size (only for stream sockets)
    - allow_reuse_address

    Instance variables:

    - server_address
    - RequestHandlerClass
    - socket

    """

    address_family = socket.AF_INET

    socket_type = socket.SOCK_STREAM

    request_queue_size = 5

    allow_reuse_address = False

    def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):
        """Constructor.  May be extended, do not override."""
        BaseServer.__init__(self, server_address, RequestHandlerClass)
        self.socket = socket.socket(self.address_family,
                                    self.socket_type)
        if bind_and_activate:
            try:
                self.server_bind()
                self.server_activate()
            except:
                self.server_close()
                raise

    def server_bind(self):
        """Called by constructor to bind the socket.

        May be overridden.

        """
        if self.allow_reuse_address:
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.bind(self.server_address)
        self.server_address = self.socket.getsockname()

    def server_activate(self):
        """Called by constructor to activate the server.

        May be overridden.

        """
        self.socket.listen(self.request_queue_size)

    def server_close(self):
        """Called to clean-up the server.

        May be overridden.

        """
        self.socket.close()

    def fileno(self):
        """Return socket file number.

        Interface required by select().

        """
        return self.socket.fileno()

    def get_request(self):
        """Get the request and client address from the socket.

        May be overridden.

        """
        return self.socket.accept()

    def shutdown_request(self, request):
        """Called to shutdown and close an individual request."""
        try:
            #explicitly shutdown.  socket.close() merely releases
            #the socket and waits for GC to perform the actual close.
            request.shutdown(socket.SHUT_WR)
        except socket.error:
            pass #some platforms may raise ENOTCONN here
        self.close_request(request)

    def close_request(self, request):
        """Called to clean up an individual request."""
        request.close()


class UDPServer(TCPServer):

    """UDP server class."""

    allow_reuse_address = False

    socket_type = socket.SOCK_DGRAM

    max_packet_size = 8192

    def get_request(self):
        data, client_addr = self.socket.recvfrom(self.max_packet_size)
        return (data, self.socket), client_addr

    def server_activate(self):
        # No need to call listen() for UDP.
        pass

    def shutdown_request(self, request):
        # No need to shutdown anything.
        self.close_request(request)

    def close_request(self, request):
        # No need to close anything.
        pass

class ForkingMixIn:

    """Mix-in class to handle each request in a new process."""

    timeout = 300
    active_children = None
    max_children = 40

    def collect_children(self):
        """Internal routine to wait for children that have exited."""
        if self.active_children is None:
            return

        # If we're above the max number of children, wait and reap them until
        # we go back below threshold. Note that we use waitpid(-1) below to be
        # able to collect children in size(<defunct children>) syscalls instead
        # of size(<children>): the downside is that this might reap children
        # which we didn't spawn, which is why we only resort to this when we're
        # above max_children.
        while len(self.active_children) >= self.max_children:
            try:
                pid, _ = os.waitpid(-1, 0)
                self.active_children.discard(pid)
            except OSError as e:
                if e.errno == errno.ECHILD:
                    # we don't have any children, we're done
                    self.active_children.clear()
                elif e.errno != errno.EINTR:
                    break

        # Now reap all defunct children.
        for pid in self.active_children.copy():
            try:
                pid, _ = os.waitpid(pid, os.WNOHANG)
                # if the child hasn't exited yet, pid will be 0 and ignored by
                # discard() below
                self.active_children.discard(pid)
            except OSError as e:
                if e.errno == errno.ECHILD:
                    # someone else reaped it
                    self.active_children.discard(pid)

    def handle_timeout(self):
        """Wait for zombies after self.timeout seconds of inactivity.

        May be extended, do not override.
        """
        self.collect_children()

    def process_request(self, request, client_address):
        """Fork a new subprocess to process the request."""
        self.collect_children()
        pid = os.fork()
        if pid:
            # Parent process
            if self.active_children is None:
                self.active_children = set()
            self.active_children.add(pid)
            self.close_request(request) #close handle in parent process
            return
        else:
            # Child process.
            # This must never return, hence os._exit()!
            try:
                self.finish_request(request, client_address)
                self.shutdown_request(request)
                os._exit(0)
            except:
                try:
                    self.handle_error(request, client_address)
                    self.shutdown_request(request)
                finally:
                    os._exit(1)


class ThreadingMixIn:
    """Mix-in class to handle each request in a new thread."""

    # Decides how threads will act upon termination of the
    # main process
    daemon_threads = False

    def process_request_thread(self, request, client_address):
        """Same as in BaseServer but as a thread.

        In addition, exception handling is done here.

        """
        try:
            self.finish_request(request, client_address)
            self.shutdown_request(request)
        except:
            self.handle_error(request, client_address)
            self.shutdown_request(request)

    def process_request(self, request, client_address):
        """Start a new thread to process the request."""
        t = threading.Thread(target = self.process_request_thread,
                             args = (request, client_address))
        t.daemon = self.daemon_threads
        t.start()


class ForkingUDPServer(ForkingMixIn, UDPServer): pass
class ForkingTCPServer(ForkingMixIn, TCPServer): pass

class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass
class ThreadingTCPServer(ThreadingMixIn, TCPServer): pass

if hasattr(socket, 'AF_UNIX'):

    class UnixStreamServer(TCPServer):
        address_family = socket.AF_UNIX

    class UnixDatagramServer(UDPServer):
        address_family = socket.AF_UNIX

    class ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer): pass

    class ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer): pass

class BaseRequestHandler:

    """Base class for request handler classes.

    This class is instantiated for each request to be handled.  The
    constructor sets the instance variables request, client_address
    and server, and then calls the handle() method.  To implement a
    specific service, all you need to do is to derive a class which
    defines a handle() method.

    The handle() method can find the request as self.request, the
    client address as self.client_address, and the server (in case it
    needs access to per-server information) as self.server.  Since a
    separate instance is created for each request, the handle() method
    can define other arbitrary instance variables.

    """

    def __init__(self, request, client_address, server):
        self.request = request
        self.client_address = client_address
        self.server = server
        self.setup()
        try:
            self.handle()
        finally:
            self.finish()

    def setup(self):
        pass

    def handle(self):
        pass

    def finish(self):
        pass


# The following two classes make it possible to use the same service
# class for stream or datagram servers.
# Each class sets up these instance variables:
# - rfile: a file object from which receives the request is read
# - wfile: a file object to which the reply is written
# When the handle() method returns, wfile is flushed properly


class StreamRequestHandler(BaseRequestHandler):

    """Define self.rfile and self.wfile for stream sockets."""

    # Default buffer sizes for rfile, wfile.
    # We default rfile to buffered because otherwise it could be
    # really slow for large data (a getc() call per byte); we make
    # wfile unbuffered because (a) often after a write() we want to
    # read and we need to flush the line; (b) big writes to unbuffered
    # files are typically optimized by stdio even when big reads
    # aren't.
    rbufsize = -1
    wbufsize = 0

    # A timeout to apply to the request socket, if not None.
    timeout = None

    # Disable nagle algorithm for this socket, if True.
    # Use only when wbufsize != 0, to avoid small packets.
    disable_nagle_algorithm = False

    def setup(self):
        self.connection = self.request
        if self.timeout is not None:
            self.connection.settimeout(self.timeout)
        if self.disable_nagle_algorithm:
            self.connection.setsockopt(socket.IPPROTO_TCP,
                                       socket.TCP_NODELAY, True)
        self.rfile = self.connection.makefile('rb', self.rbufsize)
        self.wfile = self.connection.makefile('wb', self.wbufsize)

    def finish(self):
        if not self.wfile.closed:
            try:
                self.wfile.flush()
            except socket.error:
                # A final socket error may have occurred here, such as
                # the local error ECONNABORTED.
                pass
        self.wfile.close()
        self.rfile.close()


class DatagramRequestHandler(BaseRequestHandler):

    """Define self.rfile and self.wfile for datagram sockets."""

    def setup(self):
        try:
            from cStringIO import StringIO
        except ImportError:
            from StringIO import StringIO
        self.packet, self.socket = self.request
        self.rfile = StringIO(self.packet)
        self.wfile = StringIO()

    def finish(self):
        self.socket.sendto(self.wfile.getvalue(), self.client_address)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   sO  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l Z y d d l Z Wn e k
 rw d d l	 Z n Xd d d d d d	 d
 d d d d g Z
 e e d É r  e
 j d d d d g É n  d Ñ  Z d d& d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d d' d Ñ  É  YZ d d( d Ñ  É  YZ d e e f d Ñ  É  YZ d e e f d Ñ  É  YZ d e e f d Ñ  É  YZ d	 e e f d Ñ  É  YZ e e d É rd e f d Ñ  É  YZ d e f d  Ñ  É  YZ d e e f d! Ñ  É  YZ d e e f d" Ñ  É  YZ n  d
 d) d# Ñ  É  YZ d e f d$ Ñ  É  YZ d e f d% Ñ  É  YZ d S(*   s°  Generic socket server classes.

This module tries to capture the various aspects of defining a server:

For socket-based servers:

- address family:
        - AF_INET{,6}: IP (Internet Protocol) sockets (default)
        - AF_UNIX: Unix domain sockets
        - others, e.g. AF_DECNET are conceivable (see <socket.h>
- socket type:
        - SOCK_STREAM (reliable stream, e.g. TCP)
        - SOCK_DGRAM (datagrams, e.g. UDP)

For request-based servers (including socket-based):

- client address verification before further looking at the request
        (This is actually a hook for any processing that needs to look
         at the request before anything else, e.g. logging)
- how to handle multiple requests:
        - synchronous (one request is handled at a time)
        - forking (each request is handled by a new process)
        - threading (each request is handled by a new thread)

The classes in this module favor the server type that is simplest to
write: a synchronous TCP/IP server.  This is bad class design, but
save some typing.  (There's also the issue that a deep class hierarchy
slows down method lookups.)

There are five classes in an inheritance diagram, four of which represent
synchronous servers of four types:

        +------------+
        | BaseServer |
        +------------+
              |
              v
        +-----------+        +------------------+
        | TCPServer |------->| UnixStreamServer |
        +-----------+        +------------------+
              |
              v
        +-----------+        +--------------------+
        | UDPServer |------->| UnixDatagramServer |
        +-----------+        +--------------------+

Note that UnixDatagramServer derives from UDPServer, not from
UnixStreamServer -- the only difference between an IP and a Unix
stream server is the address family, which is simply repeated in both
unix server classes.

Forking and threading versions of each type of server can be created
using the ForkingMixIn and ThreadingMixIn mix-in classes.  For
instance, a threading UDP server class is created as follows:

        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass

The Mix-in class must come first, since it overrides a method defined
in UDPServer! Setting the various member variables also changes
the behavior of the underlying server mechanism.

To implement a service, you must derive a class from
BaseRequestHandler and redefine its handle() method.  You can then run
various versions of the service by combining one of the server classes
with your request handler class.

The request handler class must be different for datagram or stream
services.  This can be hidden by using the request handler
subclasses StreamRequestHandler or DatagramRequestHandler.

Of course, you still have to use your head!

For instance, it makes no sense to use a forking server if the service
contains state in memory that can be modified by requests (since the
modifications in the child process would never reach the initial state
kept in the parent process and passed to each child).  In this case,
you can use a threading server, but you will probably have to use
locks to avoid two requests that come in nearly simultaneous to apply
conflicting changes to the server state.

On the other hand, if you are building e.g. an HTTP server, where all
data is stored externally (e.g. in the file system), a synchronous
class will essentially render the service "deaf" while one request is
being handled -- which may be for a very long time if a client is slow
to read all the data it has requested.  Here a threading or forking
server is appropriate.

In some cases, it may be appropriate to process part of a request
synchronously, but to finish processing in a forked child depending on
the request data.  This can be implemented by using a synchronous
server and doing an explicit fork in the request handler class
handle() method.

Another approach to handling multiple simultaneous requests in an
environment that supports neither threads nor fork (or where these are
too expensive or inappropriate for the service) is to maintain an
explicit table of partially finished requests and to use select() to
decide which request to work on next (or whether to handle a new
incoming request).  This is particularly important for stream services
where each client can potentially be connected for a long time (if
threads or subprocesses cannot be used).

Future work:
- Standard classes for Sun RPC (which uses either UDP or TCP)
- Standard mix-in classes to implement various authentication
  and encryption schemes
- Standard framework for select-based multiplexing

XXX Open problems:
- What to do with out-of-band data?

BaseServer:
- split generic "request" functionality out into BaseServer class.
  Copyright (C) 2000  Luke Kenneth Casson Leighton <lkcl@samba.org>

  example: read entries from a SQL database (requires overriding
  get_request() to return a table entry from the database).
  entry is processed by a RequestHandlerClass.

s   0.4iˇˇˇˇNt	   TCPServert	   UDPServert   ForkingUDPServert   ForkingTCPServert   ThreadingUDPServert   ThreadingTCPServert   BaseRequestHandlert   StreamRequestHandlert   DatagramRequestHandlert   ThreadingMixInt   ForkingMixInt   AF_UNIXt   UnixStreamServert   UnixDatagramServert   ThreadingUnixStreamServert   ThreadingUnixDatagramServerc         G   sZ   xS t  rU y |  | å  SWq t t j f k
 rQ } | j d t j k rR Ç  qR q Xq Wd S(   s*   restart a system call interrupted by EINTRi    N(   t   Truet   OSErrort   selectt   errort   argst   errnot   EINTR(   t   funcR   t   e(    (    s"   /usr/lib/python2.7/SocketServer.pyt   _eintr_retryí   s    	t
   BaseServerc           B   sï   e  Z d  Z d Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s†  Base class for server classes.

    Methods for the caller:

    - __init__(server_address, RequestHandlerClass)
    - serve_forever(poll_interval=0.5)
    - shutdown()
    - handle_request()  # if you do not use serve_forever()
    - fileno() -> int   # for select()

    Methods that may be overridden:

    - server_bind()
    - server_activate()
    - get_request() -> request, client_address
    - handle_timeout()
    - verify_request(request, client_address)
    - server_close()
    - process_request(request, client_address)
    - shutdown_request(request)
    - close_request(request)
    - handle_error()

    Methods for derived classes:

    - finish_request(request, client_address)

    Class variables that may be overridden by derived classes or
    instances:

    - timeout
    - address_family
    - socket_type
    - allow_reuse_address

    Instance variables:

    - RequestHandlerClass
    - socket

    c         C   s.   | |  _  | |  _ t j É  |  _ t |  _ d S(   s/   Constructor.  May be extended, do not override.N(   t   server_addresst   RequestHandlerClasst	   threadingt   Eventt   _BaseServer__is_shut_downt   Falset   _BaseServer__shutdown_request(   t   selfR   R   (    (    s"   /usr/lib/python2.7/SocketServer.pyt   __init__…   s    		c         C   s   d S(   sS   Called by constructor to activate the server.

        May be overridden.

        N(    (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyt   server_activate–   s    g      ‡?c         C   s   |  j  j É  zT xM |  j s_ t t j |  g g  g  | É \ } } } |  | k r |  j É  q q WWd t |  _ |  j  j É  Xd S(   s—   Handle one request at a time until shutdown.

        Polls for shutdown every poll_interval seconds. Ignores
        self.timeout. If you need to do periodic tasks, do them in
        another thread.
        N(   R   t   clearR!   R   R   t   _handle_request_noblockR    t   set(   R"   t   poll_intervalt   rt   wR   (    (    s"   /usr/lib/python2.7/SocketServer.pyt   serve_foreverÿ   s    	c         C   s   t  |  _ |  j j É  d S(   s¿   Stops the serve_forever loop.

        Blocks until the loop has finished. This must be called while
        serve_forever() is running in another thread, or it will
        deadlock.
        N(   R   R!   R   t   wait(   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyt   shutdownÓ   s    	c         C   sè   |  j  j É  } | d k r' |  j } n$ |  j d k	 rK t | |  j É } n  t t j |  g g  g  | É } | d sÅ |  j É  d S|  j É  d S(   sO   Handle one request, possibly blocking.

        Respects self.timeout.
        i    N(	   t   sockett
   gettimeoutt   Nonet   timeoutt   minR   R   t   handle_timeoutR&   (   R"   R1   t   fd_sets(    (    s"   /usr/lib/python2.7/SocketServer.pyt   handle_request  s    

c         C   sè   y |  j  É  \ } } Wn t j k
 r- d SX|  j | | É r~ y |  j | | É Wqã |  j | | É |  j | É qã Xn |  j | É d S(   sÊ   Handle one request, without blocking.

        I assume that select.select has returned that the socket is
        readable before this function was called, so there should be
        no risk of blocking in get_request().
        N(   t   get_requestR.   R   t   verify_requestt   process_requestt   handle_errort   shutdown_request(   R"   t   requestt   client_address(    (    s"   /usr/lib/python2.7/SocketServer.pyR&     s    c         C   s   d S(   sc   Called if no new request arrives within self.timeout.

        Overridden by ForkingMixIn.
        N(    (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyR3   )  s    c         C   s   t  S(   sn   Verify the request.  May be overridden.

        Return True if we should proceed with this request.

        (   R   (   R"   R;   R<   (    (    s"   /usr/lib/python2.7/SocketServer.pyR7   0  s    c         C   s!   |  j  | | É |  j | É d S(   sV   Call finish_request.

        Overridden by ForkingMixIn and ThreadingMixIn.

        N(   t   finish_requestR:   (   R"   R;   R<   (    (    s"   /usr/lib/python2.7/SocketServer.pyR8   8  s    c         C   s   d S(   sD   Called to clean-up the server.

        May be overridden.

        N(    (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyt   server_closeA  s    c         C   s   |  j  | | |  É d S(   s8   Finish one request by instantiating RequestHandlerClass.N(   R   (   R"   R;   R<   (    (    s"   /usr/lib/python2.7/SocketServer.pyR=   I  s    c         C   s   |  j  | É d S(   s3   Called to shutdown and close an individual request.N(   t   close_request(   R"   R;   (    (    s"   /usr/lib/python2.7/SocketServer.pyR:   M  s    c         C   s   d S(   s)   Called to clean up an individual request.N(    (   R"   R;   (    (    s"   /usr/lib/python2.7/SocketServer.pyR?   Q  s    c         C   s5   d d GHd G| GHd d l  } | j É  d d GHd S(   st   Handle an error gracefully.  May be overridden.

        The default is to print a traceback and continue.

        t   -i(   s4   Exception happened during processing of request fromiˇˇˇˇN(   t	   tracebackt	   print_exc(   R"   R;   R<   RA   (    (    s"   /usr/lib/python2.7/SocketServer.pyR9   U  s    	
N(   t   __name__t
   __module__t   __doc__R0   R1   R#   R$   R+   R-   R5   R&   R3   R7   R8   R>   R=   R:   R?   R9   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   õ   s    *													c           B   sw   e  Z d  Z e j Z e j Z d Z e	 Z
 e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z RS(
   s3  Base class for various socket-based server classes.

    Defaults to synchronous IP stream (i.e., TCP).

    Methods for the caller:

    - __init__(server_address, RequestHandlerClass, bind_and_activate=True)
    - serve_forever(poll_interval=0.5)
    - shutdown()
    - handle_request()  # if you don't use serve_forever()
    - fileno() -> int   # for select()

    Methods that may be overridden:

    - server_bind()
    - server_activate()
    - get_request() -> request, client_address
    - handle_timeout()
    - verify_request(request, client_address)
    - process_request(request, client_address)
    - shutdown_request(request)
    - close_request(request)
    - handle_error()

    Methods for derived classes:

    - finish_request(request, client_address)

    Class variables that may be overridden by derived classes or
    instances:

    - timeout
    - address_family
    - socket_type
    - request_queue_size (only for stream sockets)
    - allow_reuse_address

    Instance variables:

    - server_address
    - RequestHandlerClass
    - socket

    i   c         C   sj   t  j |  | | É t j |  j |  j É |  _ | rf y |  j É  |  j É  Wqf |  j É  Ç  qf Xn  d S(   s/   Constructor.  May be extended, do not override.N(   R   R#   R.   t   address_familyt   socket_typet   server_bindR$   R>   (   R"   R   R   t   bind_and_activate(    (    s"   /usr/lib/python2.7/SocketServer.pyR#   ö  s    

c         C   sQ   |  j  r( |  j j t j t j d É n  |  j j |  j É |  j j É  |  _ d S(   sO   Called by constructor to bind the socket.

        May be overridden.

        i   N(   t   allow_reuse_addressR.   t
   setsockoptt
   SOL_SOCKETt   SO_REUSEADDRt   bindR   t   getsockname(   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyRH   ß  s    	c         C   s   |  j  j |  j É d S(   sS   Called by constructor to activate the server.

        May be overridden.

        N(   R.   t   listent   request_queue_size(   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyR$   ≤  s    c         C   s   |  j  j É  d S(   sD   Called to clean-up the server.

        May be overridden.

        N(   R.   t   close(   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyR>   ∫  s    c         C   s   |  j  j É  S(   sM   Return socket file number.

        Interface required by select().

        (   R.   t   fileno(   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyRS   ¬  s    c         C   s   |  j  j É  S(   sY   Get the request and client address from the socket.

        May be overridden.

        (   R.   t   accept(   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyR6      s    c         C   s<   y | j  t j É Wn t j k
 r* n X|  j | É d S(   s3   Called to shutdown and close an individual request.N(   R-   R.   t   SHUT_WRR   R?   (   R"   R;   (    (    s"   /usr/lib/python2.7/SocketServer.pyR:   “  s
    c         C   s   | j  É  d S(   s)   Called to clean up an individual request.N(   RR   (   R"   R;   (    (    s"   /usr/lib/python2.7/SocketServer.pyR?   ‹  s    (   RC   RD   RE   R.   t   AF_INETRF   t   SOCK_STREAMRG   RQ   R    RJ   R   R#   RH   R$   R>   RS   R6   R:   R?   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR    c  s   -								
c           B   sG   e  Z d  Z e Z e j Z d Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z RS(   s   UDP server class.i    c         C   s.   |  j  j |  j É \ } } | |  j  f | f S(   N(   R.   t   recvfromt   max_packet_size(   R"   t   datat   client_addr(    (    s"   /usr/lib/python2.7/SocketServer.pyR6   Î  s    c         C   s   d  S(   N(    (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyR$   Ô  s    c         C   s   |  j  | É d  S(   N(   R?   (   R"   R;   (    (    s"   /usr/lib/python2.7/SocketServer.pyR:   Û  s    c         C   s   d  S(   N(    (   R"   R;   (    (    s"   /usr/lib/python2.7/SocketServer.pyR?   ˜  s    (   RC   RD   RE   R    RJ   R.   t
   SOCK_DGRAMRG   RY   R6   R$   R:   R?   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   ·  s   				c           B   s;   e  Z d  Z d Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s5   Mix-in class to handle each request in a new process.i,  i(   c         C   s4  |  j  d k r d Sxñ t |  j  É |  j k r´ y, t j d d É \ } } |  j  j | É Wq t k
 rß } | j t j	 k ré |  j  j
 É  q® | j t j k r® Pq® q Xq WxÅ |  j  j É  D]p } y/ t j | t j É \ } } |  j  j | É Wqº t k
 r+} | j t j	 k r,|  j  j | É q,qº Xqº Wd S(   s7   Internal routine to wait for children that have exited.Niˇˇˇˇi    (   t   active_childrenR0   t   lent   max_childrent   ost   waitpidt   discardR   R   t   ECHILDR%   R   t   copyt   WNOHANG(   R"   t   pidt   _R   (    (    s"   /usr/lib/python2.7/SocketServer.pyt   collect_children  s$    c         C   s   |  j  É  d S(   sn   Wait for zombies after self.timeout seconds of inactivity.

        May be extended, do not override.
        N(   Rh   (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyR3   %  s    c         C   s…   |  j  É  t j É  } | r[ |  j d k r: t É  |  _ n  |  j j | É |  j | É d Sy. |  j | | É |  j	 | É t j
 d É Wn9 z! |  j | | É |  j	 | É Wd t j
 d É Xn Xd S(   s-   Fork a new subprocess to process the request.Ni    i   (   Rh   R`   t   forkR]   R0   R'   t   addR?   R=   R:   t   _exitR9   (   R"   R;   R<   Rf   (    (    s"   /usr/lib/python2.7/SocketServer.pyR8   ,  s"    
N(
   RC   RD   RE   R1   R0   R]   R_   Rh   R3   R8   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR
   ˚  s   	"	c           B   s&   e  Z d  Z e Z d Ñ  Z d Ñ  Z RS(   s4   Mix-in class to handle each request in a new thread.c         C   sL   y! |  j  | | É |  j | É Wn$ |  j | | É |  j | É n Xd S(   sg   Same as in BaseServer but as a thread.

        In addition, exception handling is done here.

        N(   R=   R:   R9   (   R"   R;   R<   (    (    s"   /usr/lib/python2.7/SocketServer.pyt   process_request_threadM  s    c         C   s;   t  j d |  j d | | f É } |  j | _ | j É  d S(   s*   Start a new thread to process the request.t   targetR   N(   R   t   ThreadRl   t   daemon_threadst   daemont   start(   R"   R;   R<   t   t(    (    s"   /usr/lib/python2.7/SocketServer.pyR8   Z  s    (   RC   RD   RE   R    Ro   Rl   R8   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR	   F  s   	c           B   s   e  Z RS(    (   RC   RD   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   b  s    c           B   s   e  Z RS(    (   RC   RD   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   c  s    c           B   s   e  Z RS(    (   RC   RD   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   e  s    c           B   s   e  Z RS(    (   RC   RD   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   f  s    c           B   s   e  Z e j Z RS(    (   RC   RD   R.   R   RF   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   j  s   c           B   s   e  Z e j Z RS(    (   RC   RD   R.   R   RF   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   m  s   c           B   s   e  Z RS(    (   RC   RD   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   p  s    c           B   s   e  Z RS(    (   RC   RD   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   r  s    c           B   s2   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s•  Base class for request handler classes.

    This class is instantiated for each request to be handled.  The
    constructor sets the instance variables request, client_address
    and server, and then calls the handle() method.  To implement a
    specific service, all you need to do is to derive a class which
    defines a handle() method.

    The handle() method can find the request as self.request, the
    client address as self.client_address, and the server (in case it
    needs access to per-server information) as self.server.  Since a
    separate instance is created for each request, the handle() method
    can define other arbitrary instance variables.

    c         C   sE   | |  _  | |  _ | |  _ |  j É  z |  j É  Wd  |  j É  Xd  S(   N(   R;   R<   t   servert   setupt   handlet   finish(   R"   R;   R<   Rs   (    (    s"   /usr/lib/python2.7/SocketServer.pyR#   Ü  s    			
c         C   s   d  S(   N(    (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyRt   ê  s    c         C   s   d  S(   N(    (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyRu   ì  s    c         C   s   d  S(   N(    (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyRv   ñ  s    (   RC   RD   RE   R#   Rt   Ru   Rv   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   t  s
   	
		c           B   s8   e  Z d  Z d Z d Z d Z e Z d Ñ  Z	 d Ñ  Z
 RS(   s4   Define self.rfile and self.wfile for stream sockets.iˇˇˇˇi    c         C   sì   |  j  |  _ |  j d  k	 r1 |  j j |  j É n  |  j rY |  j j t j t j	 t
 É n  |  j j d |  j É |  _ |  j j d |  j É |  _ d  S(   Nt   rbt   wb(   R;   t
   connectionR1   R0   t
   settimeoutt   disable_nagle_algorithmRK   R.   t   IPPROTO_TCPt   TCP_NODELAYR   t   makefilet   rbufsizet   rfilet   wbufsizet   wfile(   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyRt   ∑  s    	c         C   sU   |  j  j s7 y |  j  j É  Wq7 t j k
 r3 q7 Xn  |  j  j É  |  j j É  d  S(   N(   RÇ   t   closedt   flushR.   R   RR   RÄ   (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyRv   ¡  s    N(   RC   RD   RE   R   RÅ   R0   R1   R    R{   Rt   Rv   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   ¢  s   		
c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s6   Define self.rfile and self.wfile for datagram sockets.c         C   so   y d d l  m } Wn! t k
 r7 d d l m } n X|  j \ |  _ |  _ | |  j É |  _ | É  |  _ d  S(   Niˇˇˇˇ(   t   StringIO(   t	   cStringIORÖ   t   ImportErrorR;   t   packetR.   RÄ   RÇ   (   R"   RÖ   (    (    s"   /usr/lib/python2.7/SocketServer.pyRt   —  s    c         C   s#   |  j  j |  j j É  |  j É d  S(   N(   R.   t   sendtoRÇ   t   getvalueR<   (   R"   (    (    s"   /usr/lib/python2.7/SocketServer.pyRv   ⁄  s    (   RC   RD   RE   Rt   Rv   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyR   Õ  s   		(    (    (    (    (   RE   t   __version__R.   R   t   sysR`   R   R   Rá   t   dummy_threadingt   __all__t   hasattrt   extendR   R   R    R   R
   R	   R   R   R   R   R   R   R   R   R   R   R   (    (    (    s"   /usr/lib/python2.7/SocketServer.pyt   <module>x   sH   			»~K.+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            r"""File-like objects that read from or write to a string buffer.

This implements (nearly) all stdio methods.

f = StringIO()      # ready for writing
f = StringIO(buf)   # ready for reading
f.close()           # explicitly release resources held
flag = f.isatty()   # always false
pos = f.tell()      # get current position
f.seek(pos)         # set current position
f.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF
buf = f.read()      # read until EOF
buf = f.read(n)     # read up to n bytes
buf = f.readline()  # read until end of line ('\n') or EOF
list = f.readlines()# list of f.readline() results until EOF
f.truncate([size])  # truncate file at to at most size (default: current pos)
f.write(buf)        # write at current position
f.writelines(list)  # for line in list: f.write(line)
f.getvalue()        # return whole file's contents as a string

Notes:
- Using a real file is often faster (but less convenient).
- There's also a much faster implementation in C, called cStringIO, but
  it's not subclassable.
- fileno() is left unimplemented so that code which uses it triggers
  an exception early.
- Seeking far beyond EOF and then writing will insert real null
  bytes that occupy space in the buffer.
- There's a simple test set (see end of this file).
"""
try:
    from errno import EINVAL
except ImportError:
    EINVAL = 22

__all__ = ["StringIO"]

def _complain_ifclosed(closed):
    if closed:
        raise ValueError, "I/O operation on closed file"

class StringIO:
    """class StringIO([buffer])

    When a StringIO object is created, it can be initialized to an existing
    string by passing the string to the constructor. If no string is given,
    the StringIO will start empty.

    The StringIO object can accept either Unicode or 8-bit strings, but
    mixing the two may take some care. If both are used, 8-bit strings that
    cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause
    a UnicodeError to be raised when getvalue() is called.
    """
    def __init__(self, buf = ''):
        # Force self.buf to be a string or unicode
        if not isinstance(buf, basestring):
            buf = str(buf)
        self.buf = buf
        self.len = len(buf)
        self.buflist = []
        self.pos = 0
        self.closed = False
        self.softspace = 0

    def __iter__(self):
        return self

    def next(self):
        """A file object is its own iterator, for example iter(f) returns f
        (unless f is closed). When a file is used as an iterator, typically
        in a for loop (for example, for line in f: print line), the next()
        method is called repeatedly. This method returns the next input line,
        or raises StopIteration when EOF is hit.
        """
        _complain_ifclosed(self.closed)
        r = self.readline()
        if not r:
            raise StopIteration
        return r

    def close(self):
        """Free the memory buffer.
        """
        if not self.closed:
            self.closed = True
            del self.buf, self.pos

    def isatty(self):
        """Returns False because StringIO objects are not connected to a
        tty-like device.
        """
        _complain_ifclosed(self.closed)
        return False

    def seek(self, pos, mode = 0):
        """Set the file's current position.

        The mode argument is optional and defaults to 0 (absolute file
        positioning); other values are 1 (seek relative to the current
        position) and 2 (seek relative to the file's end).

        There is no return value.
        """
        _complain_ifclosed(self.closed)
        if self.buflist:
            self.buf += ''.join(self.buflist)
            self.buflist = []
        if mode == 1:
            pos += self.pos
        elif mode == 2:
            pos += self.len
        self.pos = max(0, pos)

    def tell(self):
        """Return the file's current position."""
        _complain_ifclosed(self.closed)
        return self.pos

    def read(self, n = -1):
        """Read at most size bytes from the file
        (less if the read hits EOF before obtaining size bytes).

        If the size argument is negative or omitted, read all data until EOF
        is reached. The bytes are returned as a string object. An empty
        string is returned when EOF is encountered immediately.
        """
        _complain_ifclosed(self.closed)
        if self.buflist:
            self.buf += ''.join(self.buflist)
            self.buflist = []
        if n is None or n < 0:
            newpos = self.len
        else:
            newpos = min(self.pos+n, self.len)
        r = self.buf[self.pos:newpos]
        self.pos = newpos
        return r

    def readline(self, length=None):
        r"""Read one entire line from the file.

        A trailing newline character is kept in the string (but may be absent
        when a file ends with an incomplete line). If the size argument is
        present and non-negative, it is a maximum byte count (including the
        trailing newline) and an incomplete line may be returned.

        An empty string is returned only when EOF is encountered immediately.

        Note: Unlike stdio's fgets(), the returned string contains null
        characters ('\0') if they occurred in the input.
        """
        _complain_ifclosed(self.closed)
        if self.buflist:
            self.buf += ''.join(self.buflist)
            self.buflist = []
        i = self.buf.find('\n', self.pos)
        if i < 0:
            newpos = self.len
        else:
            newpos = i+1
        if length is not None and length >= 0:
            if self.pos + length < newpos:
                newpos = self.pos + length
        r = self.buf[self.pos:newpos]
        self.pos = newpos
        return r

    def readlines(self, sizehint = 0):
        """Read until EOF using readline() and return a list containing the
        lines thus read.

        If the optional sizehint argument is present, instead of reading up
        to EOF, whole lines totalling approximately sizehint bytes (or more
        to accommodate a final whole line).
        """
        total = 0
        lines = []
        line = self.readline()
        while line:
            lines.append(line)
            total += len(line)
            if 0 < sizehint <= total:
                break
            line = self.readline()
        return lines

    def truncate(self, size=None):
        """Truncate the file's size.

        If the optional size argument is present, the file is truncated to
        (at most) that size. The size defaults to the current position.
        The current file position is not changed unless the position
        is beyond the new file size.

        If the specified size exceeds the file's current size, the
        file remains unchanged.
        """
        _complain_ifclosed(self.closed)
        if size is None:
            size = self.pos
        elif size < 0:
            raise IOError(EINVAL, "Negative size not allowed")
        elif size < self.pos:
            self.pos = size
        self.buf = self.getvalue()[:size]
        self.len = size

    def write(self, s):
        """Write a string to the file.

        There is no return value.
        """
        _complain_ifclosed(self.closed)
        if not s: return
        # Force s to be a string or unicode
        if not isinstance(s, basestring):
            s = str(s)
        spos = self.pos
        slen = self.len
        if spos == slen:
            self.buflist.append(s)
            self.len = self.pos = spos + len(s)
            return
        if spos > slen:
            self.buflist.append('\0'*(spos - slen))
            slen = spos
        newpos = spos + len(s)
        if spos < slen:
            if self.buflist:
                self.buf += ''.join(self.buflist)
            self.buflist = [self.buf[:spos], s, self.buf[newpos:]]
            self.buf = ''
            if newpos > slen:
                slen = newpos
        else:
            self.buflist.append(s)
            slen = newpos
        self.len = slen
        self.pos = newpos

    def writelines(self, iterable):
        """Write a sequence of strings to the file. The sequence can be any
        iterable object producing strings, typically a list of strings. There
        is no return value.

        (The name is intended to match readlines(); writelines() does not add
        line separators.)
        """
        write = self.write
        for line in iterable:
            write(line)

    def flush(self):
        """Flush the internal buffer
        """
        _complain_ifclosed(self.closed)

    def getvalue(self):
        """
        Retrieve the entire contents of the "file" at any time before
        the StringIO object's close() method is called.

        The StringIO object can accept either Unicode or 8-bit strings,
        but mixing the two may take some care. If both are used, 8-bit
        strings that cannot be interpreted as 7-bit ASCII (that use the
        8th bit) will cause a UnicodeError to be raised when getvalue()
        is called.
        """
        _complain_ifclosed(self.closed)
        if self.buflist:
            self.buf += ''.join(self.buflist)
            self.buflist = []
        return self.buf


# A little test suite

def test():
    import sys
    if sys.argv[1:]:
        file = sys.argv[1]
    else:
        file = '/etc/passwd'
    lines = open(file, 'r').readlines()
    text = open(file, 'r').read()
    f = StringIO()
    for line in lines[:-2]:
        f.write(line)
    f.writelines(lines[-2:])
    if f.getvalue() != text:
        raise RuntimeError, 'write failed'
    length = f.tell()
    print 'File length =', length
    f.seek(len(lines[0]))
    f.write(lines[1])
    f.seek(0)
    print 'First line =', repr(f.readline())
    print 'Position =', f.tell()
    line = f.readline()
    print 'Second line =', repr(line)
    f.seek(-len(line), 1)
    line2 = f.read(len(line))
    if line != line2:
        raise RuntimeError, 'bad result after seek back'
    f.seek(len(line2), 1)
    list = f.readlines()
    line = list[-1]
    f.seek(f.tell() - len(line))
    line2 = f.read()
    if line != line2:
        raise RuntimeError, 'bad result after seek back from EOF'
    print 'Read', len(list), 'more lines'
    print 'File length =', f.tell()
    if f.tell() != length:
        raise RuntimeError, 'bad length'
    f.truncate(length/2)
    f.seek(0, 2)
    print 'Truncated length =', f.tell()
    if f.tell() != length/2:
        raise RuntimeError, 'truncate did not adjust length'
    f.close()

if __name__ == '__main__':
    test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   s|   d  Z  y d d l m Z Wn e k
 r3 d Z n Xd g Z d Ñ  Z d d
 d Ñ  É  YZ d Ñ  Z e d k rx e É  n  d	 S(   s
  File-like objects that read from or write to a string buffer.

This implements (nearly) all stdio methods.

f = StringIO()      # ready for writing
f = StringIO(buf)   # ready for reading
f.close()           # explicitly release resources held
flag = f.isatty()   # always false
pos = f.tell()      # get current position
f.seek(pos)         # set current position
f.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF
buf = f.read()      # read until EOF
buf = f.read(n)     # read up to n bytes
buf = f.readline()  # read until end of line ('\n') or EOF
list = f.readlines()# list of f.readline() results until EOF
f.truncate([size])  # truncate file at to at most size (default: current pos)
f.write(buf)        # write at current position
f.writelines(list)  # for line in list: f.write(line)
f.getvalue()        # return whole file's contents as a string

Notes:
- Using a real file is often faster (but less convenient).
- There's also a much faster implementation in C, called cStringIO, but
  it's not subclassable.
- fileno() is left unimplemented so that code which uses it triggers
  an exception early.
- Seeking far beyond EOF and then writing will insert real null
  bytes that occupy space in the buffer.
- There's a simple test set (see end of this file).
iˇˇˇˇ(   t   EINVALi   t   StringIOc         C   s   |  r t  d Ç n  d  S(   Ns   I/O operation on closed file(   t
   ValueError(   t   closed(    (    s   /usr/lib/python2.7/StringIO.pyt   _complain_ifclosed&   s    c           B   sß   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d	 Ñ  Z	 d
 d Ñ Z
 d d Ñ Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sÙ  class StringIO([buffer])

    When a StringIO object is created, it can be initialized to an existing
    string by passing the string to the constructor. If no string is given,
    the StringIO will start empty.

    The StringIO object can accept either Unicode or 8-bit strings, but
    mixing the two may take some care. If both are used, 8-bit strings that
    cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause
    a UnicodeError to be raised when getvalue() is called.
    t    c         C   s^   t  | t É s t | É } n  | |  _ t | É |  _ g  |  _ d |  _ t |  _ d |  _	 d  S(   Ni    (
   t
   isinstancet
   basestringt   strt   buft   lent   buflistt   post   FalseR   t	   softspace(   t   selfR	   (    (    s   /usr/lib/python2.7/StringIO.pyt   __init__6   s    				c         C   s   |  S(   N(    (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   __iter__A   s    c         C   s,   t  |  j É |  j É  } | s( t Ç n  | S(   s_  A file object is its own iterator, for example iter(f) returns f
        (unless f is closed). When a file is used as an iterator, typically
        in a for loop (for example, for line in f: print line), the next()
        method is called repeatedly. This method returns the next input line,
        or raises StopIteration when EOF is hit.
        (   R   R   t   readlinet   StopIteration(   R   t   r(    (    s   /usr/lib/python2.7/StringIO.pyt   nextD   s
    	c         C   s%   |  j  s! t |  _  |  ` |  ` n  d S(   s    Free the memory buffer.
        N(   R   t   TrueR	   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   closeQ   s    		c         C   s   t  |  j É t S(   s_   Returns False because StringIO objects are not connected to a
        tty-like device.
        (   R   R   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   isattyX   s    i    c         C   sã   t  |  j É |  j r= |  j d j |  j É 7_ g  |  _ n  | d k rY | |  j 7} n | d k ru | |  j 7} n  t d | É |  _ d S(   s  Set the file's current position.

        The mode argument is optional and defaults to 0 (absolute file
        positioning); other values are 1 (seek relative to the current
        position) and 2 (seek relative to the file's end).

        There is no return value.
        R   i   i   i    N(   R   R   R   R	   t   joinR   R
   t   max(   R   R   t   mode(    (    s   /usr/lib/python2.7/StringIO.pyt   seek_   s    		c         C   s   t  |  j É |  j S(   s#   Return the file's current position.(   R   R   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   tellr   s    iˇˇˇˇc         C   sö   t  |  j É |  j r= |  j d j |  j É 7_ g  |  _ n  | d k sU | d k  ra |  j } n t |  j | |  j É } |  j |  j | !} | |  _ | S(   sE  Read at most size bytes from the file
        (less if the read hits EOF before obtaining size bytes).

        If the size argument is negative or omitted, read all data until EOF
        is reached. The bytes are returned as a string object. An empty
        string is returned when EOF is encountered immediately.
        R   i    N(	   R   R   R   R	   R   t   NoneR
   t   minR   (   R   t   nt   newposR   (    (    s   /usr/lib/python2.7/StringIO.pyt   readw   s    		c         C   s’   t  |  j É |  j r= |  j d j |  j É 7_ g  |  _ n  |  j j d |  j É } | d k  rm |  j } n
 | d } | d k	 rµ | d k rµ |  j | | k  rµ |  j | } qµ n  |  j |  j | !} | |  _ | S(   s%  Read one entire line from the file.

        A trailing newline character is kept in the string (but may be absent
        when a file ends with an incomplete line). If the size argument is
        present and non-negative, it is a maximum byte count (including the
        trailing newline) and an incomplete line may be returned.

        An empty string is returned only when EOF is encountered immediately.

        Note: Unlike stdio's fgets(), the returned string contains null
        characters ('\0') if they occurred in the input.
        R   s   
i    i   N(	   R   R   R   R	   R   t   findR   R
   R   (   R   t   lengtht   iR!   R   (    (    s   /usr/lib/python2.7/StringIO.pyR   ã   s    	
	c         C   sr   d } g  } |  j  É  } xS | rm | j | É | t | É 7} d | k  oU | k n r^ Pn  |  j  É  } q W| S(   s'  Read until EOF using readline() and return a list containing the
        lines thus read.

        If the optional sizehint argument is present, instead of reading up
        to EOF, whole lines totalling approximately sizehint bytes (or more
        to accommodate a final whole line).
        i    (   R   t   appendR
   (   R   t   sizehintt   totalt   linest   line(    (    s   /usr/lib/python2.7/StringIO.pyt	   readlines®   s    	c         C   s~   t  |  j É | d k r% |  j } n9 | d k  rC t t d É Ç n | |  j k  r^ | |  _ n  |  j É  |  |  _ | |  _ d S(   sÑ  Truncate the file's size.

        If the optional size argument is present, the file is truncated to
        (at most) that size. The size defaults to the current position.
        The current file position is not changed unless the position
        is beyond the new file size.

        If the specified size exceeds the file's current size, the
        file remains unchanged.
        i    s   Negative size not allowedN(	   R   R   R   R   t   IOErrorR    t   getvalueR	   R
   (   R   t   size(    (    s   /usr/lib/python2.7/StringIO.pyt   truncateª   s    c         C   s^  t  |  j É | s d St | t É s5 t | É } n  |  j } |  j } | | k rÅ |  j j | É | t | É |  _ |  _ d S| | k rÆ |  j j d | | É | } n  | t | É } | | k  r2|  j rÒ |  j	 d j
 |  j É 7_	 n  |  j	 |  | |  j	 | g |  _ d |  _	 | | k rH| } qHn |  j j | É | } | |  _ | |  _ d S(   sG   Write a string to the file.

        There is no return value.
        Ns    R   (   R   R   R   R   R   R   R
   R   R&   R	   R   (   R   t   st   spost   slenR!   (    (    s   /usr/lib/python2.7/StringIO.pyt   write–   s4     				 		c         C   s(   |  j  } x | D] } | | É q Wd S(   s  Write a sequence of strings to the file. The sequence can be any
        iterable object producing strings, typically a list of strings. There
        is no return value.

        (The name is intended to match readlines(); writelines() does not add
        line separators.)
        N(   R3   (   R   t   iterableR3   R*   (    (    s   /usr/lib/python2.7/StringIO.pyt
   writelinesÒ   s    	c         C   s   t  |  j É d S(   s"   Flush the internal buffer
        N(   R   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   flush˝   s    c         C   sD   t  |  j É |  j r= |  j d j |  j É 7_ g  |  _ n  |  j S(   s∫  
        Retrieve the entire contents of the "file" at any time before
        the StringIO object's close() method is called.

        The StringIO object can accept either Unicode or 8-bit strings,
        but mixing the two may take some care. If both are used, 8-bit
        strings that cannot be interpreted as 7-bit ASCII (that use the
        8th bit) will cause a UnicodeError to be raised when getvalue()
        is called.
        R   (   R   R   R   R	   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyR-     s
    	N(   t   __name__t
   __module__t   __doc__R   R   R   R   R   R   R   R"   R   R   R+   R/   R3   R5   R6   R-   (    (    (    s   /usr/lib/python2.7/StringIO.pyR   *   s    						!		c    	      C   sç  d d  l  }  |  j d r) |  j d } n d } t | d É j É  } t | d É j É  } t É  } x | d  D] } | j | É qm W| j | d É | j É  | k r≥ t	 d Ç n  | j
 É  } d G| GH| j t | d É É | j | d É | j d É d	 Gt | j É  É GHd
 G| j
 É  GH| j É  } d Gt | É GH| j t | É d É | j t | É É } | | k rÄt	 d Ç n  | j t | É d É | j É  } | d } | j | j
 É  t | É É | j É  } | | k rÌt	 d Ç n  d Gt | É Gd GHd G| j
 É  GH| j
 É  | k r-t	 d Ç n  | j | d É | j d d É d G| j
 É  GH| j
 É  | d k rt	 d Ç n  | j É  d  S(   Niˇˇˇˇi   s   /etc/passwdR   i˛ˇˇˇs   write faileds   File length =i    s   First line =s
   Position =s   Second line =s   bad result after seek backs#   bad result after seek back from EOFt   Reads
   more liness
   bad lengthi   s   Truncated length =s   truncate did not adjust length(   t   syst   argvt   openR+   R"   R   R3   R5   R-   t   RuntimeErrorR   R   R
   t   reprR   R/   R   (	   R;   t   fileR)   t   textt   fR*   R$   t   line2t   list(    (    s   /usr/lib/python2.7/StringIO.pyt   test  sT    		
t   __main__N(    (	   R9   t   errnoR    t   ImportErrort   __all__R   R   RE   R7   (    (    (    s   /usr/lib/python2.7/StringIO.pyt   <module>   s   
		Ï	-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # This file exists as a helper for the test.test_frozen module.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """A more or less complete user-defined wrapper around dictionary objects."""

class UserDict:
    def __init__(*args, **kwargs):
        if not args:
            raise TypeError("descriptor '__init__' of 'UserDict' object "
                            "needs an argument")
        self = args[0]
        args = args[1:]
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        if args:
            dict = args[0]
        elif 'dict' in kwargs:
            dict = kwargs.pop('dict')
            import warnings
            warnings.warn("Passing 'dict' as keyword argument is "
                          "deprecated", PendingDeprecationWarning,
                          stacklevel=2)
        else:
            dict = None
        self.data = {}
        if dict is not None:
            self.update(dict)
        if len(kwargs):
            self.update(kwargs)
    def __repr__(self): return repr(self.data)
    def __cmp__(self, dict):
        if isinstance(dict, UserDict):
            return cmp(self.data, dict.data)
        else:
            return cmp(self.data, dict)
    __hash__ = None # Avoid Py3k warning
    def __len__(self): return len(self.data)
    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        if hasattr(self.__class__, "__missing__"):
            return self.__class__.__missing__(self, key)
        raise KeyError(key)
    def __setitem__(self, key, item): self.data[key] = item
    def __delitem__(self, key): del self.data[key]
    def clear(self): self.data.clear()
    def copy(self):
        if self.__class__ is UserDict:
            return UserDict(self.data.copy())
        import copy
        data = self.data
        try:
            self.data = {}
            c = copy.copy(self)
        finally:
            self.data = data
        c.update(self)
        return c
    def keys(self): return self.data.keys()
    def items(self): return self.data.items()
    def iteritems(self): return self.data.iteritems()
    def iterkeys(self): return self.data.iterkeys()
    def itervalues(self): return self.data.itervalues()
    def values(self): return self.data.values()
    def has_key(self, key): return key in self.data
    def update(*args, **kwargs):
        if not args:
            raise TypeError("descriptor 'update' of 'UserDict' object "
                            "needs an argument")
        self = args[0]
        args = args[1:]
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        if args:
            dict = args[0]
        elif 'dict' in kwargs:
            dict = kwargs.pop('dict')
            import warnings
            warnings.warn("Passing 'dict' as keyword argument is deprecated",
                          PendingDeprecationWarning, stacklevel=2)
        else:
            dict = None
        if dict is None:
            pass
        elif isinstance(dict, UserDict):
            self.data.update(dict.data)
        elif isinstance(dict, type({})) or not hasattr(dict, 'items'):
            self.data.update(dict)
        else:
            for k, v in dict.items():
                self[k] = v
        if len(kwargs):
            self.data.update(kwargs)
    def get(self, key, failobj=None):
        if key not in self:
            return failobj
        return self[key]
    def setdefault(self, key, failobj=None):
        if key not in self:
            self[key] = failobj
        return self[key]
    def pop(self, key, *args):
        return self.data.pop(key, *args)
    def popitem(self):
        return self.data.popitem()
    def __contains__(self, key):
        return key in self.data
    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d

class IterableUserDict(UserDict):
    def __iter__(self):
        return iter(self.data)

import _abcoll
_abcoll.MutableMapping.register(IterableUserDict)


class DictMixin:
    # Mixin defining all dictionary methods for classes that already have
    # a minimum dictionary interface including getitem, setitem, delitem,
    # and keys. Without knowledge of the subclass constructor, the mixin
    # does not define __init__() or copy().  In addition to the four base
    # methods, progressively more efficiency comes with defining
    # __contains__(), __iter__(), and iteritems().

    # second level definitions support higher levels
    def __iter__(self):
        for k in self.keys():
            yield k
    def has_key(self, key):
        try:
            self[key]
        except KeyError:
            return False
        return True
    def __contains__(self, key):
        return self.has_key(key)

    # third level takes advantage of second level definitions
    def iteritems(self):
        for k in self:
            yield (k, self[k])
    def iterkeys(self):
        return self.__iter__()

    # fourth level uses definitions from lower levels
    def itervalues(self):
        for _, v in self.iteritems():
            yield v
    def values(self):
        return [v for _, v in self.iteritems()]
    def items(self):
        return list(self.iteritems())
    def clear(self):
        for key in self.keys():
            del self[key]
    def setdefault(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            self[key] = default
        return default
    def pop(self, key, *args):
        if len(args) > 1:
            raise TypeError, "pop expected at most 2 arguments, got "\
                              + repr(1 + len(args))
        try:
            value = self[key]
        except KeyError:
            if args:
                return args[0]
            raise
        del self[key]
        return value
    def popitem(self):
        try:
            k, v = self.iteritems().next()
        except StopIteration:
            raise KeyError, 'container is empty'
        del self[k]
        return (k, v)
    def update(self, other=None, **kwargs):
        # Make progressively weaker assumptions about "other"
        if other is None:
            pass
        elif hasattr(other, 'iteritems'):  # iteritems saves memory and lookups
            for k, v in other.iteritems():
                self[k] = v
        elif hasattr(other, 'keys'):
            for k in other.keys():
                self[k] = other[k]
        else:
            for k, v in other:
                self[k] = v
        if kwargs:
            self.update(kwargs)
    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default
    def __repr__(self):
        return repr(dict(self.iteritems()))
    def __cmp__(self, other):
        if other is None:
            return 1
        if isinstance(other, DictMixin):
            other = dict(other.iteritems())
        return cmp(dict(self.iteritems()), other)
    def __len__(self):
        return len(self.keys())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   sb   d  Z  d d	 d Ñ  É  YZ d e f d Ñ  É  YZ d d l Z e j j e É d d
 d Ñ  É  YZ d S(   sG   A more or less complete user-defined wrapper around dictionary objects.t   UserDictc           B   sÏ   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z e d d Ñ É Z RS(   c          O   sÚ   |  s t  d É Ç n  |  d } |  d }  t |  É d k rT t  d t |  É É Ç n  |  rg |  d } nF d | k rß | j d É } d d  l } | j d t d d	 Én d  } i  | _ | d  k	 r“ | j | É n  t | É rÓ | j | É n  d  S(
   Ns<   descriptor '__init__' of 'UserDict' object needs an argumenti    i   s$   expected at most 1 arguments, got %dt   dictiˇˇˇˇs0   Passing 'dict' as keyword argument is deprecatedt
   stackleveli   (	   t	   TypeErrort   lent   popt   warningst   warnt   PendingDeprecationWarningt   Nonet   datat   update(   t   argst   kwargst   selfR   R   (    (    s   /usr/lib/python2.7/UserDict.pyt   __init__   s(    

	
	c         C   s   t  |  j É S(   N(   t   reprR
   (   R   (    (    s   /usr/lib/python2.7/UserDict.pyt   __repr__   s    c         C   s6   t  | t É r" t |  j | j É St |  j | É Sd  S(   N(   t
   isinstanceR    t   cmpR
   (   R   R   (    (    s   /usr/lib/python2.7/UserDict.pyt   __cmp__   s    c         C   s   t  |  j É S(   N(   R   R
   (   R   (    (    s   /usr/lib/python2.7/UserDict.pyt   __len__"   s    c         C   sO   | |  j  k r |  j  | St |  j d É r? |  j j |  | É St | É Ç d  S(   Nt   __missing__(   R
   t   hasattrt	   __class__R   t   KeyError(   R   t   key(    (    s   /usr/lib/python2.7/UserDict.pyt   __getitem__#   s
    c         C   s   | |  j  | <d  S(   N(   R
   (   R   R   t   item(    (    s   /usr/lib/python2.7/UserDict.pyt   __setitem__)   s    c         C   s   |  j  | =d  S(   N(   R
   (   R   R   (    (    s   /usr/lib/python2.7/UserDict.pyt   __delitem__*   s    c         C   s   |  j  j É  d  S(   N(   R
   t   clear(   R   (    (    s   /usr/lib/python2.7/UserDict.pyR   +   s    c         C   sq   |  j  t k r" t |  j j É  É Sd d  l } |  j } z i  |  _ | j |  É } Wd  | |  _ X| j |  É | S(   Niˇˇˇˇ(   R   R    R
   t   copyR   (   R   R    R
   t   c(    (    s   /usr/lib/python2.7/UserDict.pyR    ,   s    		
c         C   s   |  j  j É  S(   N(   R
   t   keys(   R   (    (    s   /usr/lib/python2.7/UserDict.pyR"   8   s    c         C   s   |  j  j É  S(   N(   R
   t   items(   R   (    (    s   /usr/lib/python2.7/UserDict.pyR#   9   s    c         C   s   |  j  j É  S(   N(   R
   t	   iteritems(   R   (    (    s   /usr/lib/python2.7/UserDict.pyR$   :   s    c         C   s   |  j  j É  S(   N(   R
   t   iterkeys(   R   (    (    s   /usr/lib/python2.7/UserDict.pyR%   ;   s    c         C   s   |  j  j É  S(   N(   R
   t
   itervalues(   R   (    (    s   /usr/lib/python2.7/UserDict.pyR&   <   s    c         C   s   |  j  j É  S(   N(   R
   t   values(   R   (    (    s   /usr/lib/python2.7/UserDict.pyR'   =   s    c         C   s   | |  j  k S(   N(   R
   (   R   R   (    (    s   /usr/lib/python2.7/UserDict.pyt   has_key>   s    c          O   sc  |  s t  d É Ç n  |  d } |  d }  t |  É d k rT t  d t |  É É Ç n  |  rg |  d } nF d | k rß | j d É } d d  l } | j d t d d	 Én d  } | d  k rº nÑ t | t É r· | j	 j
 | j	 É n_ t | t i  É É st | d
 É r| j	 j
 | É n' x$ | j É  D] \ } } | | | <q&Wt | É r_| j	 j
 | É n  d  S(   Ns:   descriptor 'update' of 'UserDict' object needs an argumenti    i   s$   expected at most 1 arguments, got %dR   iˇˇˇˇs0   Passing 'dict' as keyword argument is deprecatedR   i   R#   (   R   R   R   R   R   R   R	   R   R    R
   R   t   typeR   R#   (   R   R   R   R   R   t   kt   v(    (    s   /usr/lib/python2.7/UserDict.pyR   ?   s0    

	%c         C   s   | |  k r | S|  | S(   N(    (   R   R   t   failobj(    (    s   /usr/lib/python2.7/UserDict.pyt   get[   s    c         C   s!   | |  k r | |  | <n  |  | S(   N(    (   R   R   R,   (    (    s   /usr/lib/python2.7/UserDict.pyt
   setdefault_   s    c         G   s   |  j  j | | å S(   N(   R
   R   (   R   R   R   (    (    s   /usr/lib/python2.7/UserDict.pyR   c   s    c         C   s   |  j  j É  S(   N(   R
   t   popitem(   R   (    (    s   /usr/lib/python2.7/UserDict.pyR/   e   s    c         C   s   | |  j  k S(   N(   R
   (   R   R   (    (    s   /usr/lib/python2.7/UserDict.pyt   __contains__g   s    c         C   s(   |  É  } x | D] } | | | <q W| S(   N(    (   t   clst   iterablet   valuet   dR   (    (    s   /usr/lib/python2.7/UserDict.pyt   fromkeysi   s    	N(   t   __name__t
   __module__R   R   R   R	   t   __hash__R   R   R   R   R   R    R"   R#   R$   R%   R&   R'   R(   R   R-   R.   R   R/   R0   t   classmethodR5   (    (    (    s   /usr/lib/python2.7/UserDict.pyR       s2   																				t   IterableUserDictc           B   s   e  Z d  Ñ  Z RS(   c         C   s   t  |  j É S(   N(   t   iterR
   (   R   (    (    s   /usr/lib/python2.7/UserDict.pyt   __iter__q   s    (   R6   R7   R<   (    (    (    s   /usr/lib/python2.7/UserDict.pyR:   p   s   iˇˇˇˇNt	   DictMixinc           B   s™   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d d	 Ñ Z d
 Ñ  Z d Ñ  Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         c   s    x |  j  É  D] } | Vq Wd  S(   N(   R"   (   R   R*   (    (    s   /usr/lib/python2.7/UserDict.pyR<   Å   s    c         C   s%   y |  | Wn t  k
 r  t SXt S(   N(   R   t   Falset   True(   R   R   (    (    s   /usr/lib/python2.7/UserDict.pyR(   Ñ   s
    c         C   s   |  j  | É S(   N(   R(   (   R   R   (    (    s   /usr/lib/python2.7/UserDict.pyR0   ä   s    c         c   s$   x |  D] } | |  | f Vq Wd  S(   N(    (   R   R*   (    (    s   /usr/lib/python2.7/UserDict.pyR$   é   s    c         C   s
   |  j  É  S(   N(   R<   (   R   (    (    s   /usr/lib/python2.7/UserDict.pyR%   ë   s    c         c   s&   x |  j  É  D] \ } } | Vq Wd  S(   N(   R$   (   R   t   _R+   (    (    s   /usr/lib/python2.7/UserDict.pyR&   ï   s    c         C   s#   g  |  j  É  D] \ } } | ^ q S(   N(   R$   (   R   R@   R+   (    (    s   /usr/lib/python2.7/UserDict.pyR'   ò   s    c         C   s   t  |  j É  É S(   N(   t   listR$   (   R   (    (    s   /usr/lib/python2.7/UserDict.pyR#   ö   s    c         C   s"   x |  j  É  D] } |  | =q Wd  S(   N(   R"   (   R   R   (    (    s   /usr/lib/python2.7/UserDict.pyR   ú   s    c         C   s.   y |  | SWn t  k
 r) | |  | <n X| S(   N(   R   (   R   R   t   default(    (    s   /usr/lib/python2.7/UserDict.pyR.   ü   s
    c         G   sp   t  | É d k r2 t d t d t  | É É Ç n  y |  | } Wn" t k
 rd | r^ | d SÇ  n X|  | =| S(   Ni   s&   pop expected at most 2 arguments, got i    (   R   R   R   R   (   R   R   R   R3   (    (    s   /usr/lib/python2.7/UserDict.pyR   •   s    c         C   sJ   y |  j  É  j É  \ } } Wn t k
 r8 t d Ç n X|  | =| | f S(   Ns   container is empty(   R$   t   nextt   StopIterationR   (   R   R*   R+   (    (    s   /usr/lib/python2.7/UserDict.pyR/   ±   s    c         K   s∫   | d  k r në t | d É rH x | j É  D] \ } } | |  | <q+ WnX t | d É r xF | j É  D] } | | |  | <qd Wn! x | D] \ } } | |  | <qÜ W| r∂ |  j | É n  d  S(   NR$   R"   (   R	   R   R$   R"   R   (   R   t   otherR   R*   R+   (    (    s   /usr/lib/python2.7/UserDict.pyR   ∏   s    c         C   s%   y |  | SWn t  k
 r  | SXd  S(   N(   R   (   R   R   RB   (    (    s   /usr/lib/python2.7/UserDict.pyR-   «   s    c         C   s   t  t |  j É  É É S(   N(   R   R   R$   (   R   (    (    s   /usr/lib/python2.7/UserDict.pyR   Ã   s    c         C   sM   | d  k r d St | t É r4 t | j É  É } n  t t |  j É  É | É S(   Ni   (   R	   R   R=   R   R$   R   (   R   RE   (    (    s   /usr/lib/python2.7/UserDict.pyR   Œ   s
    c         C   s   t  |  j É  É S(   N(   R   R"   (   R   (    (    s   /usr/lib/python2.7/UserDict.pyR   ‘   s    N(   R6   R7   R<   R(   R0   R$   R%   R&   R'   R#   R   R	   R.   R   R/   R   R-   R   R   R   (    (    (    s   /usr/lib/python2.7/UserDict.pyR=   x   s"   														(    (    (   t   __doc__R    R:   t   _abcollt   MutableMappingt   registerR=   (    (    (    s   /usr/lib/python2.7/UserDict.pyt   <module>   s
   m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   s   d  S(   N(    (    (    (    s$   /usr/lib/python2.7/__phello__.foo.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   s/   d  Z  d d l Z d e j f d Ñ  É  YZ d S(   sA   A more or less complete user-defined wrapper around list objects.iˇˇˇˇNt   UserListc           B   s:  e  Z d! d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d! Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d  Ñ  Z$ RS("   c         C   ss   g  |  _  | d  k	 ro t | É t |  j  É k r= | |  j  (qo t | t É r] | j  |  j  (qo t | É |  _  n  d  S(   N(   t   datat   Nonet   typet
   isinstanceR    t   list(   t   selft   initlist(    (    s   /usr/lib/python2.7/UserList.pyt   __init__   s    	c         C   s   t  |  j É S(   N(   t   reprR   (   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __repr__   s    c         C   s   |  j  |  j | É k  S(   N(   R   t   _UserList__cast(   R   t   other(    (    s   /usr/lib/python2.7/UserList.pyt   __lt__   s    c         C   s   |  j  |  j | É k S(   N(   R   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __le__   s    c         C   s   |  j  |  j | É k S(   N(   R   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __eq__   s    c         C   s   |  j  |  j | É k S(   N(   R   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __ne__   s    c         C   s   |  j  |  j | É k S(   N(   R   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __gt__   s    c         C   s   |  j  |  j | É k S(   N(   R   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __ge__   s    c         C   s   t  | t É r | j S| Sd  S(   N(   R   R    R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __cast   s     c         C   s   t  |  j |  j | É É S(   N(   t   cmpR   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __cmp__   s    c         C   s   | |  j  k S(   N(   R   (   R   t   item(    (    s   /usr/lib/python2.7/UserList.pyt   __contains__   s    c         C   s   t  |  j É S(   N(   t   lenR   (   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __len__   s    c         C   s   |  j  | S(   N(   R   (   R   t   i(    (    s   /usr/lib/python2.7/UserList.pyt   __getitem__   s    c         C   s   | |  j  | <d  S(   N(   R   (   R   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __setitem__    s    c         C   s   |  j  | =d  S(   N(   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __delitem__!   s    c         C   s5   t  | d É } t  | d É } |  j |  j | | !É S(   Ni    (   t   maxt	   __class__R   (   R   R   t   j(    (    s   /usr/lib/python2.7/UserList.pyt   __getslice__"   s     c         C   sà   t  | d É } t  | d É } t | t É rC | j |  j | | +nA t | t |  j É É rn | |  j | | +n t | É |  j | | +d  S(   Ni    (   R   R   R    R   R   R   (   R   R   R    R   (    (    s   /usr/lib/python2.7/UserList.pyt   __setslice__%   s     c         C   s/   t  | d É } t  | d É } |  j | | 5d  S(   Ni    (   R   R   (   R   R   R    (    (    s   /usr/lib/python2.7/UserList.pyt   __delslice__-   s     c         C   sp   t  | t É r& |  j |  j | j É St  | t |  j É É rR |  j |  j | É S|  j |  j t | É É Sd  S(   N(   R   R    R   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __add__0   s
    c         C   sp   t  | t É r& |  j | j |  j É St  | t |  j É É rR |  j | |  j É S|  j t | É |  j É Sd  S(   N(   R   R    R   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __radd__7   s
    c         C   sg   t  | t É r$ |  j | j 7_ n? t  | t |  j É É rN |  j | 7_ n |  j t | É 7_ |  S(   N(   R   R    R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/UserList.pyt   __iadd__>   s    c         C   s   |  j  |  j | É S(   N(   R   R   (   R   t   n(    (    s   /usr/lib/python2.7/UserList.pyt   __mul__F   s    c         C   s   |  j  | 9_  |  S(   N(   R   (   R   R'   (    (    s   /usr/lib/python2.7/UserList.pyt   __imul__I   s    c         C   s   |  j  j | É d  S(   N(   R   t   append(   R   R   (    (    s   /usr/lib/python2.7/UserList.pyR*   L   s    c         C   s   |  j  j | | É d  S(   N(   R   t   insert(   R   R   R   (    (    s   /usr/lib/python2.7/UserList.pyR+   M   s    iˇˇˇˇc         C   s   |  j  j | É S(   N(   R   t   pop(   R   R   (    (    s   /usr/lib/python2.7/UserList.pyR,   N   s    c         C   s   |  j  j | É d  S(   N(   R   t   remove(   R   R   (    (    s   /usr/lib/python2.7/UserList.pyR-   O   s    c         C   s   |  j  j | É S(   N(   R   t   count(   R   R   (    (    s   /usr/lib/python2.7/UserList.pyR.   P   s    c         G   s   |  j  j | | å S(   N(   R   t   index(   R   R   t   args(    (    s   /usr/lib/python2.7/UserList.pyR/   Q   s    c         C   s   |  j  j É  d  S(   N(   R   t   reverse(   R   (    (    s   /usr/lib/python2.7/UserList.pyR1   R   s    c         O   s   |  j  j | | é  d  S(   N(   R   t   sort(   R   R0   t   kwds(    (    s   /usr/lib/python2.7/UserList.pyR2   S   s    c         C   s9   t  | t É r% |  j j | j É n |  j j | É d  S(   N(   R   R    R   t   extend(   R   R   (    (    s   /usr/lib/python2.7/UserList.pyR4   T   s    N(%   t   __name__t
   __module__R   R   R
   R   R   R   R   R   R   R   R   t   __hash__R   R   R   R   R   R!   R"   R#   R$   R%   R&   R(   t   __rmul__R)   R*   R+   R,   R-   R.   R/   R1   R2   R4   (    (    (    s   /usr/lib/python2.7/UserList.pyR       sD   
																													(   t   __doc__t   collectionst   MutableSequenceR    (    (    (    s   /usr/lib/python2.7/UserList.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #! /usr/bin/python2.7
## vim:ts=4:et:nowrap
"""A user-defined wrapper around string objects

Note: string objects have grown methods in Python 1.6
This module requires Python 1.6 or later.
"""
import sys
import collections

__all__ = ["UserString","MutableString"]

class UserString(collections.Sequence):
    def __init__(self, seq):
        if isinstance(seq, basestring):
            self.data = seq
        elif isinstance(seq, UserString):
            self.data = seq.data[:]
        else:
            self.data = str(seq)
    def __str__(self): return str(self.data)
    def __repr__(self): return repr(self.data)
    def __int__(self): return int(self.data)
    def __long__(self): return long(self.data)
    def __float__(self): return float(self.data)
    def __complex__(self): return complex(self.data)
    def __hash__(self): return hash(self.data)

    def __cmp__(self, string):
        if isinstance(string, UserString):
            return cmp(self.data, string.data)
        else:
            return cmp(self.data, string)
    def __contains__(self, char):
        return char in self.data

    def __len__(self): return len(self.data)
    def __getitem__(self, index): return self.__class__(self.data[index])
    def __getslice__(self, start, end):
        start = max(start, 0); end = max(end, 0)
        return self.__class__(self.data[start:end])

    def __add__(self, other):
        if isinstance(other, UserString):
            return self.__class__(self.data + other.data)
        elif isinstance(other, basestring):
            return self.__class__(self.data + other)
        else:
            return self.__class__(self.data + str(other))
    def __radd__(self, other):
        if isinstance(other, basestring):
            return self.__class__(other + self.data)
        else:
            return self.__class__(str(other) + self.data)
    def __mul__(self, n):
        return self.__class__(self.data*n)
    __rmul__ = __mul__
    def __mod__(self, args):
        return self.__class__(self.data % args)

    # the following methods are defined in alphabetical order:
    def capitalize(self): return self.__class__(self.data.capitalize())
    def center(self, width, *args):
        return self.__class__(self.data.center(width, *args))
    def count(self, sub, start=0, end=sys.maxint):
        return self.data.count(sub, start, end)
    def decode(self, encoding=None, errors=None): # XXX improve this?
        if encoding:
            if errors:
                return self.__class__(self.data.decode(encoding, errors))
            else:
                return self.__class__(self.data.decode(encoding))
        else:
            return self.__class__(self.data.decode())
    def encode(self, encoding=None, errors=None): # XXX improve this?
        if encoding:
            if errors:
                return self.__class__(self.data.encode(encoding, errors))
            else:
                return self.__class__(self.data.encode(encoding))
        else:
            return self.__class__(self.data.encode())
    def endswith(self, suffix, start=0, end=sys.maxint):
        return self.data.endswith(suffix, start, end)
    def expandtabs(self, tabsize=8):
        return self.__class__(self.data.expandtabs(tabsize))
    def find(self, sub, start=0, end=sys.maxint):
        return self.data.find(sub, start, end)
    def index(self, sub, start=0, end=sys.maxint):
        return self.data.index(sub, start, end)
    def isalpha(self): return self.data.isalpha()
    def isalnum(self): return self.data.isalnum()
    def isdecimal(self): return self.data.isdecimal()
    def isdigit(self): return self.data.isdigit()
    def islower(self): return self.data.islower()
    def isnumeric(self): return self.data.isnumeric()
    def isspace(self): return self.data.isspace()
    def istitle(self): return self.data.istitle()
    def isupper(self): return self.data.isupper()
    def join(self, seq): return self.data.join(seq)
    def ljust(self, width, *args):
        return self.__class__(self.data.ljust(width, *args))
    def lower(self): return self.__class__(self.data.lower())
    def lstrip(self, chars=None): return self.__class__(self.data.lstrip(chars))
    def partition(self, sep):
        return self.data.partition(sep)
    def replace(self, old, new, maxsplit=-1):
        return self.__class__(self.data.replace(old, new, maxsplit))
    def rfind(self, sub, start=0, end=sys.maxint):
        return self.data.rfind(sub, start, end)
    def rindex(self, sub, start=0, end=sys.maxint):
        return self.data.rindex(sub, start, end)
    def rjust(self, width, *args):
        return self.__class__(self.data.rjust(width, *args))
    def rpartition(self, sep):
        return self.data.rpartition(sep)
    def rstrip(self, chars=None): return self.__class__(self.data.rstrip(chars))
    def split(self, sep=None, maxsplit=-1):
        return self.data.split(sep, maxsplit)
    def rsplit(self, sep=None, maxsplit=-1):
        return self.data.rsplit(sep, maxsplit)
    def splitlines(self, keepends=0): return self.data.splitlines(keepends)
    def startswith(self, prefix, start=0, end=sys.maxint):
        return self.data.startswith(prefix, start, end)
    def strip(self, chars=None): return self.__class__(self.data.strip(chars))
    def swapcase(self): return self.__class__(self.data.swapcase())
    def title(self): return self.__class__(self.data.title())
    def translate(self, *args):
        return self.__class__(self.data.translate(*args))
    def upper(self): return self.__class__(self.data.upper())
    def zfill(self, width): return self.__class__(self.data.zfill(width))

class MutableString(UserString, collections.MutableSequence):
    """mutable string objects

    Python strings are immutable objects.  This has the advantage, that
    strings may be used as dictionary keys.  If this property isn't needed
    and you insist on changing string values in place instead, you may cheat
    and use MutableString.

    But the purpose of this class is an educational one: to prevent
    people from inventing their own mutable string class derived
    from UserString and than forget thereby to remove (override) the
    __hash__ method inherited from UserString.  This would lead to
    errors that would be very hard to track down.

    A faster and better solution is to rewrite your program using lists."""
    def __init__(self, string=""):
        from warnings import warnpy3k
        warnpy3k('the class UserString.MutableString has been removed in '
                    'Python 3.0', stacklevel=2)
        self.data = string

    # We inherit object.__hash__, so we must deny this explicitly
    __hash__ = None

    def __setitem__(self, index, sub):
        if isinstance(index, slice):
            if isinstance(sub, UserString):
                sub = sub.data
            elif not isinstance(sub, basestring):
                sub = str(sub)
            start, stop, step = index.indices(len(self.data))
            if step == -1:
                start, stop = stop+1, start+1
                sub = sub[::-1]
            elif step != 1:
                # XXX(twouters): I guess we should be reimplementing
                # the extended slice assignment/deletion algorithm here...
                raise TypeError, "invalid step in slicing assignment"
            start = min(start, stop)
            self.data = self.data[:start] + sub + self.data[stop:]
        else:
            if index < 0:
                index += len(self.data)
            if index < 0 or index >= len(self.data): raise IndexError
            self.data = self.data[:index] + sub + self.data[index+1:]
    def __delitem__(self, index):
        if isinstance(index, slice):
            start, stop, step = index.indices(len(self.data))
            if step == -1:
                start, stop = stop+1, start+1
            elif step != 1:
                # XXX(twouters): see same block in __setitem__
                raise TypeError, "invalid step in slicing deletion"
            start = min(start, stop)
            self.data = self.data[:start] + self.data[stop:]
        else:
            if index < 0:
                index += len(self.data)
            if index < 0 or index >= len(self.data): raise IndexError
            self.data = self.data[:index] + self.data[index+1:]
    def __setslice__(self, start, end, sub):
        start = max(start, 0); end = max(end, 0)
        if isinstance(sub, UserString):
            self.data = self.data[:start]+sub.data+self.data[end:]
        elif isinstance(sub, basestring):
            self.data = self.data[:start]+sub+self.data[end:]
        else:
            self.data =  self.data[:start]+str(sub)+self.data[end:]
    def __delslice__(self, start, end):
        start = max(start, 0); end = max(end, 0)
        self.data = self.data[:start] + self.data[end:]
    def immutable(self):
        return UserString(self.data)
    def __iadd__(self, other):
        if isinstance(other, UserString):
            self.data += other.data
        elif isinstance(other, basestring):
            self.data += other
        else:
            self.data += str(other)
        return self
    def __imul__(self, n):
        self.data *= n
        return self
    def insert(self, index, value):
        self[index:index] = value

if __name__ == "__main__":
    # execute the regression test to stdout, if called as a script:
    import os
    called_in_dir, called_as = os.path.split(sys.argv[0])
    called_as, py = os.path.splitext(called_as)
    if '-q' in sys.argv:
        from test import test_support
        test_support.verbose = 0
    __import__('test.test_' + called_as.lower())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         import sys

if hasattr(sys, 'gettotalrefcount'):
    from _sysconfigdata_d import *
else:
    from _sysconfigdata_nd import *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   sÙ   d  Z  d d l Z d d l Z d d g Z d e j f d Ñ  É  YZ d e e j f d Ñ  É  YZ e d k r d d l	 Z	 e	 j
 j e j d É \ Z Z e	 j
 j e É \ Z Z d	 e j k rŸ d d
 l m Z d e _ n  e d e j É  É n  d S(   sé   A user-defined wrapper around string objects

Note: string objects have grown methods in Python 1.6
This module requires Python 1.6 or later.
iˇˇˇˇNt
   UserStringt   MutableStringc           B   so  e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z d e j d Ñ Z d; d; d Ñ Z d; d; d Ñ Z d e j d Ñ Z d d Ñ Z d e j d Ñ Z d e j d Ñ Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d  Ñ  Z$ d! Ñ  Z% d" Ñ  Z& d# Ñ  Z' d$ Ñ  Z( d% Ñ  Z) d& Ñ  Z* d' Ñ  Z+ d; d( Ñ Z, d) Ñ  Z- d* d+ Ñ Z. d e j d, Ñ Z/ d e j d- Ñ Z0 d. Ñ  Z1 d/ Ñ  Z2 d; d0 Ñ Z3 d; d* d1 Ñ Z4 d; d* d2 Ñ Z5 d d3 Ñ Z6 d e j d4 Ñ Z7 d; d5 Ñ Z8 d6 Ñ  Z9 d7 Ñ  Z: d8 Ñ  Z; d9 Ñ  Z< d: Ñ  Z= RS(<   c         C   sM   t  | t É r | |  _ n. t  | t É r: | j |  _ n t | É |  _ d  S(   N(   t
   isinstancet
   basestringt   dataR    t   str(   t   selft   seq(    (    s    /usr/lib/python2.7/UserString.pyt   __init__   s
    c         C   s   t  |  j É S(   N(   R   R   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt   __str__   s    c         C   s   t  |  j É S(   N(   t   reprR   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt   __repr__   s    c         C   s   t  |  j É S(   N(   t   intR   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt   __int__   s    c         C   s   t  |  j É S(   N(   t   longR   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt   __long__   s    c         C   s   t  |  j É S(   N(   t   floatR   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt	   __float__   s    c         C   s   t  |  j É S(   N(   t   complexR   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt   __complex__   s    c         C   s   t  |  j É S(   N(   t   hashR   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt   __hash__   s    c         C   s6   t  | t É r" t |  j | j É St |  j | É Sd  S(   N(   R   R    t   cmpR   (   R   t   string(    (    s    /usr/lib/python2.7/UserString.pyt   __cmp__   s    c         C   s   | |  j  k S(   N(   R   (   R   t   char(    (    s    /usr/lib/python2.7/UserString.pyt   __contains__"   s    c         C   s   t  |  j É S(   N(   t   lenR   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt   __len__%   s    c         C   s   |  j  |  j | É S(   N(   t	   __class__R   (   R   t   index(    (    s    /usr/lib/python2.7/UserString.pyt   __getitem__&   s    c         C   s5   t  | d É } t  | d É } |  j |  j | | !É S(   Ni    (   t   maxR   R   (   R   t   startt   end(    (    s    /usr/lib/python2.7/UserString.pyt   __getslice__'   s     c         C   sg   t  | t É r& |  j |  j | j É St  | t É rI |  j |  j | É S|  j |  j t | É É Sd  S(   N(   R   R    R   R   R   R   (   R   t   other(    (    s    /usr/lib/python2.7/UserString.pyt   __add__+   s
    c         C   sA   t  | t É r# |  j | |  j É S|  j t | É |  j É Sd  S(   N(   R   R   R   R   R   (   R   R$   (    (    s    /usr/lib/python2.7/UserString.pyt   __radd__2   s    c         C   s   |  j  |  j | É S(   N(   R   R   (   R   t   n(    (    s    /usr/lib/python2.7/UserString.pyt   __mul__7   s    c         C   s   |  j  |  j | É S(   N(   R   R   (   R   t   args(    (    s    /usr/lib/python2.7/UserString.pyt   __mod__:   s    c         C   s   |  j  |  j j É  É S(   N(   R   R   t
   capitalize(   R   (    (    s    /usr/lib/python2.7/UserString.pyR+   >   s    c         G   s   |  j  |  j j | | å É S(   N(   R   R   t   center(   R   t   widthR)   (    (    s    /usr/lib/python2.7/UserString.pyR,   ?   s    i    c         C   s   |  j  j | | | É S(   N(   R   t   count(   R   t   subR!   R"   (    (    s    /usr/lib/python2.7/UserString.pyR.   A   s    c         C   s^   | rD | r( |  j  |  j j | | É É S|  j  |  j j | É É Sn |  j  |  j j É  É Sd  S(   N(   R   R   t   decode(   R   t   encodingt   errors(    (    s    /usr/lib/python2.7/UserString.pyR0   C   s
    c         C   s^   | rD | r( |  j  |  j j | | É É S|  j  |  j j | É É Sn |  j  |  j j É  É Sd  S(   N(   R   R   t   encode(   R   R1   R2   (    (    s    /usr/lib/python2.7/UserString.pyR3   K   s
    c         C   s   |  j  j | | | É S(   N(   R   t   endswith(   R   t   suffixR!   R"   (    (    s    /usr/lib/python2.7/UserString.pyR4   S   s    i   c         C   s   |  j  |  j j | É É S(   N(   R   R   t
   expandtabs(   R   t   tabsize(    (    s    /usr/lib/python2.7/UserString.pyR6   U   s    c         C   s   |  j  j | | | É S(   N(   R   t   find(   R   R/   R!   R"   (    (    s    /usr/lib/python2.7/UserString.pyR8   W   s    c         C   s   |  j  j | | | É S(   N(   R   R   (   R   R/   R!   R"   (    (    s    /usr/lib/python2.7/UserString.pyR   Y   s    c         C   s   |  j  j É  S(   N(   R   t   isalpha(   R   (    (    s    /usr/lib/python2.7/UserString.pyR9   [   s    c         C   s   |  j  j É  S(   N(   R   t   isalnum(   R   (    (    s    /usr/lib/python2.7/UserString.pyR:   \   s    c         C   s   |  j  j É  S(   N(   R   t	   isdecimal(   R   (    (    s    /usr/lib/python2.7/UserString.pyR;   ]   s    c         C   s   |  j  j É  S(   N(   R   t   isdigit(   R   (    (    s    /usr/lib/python2.7/UserString.pyR<   ^   s    c         C   s   |  j  j É  S(   N(   R   t   islower(   R   (    (    s    /usr/lib/python2.7/UserString.pyR=   _   s    c         C   s   |  j  j É  S(   N(   R   t	   isnumeric(   R   (    (    s    /usr/lib/python2.7/UserString.pyR>   `   s    c         C   s   |  j  j É  S(   N(   R   t   isspace(   R   (    (    s    /usr/lib/python2.7/UserString.pyR?   a   s    c         C   s   |  j  j É  S(   N(   R   t   istitle(   R   (    (    s    /usr/lib/python2.7/UserString.pyR@   b   s    c         C   s   |  j  j É  S(   N(   R   t   isupper(   R   (    (    s    /usr/lib/python2.7/UserString.pyRA   c   s    c         C   s   |  j  j | É S(   N(   R   t   join(   R   R   (    (    s    /usr/lib/python2.7/UserString.pyRB   d   s    c         G   s   |  j  |  j j | | å É S(   N(   R   R   t   ljust(   R   R-   R)   (    (    s    /usr/lib/python2.7/UserString.pyRC   e   s    c         C   s   |  j  |  j j É  É S(   N(   R   R   t   lower(   R   (    (    s    /usr/lib/python2.7/UserString.pyRD   g   s    c         C   s   |  j  |  j j | É É S(   N(   R   R   t   lstrip(   R   t   chars(    (    s    /usr/lib/python2.7/UserString.pyRE   h   s    c         C   s   |  j  j | É S(   N(   R   t	   partition(   R   t   sep(    (    s    /usr/lib/python2.7/UserString.pyRG   i   s    iˇˇˇˇc         C   s   |  j  |  j j | | | É É S(   N(   R   R   t   replace(   R   t   oldt   newt   maxsplit(    (    s    /usr/lib/python2.7/UserString.pyRI   k   s    c         C   s   |  j  j | | | É S(   N(   R   t   rfind(   R   R/   R!   R"   (    (    s    /usr/lib/python2.7/UserString.pyRM   m   s    c         C   s   |  j  j | | | É S(   N(   R   t   rindex(   R   R/   R!   R"   (    (    s    /usr/lib/python2.7/UserString.pyRN   o   s    c         G   s   |  j  |  j j | | å É S(   N(   R   R   t   rjust(   R   R-   R)   (    (    s    /usr/lib/python2.7/UserString.pyRO   q   s    c         C   s   |  j  j | É S(   N(   R   t
   rpartition(   R   RH   (    (    s    /usr/lib/python2.7/UserString.pyRP   s   s    c         C   s   |  j  |  j j | É É S(   N(   R   R   t   rstrip(   R   RF   (    (    s    /usr/lib/python2.7/UserString.pyRQ   u   s    c         C   s   |  j  j | | É S(   N(   R   t   split(   R   RH   RL   (    (    s    /usr/lib/python2.7/UserString.pyRR   v   s    c         C   s   |  j  j | | É S(   N(   R   t   rsplit(   R   RH   RL   (    (    s    /usr/lib/python2.7/UserString.pyRS   x   s    c         C   s   |  j  j | É S(   N(   R   t
   splitlines(   R   t   keepends(    (    s    /usr/lib/python2.7/UserString.pyRT   z   s    c         C   s   |  j  j | | | É S(   N(   R   t
   startswith(   R   t   prefixR!   R"   (    (    s    /usr/lib/python2.7/UserString.pyRV   {   s    c         C   s   |  j  |  j j | É É S(   N(   R   R   t   strip(   R   RF   (    (    s    /usr/lib/python2.7/UserString.pyRX   }   s    c         C   s   |  j  |  j j É  É S(   N(   R   R   t   swapcase(   R   (    (    s    /usr/lib/python2.7/UserString.pyRY   ~   s    c         C   s   |  j  |  j j É  É S(   N(   R   R   t   title(   R   (    (    s    /usr/lib/python2.7/UserString.pyRZ      s    c         G   s   |  j  |  j j | å  É S(   N(   R   R   t	   translate(   R   R)   (    (    s    /usr/lib/python2.7/UserString.pyR[   Ä   s    c         C   s   |  j  |  j j É  É S(   N(   R   R   t   upper(   R   (    (    s    /usr/lib/python2.7/UserString.pyR\   Ç   s    c         C   s   |  j  |  j j | É É S(   N(   R   R   t   zfill(   R   R-   (    (    s    /usr/lib/python2.7/UserString.pyR]   É   s    N(>   t   __name__t
   __module__R   R	   R   R   R   R   R   R   R   R   R   R   R#   R%   R&   R(   t   __rmul__R*   R+   R,   t   syst   maxintR.   t   NoneR0   R3   R4   R6   R8   R   R9   R:   R;   R<   R=   R>   R?   R@   RA   RB   RC   RD   RE   RG   RI   RM   RN   RO   RP   RQ   RR   RS   RT   RV   RX   RY   RZ   R[   R\   R]   (    (    (    s    /usr/lib/python2.7/UserString.pyR       sr   																																						c           B   sh   e  Z d  Z d d Ñ Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z RS(   sú  mutable string objects

    Python strings are immutable objects.  This has the advantage, that
    strings may be used as dictionary keys.  If this property isn't needed
    and you insist on changing string values in place instead, you may cheat
    and use MutableString.

    But the purpose of this class is an educational one: to prevent
    people from inventing their own mutable string class derived
    from UserString and than forget thereby to remove (override) the
    __hash__ method inherited from UserString.  This would lead to
    errors that would be very hard to track down.

    A faster and better solution is to rewrite your program using lists.t    c         C   s-   d d l  m } | d d d É| |  _ d  S(   Niˇˇˇˇ(   t   warnpy3ksA   the class UserString.MutableString has been removed in Python 3.0t
   stackleveli   (   t   warningsRe   R   (   R   R   Re   (    (    s    /usr/lib/python2.7/UserString.pyR   î   s    	c         C   s\  t  | t É rÈ t  | t É r* | j } n t  | t É sH t | É } n  | j t |  j É É \ } } } | d k r† | d | d } } | d  d  d Ö } n | d k r∏ t d Ç n  t	 | | É } |  j |  | |  j | |  _ no | d k  r| t |  j É 7} n  | d k  s,| t |  j É k r5t
 Ç n  |  j |  | |  j | d |  _ d  S(   Niˇˇˇˇi   s"   invalid step in slicing assignmenti    (   R   t   sliceR    R   R   R   t   indicesR   t	   TypeErrort   mint
   IndexError(   R   R   R/   R!   t   stopt   step(    (    s    /usr/lib/python2.7/UserString.pyt   __setitem__ù   s$    !"! 	c         C   s  t  | t É rô | j t |  j É É \ } } } | d k rT | d | d } } n | d k rl t d Ç n  t | | É } |  j |  |  j | |  _ nk | d k  rª | t |  j É 7} n  | d k  s‹ | t |  j É k rÂ t Ç n  |  j |  |  j | d |  _ d  S(   Niˇˇˇˇi   s    invalid step in slicing deletioni    (   R   Rh   Ri   R   R   Rj   Rk   Rl   (   R   R   R!   Rm   Rn   (    (    s    /usr/lib/python2.7/UserString.pyt   __delitem__≤   s    !! 	c         C   s¨   t  | d É } t  | d É } t | t É rR |  j |  | j |  j | |  _ nV t | t É rÉ |  j |  | |  j | |  _ n% |  j |  t | É |  j | |  _ d  S(   Ni    (   R    R   R    R   R   R   (   R   R!   R"   R/   (    (    s    /usr/lib/python2.7/UserString.pyt   __setslice__¡   s     %"c         C   s=   t  | d É } t  | d É } |  j |  |  j | |  _ d  S(   Ni    (   R    R   (   R   R!   R"   (    (    s    /usr/lib/python2.7/UserString.pyt   __delslice__…   s     c         C   s   t  |  j É S(   N(   R    R   (   R   (    (    s    /usr/lib/python2.7/UserString.pyt	   immutableÃ   s    c         C   s^   t  | t É r$ |  j | j 7_ n6 t  | t É rE |  j | 7_ n |  j t | É 7_ |  S(   N(   R   R    R   R   R   (   R   R$   (    (    s    /usr/lib/python2.7/UserString.pyt   __iadd__Œ   s    c         C   s   |  j  | 9_  |  S(   N(   R   (   R   R'   (    (    s    /usr/lib/python2.7/UserString.pyt   __imul__÷   s    c         C   s   | |  | | +d  S(   N(    (   R   R   t   value(    (    s    /usr/lib/python2.7/UserString.pyt   insertŸ   s    N(   R^   R_   t   __doc__R   Rc   R   Ro   Rp   Rq   Rr   Rs   Rt   Ru   Rw   (    (    (    s    /usr/lib/python2.7/UserString.pyR   Ö   s   							t   __main__i    s   -q(   t   test_supports
   test.test_(   Rx   Ra   t   collectionst   __all__t   SequenceR    t   MutableSequenceR   R^   t   ost   pathRR   t   argvt   called_in_dirt	   called_ast   splitextt   pyt   testRz   t   verboset
   __import__RD   (    (    (    s    /usr/lib/python2.7/UserString.pyt   <module>   s   xW                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """Load / save to libwww-perl (LWP) format files.

Actually, the format is slightly extended from that used by LWP's
(libwww-perl's) HTTP::Cookies, to avoid losing some RFC 2965 information
not recorded by LWP.

It uses the version string "2.0", though really there isn't an LWP Cookies
2.0 format.  This indicates that there is extra information in here
(domain_dot and # port_spec) while still being compatible with
libwww-perl, I hope.

"""

import time, re
from cookielib import (_warn_unhandled_exception, FileCookieJar, LoadError,
                       Cookie, MISSING_FILENAME_TEXT,
                       join_header_words, split_header_words,
                       iso2time, time2isoz)

def lwp_cookie_str(cookie):
    """Return string representation of Cookie in the LWP cookie file format.

    Actually, the format is extended a bit -- see module docstring.

    """
    h = [(cookie.name, cookie.value),
         ("path", cookie.path),
         ("domain", cookie.domain)]
    if cookie.port is not None: h.append(("port", cookie.port))
    if cookie.path_specified: h.append(("path_spec", None))
    if cookie.port_specified: h.append(("port_spec", None))
    if cookie.domain_initial_dot: h.append(("domain_dot", None))
    if cookie.secure: h.append(("secure", None))
    if cookie.expires: h.append(("expires",
                               time2isoz(float(cookie.expires))))
    if cookie.discard: h.append(("discard", None))
    if cookie.comment: h.append(("comment", cookie.comment))
    if cookie.comment_url: h.append(("commenturl", cookie.comment_url))

    keys = cookie._rest.keys()
    keys.sort()
    for k in keys:
        h.append((k, str(cookie._rest[k])))

    h.append(("version", str(cookie.version)))

    return join_header_words([h])

class LWPCookieJar(FileCookieJar):
    """
    The LWPCookieJar saves a sequence of "Set-Cookie3" lines.
    "Set-Cookie3" is the format used by the libwww-perl library, not known
    to be compatible with any browser, but which is easy to read and
    doesn't lose information about RFC 2965 cookies.

    Additional methods

    as_lwp_str(ignore_discard=True, ignore_expired=True)

    """

    def as_lwp_str(self, ignore_discard=True, ignore_expires=True):
        """Return cookies as a string of "\\n"-separated "Set-Cookie3" headers.

        ignore_discard and ignore_expires: see docstring for FileCookieJar.save

        """
        now = time.time()
        r = []
        for cookie in self:
            if not ignore_discard and cookie.discard:
                continue
            if not ignore_expires and cookie.is_expired(now):
                continue
            r.append("Set-Cookie3: %s" % lwp_cookie_str(cookie))
        return "\n".join(r+[""])

    def save(self, filename=None, ignore_discard=False, ignore_expires=False):
        if filename is None:
            if self.filename is not None: filename = self.filename
            else: raise ValueError(MISSING_FILENAME_TEXT)

        f = open(filename, "w")
        try:
            # There really isn't an LWP Cookies 2.0 format, but this indicates
            # that there is extra information in here (domain_dot and
            # port_spec) while still being compatible with libwww-perl, I hope.
            f.write("#LWP-Cookies-2.0\n")
            f.write(self.as_lwp_str(ignore_discard, ignore_expires))
        finally:
            f.close()

    def _really_load(self, f, filename, ignore_discard, ignore_expires):
        magic = f.readline()
        if not re.search(self.magic_re, magic):
            msg = ("%r does not look like a Set-Cookie3 (LWP) format "
                   "file" % filename)
            raise LoadError(msg)

        now = time.time()

        header = "Set-Cookie3:"
        boolean_attrs = ("port_spec", "path_spec", "domain_dot",
                         "secure", "discard")
        value_attrs = ("version",
                       "port", "path", "domain",
                       "expires",
                       "comment", "commenturl")

        try:
            while 1:
                line = f.readline()
                if line == "": break
                if not line.startswith(header):
                    continue
                line = line[len(header):].strip()

                for data in split_header_words([line]):
                    name, value = data[0]
                    standard = {}
                    rest = {}
                    for k in boolean_attrs:
                        standard[k] = False
                    for k, v in data[1:]:
                        if k is not None:
                            lc = k.lower()
                        else:
                            lc = None
                        # don't lose case distinction for unknown fields
                        if (lc in value_attrs) or (lc in boolean_attrs):
                            k = lc
                        if k in boolean_attrs:
                            if v is None: v = True
                            standard[k] = v
                        elif k in value_attrs:
                            standard[k] = v
                        else:
                            rest[k] = v

                    h = standard.get
                    expires = h("expires")
                    discard = h("discard")
                    if expires is not None:
                        expires = iso2time(expires)
                    if expires is None:
                        discard = True
                    domain = h("domain")
                    domain_specified = domain.startswith(".")
                    c = Cookie(h("version"), name, value,
                               h("port"), h("port_spec"),
                               domain, domain_specified, h("domain_dot"),
                               h("path"), h("path_spec"),
                               h("secure"),
                               expires,
                               discard,
                               h("comment"),
                               h("commenturl"),
                               rest)
                    if not ignore_discard and c.discard:
                        continue
                    if not ignore_expires and c.is_expired(now):
                        continue
                    self.set_cookie(c)

        except IOError:
            raise
        except Exception:
            _warn_unhandled_exception()
            raise LoadError("invalid Set-Cookie3 format file %r: %r" %
                            (filename, line))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   sÅ   d  Z  d d l Z d d l Z d d l m Z m Z m Z m Z m Z m	 Z	 m
 Z
 m Z m Z d Ñ  Z d e f d Ñ  É  YZ d S(   sµ  Load / save to libwww-perl (LWP) format files.

Actually, the format is slightly extended from that used by LWP's
(libwww-perl's) HTTP::Cookies, to avoid losing some RFC 2965 information
not recorded by LWP.

It uses the version string "2.0", though really there isn't an LWP Cookies
2.0 format.  This indicates that there is extra information in here
(domain_dot and # port_spec) while still being compatible with
libwww-perl, I hope.

iˇˇˇˇN(	   t   _warn_unhandled_exceptiont   FileCookieJart	   LoadErrort   Cookiet   MISSING_FILENAME_TEXTt   join_header_wordst   split_header_wordst   iso2timet	   time2isozc         C   s∑  |  j  |  j f d |  j f d |  j f g } |  j d k	 rU | j d |  j f É n  |  j rn | j d É n  |  j rá | j d É n  |  j	 r† | j d É n  |  j
 rπ | j d É n  |  j rÁ | j d t t |  j É É f É n  |  j r | j d É n  |  j r"| j d
 |  j f É n  |  j rD| j d |  j f É n  |  j j É  } | j É  x. | D]& } | j | t |  j | É f É qdW| j d t |  j É f É t | g É S(   sê   Return string representation of Cookie in the LWP cookie file format.

    Actually, the format is extended a bit -- see module docstring.

    t   patht   domaint   portt	   path_spect	   port_spect
   domain_dott   securet   expirest   discardt   commentt
   commenturlt   versionN(   R   N(   R   N(   R   N(   R   N(   R   N(   t   namet   valueR	   R
   R   t   Nonet   appendt   path_specifiedt   port_specifiedt   domain_initial_dotR   R   R   t   floatR   R   t   comment_urlt   _restt   keyst   sortt   strR   R   (   t   cookiet   hR   t   k(    (    s#   /usr/lib/python2.7/_LWPCookieJar.pyt   lwp_cookie_str   s8     	 	 	 	 	 		 	 	 
$t   LWPCookieJarc           B   s8   e  Z d  Z e e d Ñ Z d e e d Ñ Z d Ñ  Z RS(   s[  
    The LWPCookieJar saves a sequence of "Set-Cookie3" lines.
    "Set-Cookie3" is the format used by the libwww-perl library, not known
    to be compatible with any browser, but which is easy to read and
    doesn't lose information about RFC 2965 cookies.

    Additional methods

    as_lwp_str(ignore_discard=True, ignore_expired=True)

    c         C   sÄ   t  j  É  } g  } xW |  D]O } | r5 | j r5 q n  | rQ | j | É rQ q n  | j d t | É É q Wd j | d g É S(   sû   Return cookies as a string of "\n"-separated "Set-Cookie3" headers.

        ignore_discard and ignore_expires: see docstring for FileCookieJar.save

        s   Set-Cookie3: %ss   
t    (   t   timeR   t
   is_expiredR   R%   t   join(   t   selft   ignore_discardt   ignore_expirest   nowt   rR"   (    (    s#   /usr/lib/python2.7/_LWPCookieJar.pyt
   as_lwp_str>   s    c         C   sÅ   | d  k r6 |  j d  k	 r' |  j } q6 t t É Ç n  t | d É } z* | j d É | j |  j | | É É Wd  | j É  Xd  S(   Nt   ws   #LWP-Cookies-2.0
(   R   t   filenamet
   ValueErrorR   t   opent   writeR0   t   close(   R+   R2   R,   R-   t   f(    (    s#   /usr/lib/python2.7/_LWPCookieJar.pyt   saveN   s     c         C   s  | j  É  } t j |  j | É s: d | } t | É Ç n  t j É  } d } d }	 d }
 ykxd| j  É  } | d k rz Pn  | j | É sè q^ n  | t | É j É  } xt	 | g É D]} | d \ } } i  } i  } x |	 D] } t
 | | <qﬁ Wx´ | d D]ü \ } } | d  k	 r$| j É  } n d  } | |
 k sB| |	 k rK| } n  | |	 k ry| d  k rlt } n  | | | <q˝ | |
 k rí| | | <q˝ | | | <q˝ W| j } | d É } | d É } | d  k	 r‹t | É } n  | d  k rÒt } n  | d É } | j d É } t | d É | | | d	 É | d É | | | d É | d
 É | d É | d É | | | d É | d É | É } | rë| j rëqµ n  | r≠| j | É r≠qµ n  |  j | É qµ Wq^ WWnA t k
 rŸÇ  n. t k
 rt É  t d | | f É Ç n Xd  S(   Ns5   %r does not look like a Set-Cookie3 (LWP) format files   Set-Cookie3:R   R   R   R   R   R   R   R	   R
   R   R   R   R'   i    i   t   .s&   invalid Set-Cookie3 format file %r: %r(   R   R   R   R   R   (   R   R   R	   R
   R   R   R   (   t   readlinet   ret   searcht   magic_reR   R(   t
   startswitht   lent   stripR   t   FalseR   t   lowert   Truet   getR   R   R   R)   t
   set_cookiet   IOErrort	   ExceptionR    (   R+   R7   R2   R,   R-   t   magict   msgR.   t   headert   boolean_attrst   value_attrst   linet   dataR   R   t   standardt   restR$   t   vt   lcR#   R   R   R
   t   domain_specifiedt   c(    (    s#   /usr/lib/python2.7/_LWPCookieJar.pyt   _really_load]   så         	 							N(	   t   __name__t
   __module__t   __doc__RC   R0   R   RA   R8   RU   (    (    (    s#   /usr/lib/python2.7/_LWPCookieJar.pyR&   1   s   (   RX   R(   R;   t	   cookielibR    R   R   R   R   R   R   R   R   R%   R&   (    (    (    s#   /usr/lib/python2.7/_LWPCookieJar.pyt   <module>   s   @	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """Mozilla / Netscape cookie loading / saving."""

import re, time

from cookielib import (_warn_unhandled_exception, FileCookieJar, LoadError,
                       Cookie, MISSING_FILENAME_TEXT)

class MozillaCookieJar(FileCookieJar):
    """

    WARNING: you may want to backup your browser's cookies file if you use
    this class to save cookies.  I *think* it works, but there have been
    bugs in the past!

    This class differs from CookieJar only in the format it uses to save and
    load cookies to and from a file.  This class uses the Mozilla/Netscape
    `cookies.txt' format.  lynx uses this file format, too.

    Don't expect cookies saved while the browser is running to be noticed by
    the browser (in fact, Mozilla on unix will overwrite your saved cookies if
    you change them on disk while it's running; on Windows, you probably can't
    save at all while the browser is running).

    Note that the Mozilla/Netscape format will downgrade RFC2965 cookies to
    Netscape cookies on saving.

    In particular, the cookie version and port number information is lost,
    together with information about whether or not Path, Port and Discard were
    specified by the Set-Cookie2 (or Set-Cookie) header, and whether or not the
    domain as set in the HTTP header started with a dot (yes, I'm aware some
    domains in Netscape files start with a dot and some don't -- trust me, you
    really don't want to know any more about this).

    Note that though Mozilla and Netscape use the same format, they use
    slightly different headers.  The class saves cookies using the Netscape
    header by default (Mozilla can cope with that).

    """
    magic_re = "#( Netscape)? HTTP Cookie File"
    header = """\
# Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This is a generated file!  Do not edit.

"""

    def _really_load(self, f, filename, ignore_discard, ignore_expires):
        now = time.time()

        magic = f.readline()
        if not re.search(self.magic_re, magic):
            f.close()
            raise LoadError(
                "%r does not look like a Netscape format cookies file" %
                filename)

        try:
            while 1:
                line = f.readline()
                if line == "": break

                # last field may be absent, so keep any trailing tab
                if line.endswith("\n"): line = line[:-1]

                # skip comments and blank lines XXX what is $ for?
                if (line.strip().startswith(("#", "$")) or
                    line.strip() == ""):
                    continue

                domain, domain_specified, path, secure, expires, name, value = \
                        line.split("\t")
                secure = (secure == "TRUE")
                domain_specified = (domain_specified == "TRUE")
                if name == "":
                    # cookies.txt regards 'Set-Cookie: foo' as a cookie
                    # with no name, whereas cookielib regards it as a
                    # cookie with no value.
                    name = value
                    value = None

                initial_dot = domain.startswith(".")
                assert domain_specified == initial_dot

                discard = False
                if expires == "":
                    expires = None
                    discard = True

                # assume path_specified is false
                c = Cookie(0, name, value,
                           None, False,
                           domain, domain_specified, initial_dot,
                           path, False,
                           secure,
                           expires,
                           discard,
                           None,
                           None,
                           {})
                if not ignore_discard and c.discard:
                    continue
                if not ignore_expires and c.is_expired(now):
                    continue
                self.set_cookie(c)

        except IOError:
            raise
        except Exception:
            _warn_unhandled_exception()
            raise LoadError("invalid Netscape format cookies file %r: %r" %
                            (filename, line))

    def save(self, filename=None, ignore_discard=False, ignore_expires=False):
        if filename is None:
            if self.filename is not None: filename = self.filename
            else: raise ValueError(MISSING_FILENAME_TEXT)

        f = open(filename, "w")
        try:
            f.write(self.header)
            now = time.time()
            for cookie in self:
                if not ignore_discard and cookie.discard:
                    continue
                if not ignore_expires and cookie.is_expired(now):
                    continue
                if cookie.secure: secure = "TRUE"
                else: secure = "FALSE"
                if cookie.domain.startswith("."): initial_dot = "TRUE"
                else: initial_dot = "FALSE"
                if cookie.expires is not None:
                    expires = str(cookie.expires)
                else:
                    expires = ""
                if cookie.value is None:
                    # cookies.txt regards 'Set-Cookie: foo' as a cookie
                    # with no name, whereas cookielib regards it as a
                    # cookie with no value.
                    name = ""
                    value = cookie.name
                else:
                    name = cookie.name
                    value = cookie.value
                f.write(
                    "\t".join([cookie.domain, initial_dot, cookie.path,
                               secure, expires, name, value])+
                    "\n")
        finally:
            f.close()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   s`   d  Z  d d l Z d d l Z d d l m Z m Z m Z m Z m Z d e f d Ñ  É  YZ	 d S(   s+   Mozilla / Netscape cookie loading / saving.iˇˇˇˇN(   t   _warn_unhandled_exceptiont   FileCookieJart	   LoadErrort   Cookiet   MISSING_FILENAME_TEXTt   MozillaCookieJarc           B   s5   e  Z d  Z d Z d Z d Ñ  Z d e e d Ñ Z RS(   sí  

    WARNING: you may want to backup your browser's cookies file if you use
    this class to save cookies.  I *think* it works, but there have been
    bugs in the past!

    This class differs from CookieJar only in the format it uses to save and
    load cookies to and from a file.  This class uses the Mozilla/Netscape
    `cookies.txt' format.  lynx uses this file format, too.

    Don't expect cookies saved while the browser is running to be noticed by
    the browser (in fact, Mozilla on unix will overwrite your saved cookies if
    you change them on disk while it's running; on Windows, you probably can't
    save at all while the browser is running).

    Note that the Mozilla/Netscape format will downgrade RFC2965 cookies to
    Netscape cookies on saving.

    In particular, the cookie version and port number information is lost,
    together with information about whether or not Path, Port and Discard were
    specified by the Set-Cookie2 (or Set-Cookie) header, and whether or not the
    domain as set in the HTTP header started with a dot (yes, I'm aware some
    domains in Netscape files start with a dot and some don't -- trust me, you
    really don't want to know any more about this).

    Note that though Mozilla and Netscape use the same format, they use
    slightly different headers.  The class saves cookies using the Netscape
    header by default (Mozilla can cope with that).

    s   #( Netscape)? HTTP Cookie Filesr   # Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This is a generated file!  Do not edit.

c         C   s  t  j  É  } | j É  } t j |  j | É sJ | j É  t d | É Ç n  yÅxz| j É  } | d k rl Pn  | j d É rà | d  } n  | j É  j	 d É sP | j É  d k rµ qP n  | j
 d É \ } }	 }
 } } } } | d k } |	 d k }	 | d k r| } d  } n  | j	 d	 É } |	 | k s-t Ç t } | d k rNd  } t } n  t d
 | | d  t | |	 | |
 t | | | d  d  i  É } | rù| j rùqP n  | rπ| j | É rπqP n  |  j | É qP WWnA t k
 r·Ç  n. t k
 rt É  t d | | f É Ç n Xd  S(   Ns4   %r does not look like a Netscape format cookies filet    s   
iˇˇˇˇt   #t   $s   	t   TRUEt   .i    s+   invalid Netscape format cookies file %r: %r(   R   R   (   t   timet   readlinet   ret   searcht   magic_ret   closeR   t   endswitht   stript
   startswitht   splitt   Nonet   AssertionErrort   Falset   TrueR   t   discardt
   is_expiredt
   set_cookiet   IOErrort	   ExceptionR    (   t   selft   ft   filenamet   ignore_discardt   ignore_expirest   nowt   magict   linet   domaint   domain_specifiedt   patht   securet   expirest   namet   valuet   initial_dotR   t   c(    (    s'   /usr/lib/python2.7/_MozillaCookieJar.pyt   _really_load/   sd    
  $				c      
   C   sÇ  | d  k r6 |  j d  k	 r' |  j } q6 t t É Ç n  t | d É } z+| j |  j É t j É  } x|  D] } | rá | j rá qk n  | r£ | j	 | É r£ qk n  | j
 rµ d } n d } | j j d É r÷ d } n d } | j d  k	 r˝ t | j É }	 n d }	 | j d  k r$d }
 | j } n | j }
 | j } | j d j | j | | j | |	 |
 | g É d É qk WWd  | j É  Xd  S(   Nt   wR	   t   FALSER
   R   s   	s   
(   R   R    t
   ValueErrorR   t   opent   writet   headerR   R   R   R)   R&   R   R*   t   strR,   R+   t   joinR(   R   (   R   R    R!   R"   R   R#   t   cookieR)   R-   R*   R+   R,   (    (    s'   /usr/lib/python2.7/_MozillaCookieJar.pyt   saveq   s@     	 	 			N(	   t   __name__t
   __module__t   __doc__R   R5   R/   R   R   R9   (    (    (    s'   /usr/lib/python2.7/_MozillaCookieJar.pyR      s
   	B(
   R<   R   R   t	   cookielibR    R   R   R   R   R   (    (    (    s'   /usr/lib/python2.7/_MozillaCookieJar.pyt   <module>   s   (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """Record of phased-in incompatible language changes.

Each line is of the form:

    FeatureName = "_Feature(" OptionalRelease "," MandatoryRelease ","
                              CompilerFlag ")"

where, normally, OptionalRelease < MandatoryRelease, and both are 5-tuples
of the same form as sys.version_info:

    (PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
     PY_MINOR_VERSION, # the 1; an int
     PY_MICRO_VERSION, # the 0; an int
     PY_RELEASE_LEVEL, # "alpha", "beta", "candidate" or "final"; string
     PY_RELEASE_SERIAL # the 3; an int
    )

OptionalRelease records the first release in which

    from __future__ import FeatureName

was accepted.

In the case of MandatoryReleases that have not yet occurred,
MandatoryRelease predicts the release in which the feature will become part
of the language.

Else MandatoryRelease records when the feature became part of the language;
in releases at or after that, modules no longer need

    from __future__ import FeatureName

to use the feature in question, but may continue to use such imports.

MandatoryRelease may also be None, meaning that a planned feature got
dropped.

Instances of class _Feature have two corresponding methods,
.getOptionalRelease() and .getMandatoryRelease().

CompilerFlag is the (bitfield) flag that should be passed in the fourth
argument to the builtin function compile() to enable the feature in
dynamically compiled code.  This flag is stored in the .compiler_flag
attribute on _Future instances.  These values must match the appropriate
#defines of CO_xxx flags in Include/compile.h.

No feature line is ever to be deleted from this file.
"""

all_feature_names = [
    "nested_scopes",
    "generators",
    "division",
    "absolute_import",
    "with_statement",
    "print_function",
    "unicode_literals",
]

__all__ = ["all_feature_names"] + all_feature_names

# The CO_xxx symbols are defined here under the same names used by
# compile.h, so that an editor search will find them here.  However,
# they're not exported in __all__, because they don't really belong to
# this module.
CO_NESTED            = 0x0010   # nested_scopes
CO_GENERATOR_ALLOWED = 0        # generators (obsolete, was 0x1000)
CO_FUTURE_DIVISION   = 0x2000   # division
CO_FUTURE_ABSOLUTE_IMPORT = 0x4000 # perform absolute imports by default
CO_FUTURE_WITH_STATEMENT  = 0x8000   # with statement
CO_FUTURE_PRINT_FUNCTION  = 0x10000   # print function
CO_FUTURE_UNICODE_LITERALS = 0x20000 # unicode string literals

class _Feature:
    def __init__(self, optionalRelease, mandatoryRelease, compiler_flag):
        self.optional = optionalRelease
        self.mandatory = mandatoryRelease
        self.compiler_flag = compiler_flag

    def getOptionalRelease(self):
        """Return first release in which this feature was recognized.

        This is a 5-tuple, of the same form as sys.version_info.
        """

        return self.optional

    def getMandatoryRelease(self):
        """Return release in which this feature will become mandatory.

        This is a 5-tuple, of the same form as sys.version_info, or, if
        the feature was dropped, is None.
        """

        return self.mandatory

    def __repr__(self):
        return "_Feature" + repr((self.optional,
                                  self.mandatory,
                                  self.compiler_flag))

nested_scopes = _Feature((2, 1, 0, "beta",  1),
                         (2, 2, 0, "alpha", 0),
                         CO_NESTED)

generators = _Feature((2, 2, 0, "alpha", 1),
                      (2, 3, 0, "final", 0),
                      CO_GENERATOR_ALLOWED)

division = _Feature((2, 2, 0, "alpha", 2),
                    (3, 0, 0, "alpha", 0),
                    CO_FUTURE_DIVISION)

absolute_import = _Feature((2, 5, 0, "alpha", 1),
                           (3, 0, 0, "alpha", 0),
                           CO_FUTURE_ABSOLUTE_IMPORT)

with_statement = _Feature((2, 5, 0, "alpha", 1),
                          (2, 6, 0, "alpha", 0),
                          CO_FUTURE_WITH_STATEMENT)

print_function = _Feature((2, 6, 0, "alpha", 2),
                          (3, 0, 0, "alpha", 0),
                          CO_FUTURE_PRINT_FUNCTION)

unicode_literals = _Feature((2, 6, 0, "alpha", 2),
                            (3, 0, 0, "alpha", 0),
                            CO_FUTURE_UNICODE_LITERALS)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sÌ   d  Z  d d d d d d d g Z d g e Z d	 Z d
 Z d Z d Z d Z d Z d Z	 d d d Ñ  É  YZ
 e
 d d e É Z e
 d d e É Z e
 d  d! e É Z e
 d" d# e É Z e
 d$ d% e É Z e
 d& d' e É Z e
 d( d) e	 É Z d S(*   sf  Record of phased-in incompatible language changes.

Each line is of the form:

    FeatureName = "_Feature(" OptionalRelease "," MandatoryRelease ","
                              CompilerFlag ")"

where, normally, OptionalRelease < MandatoryRelease, and both are 5-tuples
of the same form as sys.version_info:

    (PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
     PY_MINOR_VERSION, # the 1; an int
     PY_MICRO_VERSION, # the 0; an int
     PY_RELEASE_LEVEL, # "alpha", "beta", "candidate" or "final"; string
     PY_RELEASE_SERIAL # the 3; an int
    )

OptionalRelease records the first release in which

    from __future__ import FeatureName

was accepted.

In the case of MandatoryReleases that have not yet occurred,
MandatoryRelease predicts the release in which the feature will become part
of the language.

Else MandatoryRelease records when the feature became part of the language;
in releases at or after that, modules no longer need

    from __future__ import FeatureName

to use the feature in question, but may continue to use such imports.

MandatoryRelease may also be None, meaning that a planned feature got
dropped.

Instances of class _Feature have two corresponding methods,
.getOptionalRelease() and .getMandatoryRelease().

CompilerFlag is the (bitfield) flag that should be passed in the fourth
argument to the builtin function compile() to enable the feature in
dynamically compiled code.  This flag is stored in the .compiler_flag
attribute on _Future instances.  These values must match the appropriate
#defines of CO_xxx flags in Include/compile.h.

No feature line is ever to be deleted from this file.
t   nested_scopest
   generatorst   divisiont   absolute_importt   with_statementt   print_functiont   unicode_literalst   all_feature_namesi   i    i    i @  i Ä  i   i   t   _Featurec           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   | |  _  | |  _ | |  _ d  S(   N(   t   optionalt	   mandatoryt   compiler_flag(   t   selft   optionalReleaset   mandatoryReleaseR   (    (    s    /usr/lib/python2.7/__future__.pyt   __init__K   s    		c         C   s   |  j  S(   sÖ   Return first release in which this feature was recognized.

        This is a 5-tuple, of the same form as sys.version_info.
        (   R	   (   R   (    (    s    /usr/lib/python2.7/__future__.pyt   getOptionalReleaseP   s    c         C   s   |  j  S(   s∑   Return release in which this feature will become mandatory.

        This is a 5-tuple, of the same form as sys.version_info, or, if
        the feature was dropped, is None.
        (   R
   (   R   (    (    s    /usr/lib/python2.7/__future__.pyt   getMandatoryReleaseX   s    c         C   s    d t  |  j |  j |  j f É S(   NR   (   t   reprR	   R
   R   (   R   (    (    s    /usr/lib/python2.7/__future__.pyt   __repr__a   s    (   t   __name__t
   __module__R   R   R   R   (    (    (    s    /usr/lib/python2.7/__future__.pyR   J   s   				i   i   t   betat   alphai   t   finali   i   N(    (   i   i   i    R   i   (   i   i   i    R   i    (   i   i   i    R   i   (   i   i   i    R   i    (   i   i   i    R   i   (   i   i    i    R   i    (   i   i   i    R   i   (   i   i    i    R   i    (   i   i   i    R   i   (   i   i   i    R   i    (   i   i   i    R   i   (   i   i    i    R   i    (   i   i   i    R   i   (   i   i    i    R   i    (   t   __doc__R   t   __all__t	   CO_NESTEDt   CO_GENERATOR_ALLOWEDt   CO_FUTURE_DIVISIONt   CO_FUTURE_ABSOLUTE_IMPORTt   CO_FUTURE_WITH_STATEMENTt   CO_FUTURE_PRINT_FUNCTIONt   CO_FUTURE_UNICODE_LITERALSR   R    R   R   R   R   R   R   (    (    (    s    /usr/lib/python2.7/__future__.pyt   <module>0   sJ   							                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Abstract Base Classes (ABCs) for collections, according to PEP 3119.

DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported
via collections; they are defined here only to alleviate certain
bootstrapping issues.  Unit tests are in test_collections.
"""

from abc import ABCMeta, abstractmethod
import sys

__all__ = ["Hashable", "Iterable", "Iterator",
           "Sized", "Container", "Callable",
           "Set", "MutableSet",
           "Mapping", "MutableMapping",
           "MappingView", "KeysView", "ItemsView", "ValuesView",
           "Sequence", "MutableSequence",
           ]

### ONE-TRICK PONIES ###

def _hasattr(C, attr):
    try:
        return any(attr in B.__dict__ for B in C.__mro__)
    except AttributeError:
        # Old-style class
        return hasattr(C, attr)


class Hashable:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __hash__(self):
        return 0

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Hashable:
            try:
                for B in C.__mro__:
                    if "__hash__" in B.__dict__:
                        if B.__dict__["__hash__"]:
                            return True
                        break
            except AttributeError:
                # Old-style class
                if getattr(C, "__hash__", None):
                    return True
        return NotImplemented


class Iterable:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __iter__(self):
        while False:
            yield None

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterable:
            if _hasattr(C, "__iter__"):
                return True
        return NotImplemented

Iterable.register(str)


class Iterator(Iterable):

    @abstractmethod
    def next(self):
        'Return the next item from the iterator. When exhausted, raise StopIteration'
        raise StopIteration

    def __iter__(self):
        return self

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterator:
            if _hasattr(C, "next") and _hasattr(C, "__iter__"):
                return True
        return NotImplemented


class Sized:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __len__(self):
        return 0

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Sized:
            if _hasattr(C, "__len__"):
                return True
        return NotImplemented


class Container:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __contains__(self, x):
        return False

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Container:
            if _hasattr(C, "__contains__"):
                return True
        return NotImplemented


class Callable:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __call__(self, *args, **kwds):
        return False

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Callable:
            if _hasattr(C, "__call__"):
                return True
        return NotImplemented


### SETS ###


class Set(Sized, Iterable, Container):
    """A set is a finite, iterable container.

    This class provides concrete generic implementations of all
    methods except for __contains__, __iter__ and __len__.

    To override the comparisons (presumably for speed, as the
    semantics are fixed), redefine __le__ and __ge__,
    then the other operations will automatically follow suit.
    """

    def __le__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        if len(self) > len(other):
            return False
        for elem in self:
            if elem not in other:
                return False
        return True

    def __lt__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        return len(self) < len(other) and self.__le__(other)

    def __gt__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        return len(self) > len(other) and self.__ge__(other)

    def __ge__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        if len(self) < len(other):
            return False
        for elem in other:
            if elem not in self:
                return False
        return True

    def __eq__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        return len(self) == len(other) and self.__le__(other)

    def __ne__(self, other):
        return not (self == other)

    @classmethod
    def _from_iterable(cls, it):
        '''Construct an instance of the class from any iterable input.

        Must override this method if the class constructor signature
        does not accept an iterable for an input.
        '''
        return cls(it)

    def __and__(self, other):
        if not isinstance(other, Iterable):
            return NotImplemented
        return self._from_iterable(value for value in other if value in self)

    __rand__ = __and__

    def isdisjoint(self, other):
        'Return True if two sets have a null intersection.'
        for value in other:
            if value in self:
                return False
        return True

    def __or__(self, other):
        if not isinstance(other, Iterable):
            return NotImplemented
        chain = (e for s in (self, other) for e in s)
        return self._from_iterable(chain)

    __ror__ = __or__

    def __sub__(self, other):
        if not isinstance(other, Set):
            if not isinstance(other, Iterable):
                return NotImplemented
            other = self._from_iterable(other)
        return self._from_iterable(value for value in self
                                   if value not in other)

    def __rsub__(self, other):
        if not isinstance(other, Set):
            if not isinstance(other, Iterable):
                return NotImplemented
            other = self._from_iterable(other)
        return self._from_iterable(value for value in other
                                   if value not in self)

    def __xor__(self, other):
        if not isinstance(other, Set):
            if not isinstance(other, Iterable):
                return NotImplemented
            other = self._from_iterable(other)
        return (self - other) | (other - self)

    __rxor__ = __xor__

    # Sets are not hashable by default, but subclasses can change this
    __hash__ = None

    def _hash(self):
        """Compute the hash value of a set.

        Note that we don't define __hash__: not all sets are hashable.
        But if you define a hashable set type, its __hash__ should
        call this function.

        This must be compatible __eq__.

        All sets ought to compare equal if they contain the same
        elements, regardless of how they are implemented, and
        regardless of the order of the elements; so there's not much
        freedom for __eq__ or __hash__.  We match the algorithm used
        by the built-in frozenset type.
        """
        MAX = sys.maxint
        MASK = 2 * MAX + 1
        n = len(self)
        h = 1927868237 * (n + 1)
        h &= MASK
        for x in self:
            hx = hash(x)
            h ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167
            h &= MASK
        h = h * 69069 + 907133923
        h &= MASK
        if h > MAX:
            h -= MASK + 1
        if h == -1:
            h = 590923713
        return h

Set.register(frozenset)


class MutableSet(Set):
    """A mutable set is a finite, iterable container.

    This class provides concrete generic implementations of all
    methods except for __contains__, __iter__, __len__,
    add(), and discard().

    To override the comparisons (presumably for speed, as the
    semantics are fixed), all you have to do is redefine __le__ and
    then the other operations will automatically follow suit.
    """

    @abstractmethod
    def add(self, value):
        """Add an element."""
        raise NotImplementedError

    @abstractmethod
    def discard(self, value):
        """Remove an element.  Do not raise an exception if absent."""
        raise NotImplementedError

    def remove(self, value):
        """Remove an element. If not a member, raise a KeyError."""
        if value not in self:
            raise KeyError(value)
        self.discard(value)

    def pop(self):
        """Return the popped value.  Raise KeyError if empty."""
        it = iter(self)
        try:
            value = next(it)
        except StopIteration:
            raise KeyError
        self.discard(value)
        return value

    def clear(self):
        """This is slow (creates N new iterators!) but effective."""
        try:
            while True:
                self.pop()
        except KeyError:
            pass

    def __ior__(self, it):
        for value in it:
            self.add(value)
        return self

    def __iand__(self, it):
        for value in (self - it):
            self.discard(value)
        return self

    def __ixor__(self, it):
        if it is self:
            self.clear()
        else:
            if not isinstance(it, Set):
                it = self._from_iterable(it)
            for value in it:
                if value in self:
                    self.discard(value)
                else:
                    self.add(value)
        return self

    def __isub__(self, it):
        if it is self:
            self.clear()
        else:
            for value in it:
                self.discard(value)
        return self

MutableSet.register(set)


### MAPPINGS ###


class Mapping(Sized, Iterable, Container):

    """A Mapping is a generic container for associating key/value
    pairs.

    This class provides concrete generic implementations of all
    methods except for __getitem__, __iter__, and __len__.

    """

    @abstractmethod
    def __getitem__(self, key):
        raise KeyError

    def get(self, key, default=None):
        'D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.'
        try:
            return self[key]
        except KeyError:
            return default

    def __contains__(self, key):
        try:
            self[key]
        except KeyError:
            return False
        else:
            return True

    def iterkeys(self):
        'D.iterkeys() -> an iterator over the keys of D'
        return iter(self)

    def itervalues(self):
        'D.itervalues() -> an iterator over the values of D'
        for key in self:
            yield self[key]

    def iteritems(self):
        'D.iteritems() -> an iterator over the (key, value) items of D'
        for key in self:
            yield (key, self[key])

    def keys(self):
        "D.keys() -> list of D's keys"
        return list(self)

    def items(self):
        "D.items() -> list of D's (key, value) pairs, as 2-tuples"
        return [(key, self[key]) for key in self]

    def values(self):
        "D.values() -> list of D's values"
        return [self[key] for key in self]

    # Mappings are not hashable by default, but subclasses can change this
    __hash__ = None

    def __eq__(self, other):
        if not isinstance(other, Mapping):
            return NotImplemented
        return dict(self.items()) == dict(other.items())

    def __ne__(self, other):
        return not (self == other)

class MappingView(Sized):

    def __init__(self, mapping):
        self._mapping = mapping

    def __len__(self):
        return len(self._mapping)

    def __repr__(self):
        return '{0.__class__.__name__}({0._mapping!r})'.format(self)


class KeysView(MappingView, Set):

    @classmethod
    def _from_iterable(self, it):
        return set(it)

    def __contains__(self, key):
        return key in self._mapping

    def __iter__(self):
        for key in self._mapping:
            yield key

KeysView.register(type({}.viewkeys()))

class ItemsView(MappingView, Set):

    @classmethod
    def _from_iterable(self, it):
        return set(it)

    def __contains__(self, item):
        key, value = item
        try:
            v = self._mapping[key]
        except KeyError:
            return False
        else:
            return v == value

    def __iter__(self):
        for key in self._mapping:
            yield (key, self._mapping[key])

ItemsView.register(type({}.viewitems()))

class ValuesView(MappingView):

    def __contains__(self, value):
        for key in self._mapping:
            if value == self._mapping[key]:
                return True
        return False

    def __iter__(self):
        for key in self._mapping:
            yield self._mapping[key]

ValuesView.register(type({}.viewvalues()))

class MutableMapping(Mapping):

    """A MutableMapping is a generic container for associating
    key/value pairs.

    This class provides concrete generic implementations of all
    methods except for __getitem__, __setitem__, __delitem__,
    __iter__, and __len__.

    """

    @abstractmethod
    def __setitem__(self, key, value):
        raise KeyError

    @abstractmethod
    def __delitem__(self, key):
        raise KeyError

    __marker = object()

    def pop(self, key, default=__marker):
        '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
          If key is not found, d is returned if given, otherwise KeyError is raised.
        '''
        try:
            value = self[key]
        except KeyError:
            if default is self.__marker:
                raise
            return default
        else:
            del self[key]
            return value

    def popitem(self):
        '''D.popitem() -> (k, v), remove and return some (key, value) pair
           as a 2-tuple; but raise KeyError if D is empty.
        '''
        try:
            key = next(iter(self))
        except StopIteration:
            raise KeyError
        value = self[key]
        del self[key]
        return key, value

    def clear(self):
        'D.clear() -> None.  Remove all items from D.'
        try:
            while True:
                self.popitem()
        except KeyError:
            pass

    def update(*args, **kwds):
        ''' D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
            If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
            If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
            In either case, this is followed by: for k, v in F.items(): D[k] = v
        '''
        if not args:
            raise TypeError("descriptor 'update' of 'MutableMapping' object "
                            "needs an argument")
        self = args[0]
        args = args[1:]
        if len(args) > 1:
            raise TypeError('update expected at most 1 arguments, got %d' %
                            len(args))
        if args:
            other = args[0]
            if isinstance(other, Mapping):
                for key in other:
                    self[key] = other[key]
            elif hasattr(other, "keys"):
                for key in other.keys():
                    self[key] = other[key]
            else:
                for key, value in other:
                    self[key] = value
        for key, value in kwds.items():
            self[key] = value

    def setdefault(self, key, default=None):
        'D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D'
        try:
            return self[key]
        except KeyError:
            self[key] = default
        return default

MutableMapping.register(dict)


### SEQUENCES ###


class Sequence(Sized, Iterable, Container):
    """All the operations on a read-only sequence.

    Concrete subclasses must override __new__ or __init__,
    __getitem__, and __len__.
    """

    @abstractmethod
    def __getitem__(self, index):
        raise IndexError

    def __iter__(self):
        i = 0
        try:
            while True:
                v = self[i]
                yield v
                i += 1
        except IndexError:
            return

    def __contains__(self, value):
        for v in self:
            if v == value:
                return True
        return False

    def __reversed__(self):
        for i in reversed(range(len(self))):
            yield self[i]

    def index(self, value):
        '''S.index(value) -> integer -- return first index of value.
           Raises ValueError if the value is not present.
        '''
        for i, v in enumerate(self):
            if v == value:
                return i
        raise ValueError

    def count(self, value):
        'S.count(value) -> integer -- return number of occurrences of value'
        return sum(1 for v in self if v == value)

Sequence.register(tuple)
Sequence.register(basestring)
Sequence.register(buffer)
Sequence.register(xrange)


class MutableSequence(Sequence):

    """All the operations on a read-only sequence.

    Concrete subclasses must provide __new__ or __init__,
    __getitem__, __setitem__, __delitem__, __len__, and insert().

    """

    @abstractmethod
    def __setitem__(self, index, value):
        raise IndexError

    @abstractmethod
    def __delitem__(self, index):
        raise IndexError

    @abstractmethod
    def insert(self, index, value):
        'S.insert(index, object) -- insert object before index'
        raise IndexError

    def append(self, value):
        'S.append(object) -- append object to the end of the sequence'
        self.insert(len(self), value)

    def reverse(self):
        'S.reverse() -- reverse *IN PLACE*'
        n = len(self)
        for i in range(n//2):
            self[i], self[n-i-1] = self[n-i-1], self[i]

    def extend(self, values):
        'S.extend(iterable) -- extend sequence by appending elements from the iterable'
        for v in values:
            self.append(v)

    def pop(self, index=-1):
        '''S.pop([index]) -> item -- remove and return item at index (default last).
           Raise IndexError if list is empty or index is out of range.
        '''
        v = self[index]
        del self[index]
        return v

    def remove(self, value):
        '''S.remove(value) -- remove first occurrence of value.
           Raise ValueError if the value is not present.
        '''
        del self[self.index(value)]

    def __iadd__(self, values):
        self.extend(values)
        return self

MutableSequence.register(list)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   sî  d  Z  d d l m Z m Z d d l Z d d d d d d	 d
 d d d d d d d d d g Z d Ñ  Z d d% d Ñ  É  YZ d d& d Ñ  É  YZ e j	 e
 É d e f d Ñ  É  YZ d d' d Ñ  É  YZ d d( d Ñ  É  YZ d	 d) d Ñ  É  YZ d
 e e e f d Ñ  É  YZ e j	 e É d e f d Ñ  É  YZ e j	 e É d e e e f d Ñ  É  YZ d e f d Ñ  É  YZ d e e f d Ñ  É  YZ e j	 e i  j É  É É d e e f d  Ñ  É  YZ e j	 e i  j É  É É d e f d! Ñ  É  YZ e j	 e i  j É  É É d e f d" Ñ  É  YZ e j	 e É d e e e f d# Ñ  É  YZ e j	 e É e j	 e  É e j	 e! É e j	 e" É d e f d$ Ñ  É  YZ# e# j	 e$ É d S(*   s  Abstract Base Classes (ABCs) for collections, according to PEP 3119.

DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported
via collections; they are defined here only to alleviate certain
bootstrapping issues.  Unit tests are in test_collections.
iˇˇˇˇ(   t   ABCMetat   abstractmethodNt   Hashablet   Iterablet   Iteratort   Sizedt	   Containert   Callablet   Sett
   MutableSett   Mappingt   MutableMappingt   MappingViewt   KeysViewt	   ItemsViewt
   ValuesViewt   Sequencet   MutableSequencec            sC   y! t  á  f d Ü  |  j DÉ É SWn t k
 r> t |  à  É SXd  S(   Nc         3   s   |  ] } à  | j  k Vq d  S(   N(   t   __dict__(   t   .0t   B(   t   attr(    s   /usr/lib/python2.7/_abcoll.pys	   <genexpr>   s    (   t   anyt   __mro__t   AttributeErrort   hasattr(   t   CR   (    (   R   s   /usr/lib/python2.7/_abcoll.pyt   _hasattr   s    !c           B   s,   e  Z e Z e d  Ñ  É Z e d Ñ  É Z RS(   c         C   s   d S(   Ni    (    (   t   self(    (    s   /usr/lib/python2.7/_abcoll.pyt   __hash__#   s    c         C   sy   |  t  k ru y< x5 | j D]* } d | j k r | j d r? t SPq q WWqu t k
 rq t | d d  É rr t Squ Xn  t S(   NR   (   R   R   R   t   TrueR   t   getattrt   Nonet   NotImplemented(   t   clsR   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __subclasshook__'   s    (   t   __name__t
   __module__R    t   __metaclass__R   R   t   classmethodR#   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR       s   c           B   s,   e  Z e Z e d  Ñ  É Z e d Ñ  É Z RS(   c         c   s   x t  r d  Vq Wd  S(   N(   t   FalseR    (   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __iter__:   s    	c         C   s&   |  t  k r" t | d É r" t Sn  t S(   NR)   (   R   R   R   R!   (   R"   R   (    (    s   /usr/lib/python2.7/_abcoll.pyR#   ?   s    (   R$   R%   R    R&   R   R)   R'   R#   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   7   s   c           B   s/   e  Z e d  Ñ  É Z d Ñ  Z e d Ñ  É Z RS(   c         C   s
   t  Ç d S(   sK   Return the next item from the iterator. When exhausted, raise StopIterationN(   t   StopIteration(   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   nextK   s    c         C   s   |  S(   N(    (   R   (    (    s   /usr/lib/python2.7/_abcoll.pyR)   P   s    c         C   s5   |  t  k r1 t | d É r1 t | d É r1 t Sn  t S(   NR+   R)   (   R   R   R   R!   (   R"   R   (    (    s   /usr/lib/python2.7/_abcoll.pyR#   S   s    (   R$   R%   R   R+   R)   R'   R#   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   I   s   	c           B   s,   e  Z e Z e d  Ñ  É Z e d Ñ  É Z RS(   c         C   s   d S(   Ni    (    (   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __len__^   s    c         C   s&   |  t  k r" t | d É r" t Sn  t S(   NR,   (   R   R   R   R!   (   R"   R   (    (    s   /usr/lib/python2.7/_abcoll.pyR#   b   s    (   R$   R%   R    R&   R   R,   R'   R#   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   [   s   c           B   s,   e  Z e Z e d  Ñ  É Z e d Ñ  É Z RS(   c         C   s   t  S(   N(   R(   (   R   t   x(    (    s   /usr/lib/python2.7/_abcoll.pyt   __contains__m   s    c         C   s&   |  t  k r" t | d É r" t Sn  t S(   NR.   (   R   R   R   R!   (   R"   R   (    (    s   /usr/lib/python2.7/_abcoll.pyR#   q   s    (   R$   R%   R    R&   R   R.   R'   R#   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   j   s   c           B   s,   e  Z e Z e d  Ñ  É Z e d Ñ  É Z RS(   c         O   s   t  S(   N(   R(   (   R   t   argst   kwds(    (    s   /usr/lib/python2.7/_abcoll.pyt   __call__|   s    c         C   s&   |  t  k r" t | d É r" t Sn  t S(   NR1   (   R   R   R   R!   (   R"   R   (    (    s   /usr/lib/python2.7/_abcoll.pyR#   Ä   s    (   R$   R%   R    R&   R   R1   R'   R#   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   y   s   c           B   s™   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e	 d Ñ  É Z
 d Ñ  Z e Z d	 Ñ  Z d
 Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Z d Ñ  Z RS(   sZ  A set is a finite, iterable container.

    This class provides concrete generic implementations of all
    methods except for __contains__, __iter__ and __len__.

    To override the comparisons (presumably for speed, as the
    semantics are fixed), redefine __le__ and __ge__,
    then the other operations will automatically follow suit.
    c         C   sT   t  | t É s t St |  É t | É k r/ t Sx |  D] } | | k r6 t Sq6 Wt S(   N(   t
   isinstanceR   R!   t   lenR(   R   (   R   t   othert   elem(    (    s   /usr/lib/python2.7/_abcoll.pyt   __le__ñ   s    c         C   s8   t  | t É s t St |  É t | É k  o7 |  j | É S(   N(   R2   R   R!   R3   R6   (   R   R4   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __lt__†   s    c         C   s8   t  | t É s t St |  É t | É k o7 |  j | É S(   N(   R2   R   R!   R3   t   __ge__(   R   R4   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __gt__•   s    c         C   sT   t  | t É s t St |  É t | É k  r/ t Sx | D] } | |  k r6 t Sq6 Wt S(   N(   R2   R   R!   R3   R(   R   (   R   R4   R5   (    (    s   /usr/lib/python2.7/_abcoll.pyR8   ™   s    c         C   s8   t  | t É s t St |  É t | É k o7 |  j | É S(   N(   R2   R   R!   R3   R6   (   R   R4   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __eq__¥   s    c         C   s   |  | k S(   N(    (   R   R4   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __ne__π   s    c         C   s
   |  | É S(   sº   Construct an instance of the class from any iterable input.

        Must override this method if the class constructor signature
        does not accept an iterable for an input.
        (    (   R"   t   it(    (    s   /usr/lib/python2.7/_abcoll.pyt   _from_iterableº   s    c            s0   t  | t É s t Sà  j á  f d Ü  | DÉ É S(   Nc         3   s!   |  ] } | à  k r | Vq d  S(   N(    (   R   t   value(   R   (    s   /usr/lib/python2.7/_abcoll.pys	   <genexpr>»   s    (   R2   R   R!   R=   (   R   R4   (    (   R   s   /usr/lib/python2.7/_abcoll.pyt   __and__≈   s    c         C   s%   x | D] } | |  k r t  Sq Wt S(   s1   Return True if two sets have a null intersection.(   R(   R   (   R   R4   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt
   isdisjointÃ   s    c         C   s6   t  | t É s t Sd Ñ  |  | f DÉ } |  j | É S(   Nc         s   s"   |  ] } | D] } | Vq q d  S(   N(    (   R   t   st   e(    (    s   /usr/lib/python2.7/_abcoll.pys	   <genexpr>÷   s    (   R2   R   R!   R=   (   R   R4   t   chain(    (    s   /usr/lib/python2.7/_abcoll.pyt   __or__”   s    c            sQ   t  à  t É s4 t  à  t É s" t S|  j à  É â  n  |  j á  f d Ü  |  DÉ É S(   Nc         3   s!   |  ] } | à  k r | Vq d  S(   N(    (   R   R>   (   R4   (    s   /usr/lib/python2.7/_abcoll.pys	   <genexpr>‡   s    (   R2   R   R   R!   R=   (   R   R4   (    (   R4   s   /usr/lib/python2.7/_abcoll.pyt   __sub__€   s
    c            sQ   t  | t É s4 t  | t É s" t Sà  j | É } n  à  j á  f d Ü  | DÉ É S(   Nc         3   s!   |  ] } | à  k r | Vq d  S(   N(    (   R   R>   (   R   (    s   /usr/lib/python2.7/_abcoll.pys	   <genexpr>Ë   s    (   R2   R   R   R!   R=   (   R   R4   (    (   R   s   /usr/lib/python2.7/_abcoll.pyt   __rsub__„   s
    c         C   sD   t  | t É s4 t  | t É s" t S|  j | É } n  |  | | |  BS(   N(   R2   R   R   R!   R=   (   R   R4   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __xor__Î   s
    c         C   s    t  j } d | d } t |  É } d | d } | | M} x> |  D]6 } t | É } | | | d >Ad Ad N} | | M} qB W| d d } | | M} | | k r± | | d 8} n  | d	 k r∆ d
 } n  | S(   s+  Compute the hash value of a set.

        Note that we don't define __hash__: not all sets are hashable.
        But if you define a hashable set type, its __hash__ should
        call this function.

        This must be compatible __eq__.

        All sets ought to compare equal if they contain the same
        elements, regardless of how they are implemented, and
        regardless of the order of the elements; so there's not much
        freedom for __eq__ or __hash__.  We match the algorithm used
        by the built-in frozenset type.
        i   i   iMÔËri   i≥M[l   ◊4~2 iÕ i„√6iˇˇˇˇi¡«8#(   t   syst   maxintR3   t   hash(   R   t   MAXt   MASKt   nt   hR-   t   hx(    (    s   /usr/lib/python2.7/_abcoll.pyt   _hash˜   s     	

	N(   R$   R%   t   __doc__R6   R7   R9   R8   R:   R;   R'   R=   R?   t   __rand__R@   RD   t   __ror__RE   RF   RG   t   __rxor__R    R   RP   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   ã   s&   		
			
									c           B   sk   e  Z d  Z e d Ñ  É Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z RS(
   sá  A mutable set is a finite, iterable container.

    This class provides concrete generic implementations of all
    methods except for __contains__, __iter__, __len__,
    add(), and discard().

    To override the comparisons (presumably for speed, as the
    semantics are fixed), all you have to do is redefine __le__ and
    then the other operations will automatically follow suit.
    c         C   s
   t  Ç d S(   s   Add an element.N(   t   NotImplementedError(   R   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   add&  s    c         C   s
   t  Ç d S(   s8   Remove an element.  Do not raise an exception if absent.N(   RU   (   R   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   discard+  s    c         C   s,   | |  k r t  | É Ç n  |  j | É d S(   s5   Remove an element. If not a member, raise a KeyError.N(   t   KeyErrorRW   (   R   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   remove0  s    c         C   sG   t  |  É } y t | É } Wn t k
 r5 t Ç n X|  j | É | S(   s2   Return the popped value.  Raise KeyError if empty.(   t   iterR+   R*   RX   RW   (   R   R<   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   pop6  s    
c         C   s3   y x t  r |  j É  q WWn t k
 r. n Xd S(   s6   This is slow (creates N new iterators!) but effective.N(   R   R[   RX   (   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   clear@  s
    	c         C   s"   x | D] } |  j  | É q W|  S(   N(   RV   (   R   R<   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __ior__H  s    c         C   s&   x |  | D] } |  j  | É q W|  S(   N(   RW   (   R   R<   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __iand__M  s    c         C   sx   | |  k r |  j  É  n[ t | t É s: |  j | É } n  x7 | D]/ } | |  k rc |  j | É qA |  j | É qA W|  S(   N(   R\   R2   R   R=   RW   RV   (   R   R<   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __ixor__R  s    c         C   s;   | |  k r |  j  É  n x | D] } |  j | É q  W|  S(   N(   R\   RW   (   R   R<   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __isub___  s
    (   R$   R%   RQ   R   RV   RW   RY   R[   R\   R]   R^   R_   R`   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR	     s   
		
				c           B   sÄ   e  Z d  Z e d Ñ  É Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d Z d
 Ñ  Z d Ñ  Z RS(   s«   A Mapping is a generic container for associating key/value
    pairs.

    This class provides concrete generic implementations of all
    methods except for __getitem__, __iter__, and __len__.

    c         C   s
   t  Ç d  S(   N(   RX   (   R   t   key(    (    s   /usr/lib/python2.7/_abcoll.pyt   __getitem__w  s    c         C   s%   y |  | SWn t  k
 r  | SXd S(   s<   D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.N(   RX   (   R   Ra   t   default(    (    s   /usr/lib/python2.7/_abcoll.pyt   get{  s    c         C   s)   y |  | Wn t  k
 r  t SXt Sd  S(   N(   RX   R(   R   (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyR.   Ç  s
    c         C   s
   t  |  É S(   s.   D.iterkeys() -> an iterator over the keys of D(   RZ   (   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   iterkeysä  s    c         c   s   x |  D] } |  | Vq Wd S(   s2   D.itervalues() -> an iterator over the values of DN(    (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyt
   itervaluesé  s    c         c   s$   x |  D] } | |  | f Vq Wd S(   s=   D.iteritems() -> an iterator over the (key, value) items of DN(    (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyt	   iteritemsì  s    c         C   s
   t  |  É S(   s   D.keys() -> list of D's keys(   t   list(   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   keysò  s    c         C   s!   g  |  D] } | |  | f ^ q S(   s8   D.items() -> list of D's (key, value) pairs, as 2-tuples(    (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyt   itemsú  s    c         C   s   g  |  D] } |  | ^ q S(   s    D.values() -> list of D's values(    (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyt   values†  s    c         C   s5   t  | t É s t St |  j É  É t | j É  É k S(   N(   R2   R
   R!   t   dictRj   (   R   R4   (    (    s   /usr/lib/python2.7/_abcoll.pyR:   ß  s    c         C   s   |  | k S(   N(    (   R   R4   (    (    s   /usr/lib/python2.7/_abcoll.pyR;   ¨  s    N(   R$   R%   RQ   R   Rb   R    Rd   R.   Re   Rf   Rg   Ri   Rj   Rk   R   R:   R;   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR
   m  s   								c           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   | |  _  d  S(   N(   t   _mapping(   R   t   mapping(    (    s   /usr/lib/python2.7/_abcoll.pyt   __init__±  s    c         C   s   t  |  j É S(   N(   R3   Rm   (   R   (    (    s   /usr/lib/python2.7/_abcoll.pyR,   ¥  s    c         C   s   d j  |  É S(   Ns&   {0.__class__.__name__}({0._mapping!r})(   t   format(   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __repr__∑  s    (   R$   R%   Ro   R,   Rq   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   Ø  s   		c           B   s)   e  Z e d  Ñ  É Z d Ñ  Z d Ñ  Z RS(   c         C   s
   t  | É S(   N(   t   set(   R   R<   (    (    s   /usr/lib/python2.7/_abcoll.pyR=   Ω  s    c         C   s   | |  j  k S(   N(   Rm   (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyR.   ¡  s    c         c   s   x |  j  D] } | Vq
 Wd  S(   N(   Rm   (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyR)   ƒ  s    (   R$   R%   R'   R=   R.   R)   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   ª  s   	c           B   s)   e  Z e d  Ñ  É Z d Ñ  Z d Ñ  Z RS(   c         C   s
   t  | É S(   N(   Rr   (   R   R<   (    (    s   /usr/lib/python2.7/_abcoll.pyR=   Ã  s    c         C   s@   | \ } } y |  j  | } Wn t k
 r1 t SX| | k Sd  S(   N(   Rm   RX   R(   (   R   t   itemRa   R>   t   v(    (    s   /usr/lib/python2.7/_abcoll.pyR.   –  s    c         c   s*   x# |  j  D] } | |  j  | f Vq
 Wd  S(   N(   Rm   (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyR)   Ÿ  s    (   R$   R%   R'   R=   R.   R)   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR      s   		c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s/   x( |  j  D] } | |  j  | k r
 t Sq
 Wt S(   N(   Rm   R   R(   (   R   R>   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyR.   ·  s    c         c   s$   x |  j  D] } |  j  | Vq
 Wd  S(   N(   Rm   (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyR)   Á  s    (   R$   R%   R.   R)   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   ﬂ  s   	c           B   sh   e  Z d  Z e d Ñ  É Z e d Ñ  É Z e É  Z e d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d d Ñ Z RS(	   sÏ   A MutableMapping is a generic container for associating
    key/value pairs.

    This class provides concrete generic implementations of all
    methods except for __getitem__, __setitem__, __delitem__,
    __iter__, and __len__.

    c         C   s
   t  Ç d  S(   N(   RX   (   R   Ra   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __setitem__¯  s    c         C   s
   t  Ç d  S(   N(   RX   (   R   Ra   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __delitem__¸  s    c         C   sG   y |  | } Wn' t  k
 r7 | |  j k r3 Ç  n  | SX|  | =| Sd S(   s©   D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
          If key is not found, d is returned if given, otherwise KeyError is raised.
        N(   RX   t   _MutableMapping__marker(   R   Ra   Rc   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyR[     s    c         C   sK   y t  t |  É É } Wn t k
 r/ t Ç n X|  | } |  | =| | f S(   sÉ   D.popitem() -> (k, v), remove and return some (key, value) pair
           as a 2-tuple; but raise KeyError if D is empty.
        (   R+   RZ   R*   RX   (   R   Ra   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   popitem  s    

c         C   s3   y x t  r |  j É  q WWn t k
 r. n Xd S(   s,   D.clear() -> None.  Remove all items from D.N(   R   Rx   RX   (   R   (    (    s   /usr/lib/python2.7/_abcoll.pyR\     s
    	c          O   s  |  s t  d É Ç n  |  d } |  d }  t |  É d k rT t  d t |  É É Ç n  |  r |  d } t | t É rï xw | D] } | | | | <qz Wq t | d É rÃ xF | j É  D] } | | | | <q± Wq x! | D] \ } } | | | <q” Wn  x$ | j É  D] \ } } | | | <q˝ Wd S(   sK   D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
            If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
            If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
            In either case, this is followed by: for k, v in F.items(): D[k] = v
        s@   descriptor 'update' of 'MutableMapping' object needs an argumenti    i   s+   update expected at most 1 arguments, got %dRi   N(   t	   TypeErrorR3   R2   R
   R   Ri   Rj   (   R/   R0   R   R4   Ra   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   update$  s&    


c         C   s.   y |  | SWn t  k
 r) | |  | <n X| S(   s@   D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D(   RX   (   R   Ra   Rc   (    (    s   /usr/lib/python2.7/_abcoll.pyt
   setdefault@  s
    N(   R$   R%   RQ   R   Ru   Rv   t   objectRw   R[   Rx   R\   Rz   R    R{   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   Ì  s   					c           B   sJ   e  Z d  Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   sä   All the operations on a read-only sequence.

    Concrete subclasses must override __new__ or __init__,
    __getitem__, and __len__.
    c         C   s
   t  Ç d  S(   N(   t
   IndexError(   R   t   index(    (    s   /usr/lib/python2.7/_abcoll.pyRb   U  s    c         c   sI   d } y* x# t  r. |  | } | V| d 7} q WWn t k
 rD d  SXd  S(   Ni    i   (   R   R}   (   R   t   iRt   (    (    s   /usr/lib/python2.7/_abcoll.pyR)   Y  s    	
c         C   s%   x |  D] } | | k r t  Sq Wt S(   N(   R   R(   (   R   R>   Rt   (    (    s   /usr/lib/python2.7/_abcoll.pyR.   c  s    c         c   s0   x) t  t t |  É É É D] } |  | Vq Wd  S(   N(   t   reversedt   rangeR3   (   R   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __reversed__i  s    c         C   s7   x* t  |  É D] \ } } | | k r | Sq Wt Ç d S(   s|   S.index(value) -> integer -- return first index of value.
           Raises ValueError if the value is not present.
        N(   t	   enumeratet
   ValueError(   R   R>   R   Rt   (    (    s   /usr/lib/python2.7/_abcoll.pyR~   m  s    c            s   t  á  f d Ü  |  DÉ É S(   sB   S.count(value) -> integer -- return number of occurrences of valuec         3   s!   |  ] } | à  k r d  Vq d S(   i   N(    (   R   Rt   (   R>   (    s   /usr/lib/python2.7/_abcoll.pys	   <genexpr>x  s    (   t   sum(   R   R>   (    (   R>   s   /usr/lib/python2.7/_abcoll.pyt   countv  s    (
   R$   R%   RQ   R   Rb   R)   R.   RÇ   R~   RÜ   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   N  s   	
				c           B   st   e  Z d  Z e d Ñ  É Z e d Ñ  É Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z	 d d Ñ Z
 d	 Ñ  Z d
 Ñ  Z RS(   sÆ   All the operations on a read-only sequence.

    Concrete subclasses must provide __new__ or __init__,
    __getitem__, __setitem__, __delitem__, __len__, and insert().

    c         C   s
   t  Ç d  S(   N(   R}   (   R   R~   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyRu   â  s    c         C   s
   t  Ç d  S(   N(   R}   (   R   R~   (    (    s   /usr/lib/python2.7/_abcoll.pyRv   ç  s    c         C   s
   t  Ç d S(   s5   S.insert(index, object) -- insert object before indexN(   R}   (   R   R~   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   insertë  s    c         C   s   |  j  t |  É | É d S(   s<   S.append(object) -- append object to the end of the sequenceN(   Rá   R3   (   R   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyt   appendñ  s    c         C   sX   t  |  É } xE t | d É D]3 } |  | | d |  | |  | <|  | | d <q Wd S(   s!   S.reverse() -- reverse *IN PLACE*i   i   N(   R3   RÅ   (   R   RM   R   (    (    s   /usr/lib/python2.7/_abcoll.pyt   reverseö  s    c         C   s"   x | D] } |  j  | É q Wd S(   sM   S.extend(iterable) -- extend sequence by appending elements from the iterableN(   Rà   (   R   Rk   Rt   (    (    s   /usr/lib/python2.7/_abcoll.pyt   extend†  s    iˇˇˇˇc         C   s   |  | } |  | =| S(   sô   S.pop([index]) -> item -- remove and return item at index (default last).
           Raise IndexError if list is empty or index is out of range.
        (    (   R   R~   Rt   (    (    s   /usr/lib/python2.7/_abcoll.pyR[   •  s    
c         C   s   |  |  j  | É =d S(   sv   S.remove(value) -- remove first occurrence of value.
           Raise ValueError if the value is not present.
        N(   R~   (   R   R>   (    (    s   /usr/lib/python2.7/_abcoll.pyRY   ≠  s    c         C   s   |  j  | É |  S(   N(   Rä   (   R   Rk   (    (    s   /usr/lib/python2.7/_abcoll.pyt   __iadd__≥  s    (   R$   R%   RQ   R   Ru   Rv   Rá   Rà   Râ   Rä   R[   RY   Rã   (    (    (    s   /usr/lib/python2.7/_abcoll.pyR   Ä  s   				(    (    (    (    (    (%   RQ   t   abcR    R   RH   t   __all__R   R   R   t   registert   strR   R   R   R   R   t	   frozensetR	   Rr   R
   R   R   t   typet   viewkeysR   t	   viewitemsR   t
   viewvaluesR   Rl   R   t   tuplet
   basestringt   buffert   xrangeR   Rh   (    (    (    s   /usr/lib/python2.7/_abcoll.pyt   <module>	   sJ   			åMB[,7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """Shared OS X support functions."""

import os
import re
import sys

__all__ = [
    'compiler_fixup',
    'customize_config_vars',
    'customize_compiler',
    'get_platform_osx',
]

# configuration variables that may contain universal build flags,
# like "-arch" or "-isdkroot", that may need customization for
# the user environment
_UNIVERSAL_CONFIG_VARS = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS', 'BASECFLAGS',
                            'BLDSHARED', 'LDSHARED', 'CC', 'CXX',
                            'PY_CFLAGS', 'PY_LDFLAGS', 'PY_CPPFLAGS',
                            'PY_CORE_CFLAGS')

# configuration variables that may contain compiler calls
_COMPILER_CONFIG_VARS = ('BLDSHARED', 'LDSHARED', 'CC', 'CXX')

# prefix added to original configuration variable names
_INITPRE = '_OSX_SUPPORT_INITIAL_'


def _find_executable(executable, path=None):
    """Tries to find 'executable' in the directories listed in 'path'.

    A string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH'].  Returns the complete filename or None if not found.
    """
    if path is None:
        path = os.environ['PATH']

    paths = path.split(os.pathsep)
    base, ext = os.path.splitext(executable)

    if (sys.platform == 'win32' or os.name == 'os2') and (ext != '.exe'):
        executable = executable + '.exe'

    if not os.path.isfile(executable):
        for p in paths:
            f = os.path.join(p, executable)
            if os.path.isfile(f):
                # the file exists, we have a shot at spawn working
                return f
        return None
    else:
        return executable


def _read_output(commandstring):
    """Output from successful command execution or None"""
    # Similar to os.popen(commandstring, "r").read(),
    # but without actually using os.popen because that
    # function is not usable during python bootstrap.
    # tempfile is also not available then.
    import contextlib
    try:
        import tempfile
        fp = tempfile.NamedTemporaryFile()
    except ImportError:
        fp = open("/tmp/_osx_support.%s"%(
            os.getpid(),), "w+b")

    with contextlib.closing(fp) as fp:
        cmd = "%s 2>/dev/null >'%s'" % (commandstring, fp.name)
        return fp.read().strip() if not os.system(cmd) else None


def _find_build_tool(toolname):
    """Find a build tool on current path or using xcrun"""
    return (_find_executable(toolname)
                or _read_output("/usr/bin/xcrun -find %s" % (toolname,))
                or ''
            )

_SYSTEM_VERSION = None

def _get_system_version():
    """Return the OS X system version as a string"""
    # Reading this plist is a documented way to get the system
    # version (see the documentation for the Gestalt Manager)
    # We avoid using platform.mac_ver to avoid possible bootstrap issues during
    # the build of Python itself (distutils is used to build standard library
    # extensions).

    global _SYSTEM_VERSION

    if _SYSTEM_VERSION is None:
        _SYSTEM_VERSION = ''
        try:
            f = open('/System/Library/CoreServices/SystemVersion.plist')
        except IOError:
            # We're on a plain darwin box, fall back to the default
            # behaviour.
            pass
        else:
            try:
                m = re.search(r'<key>ProductUserVisibleVersion</key>\s*'
                              r'<string>(.*?)</string>', f.read())
            finally:
                f.close()
            if m is not None:
                _SYSTEM_VERSION = '.'.join(m.group(1).split('.')[:2])
            # else: fall back to the default behaviour

    return _SYSTEM_VERSION

def _remove_original_values(_config_vars):
    """Remove original unmodified values for testing"""
    # This is needed for higher-level cross-platform tests of get_platform.
    for k in list(_config_vars):
        if k.startswith(_INITPRE):
            del _config_vars[k]

def _save_modified_value(_config_vars, cv, newvalue):
    """Save modified and original unmodified value of configuration var"""

    oldvalue = _config_vars.get(cv, '')
    if (oldvalue != newvalue) and (_INITPRE + cv not in _config_vars):
        _config_vars[_INITPRE + cv] = oldvalue
    _config_vars[cv] = newvalue

def _supports_universal_builds():
    """Returns True if universal builds are supported on this system"""
    # As an approximation, we assume that if we are running on 10.4 or above,
    # then we are running with an Xcode environment that supports universal
    # builds, in particular -isysroot and -arch arguments to the compiler. This
    # is in support of allowing 10.4 universal builds to run on 10.3.x systems.

    osx_version = _get_system_version()
    if osx_version:
        try:
            osx_version = tuple(int(i) for i in osx_version.split('.'))
        except ValueError:
            osx_version = ''
    return bool(osx_version >= (10, 4)) if osx_version else False


def _find_appropriate_compiler(_config_vars):
    """Find appropriate C compiler for extension module builds"""

    # Issue #13590:
    #    The OSX location for the compiler varies between OSX
    #    (or rather Xcode) releases.  With older releases (up-to 10.5)
    #    the compiler is in /usr/bin, with newer releases the compiler
    #    can only be found inside Xcode.app if the "Command Line Tools"
    #    are not installed.
    #
    #    Furthermore, the compiler that can be used varies between
    #    Xcode releases. Up to Xcode 4 it was possible to use 'gcc-4.2'
    #    as the compiler, after that 'clang' should be used because
    #    gcc-4.2 is either not present, or a copy of 'llvm-gcc' that
    #    miscompiles Python.

    # skip checks if the compiler was overridden with a CC env variable
    if 'CC' in os.environ:
        return _config_vars

    # The CC config var might contain additional arguments.
    # Ignore them while searching.
    cc = oldcc = _config_vars['CC'].split()[0]
    if not _find_executable(cc):
        # Compiler is not found on the shell search PATH.
        # Now search for clang, first on PATH (if the Command LIne
        # Tools have been installed in / or if the user has provided
        # another location via CC).  If not found, try using xcrun
        # to find an uninstalled clang (within a selected Xcode).

        # NOTE: Cannot use subprocess here because of bootstrap
        # issues when building Python itself (and os.popen is
        # implemented on top of subprocess and is therefore not
        # usable as well)

        cc = _find_build_tool('clang')

    elif os.path.basename(cc).startswith('gcc'):
        # Compiler is GCC, check if it is LLVM-GCC
        data = _read_output("'%s' --version"
                             % (cc.replace("'", "'\"'\"'"),))
        if data and 'llvm-gcc' in data:
            # Found LLVM-GCC, fall back to clang
            cc = _find_build_tool('clang')

    if not cc:
        raise SystemError(
               "Cannot locate working compiler")

    if cc != oldcc:
        # Found a replacement compiler.
        # Modify config vars using new compiler, if not already explicitly
        # overridden by an env variable, preserving additional arguments.
        for cv in _COMPILER_CONFIG_VARS:
            if cv in _config_vars and cv not in os.environ:
                cv_split = _config_vars[cv].split()
                cv_split[0] = cc if cv != 'CXX' else cc + '++'
                _save_modified_value(_config_vars, cv, ' '.join(cv_split))

    return _config_vars


def _remove_universal_flags(_config_vars):
    """Remove all universal build arguments from config vars"""

    for cv in _UNIVERSAL_CONFIG_VARS:
        # Do not alter a config var explicitly overridden by env var
        if cv in _config_vars and cv not in os.environ:
            flags = _config_vars[cv]
            flags = re.sub('-arch\s+\w+\s', ' ', flags)
            flags = re.sub('-isysroot [^ \t]*', ' ', flags)
            _save_modified_value(_config_vars, cv, flags)

    return _config_vars


def _remove_unsupported_archs(_config_vars):
    """Remove any unsupported archs from config vars"""
    # Different Xcode releases support different sets for '-arch'
    # flags. In particular, Xcode 4.x no longer supports the
    # PPC architectures.
    #
    # This code automatically removes '-arch ppc' and '-arch ppc64'
    # when these are not supported. That makes it possible to
    # build extensions on OSX 10.7 and later with the prebuilt
    # 32-bit installer on the python.org website.

    # skip checks if the compiler was overridden with a CC env variable
    if 'CC' in os.environ:
        return _config_vars

    if re.search('-arch\s+ppc', _config_vars['CFLAGS']) is not None:
        # NOTE: Cannot use subprocess here because of bootstrap
        # issues when building Python itself
        status = os.system(
            """echo 'int main{};' | """
            """'%s' -c -arch ppc -x c -o /dev/null /dev/null 2>/dev/null"""
            %(_config_vars['CC'].replace("'", "'\"'\"'"),))
        if status:
            # The compile failed for some reason.  Because of differences
            # across Xcode and compiler versions, there is no reliable way
            # to be sure why it failed.  Assume here it was due to lack of
            # PPC support and remove the related '-arch' flags from each
            # config variables not explicitly overridden by an environment
            # variable.  If the error was for some other reason, we hope the
            # failure will show up again when trying to compile an extension
            # module.
            for cv in _UNIVERSAL_CONFIG_VARS:
                if cv in _config_vars and cv not in os.environ:
                    flags = _config_vars[cv]
                    flags = re.sub('-arch\s+ppc\w*\s', ' ', flags)
                    _save_modified_value(_config_vars, cv, flags)

    return _config_vars


def _override_all_archs(_config_vars):
    """Allow override of all archs with ARCHFLAGS env var"""
    # NOTE: This name was introduced by Apple in OSX 10.5 and
    # is used by several scripting languages distributed with
    # that OS release.
    if 'ARCHFLAGS' in os.environ:
        arch = os.environ['ARCHFLAGS']
        for cv in _UNIVERSAL_CONFIG_VARS:
            if cv in _config_vars and '-arch' in _config_vars[cv]:
                flags = _config_vars[cv]
                flags = re.sub('-arch\s+\w+\s', ' ', flags)
                flags = flags + ' ' + arch
                _save_modified_value(_config_vars, cv, flags)

    return _config_vars


def _check_for_unavailable_sdk(_config_vars):
    """Remove references to any SDKs not available"""
    # If we're on OSX 10.5 or later and the user tries to
    # compile an extension using an SDK that is not present
    # on the current machine it is better to not use an SDK
    # than to fail.  This is particularly important with
    # the standalone Command Line Tools alternative to a
    # full-blown Xcode install since the CLT packages do not
    # provide SDKs.  If the SDK is not present, it is assumed
    # that the header files and dev libs have been installed
    # to /usr and /System/Library by either a standalone CLT
    # package or the CLT component within Xcode.
    cflags = _config_vars.get('CFLAGS', '')
    m = re.search(r'-isysroot\s+(\S+)', cflags)
    if m is not None:
        sdk = m.group(1)
        if not os.path.exists(sdk):
            for cv in _UNIVERSAL_CONFIG_VARS:
                # Do not alter a config var explicitly overridden by env var
                if cv in _config_vars and cv not in os.environ:
                    flags = _config_vars[cv]
                    flags = re.sub(r'-isysroot\s+\S+(?:\s|$)', ' ', flags)
                    _save_modified_value(_config_vars, cv, flags)

    return _config_vars


def compiler_fixup(compiler_so, cc_args):
    """
    This function will strip '-isysroot PATH' and '-arch ARCH' from the
    compile flags if the user has specified one them in extra_compile_flags.

    This is needed because '-arch ARCH' adds another architecture to the
    build, without a way to remove an architecture. Furthermore GCC will
    barf if multiple '-isysroot' arguments are present.
    """
    stripArch = stripSysroot = False

    compiler_so = list(compiler_so)

    if not _supports_universal_builds():
        # OSX before 10.4.0, these don't support -arch and -isysroot at
        # all.
        stripArch = stripSysroot = True
    else:
        stripArch = '-arch' in cc_args
        stripSysroot = '-isysroot' in cc_args

    if stripArch or 'ARCHFLAGS' in os.environ:
        while True:
            try:
                index = compiler_so.index('-arch')
                # Strip this argument and the next one:
                del compiler_so[index:index+2]
            except ValueError:
                break

    if 'ARCHFLAGS' in os.environ and not stripArch:
        # User specified different -arch flags in the environ,
        # see also distutils.sysconfig
        compiler_so = compiler_so + os.environ['ARCHFLAGS'].split()

    if stripSysroot:
        while True:
            try:
                index = compiler_so.index('-isysroot')
                # Strip this argument and the next one:
                del compiler_so[index:index+2]
            except ValueError:
                break

    # Check if the SDK that is used during compilation actually exists,
    # the universal build requires the usage of a universal SDK and not all
    # users have that installed by default.
    sysroot = None
    if '-isysroot' in cc_args:
        idx = cc_args.index('-isysroot')
        sysroot = cc_args[idx+1]
    elif '-isysroot' in compiler_so:
        idx = compiler_so.index('-isysroot')
        sysroot = compiler_so[idx+1]

    if sysroot and not os.path.isdir(sysroot):
        from distutils import log
        log.warn("Compiling with an SDK that doesn't seem to exist: %s",
                sysroot)
        log.warn("Please check your Xcode installation")

    return compiler_so


def customize_config_vars(_config_vars):
    """Customize Python build configuration variables.

    Called internally from sysconfig with a mutable mapping
    containing name/value pairs parsed from the configured
    makefile used to build this interpreter.  Returns
    the mapping updated as needed to reflect the environment
    in which the interpreter is running; in the case of
    a Python from a binary installer, the installed
    environment may be very different from the build
    environment, i.e. different OS levels, different
    built tools, different available CPU architectures.

    This customization is performed whenever
    distutils.sysconfig.get_config_vars() is first
    called.  It may be used in environments where no
    compilers are present, i.e. when installing pure
    Python dists.  Customization of compiler paths
    and detection of unavailable archs is deferred
    until the first extension module build is
    requested (in distutils.sysconfig.customize_compiler).

    Currently called from distutils.sysconfig
    """

    if not _supports_universal_builds():
        # On Mac OS X before 10.4, check if -arch and -isysroot
        # are in CFLAGS or LDFLAGS and remove them if they are.
        # This is needed when building extensions on a 10.3 system
        # using a universal build of python.
        _remove_universal_flags(_config_vars)

    # Allow user to override all archs with ARCHFLAGS env var
    _override_all_archs(_config_vars)

    # Remove references to sdks that are not found
    _check_for_unavailable_sdk(_config_vars)

    return _config_vars


def customize_compiler(_config_vars):
    """Customize compiler path and configuration variables.

    This customization is performed when the first
    extension module build is requested
    in distutils.sysconfig.customize_compiler).
    """

    # Find a compiler to use for extension module builds
    _find_appropriate_compiler(_config_vars)

    # Remove ppc arch flags if not supported here
    _remove_unsupported_archs(_config_vars)

    # Allow user to override all archs with ARCHFLAGS env var
    _override_all_archs(_config_vars)

    return _config_vars


def get_platform_osx(_config_vars, osname, release, machine):
    """Filter values for get_platform()"""
    # called from get_platform() in sysconfig and distutils.util
    #
    # For our purposes, we'll assume that the system version from
    # distutils' perspective is what MACOSX_DEPLOYMENT_TARGET is set
    # to. This makes the compatibility story a bit more sane because the
    # machine is going to compile and link as if it were
    # MACOSX_DEPLOYMENT_TARGET.

    macver = _config_vars.get('MACOSX_DEPLOYMENT_TARGET', '')
    macrelease = _get_system_version() or macver
    macver = macver or macrelease

    if macver:
        release = macver
        osname = "macosx"

        # Use the original CFLAGS value, if available, so that we
        # return the same machine type for the platform string.
        # Otherwise, distutils may consider this a cross-compiling
        # case and disallow installs.
        cflags = _config_vars.get(_INITPRE+'CFLAGS',
                                    _config_vars.get('CFLAGS', ''))
        if macrelease:
            try:
                macrelease = tuple(int(i) for i in macrelease.split('.')[0:2])
            except ValueError:
                macrelease = (10, 0)
        else:
            # assume no universal support
            macrelease = (10, 0)

        if (macrelease >= (10, 4)) and '-arch' in cflags.strip():
            # The universal build will build fat binaries, but not on
            # systems before 10.4

            machine = 'fat'

            archs = re.findall('-arch\s+(\S+)', cflags)
            archs = tuple(sorted(set(archs)))

            if len(archs) == 1:
                machine = archs[0]
            elif archs == ('i386', 'ppc'):
                machine = 'fat'
            elif archs == ('i386', 'x86_64'):
                machine = 'intel'
            elif archs == ('i386', 'ppc', 'x86_64'):
                machine = 'fat3'
            elif archs == ('ppc64', 'x86_64'):
                machine = 'fat64'
            elif archs == ('i386', 'ppc', 'ppc64', 'x86_64'):
                machine = 'universal'
            else:
                raise ValueError(
                   "Don't know machine value for archs=%r" % (archs,))

        elif machine == 'i386':
            # On OSX the machine type returned by uname is always the
            # 32-bit variant, even if the executable architecture is
            # the 64-bit variant
            if sys.maxint >= 2**32:
                machine = 'x86_64'

        elif machine in ('PowerPC', 'Power_Macintosh'):
            # Pick a sane name for the PPC architecture.
            # See 'i386' case
            if sys.maxint >= 2**32:
                machine = 'ppc64'
            else:
                machine = 'ppc'

    return (osname, release, machine)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sÎ   d  Z  d d l Z d d l Z d d l Z d d d d g Z d$ Z d% Z d Z d d Ñ Z	 d Ñ  Z
 d Ñ  Z d a d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d  Ñ  Z d! Ñ  Z d" Ñ  Z d# Ñ  Z d S(&   s   Shared OS X support functions.iˇˇˇˇNt   compiler_fixupt   customize_config_varst   customize_compilert   get_platform_osxt   CFLAGSt   LDFLAGSt   CPPFLAGSt
   BASECFLAGSt	   BLDSHAREDt   LDSHAREDt   CCt   CXXt	   PY_CFLAGSt
   PY_LDFLAGSt   PY_CPPFLAGSt   PY_CORE_CFLAGSt   _OSX_SUPPORT_INITIAL_c         C   s◊   | d k r t j d } n  | j t j É } t j j |  É \ } } t j d k sd t j	 d k r} | d k r} |  d }  n  t j j
 |  É sœ x9 | D]1 } t j j | |  É } t j j
 | É rñ | Sqñ Wd S|  Sd S(   s⁄   Tries to find 'executable' in the directories listed in 'path'.

    A string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH'].  Returns the complete filename or None if not found.
    t   PATHt   win32t   os2s   .exeN(   t   Nonet   ost   environt   splitt   pathsept   patht   splitextt   syst   platformt   namet   isfilet   join(   t
   executableR   t   pathst   baset   extt   pt   f(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _find_executable   s    *c         C   s™   d d l  } y d d l } | j É  } Wn- t k
 rW t d t j É  f d É } n X| j | É è= } d |  | j f } t j	 | É sú | j
 É  j É  Sd SWd QXd S(   s0   Output from successful command execution or NoneiˇˇˇˇNs   /tmp/_osx_support.%ss   w+bs   %s 2>/dev/null >'%s'(   t
   contextlibt   tempfilet   NamedTemporaryFilet   ImportErrort   openR   t   getpidt   closingR   t   systemt   readt   stripR   (   t   commandstringR'   R(   t   fpt   cmd(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _read_output7   s    c         C   s#   t  |  É p" t d |  f É p" d S(   s0   Find a build tool on current path or using xcruns   /usr/bin/xcrun -find %st    (   R&   R4   (   t   toolname(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _find_build_toolJ   s    c          C   sõ   t  d k ró d a  y t d É }  Wn t k
 r5 qó Xz t j d |  j É  É } Wd |  j É  X| d k	 ró d j | j	 d É j
 d É d  É a  qó n  t  S(   s*   Return the OS X system version as a stringR5   s0   /System/Library/CoreServices/SystemVersion.plists=   <key>ProductUserVisibleVersion</key>\s*<string>(.*?)</string>Nt   .i   i   (   t   _SYSTEM_VERSIONR   R+   t   IOErrort   ret   searchR/   t   closeR   t   groupR   (   R%   t   m(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _get_system_versionS   s    
	+c         C   s4   x- t  |  É D] } | j t É r |  | =q q Wd S(   s-   Remove original unmodified values for testingN(   t   listt
   startswitht   _INITPRE(   t   _config_varst   k(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _remove_original_valuesq   s    c         C   sM   |  j  | d É } | | k r? t | |  k r? | |  t | <n  | |  | <d S(   s@   Save modified and original unmodified value of configuration varR5   N(   t   getRC   (   RD   t   cvt   newvaluet   oldvalue(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _save_modified_valuex   s    c          C   si   t  É  }  |  rO y# t d Ñ  |  j d É DÉ É }  WqO t k
 rK d }  qO Xn  |  re t |  d k É St S(   s=   Returns True if universal builds are supported on this systemc         s   s   |  ] } t  | É Vq d  S(   N(   t   int(   t   .0t   i(    (    s"   /usr/lib/python2.7/_osx_support.pys	   <genexpr>ä   s    R8   R5   i
   i   (   i
   i   (   R@   t   tupleR   t
   ValueErrort   boolt   False(   t   osx_version(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _supports_universal_buildsÄ   s    	#c         C   sD  d t  j k r |  S|  d j É  d } } t | É sF t d É } n^ t  j j | É j d É r§ t d | j	 d d É f É } | r§ d | k r§ t d É } q§ n  | sπ t
 d	 É Ç n  | | k r@xx t D]m } | |  k rÃ | t  j k rÃ |  | j É  } | d
 k r| n | d | d <t |  | d j | É É qÃ qÃ Wn  |  S(   s7   Find appropriate C compiler for extension module buildsR
   i    t   clangt   gccs   '%s' --versiont   's   '"'"'s   llvm-gccs   Cannot locate working compilerR   s   ++t    (   R   R   R   R&   R7   R   t   basenameRB   R4   t   replacet   SystemErrort   _COMPILER_CONFIG_VARSRK   R   (   RD   t   cct   oldcct   dataRH   t   cv_split(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _find_appropriate_compilerê   s(     #c         C   sw   xp t  D]h } | |  k r | t j k r |  | } t j d d | É } t j d d | É } t |  | | É q q W|  S(   s5   Remove all universal build arguments from config varss   -arch\s+\w+\sRX   s   -isysroot [^ 	]*(   t   _UNIVERSAL_CONFIG_VARSR   R   R;   t   subRK   (   RD   RH   t   flags(    (    s"   /usr/lib/python2.7/_osx_support.pyt   _remove_universal_flagsŒ   s    
c         C   s√   d t  j k r |  St j d |  d É d	 k	 rø t  j d |  d j d d É f É } | rø x^ t D]S } | |  k rb | t  j k rb |  | } t j d d | É } t	 |  | | É qb qb Wqø n  |  S(
   s-   Remove any unsupported archs from config varsR
   s   -arch\s+ppcR   sN   echo 'int main{};' | '%s' -c -arch ppc -x c -o /dev/null /dev/null 2>/dev/nullRW   s   '"'"'s   -arch\s+ppc\w*\sRX   N(
   R   R   R;   R<   R   R.   RZ   Rb   Rc   RK   (   RD   t   statusRH   Rd   (    (    s"   /usr/lib/python2.7/_osx_support.pyt   _remove_unsupported_archs‹   s    	
c         C   sê   d t  j k rå t  j d } xm t D]b } | |  k r# d |  | k r# |  | } t j d d | É } | d | } t |  | | É q# q# Wn  |  S(   s2   Allow override of all archs with ARCHFLAGS env vart	   ARCHFLAGSs   -archs   -arch\s+\w+\sRX   (   R   R   Rb   R;   Rc   RK   (   RD   t   archRH   Rd   (    (    s"   /usr/lib/python2.7/_osx_support.pyt   _override_all_archs  s    
c         C   sπ   |  j  d d É } t j d | É } | d k	 rµ | j d É } t j j | É sµ x^ t D]S } | |  k rX | t j	 k rX |  | } t j
 d d | É } t |  | | É qX qX Wqµ n  |  S(   s+   Remove references to any SDKs not availableR   R5   s   -isysroot\s+(\S+)i   s   -isysroot\s+\S+(?:\s|$)RX   N(   RG   R;   R<   R   R>   R   R   t   existsRb   R   Rc   RK   (   RD   t   cflagsR?   t   sdkRH   Rd   (    (    s"   /usr/lib/python2.7/_osx_support.pyt   _check_for_unavailable_sdk  s    
c         C   s∆  t  } } t |  É }  t É  s, t } } n d | k } d | k } | sY d t j k rü xC t rõ y! |  j d É } |  | | d 5Wq\ t k
 ró Pq\ Xq\ Wn  d t j k rœ | rœ |  t j d j É  }  n  | rxC t ry! |  j d É } |  | | d 5Wqÿ t k
 rPqÿ Xqÿ Wn  d
 } d | k rM| j d É } | | d } n, d |  k ry|  j d É } |  | d } n  | r¬t j
 j | É r¬d d l m } | j d | É | j d	 É n  |  S(   se  
    This function will strip '-isysroot PATH' and '-arch ARCH' from the
    compile flags if the user has specified one them in extra_compile_flags.

    This is needed because '-arch ARCH' adds another architecture to the
    build, without a way to remove an architecture. Furthermore GCC will
    barf if multiple '-isysroot' arguments are present.
    s   -archs	   -isysrootRh   i   i   iˇˇˇˇ(   t   logs4   Compiling with an SDK that doesn't seem to exist: %ss$   Please check your Xcode installationN(   RR   RA   RT   t   TrueR   R   t   indexRP   R   R   R   t   isdirt	   distutilsRo   t   warn(   t   compiler_sot   cc_argst	   stripArcht   stripSysrootRq   t   sysroott   idxRo   (    (    s"   /usr/lib/python2.7/_osx_support.pyR    0  sF    	
				c         C   s.   t  É  s t |  É n  t |  É t |  É |  S(   sˆ  Customize Python build configuration variables.

    Called internally from sysconfig with a mutable mapping
    containing name/value pairs parsed from the configured
    makefile used to build this interpreter.  Returns
    the mapping updated as needed to reflect the environment
    in which the interpreter is running; in the case of
    a Python from a binary installer, the installed
    environment may be very different from the build
    environment, i.e. different OS levels, different
    built tools, different available CPU architectures.

    This customization is performed whenever
    distutils.sysconfig.get_config_vars() is first
    called.  It may be used in environments where no
    compilers are present, i.e. when installing pure
    Python dists.  Customization of compiler paths
    and detection of unavailable archs is deferred
    until the first extension module build is
    requested (in distutils.sysconfig.customize_compiler).

    Currently called from distutils.sysconfig
    (   RT   Re   Rj   Rn   (   RD   (    (    s"   /usr/lib/python2.7/_osx_support.pyR   p  s
    	

c         C   s"   t  |  É t |  É t |  É |  S(   s≈   Customize compiler path and configuration variables.

    This customization is performed when the first
    extension module build is requested
    in distutils.sysconfig.customize_compiler).
    (   Ra   Rg   Rj   (   RD   (    (    s"   /usr/lib/python2.7/_osx_support.pyR   ô  s    	


c         C   s  |  j  d d É } t É  p | } | p* | } | r˜| } d } |  j  t d |  j  d d É É } | rÆ y* t d Ñ  | j d É d d !DÉ É } Wq¥ t k
 r™ d } q¥ Xn d } | d k r†d | j É  k r†d } t j d | É } t t	 t
 | É É É } t | É d k r!| d } qÙ| d k r6d } qÙ| d k rKd } qÙ| d  k r`d } qÙ| d! k rud } qÙ| d" k räd } qÙt d | f É Ç q˜| d k r«t j d# k rÙd } qÙq˜| d$ k r˜t j d% k rÎd } qÙd } q˜n  | | | f S(&   s    Filter values for get_platform()t   MACOSX_DEPLOYMENT_TARGETR5   t   macosxR   c         s   s   |  ] } t  | É Vq d  S(   N(   RL   (   RM   RN   (    (    s"   /usr/lib/python2.7/_osx_support.pys	   <genexpr>«  s    R8   i    i   i
   i   s   -archt   fats   -arch\s+(\S+)i   t   i386t   ppct   x86_64t   intelt   fat3t   ppc64t   fat64t	   universals%   Don't know machine value for archs=%ri    t   PowerPCt   Power_Macintosh(   i
   i    (   i
   i    (   i
   i   (   R~   R   (   R~   RÄ   (   R~   R   RÄ   (   RÉ   RÄ   (   R~   R   RÉ   RÄ   l        (   RÜ   Rá   l        (   RG   R@   RC   RO   R   RP   R0   R;   t   findallt   sortedt   sett   lenR   t   maxint(   RD   t   osnamet   releaset   machinet   macvert
   macreleaseRl   t   archs(    (    s"   /usr/lib/python2.7/_osx_support.pyR   ≠  sP    
*						(   R   R   R   R   R   R	   R
   R   R   R   R   R   (   R   R	   R
   R   (   t   __doc__R   R;   R   t   __all__Rb   R\   RC   R   R&   R4   R7   R9   R@   RF   RK   RT   Ra   Re   Rg   Rj   Rn   R    R   R   R   (    (    (    s"   /usr/lib/python2.7/_osx_support.pyt   <module>   s<   	   							>		(			@	)	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """
Python implementation of the io module.
"""

from __future__ import (print_function, unicode_literals)

import os
import abc
import codecs
import sys
import warnings
import errno
# Import thread instead of threading to reduce startup cost
try:
    from thread import allocate_lock as Lock
except ImportError:
    from dummy_thread import allocate_lock as Lock

import io
from io import (__all__, SEEK_SET, SEEK_CUR, SEEK_END)
from errno import EINTR

__metaclass__ = type

# open() uses st_blksize whenever we can
DEFAULT_BUFFER_SIZE = 8 * 1024  # bytes

# NOTE: Base classes defined here are registered with the "official" ABCs
# defined in io.py. We don't use real inheritance though, because we don't want
# to inherit the C implementations.


class BlockingIOError(IOError):

    """Exception raised when I/O would block on a non-blocking I/O stream."""

    def __init__(self, errno, strerror, characters_written=0):
        super(IOError, self).__init__(errno, strerror)
        if not isinstance(characters_written, (int, long)):
            raise TypeError("characters_written must be a integer")
        self.characters_written = characters_written


def open(file, mode="r", buffering=-1,
         encoding=None, errors=None,
         newline=None, closefd=True):

    r"""Open file and return a stream.  Raise IOError upon failure.

    file is either a text or byte string giving the name (and the path
    if the file isn't in the current working directory) of the file to
    be opened or an integer file descriptor of the file to be
    wrapped. (If a file descriptor is given, it is closed when the
    returned I/O object is closed, unless closefd is set to False.)

    mode is an optional string that specifies the mode in which the file
    is opened. It defaults to 'r' which means open for reading in text
    mode.  Other common values are 'w' for writing (truncating the file if
    it already exists), and 'a' for appending (which on some Unix systems,
    means that all writes append to the end of the file regardless of the
    current seek position). In text mode, if encoding is not specified the
    encoding used is platform dependent. (For reading and writing raw
    bytes use binary mode and leave encoding unspecified.) The available
    modes are:

    ========= ===============================================================
    Character Meaning
    --------- ---------------------------------------------------------------
    'r'       open for reading (default)
    'w'       open for writing, truncating the file first
    'a'       open for writing, appending to the end of the file if it exists
    'b'       binary mode
    't'       text mode (default)
    '+'       open a disk file for updating (reading and writing)
    'U'       universal newline mode (for backwards compatibility; unneeded
              for new code)
    ========= ===============================================================

    The default mode is 'rt' (open for reading text). For binary random
    access, the mode 'w+b' opens and truncates the file to 0 bytes, while
    'r+b' opens the file without truncation.

    Python distinguishes between files opened in binary and text modes,
    even when the underlying operating system doesn't. Files opened in
    binary mode (appending 'b' to the mode argument) return contents as
    bytes objects without any decoding. In text mode (the default, or when
    't' is appended to the mode argument), the contents of the file are
    returned as strings, the bytes having been first decoded using a
    platform-dependent encoding or using the specified encoding if given.

    buffering is an optional integer used to set the buffering policy.
    Pass 0 to switch buffering off (only allowed in binary mode), 1 to select
    line buffering (only usable in text mode), and an integer > 1 to indicate
    the size of a fixed-size chunk buffer.  When no buffering argument is
    given, the default buffering policy works as follows:

    * Binary files are buffered in fixed-size chunks; the size of the buffer
      is chosen using a heuristic trying to determine the underlying device's
      "block size" and falling back on `io.DEFAULT_BUFFER_SIZE`.
      On many systems, the buffer will typically be 4096 or 8192 bytes long.

    * "Interactive" text files (files for which isatty() returns True)
      use line buffering.  Other text files use the policy described above
      for binary files.

    encoding is the name of the encoding used to decode or encode the
    file. This should only be used in text mode. The default encoding is
    platform dependent, but any encoding supported by Python can be
    passed.  See the codecs module for the list of supported encodings.

    errors is an optional string that specifies how encoding errors are to
    be handled---this argument should not be used in binary mode. Pass
    'strict' to raise a ValueError exception if there is an encoding error
    (the default of None has the same effect), or pass 'ignore' to ignore
    errors. (Note that ignoring encoding errors can lead to data loss.)
    See the documentation for codecs.register for a list of the permitted
    encoding error strings.

    newline controls how universal newlines works (it only applies to text
    mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as
    follows:

    * On input, if newline is None, universal newlines mode is
      enabled. Lines in the input can end in '\n', '\r', or '\r\n', and
      these are translated into '\n' before being returned to the
      caller. If it is '', universal newline mode is enabled, but line
      endings are returned to the caller untranslated. If it has any of
      the other legal values, input lines are only terminated by the given
      string, and the line ending is returned to the caller untranslated.

    * On output, if newline is None, any '\n' characters written are
      translated to the system default line separator, os.linesep. If
      newline is '', no translation takes place. If newline is any of the
      other legal values, any '\n' characters written are translated to
      the given string.

    If closefd is False, the underlying file descriptor will be kept open
    when the file is closed. This does not work when a file name is given
    and must be True in that case.

    open() returns a file object whose type depends on the mode, and
    through which the standard file operations such as reading and writing
    are performed. When open() is used to open a file in a text mode ('w',
    'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open
    a file in a binary mode, the returned class varies: in read binary
    mode, it returns a BufferedReader; in write binary and append binary
    modes, it returns a BufferedWriter, and in read/write mode, it returns
    a BufferedRandom.

    It is also possible to use a string or bytearray as a file for both
    reading and writing. For strings StringIO can be used like a file
    opened in a text mode, and for bytes a BytesIO can be used like a file
    opened in a binary mode.
    """
    if not isinstance(file, (basestring, int, long)):
        raise TypeError("invalid file: %r" % file)
    if not isinstance(mode, basestring):
        raise TypeError("invalid mode: %r" % mode)
    if not isinstance(buffering, (int, long)):
        raise TypeError("invalid buffering: %r" % buffering)
    if encoding is not None and not isinstance(encoding, basestring):
        raise TypeError("invalid encoding: %r" % encoding)
    if errors is not None and not isinstance(errors, basestring):
        raise TypeError("invalid errors: %r" % errors)
    modes = set(mode)
    if modes - set("arwb+tU") or len(mode) > len(modes):
        raise ValueError("invalid mode: %r" % mode)
    reading = "r" in modes
    writing = "w" in modes
    appending = "a" in modes
    updating = "+" in modes
    text = "t" in modes
    binary = "b" in modes
    if "U" in modes:
        if writing or appending:
            raise ValueError("can't use U and writing mode at once")
        reading = True
    if text and binary:
        raise ValueError("can't have text and binary mode at once")
    if reading + writing + appending > 1:
        raise ValueError("can't have read/write/append mode at once")
    if not (reading or writing or appending):
        raise ValueError("must have exactly one of read/write/append mode")
    if binary and encoding is not None:
        raise ValueError("binary mode doesn't take an encoding argument")
    if binary and errors is not None:
        raise ValueError("binary mode doesn't take an errors argument")
    if binary and newline is not None:
        raise ValueError("binary mode doesn't take a newline argument")
    raw = FileIO(file,
                 (reading and "r" or "") +
                 (writing and "w" or "") +
                 (appending and "a" or "") +
                 (updating and "+" or ""),
                 closefd)
    result = raw
    try:
        line_buffering = False
        if buffering == 1 or buffering < 0 and raw.isatty():
            buffering = -1
            line_buffering = True
        if buffering < 0:
            buffering = DEFAULT_BUFFER_SIZE
            try:
                bs = os.fstat(raw.fileno()).st_blksize
            except (os.error, AttributeError):
                pass
            else:
                if bs > 1:
                    buffering = bs
        if buffering < 0:
            raise ValueError("invalid buffering size")
        if buffering == 0:
            if binary:
                return result
            raise ValueError("can't have unbuffered text I/O")
        if updating:
            buffer = BufferedRandom(raw, buffering)
        elif writing or appending:
            buffer = BufferedWriter(raw, buffering)
        elif reading:
            buffer = BufferedReader(raw, buffering)
        else:
            raise ValueError("unknown mode: %r" % mode)
        result = buffer
        if binary:
            return result
        text = TextIOWrapper(buffer, encoding, errors, newline, line_buffering)
        result = text
        text.mode = mode
        return result
    except:
        result.close()
        raise


class DocDescriptor:
    """Helper for builtins.open.__doc__
    """
    def __get__(self, obj, typ):
        return (
            "open(file, mode='r', buffering=-1, encoding=None, "
                 "errors=None, newline=None, closefd=True)\n\n" +
            open.__doc__)

class OpenWrapper:
    """Wrapper for builtins.open

    Trick so that open won't become a bound method when stored
    as a class variable (as dbm.dumb does).

    See initstdio() in Python/pythonrun.c.
    """
    __doc__ = DocDescriptor()

    def __new__(cls, *args, **kwargs):
        return open(*args, **kwargs)


class UnsupportedOperation(ValueError, IOError):
    pass


class IOBase:
    __metaclass__ = abc.ABCMeta

    """The abstract base class for all I/O classes, acting on streams of
    bytes. There is no public constructor.

    This class provides dummy implementations for many methods that
    derived classes can override selectively; the default implementations
    represent a file that cannot be read, written or seeked.

    Even though IOBase does not declare read, readinto, or write because
    their signatures will vary, implementations and clients should
    consider those methods part of the interface. Also, implementations
    may raise an IOError when operations they do not support are called.

    The basic type used for binary data read from or written to a file is
    the bytes type. Method arguments may also be bytearray or memoryview of
    arrays of bytes. In some cases, such as readinto, a writable object such
    as bytearray is required. Text I/O classes work with unicode data.

    Note that calling any method (even inquiries) on a closed stream is
    undefined. Implementations may raise IOError in this case.

    IOBase (and its subclasses) support the iterator protocol, meaning
    that an IOBase object can be iterated over yielding the lines in a
    stream.

    IOBase also supports the :keyword:`with` statement. In this example,
    fp is closed after the suite of the with statement is complete:

    with open('spam.txt', 'r') as fp:
        fp.write('Spam and eggs!')
    """

    ### Internal ###

    def _unsupported(self, name):
        """Internal: raise an exception for unsupported operations."""
        raise UnsupportedOperation("%s.%s() not supported" %
                                   (self.__class__.__name__, name))

    ### Positioning ###

    def seek(self, pos, whence=0):
        """Change stream position.

        Change the stream position to byte offset pos. Argument pos is
        interpreted relative to the position indicated by whence.  Values
        for whence are:

        * 0 -- start of stream (the default); offset should be zero or positive
        * 1 -- current stream position; offset may be negative
        * 2 -- end of stream; offset is usually negative

        Return the new absolute position.
        """
        self._unsupported("seek")

    def tell(self):
        """Return current stream position."""
        return self.seek(0, 1)

    def truncate(self, pos=None):
        """Truncate file to size bytes.

        Size defaults to the current IO position as reported by tell().  Return
        the new size.
        """
        self._unsupported("truncate")

    ### Flush and close ###

    def flush(self):
        """Flush write buffers, if applicable.

        This is not implemented for read-only and non-blocking streams.
        """
        self._checkClosed()
        # XXX Should this return the number of bytes written???

    __closed = False

    def close(self):
        """Flush and close the IO object.

        This method has no effect if the file is already closed.
        """
        if not self.__closed:
            try:
                self.flush()
            finally:
                self.__closed = True

    def __del__(self):
        """Destructor.  Calls close()."""
        # The try/except block is in case this is called at program
        # exit time, when it's possible that globals have already been
        # deleted, and then the close() call might fail.  Since
        # there's nothing we can do about such failures and they annoy
        # the end users, we suppress the traceback.
        try:
            self.close()
        except:
            pass

    ### Inquiries ###

    def seekable(self):
        """Return whether object supports random access.

        If False, seek(), tell() and truncate() will raise IOError.
        This method may need to do a test seek().
        """
        return False

    def _checkSeekable(self, msg=None):
        """Internal: raise an IOError if file is not seekable
        """
        if not self.seekable():
            raise IOError("File or stream is not seekable."
                          if msg is None else msg)


    def readable(self):
        """Return whether object was opened for reading.

        If False, read() will raise IOError.
        """
        return False

    def _checkReadable(self, msg=None):
        """Internal: raise an IOError if file is not readable
        """
        if not self.readable():
            raise IOError("File or stream is not readable."
                          if msg is None else msg)

    def writable(self):
        """Return whether object was opened for writing.

        If False, write() and truncate() will raise IOError.
        """
        return False

    def _checkWritable(self, msg=None):
        """Internal: raise an IOError if file is not writable
        """
        if not self.writable():
            raise IOError("File or stream is not writable."
                          if msg is None else msg)

    @property
    def closed(self):
        """closed: bool.  True iff the file has been closed.

        For backwards compatibility, this is a property, not a predicate.
        """
        return self.__closed

    def _checkClosed(self, msg=None):
        """Internal: raise a ValueError if file is closed
        """
        if self.closed:
            raise ValueError("I/O operation on closed file."
                             if msg is None else msg)

    ### Context manager ###

    def __enter__(self):
        """Context management protocol.  Returns self."""
        self._checkClosed()
        return self

    def __exit__(self, *args):
        """Context management protocol.  Calls close()"""
        self.close()

    ### Lower-level APIs ###

    # XXX Should these be present even if unimplemented?

    def fileno(self):
        """Returns underlying file descriptor if one exists.

        An IOError is raised if the IO object does not use a file descriptor.
        """
        self._unsupported("fileno")

    def isatty(self):
        """Return whether this is an 'interactive' stream.

        Return False if it can't be determined.
        """
        self._checkClosed()
        return False

    ### Readline[s] and writelines ###

    def readline(self, limit=-1):
        r"""Read and return a line from the stream.

        If limit is specified, at most limit bytes will be read.

        The line terminator is always b'\n' for binary files; for text
        files, the newlines argument to open can be used to select the line
        terminator(s) recognized.
        """
        # For backwards compatibility, a (slowish) readline().
        if hasattr(self, "peek"):
            def nreadahead():
                readahead = self.peek(1)
                if not readahead:
                    return 1
                n = (readahead.find(b"\n") + 1) or len(readahead)
                if limit >= 0:
                    n = min(n, limit)
                return n
        else:
            def nreadahead():
                return 1
        if limit is None:
            limit = -1
        elif not isinstance(limit, (int, long)):
            raise TypeError("limit must be an integer")
        res = bytearray()
        while limit < 0 or len(res) < limit:
            b = self.read(nreadahead())
            if not b:
                break
            res += b
            if res.endswith(b"\n"):
                break
        return bytes(res)

    def __iter__(self):
        self._checkClosed()
        return self

    def next(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

    def readlines(self, hint=None):
        """Return a list of lines from the stream.

        hint can be specified to control the number of lines read: no more
        lines will be read if the total size (in bytes/characters) of all
        lines so far exceeds hint.
        """
        if hint is not None and not isinstance(hint, (int, long)):
            raise TypeError("integer or None expected")
        if hint is None or hint <= 0:
            return list(self)
        n = 0
        lines = []
        for line in self:
            lines.append(line)
            n += len(line)
            if n >= hint:
                break
        return lines

    def writelines(self, lines):
        self._checkClosed()
        for line in lines:
            self.write(line)

io.IOBase.register(IOBase)


class RawIOBase(IOBase):

    """Base class for raw binary I/O."""

    # The read() method is implemented by calling readinto(); derived
    # classes that want to support read() only need to implement
    # readinto() as a primitive operation.  In general, readinto() can be
    # more efficient than read().

    # (It would be tempting to also provide an implementation of
    # readinto() in terms of read(), in case the latter is a more suitable
    # primitive operation, but that would lead to nasty recursion in case
    # a subclass doesn't implement either.)

    def read(self, n=-1):
        """Read and return up to n bytes.

        Returns an empty bytes object on EOF, or None if the object is
        set not to block and has no data to read.
        """
        if n is None:
            n = -1
        if n < 0:
            return self.readall()
        b = bytearray(n.__index__())
        n = self.readinto(b)
        if n is None:
            return None
        del b[n:]
        return bytes(b)

    def readall(self):
        """Read until EOF, using multiple read() call."""
        res = bytearray()
        while True:
            data = self.read(DEFAULT_BUFFER_SIZE)
            if not data:
                break
            res += data
        if res:
            return bytes(res)
        else:
            # b'' or None
            return data

    def readinto(self, b):
        """Read up to len(b) bytes into b.

        Returns number of bytes read (0 for EOF), or None if the object
        is set not to block and has no data to read.
        """
        self._unsupported("readinto")

    def write(self, b):
        """Write the given buffer to the IO stream.

        Returns the number of bytes written, which may be less than len(b).
        """
        self._unsupported("write")

io.RawIOBase.register(RawIOBase)
from _io import FileIO
RawIOBase.register(FileIO)


class BufferedIOBase(IOBase):

    """Base class for buffered IO objects.

    The main difference with RawIOBase is that the read() method
    supports omitting the size argument, and does not have a default
    implementation that defers to readinto().

    In addition, read(), readinto() and write() may raise
    BlockingIOError if the underlying raw stream is in non-blocking
    mode and not ready; unlike their raw counterparts, they will never
    return None.

    A typical implementation should not inherit from a RawIOBase
    implementation, but wrap one.
    """

    def read(self, n=None):
        """Read and return up to n bytes.

        If the argument is omitted, None, or negative, reads and
        returns all data until EOF.

        If the argument is positive, and the underlying raw stream is
        not 'interactive', multiple raw reads may be issued to satisfy
        the byte count (unless EOF is reached first).  But for
        interactive raw streams (XXX and for pipes?), at most one raw
        read will be issued, and a short result does not imply that
        EOF is imminent.

        Returns an empty bytes array on EOF.

        Raises BlockingIOError if the underlying raw stream has no
        data at the moment.
        """
        self._unsupported("read")

    def read1(self, n=None):
        """Read up to n bytes with at most one read() system call."""
        self._unsupported("read1")

    def readinto(self, b):
        """Read up to len(b) bytes into b.

        Like read(), this may issue multiple reads to the underlying raw
        stream, unless the latter is 'interactive'.

        Returns the number of bytes read (0 for EOF).

        Raises BlockingIOError if the underlying raw stream has no
        data at the moment.
        """
        data = self.read(len(b))
        n = len(data)
        try:
            b[:n] = data
        except TypeError as err:
            import array
            if not isinstance(b, array.array):
                raise err
            b[:n] = array.array(b'b', data)
        return n

    def write(self, b):
        """Write the given buffer to the IO stream.

        Return the number of bytes written, which is always len(b).

        Raises BlockingIOError if the buffer is full and the
        underlying raw stream cannot accept more data at the moment.
        """
        self._unsupported("write")

    def detach(self):
        """
        Separate the underlying raw stream from the buffer and return it.

        After the raw stream has been detached, the buffer is in an unusable
        state.
        """
        self._unsupported("detach")

io.BufferedIOBase.register(BufferedIOBase)


class _BufferedIOMixin(BufferedIOBase):

    """A mixin implementation of BufferedIOBase with an underlying raw stream.

    This passes most requests on to the underlying raw stream.  It
    does *not* provide implementations of read(), readinto() or
    write().
    """

    def __init__(self, raw):
        self._raw = raw

    ### Positioning ###

    def seek(self, pos, whence=0):
        new_position = self.raw.seek(pos, whence)
        if new_position < 0:
            raise IOError("seek() returned an invalid position")
        return new_position

    def tell(self):
        pos = self.raw.tell()
        if pos < 0:
            raise IOError("tell() returned an invalid position")
        return pos

    def truncate(self, pos=None):
        # Flush the stream.  We're mixing buffered I/O with lower-level I/O,
        # and a flush may be necessary to synch both views of the current
        # file state.
        self.flush()

        if pos is None:
            pos = self.tell()
        # XXX: Should seek() be used, instead of passing the position
        # XXX  directly to truncate?
        return self.raw.truncate(pos)

    ### Flush and close ###

    def flush(self):
        if self.closed:
            raise ValueError("flush of closed file")
        self.raw.flush()

    def close(self):
        if self.raw is not None and not self.closed:
            try:
                # may raise BlockingIOError or BrokenPipeError etc
                self.flush()
            finally:
                self.raw.close()

    def detach(self):
        if self.raw is None:
            raise ValueError("raw stream already detached")
        self.flush()
        raw = self._raw
        self._raw = None
        return raw

    ### Inquiries ###

    def seekable(self):
        return self.raw.seekable()

    def readable(self):
        return self.raw.readable()

    def writable(self):
        return self.raw.writable()

    @property
    def raw(self):
        return self._raw

    @property
    def closed(self):
        return self.raw.closed

    @property
    def name(self):
        return self.raw.name

    @property
    def mode(self):
        return self.raw.mode

    def __repr__(self):
        clsname = self.__class__.__name__
        try:
            name = self.name
        except Exception:
            return "<_pyio.{0}>".format(clsname)
        else:
            return "<_pyio.{0} name={1!r}>".format(clsname, name)

    ### Lower-level APIs ###

    def fileno(self):
        return self.raw.fileno()

    def isatty(self):
        return self.raw.isatty()


class BytesIO(BufferedIOBase):

    """Buffered I/O implementation using an in-memory bytes buffer."""

    def __init__(self, initial_bytes=None):
        buf = bytearray()
        if initial_bytes is not None:
            buf.extend(initial_bytes)
        self._buffer = buf
        self._pos = 0

    def __getstate__(self):
        if self.closed:
            raise ValueError("__getstate__ on closed file")
        return self.__dict__.copy()

    def getvalue(self):
        """Return the bytes value (contents) of the buffer
        """
        if self.closed:
            raise ValueError("getvalue on closed file")
        return bytes(self._buffer)

    def read(self, n=None):
        if self.closed:
            raise ValueError("read from closed file")
        if n is None:
            n = -1
        if not isinstance(n, (int, long)):
            raise TypeError("integer argument expected, got {0!r}".format(
                type(n)))
        if n < 0:
            n = len(self._buffer)
        if len(self._buffer) <= self._pos:
            return b""
        newpos = min(len(self._buffer), self._pos + n)
        b = self._buffer[self._pos : newpos]
        self._pos = newpos
        return bytes(b)

    def read1(self, n):
        """This is the same as read.
        """
        return self.read(n)

    def write(self, b):
        if self.closed:
            raise ValueError("write to closed file")
        if isinstance(b, unicode):
            raise TypeError("can't write unicode to binary stream")
        n = len(b)
        if n == 0:
            return 0
        pos = self._pos
        if pos > len(self._buffer):
            # Inserts null bytes between the current end of the file
            # and the new write position.
            padding = b'\x00' * (pos - len(self._buffer))
            self._buffer += padding
        self._buffer[pos:pos + n] = b
        self._pos += n
        return n

    def seek(self, pos, whence=0):
        if self.closed:
            raise ValueError("seek on closed file")
        try:
            pos.__index__
        except AttributeError:
            raise TypeError("an integer is required")
        if whence == 0:
            if pos < 0:
                raise ValueError("negative seek position %r" % (pos,))
            self._pos = pos
        elif whence == 1:
            self._pos = max(0, self._pos + pos)
        elif whence == 2:
            self._pos = max(0, len(self._buffer) + pos)
        else:
            raise ValueError("invalid whence value")
        return self._pos

    def tell(self):
        if self.closed:
            raise ValueError("tell on closed file")
        return self._pos

    def truncate(self, pos=None):
        if self.closed:
            raise ValueError("truncate on closed file")
        if pos is None:
            pos = self._pos
        else:
            try:
                pos.__index__
            except AttributeError:
                raise TypeError("an integer is required")
            if pos < 0:
                raise ValueError("negative truncate position %r" % (pos,))
        del self._buffer[pos:]
        return pos

    def readable(self):
        if self.closed:
            raise ValueError("I/O operation on closed file.")
        return True

    def writable(self):
        if self.closed:
            raise ValueError("I/O operation on closed file.")
        return True

    def seekable(self):
        if self.closed:
            raise ValueError("I/O operation on closed file.")
        return True


class BufferedReader(_BufferedIOMixin):

    """BufferedReader(raw[, buffer_size])

    A buffer for a readable, sequential BaseRawIO object.

    The constructor creates a BufferedReader for the given readable raw
    stream and buffer_size. If buffer_size is omitted, DEFAULT_BUFFER_SIZE
    is used.
    """

    def __init__(self, raw, buffer_size=DEFAULT_BUFFER_SIZE):
        """Create a new buffered reader using the given readable raw IO object.
        """
        if not raw.readable():
            raise IOError('"raw" argument must be readable.')

        _BufferedIOMixin.__init__(self, raw)
        if buffer_size <= 0:
            raise ValueError("invalid buffer size")
        self.buffer_size = buffer_size
        self._reset_read_buf()
        self._read_lock = Lock()

    def _reset_read_buf(self):
        self._read_buf = b""
        self._read_pos = 0

    def read(self, n=None):
        """Read n bytes.

        Returns exactly n bytes of data unless the underlying raw IO
        stream reaches EOF or if the call would block in non-blocking
        mode. If n is negative, read until EOF or until read() would
        block.
        """
        if n is not None and n < -1:
            raise ValueError("invalid number of bytes to read")
        with self._read_lock:
            return self._read_unlocked(n)

    def _read_unlocked(self, n=None):
        nodata_val = b""
        empty_values = (b"", None)
        buf = self._read_buf
        pos = self._read_pos

        # Special case for when the number of bytes to read is unspecified.
        if n is None or n == -1:
            self._reset_read_buf()
            chunks = [buf[pos:]]  # Strip the consumed bytes.
            current_size = 0
            while True:
                # Read until EOF or until read() would block.
                try:
                    chunk = self.raw.read()
                except IOError as e:
                    if e.errno != EINTR:
                        raise
                    continue
                if chunk in empty_values:
                    nodata_val = chunk
                    break
                current_size += len(chunk)
                chunks.append(chunk)
            return b"".join(chunks) or nodata_val

        # The number of bytes to read is specified, return at most n bytes.
        avail = len(buf) - pos  # Length of the available buffered data.
        if n <= avail:
            # Fast path: the data to read is fully buffered.
            self._read_pos += n
            return buf[pos:pos+n]
        # Slow path: read from the stream until enough bytes are read,
        # or until an EOF occurs or until read() would block.
        chunks = [buf[pos:]]
        wanted = max(self.buffer_size, n)
        while avail < n:
            try:
                chunk = self.raw.read(wanted)
            except IOError as e:
                if e.errno != EINTR:
                    raise
                continue
            if chunk in empty_values:
                nodata_val = chunk
                break
            avail += len(chunk)
            chunks.append(chunk)
        # n is more than avail only when an EOF occurred or when
        # read() would have blocked.
        n = min(n, avail)
        out = b"".join(chunks)
        self._read_buf = out[n:]  # Save the extra data in the buffer.
        self._read_pos = 0
        return out[:n] if out else nodata_val

    def peek(self, n=0):
        """Returns buffered bytes without advancing the position.

        The argument indicates a desired minimal number of bytes; we
        do at most one raw read to satisfy it.  We never return more
        than self.buffer_size.
        """
        with self._read_lock:
            return self._peek_unlocked(n)

    def _peek_unlocked(self, n=0):
        want = min(n, self.buffer_size)
        have = len(self._read_buf) - self._read_pos
        if have < want or have <= 0:
            to_read = self.buffer_size - have
            while True:
                try:
                    current = self.raw.read(to_read)
                except IOError as e:
                    if e.errno != EINTR:
                        raise
                    continue
                break
            if current:
                self._read_buf = self._read_buf[self._read_pos:] + current
                self._read_pos = 0
        return self._read_buf[self._read_pos:]

    def read1(self, n):
        """Reads up to n bytes, with at most one read() system call."""
        # Returns up to n bytes.  If at least one byte is buffered, we
        # only return buffered bytes.  Otherwise, we do one raw read.
        if n < 0:
            raise ValueError("number of bytes to read must be positive")
        if n == 0:
            return b""
        with self._read_lock:
            self._peek_unlocked(1)
            return self._read_unlocked(
                min(n, len(self._read_buf) - self._read_pos))

    def tell(self):
        return _BufferedIOMixin.tell(self) - len(self._read_buf) + self._read_pos

    def seek(self, pos, whence=0):
        if not (0 <= whence <= 2):
            raise ValueError("invalid whence value")
        with self._read_lock:
            if whence == 1:
                pos -= len(self._read_buf) - self._read_pos
            pos = _BufferedIOMixin.seek(self, pos, whence)
            self._reset_read_buf()
            return pos

class BufferedWriter(_BufferedIOMixin):

    """A buffer for a writeable sequential RawIO object.

    The constructor creates a BufferedWriter for the given writeable raw
    stream. If the buffer_size is not given, it defaults to
    DEFAULT_BUFFER_SIZE.
    """

    _warning_stack_offset = 2

    def __init__(self, raw,
                 buffer_size=DEFAULT_BUFFER_SIZE, max_buffer_size=None):
        if not raw.writable():
            raise IOError('"raw" argument must be writable.')

        _BufferedIOMixin.__init__(self, raw)
        if buffer_size <= 0:
            raise ValueError("invalid buffer size")
        if max_buffer_size is not None:
            warnings.warn("max_buffer_size is deprecated", DeprecationWarning,
                          self._warning_stack_offset)
        self.buffer_size = buffer_size
        self._write_buf = bytearray()
        self._write_lock = Lock()

    def write(self, b):
        if self.closed:
            raise ValueError("write to closed file")
        if isinstance(b, unicode):
            raise TypeError("can't write unicode to binary stream")
        with self._write_lock:
            # XXX we can implement some more tricks to try and avoid
            # partial writes
            if len(self._write_buf) > self.buffer_size:
                # We're full, so let's pre-flush the buffer.  (This may
                # raise BlockingIOError with characters_written == 0.)
                self._flush_unlocked()
            before = len(self._write_buf)
            self._write_buf.extend(b)
            written = len(self._write_buf) - before
            if len(self._write_buf) > self.buffer_size:
                try:
                    self._flush_unlocked()
                except BlockingIOError as e:
                    if len(self._write_buf) > self.buffer_size:
                        # We've hit the buffer_size. We have to accept a partial
                        # write and cut back our buffer.
                        overage = len(self._write_buf) - self.buffer_size
                        written -= overage
                        self._write_buf = self._write_buf[:self.buffer_size]
                        raise BlockingIOError(e.errno, e.strerror, written)
            return written

    def truncate(self, pos=None):
        with self._write_lock:
            self._flush_unlocked()
            if pos is None:
                pos = self.raw.tell()
            return self.raw.truncate(pos)

    def flush(self):
        with self._write_lock:
            self._flush_unlocked()

    def _flush_unlocked(self):
        if self.closed:
            raise ValueError("flush of closed file")
        while self._write_buf:
            try:
                n = self.raw.write(self._write_buf)
            except BlockingIOError:
                raise RuntimeError("self.raw should implement RawIOBase: it "
                                   "should not raise BlockingIOError")
            except IOError as e:
                if e.errno != EINTR:
                    raise
                continue
            if n is None:
                raise BlockingIOError(
                    errno.EAGAIN,
                    "write could not complete without blocking", 0)
            if n > len(self._write_buf) or n < 0:
                raise IOError("write() returned incorrect number of bytes")
            del self._write_buf[:n]

    def tell(self):
        return _BufferedIOMixin.tell(self) + len(self._write_buf)

    def seek(self, pos, whence=0):
        if not (0 <= whence <= 2):
            raise ValueError("invalid whence")
        with self._write_lock:
            self._flush_unlocked()
            return _BufferedIOMixin.seek(self, pos, whence)


class BufferedRWPair(BufferedIOBase):

    """A buffered reader and writer object together.

    A buffered reader object and buffered writer object put together to
    form a sequential IO object that can read and write. This is typically
    used with a socket or two-way pipe.

    reader and writer are RawIOBase objects that are readable and
    writeable respectively. If the buffer_size is omitted it defaults to
    DEFAULT_BUFFER_SIZE.
    """

    # XXX The usefulness of this (compared to having two separate IO
    # objects) is questionable.

    def __init__(self, reader, writer,
                 buffer_size=DEFAULT_BUFFER_SIZE, max_buffer_size=None):
        """Constructor.

        The arguments are two RawIO instances.
        """
        if max_buffer_size is not None:
            warnings.warn("max_buffer_size is deprecated", DeprecationWarning, 2)

        if not reader.readable():
            raise IOError('"reader" argument must be readable.')

        if not writer.writable():
            raise IOError('"writer" argument must be writable.')

        self.reader = BufferedReader(reader, buffer_size)
        self.writer = BufferedWriter(writer, buffer_size)

    def read(self, n=None):
        if n is None:
            n = -1
        return self.reader.read(n)

    def readinto(self, b):
        return self.reader.readinto(b)

    def write(self, b):
        return self.writer.write(b)

    def peek(self, n=0):
        return self.reader.peek(n)

    def read1(self, n):
        return self.reader.read1(n)

    def readable(self):
        return self.reader.readable()

    def writable(self):
        return self.writer.writable()

    def flush(self):
        return self.writer.flush()

    def close(self):
        try:
            self.writer.close()
        finally:
            self.reader.close()

    def isatty(self):
        return self.reader.isatty() or self.writer.isatty()

    @property
    def closed(self):
        return self.writer.closed


class BufferedRandom(BufferedWriter, BufferedReader):

    """A buffered interface to random access streams.

    The constructor creates a reader and writer for a seekable stream,
    raw, given in the first argument. If the buffer_size is omitted it
    defaults to DEFAULT_BUFFER_SIZE.
    """

    _warning_stack_offset = 3

    def __init__(self, raw,
                 buffer_size=DEFAULT_BUFFER_SIZE, max_buffer_size=None):
        raw._checkSeekable()
        BufferedReader.__init__(self, raw, buffer_size)
        BufferedWriter.__init__(self, raw, buffer_size, max_buffer_size)

    def seek(self, pos, whence=0):
        if not (0 <= whence <= 2):
            raise ValueError("invalid whence")
        self.flush()
        if self._read_buf:
            # Undo read ahead.
            with self._read_lock:
                self.raw.seek(self._read_pos - len(self._read_buf), 1)
        # First do the raw seek, then empty the read buffer, so that
        # if the raw seek fails, we don't lose buffered data forever.
        pos = self.raw.seek(pos, whence)
        with self._read_lock:
            self._reset_read_buf()
        if pos < 0:
            raise IOError("seek() returned invalid position")
        return pos

    def tell(self):
        if self._write_buf:
            return BufferedWriter.tell(self)
        else:
            return BufferedReader.tell(self)

    def truncate(self, pos=None):
        if pos is None:
            pos = self.tell()
        # Use seek to flush the read buffer.
        return BufferedWriter.truncate(self, pos)

    def read(self, n=None):
        if n is None:
            n = -1
        self.flush()
        return BufferedReader.read(self, n)

    def readinto(self, b):
        self.flush()
        return BufferedReader.readinto(self, b)

    def peek(self, n=0):
        self.flush()
        return BufferedReader.peek(self, n)

    def read1(self, n):
        self.flush()
        return BufferedReader.read1(self, n)

    def write(self, b):
        if self._read_buf:
            # Undo readahead
            with self._read_lock:
                self.raw.seek(self._read_pos - len(self._read_buf), 1)
                self._reset_read_buf()
        return BufferedWriter.write(self, b)


class TextIOBase(IOBase):

    """Base class for text I/O.

    This class provides a character and line based interface to stream
    I/O. There is no readinto method because Python's character strings
    are immutable. There is no public constructor.
    """

    def read(self, n=-1):
        """Read at most n characters from stream.

        Read from underlying buffer until we have n characters or we hit EOF.
        If n is negative or omitted, read until EOF.
        """
        self._unsupported("read")

    def write(self, s):
        """Write string s to stream."""
        self._unsupported("write")

    def truncate(self, pos=None):
        """Truncate size to pos."""
        self._unsupported("truncate")

    def readline(self):
        """Read until newline or EOF.

        Returns an empty string if EOF is hit immediately.
        """
        self._unsupported("readline")

    def detach(self):
        """
        Separate the underlying buffer from the TextIOBase and return it.

        After the underlying buffer has been detached, the TextIO is in an
        unusable state.
        """
        self._unsupported("detach")

    @property
    def encoding(self):
        """Subclasses should override."""
        return None

    @property
    def newlines(self):
        """Line endings translated so far.

        Only line endings translated during reading are considered.

        Subclasses should override.
        """
        return None

    @property
    def errors(self):
        """Error setting of the decoder or encoder.

        Subclasses should override."""
        return None

io.TextIOBase.register(TextIOBase)


class IncrementalNewlineDecoder(codecs.IncrementalDecoder):
    r"""Codec used when reading a file in universal newlines mode.  It wraps
    another incremental decoder, translating \r\n and \r into \n.  It also
    records the types of newlines encountered.  When used with
    translate=False, it ensures that the newline sequence is returned in
    one piece.
    """
    def __init__(self, decoder, translate, errors='strict'):
        codecs.IncrementalDecoder.__init__(self, errors=errors)
        self.translate = translate
        self.decoder = decoder
        self.seennl = 0
        self.pendingcr = False

    def decode(self, input, final=False):
        # decode input (with the eventual \r from a previous pass)
        if self.decoder is None:
            output = input
        else:
            output = self.decoder.decode(input, final=final)
        if self.pendingcr and (output or final):
            output = "\r" + output
            self.pendingcr = False

        # retain last \r even when not translating data:
        # then readline() is sure to get \r\n in one pass
        if output.endswith("\r") and not final:
            output = output[:-1]
            self.pendingcr = True

        # Record which newlines are read
        crlf = output.count('\r\n')
        cr = output.count('\r') - crlf
        lf = output.count('\n') - crlf
        self.seennl |= (lf and self._LF) | (cr and self._CR) \
                    | (crlf and self._CRLF)

        if self.translate:
            if crlf:
                output = output.replace("\r\n", "\n")
            if cr:
                output = output.replace("\r", "\n")

        return output

    def getstate(self):
        if self.decoder is None:
            buf = b""
            flag = 0
        else:
            buf, flag = self.decoder.getstate()
        flag <<= 1
        if self.pendingcr:
            flag |= 1
        return buf, flag

    def setstate(self, state):
        buf, flag = state
        self.pendingcr = bool(flag & 1)
        if self.decoder is not None:
            self.decoder.setstate((buf, flag >> 1))

    def reset(self):
        self.seennl = 0
        self.pendingcr = False
        if self.decoder is not None:
            self.decoder.reset()

    _LF = 1
    _CR = 2
    _CRLF = 4

    @property
    def newlines(self):
        return (None,
                "\n",
                "\r",
                ("\r", "\n"),
                "\r\n",
                ("\n", "\r\n"),
                ("\r", "\r\n"),
                ("\r", "\n", "\r\n")
               )[self.seennl]


class TextIOWrapper(TextIOBase):

    r"""Character and line based layer over a BufferedIOBase object, buffer.

    encoding gives the name of the encoding that the stream will be
    decoded or encoded with. It defaults to locale.getpreferredencoding.

    errors determines the strictness of encoding and decoding (see the
    codecs.register) and defaults to "strict".

    newline can be None, '', '\n', '\r', or '\r\n'.  It controls the
    handling of line endings. If it is None, universal newlines is
    enabled.  With this enabled, on input, the lines endings '\n', '\r',
    or '\r\n' are translated to '\n' before being returned to the
    caller. Conversely, on output, '\n' is translated to the system
    default line separator, os.linesep. If newline is any other of its
    legal values, that newline becomes the newline when the file is read
    and it is returned untranslated. On output, '\n' is converted to the
    newline.

    If line_buffering is True, a call to flush is implied when a call to
    write contains a newline character.
    """

    _CHUNK_SIZE = 2048

    def __init__(self, buffer, encoding=None, errors=None, newline=None,
                 line_buffering=False):
        if newline is not None and not isinstance(newline, basestring):
            raise TypeError("illegal newline type: %r" % (type(newline),))
        if newline not in (None, "", "\n", "\r", "\r\n"):
            raise ValueError("illegal newline value: %r" % (newline,))
        if encoding is None:
            try:
                import locale
            except ImportError:
                # Importing locale may fail if Python is being built
                encoding = "ascii"
            else:
                encoding = locale.getpreferredencoding()

        if not isinstance(encoding, basestring):
            raise ValueError("invalid encoding: %r" % encoding)

        if sys.py3kwarning and not codecs.lookup(encoding)._is_text_encoding:
            msg = ("%r is not a text encoding; "
                   "use codecs.open() to handle arbitrary codecs")
            warnings.warnpy3k(msg % encoding, stacklevel=2)

        if errors is None:
            errors = "strict"
        else:
            if not isinstance(errors, basestring):
                raise ValueError("invalid errors: %r" % errors)

        self._buffer = buffer
        self._line_buffering = line_buffering
        self._encoding = encoding
        self._errors = errors
        self._readuniversal = not newline
        self._readtranslate = newline is None
        self._readnl = newline
        self._writetranslate = newline != ''
        self._writenl = newline or os.linesep
        self._encoder = None
        self._decoder = None
        self._decoded_chars = ''  # buffer for text returned from decoder
        self._decoded_chars_used = 0  # offset into _decoded_chars for read()
        self._snapshot = None  # info for reconstructing decoder state
        self._seekable = self._telling = self.buffer.seekable()

        if self._seekable and self.writable():
            position = self.buffer.tell()
            if position != 0:
                try:
                    self._get_encoder().setstate(0)
                except LookupError:
                    # Sometimes the encoder doesn't exist
                    pass

    # self._snapshot is either None, or a tuple (dec_flags, next_input)
    # where dec_flags is the second (integer) item of the decoder state
    # and next_input is the chunk of input bytes that comes next after the
    # snapshot point.  We use this to reconstruct decoder states in tell().

    # Naming convention:
    #   - "bytes_..." for integer variables that count input bytes
    #   - "chars_..." for integer variables that count decoded characters

    def __repr__(self):
        try:
            name = self.name
        except Exception:
            return "<_pyio.TextIOWrapper encoding='{0}'>".format(self.encoding)
        else:
            return "<_pyio.TextIOWrapper name={0!r} encoding='{1}'>".format(
                name, self.encoding)

    @property
    def encoding(self):
        return self._encoding

    @property
    def errors(self):
        return self._errors

    @property
    def line_buffering(self):
        return self._line_buffering

    @property
    def buffer(self):
        return self._buffer

    def seekable(self):
        if self.closed:
            raise ValueError("I/O operation on closed file.")
        return self._seekable

    def readable(self):
        return self.buffer.readable()

    def writable(self):
        return self.buffer.writable()

    def flush(self):
        self.buffer.flush()
        self._telling = self._seekable

    def close(self):
        if self.buffer is not None and not self.closed:
            try:
                self.flush()
            finally:
                self.buffer.close()

    @property
    def closed(self):
        return self.buffer.closed

    @property
    def name(self):
        return self.buffer.name

    def fileno(self):
        return self.buffer.fileno()

    def isatty(self):
        return self.buffer.isatty()

    def write(self, s):
        if self.closed:
            raise ValueError("write to closed file")
        if not isinstance(s, unicode):
            raise TypeError("can't write %s to text stream" %
                            s.__class__.__name__)
        length = len(s)
        haslf = (self._writetranslate or self._line_buffering) and "\n" in s
        if haslf and self._writetranslate and self._writenl != "\n":
            s = s.replace("\n", self._writenl)
        encoder = self._encoder or self._get_encoder()
        # XXX What if we were just reading?
        b = encoder.encode(s)
        self.buffer.write(b)
        if self._line_buffering and (haslf or "\r" in s):
            self.flush()
        self._snapshot = None
        if self._decoder:
            self._decoder.reset()
        return length

    def _get_encoder(self):
        make_encoder = codecs.getincrementalencoder(self._encoding)
        self._encoder = make_encoder(self._errors)
        return self._encoder

    def _get_decoder(self):
        make_decoder = codecs.getincrementaldecoder(self._encoding)
        decoder = make_decoder(self._errors)
        if self._readuniversal:
            decoder = IncrementalNewlineDecoder(decoder, self._readtranslate)
        self._decoder = decoder
        return decoder

    # The following three methods implement an ADT for _decoded_chars.
    # Text returned from the decoder is buffered here until the client
    # requests it by calling our read() or readline() method.
    def _set_decoded_chars(self, chars):
        """Set the _decoded_chars buffer."""
        self._decoded_chars = chars
        self._decoded_chars_used = 0

    def _get_decoded_chars(self, n=None):
        """Advance into the _decoded_chars buffer."""
        offset = self._decoded_chars_used
        if n is None:
            chars = self._decoded_chars[offset:]
        else:
            chars = self._decoded_chars[offset:offset + n]
        self._decoded_chars_used += len(chars)
        return chars

    def _rewind_decoded_chars(self, n):
        """Rewind the _decoded_chars buffer."""
        if self._decoded_chars_used < n:
            raise AssertionError("rewind decoded_chars out of bounds")
        self._decoded_chars_used -= n

    def _read_chunk(self):
        """
        Read and decode the next chunk of data from the BufferedReader.
        """

        # The return value is True unless EOF was reached.  The decoded
        # string is placed in self._decoded_chars (replacing its previous
        # value).  The entire input chunk is sent to the decoder, though
        # some of it may remain buffered in the decoder, yet to be
        # converted.

        if self._decoder is None:
            raise ValueError("no decoder")

        if self._telling:
            # To prepare for tell(), we need to snapshot a point in the
            # file where the decoder's input buffer is empty.

            dec_buffer, dec_flags = self._decoder.getstate()
            # Given this, we know there was a valid snapshot point
            # len(dec_buffer) bytes ago with decoder state (b'', dec_flags).

        # Read a chunk, decode it, and put the result in self._decoded_chars.
        input_chunk = self.buffer.read1(self._CHUNK_SIZE)
        eof = not input_chunk
        self._set_decoded_chars(self._decoder.decode(input_chunk, eof))

        if self._telling:
            # At the snapshot point, len(dec_buffer) bytes before the read,
            # the next input to be decoded is dec_buffer + input_chunk.
            self._snapshot = (dec_flags, dec_buffer + input_chunk)

        return not eof

    def _pack_cookie(self, position, dec_flags=0,
                           bytes_to_feed=0, need_eof=0, chars_to_skip=0):
        # The meaning of a tell() cookie is: seek to position, set the
        # decoder flags to dec_flags, read bytes_to_feed bytes, feed them
        # into the decoder with need_eof as the EOF flag, then skip
        # chars_to_skip characters of the decoded result.  For most simple
        # decoders, tell() will often just give a byte offset in the file.
        return (position | (dec_flags<<64) | (bytes_to_feed<<128) |
               (chars_to_skip<<192) | bool(need_eof)<<256)

    def _unpack_cookie(self, bigint):
        rest, position = divmod(bigint, 1<<64)
        rest, dec_flags = divmod(rest, 1<<64)
        rest, bytes_to_feed = divmod(rest, 1<<64)
        need_eof, chars_to_skip = divmod(rest, 1<<64)
        return position, dec_flags, bytes_to_feed, need_eof, chars_to_skip

    def tell(self):
        if not self._seekable:
            raise IOError("underlying stream is not seekable")
        if not self._telling:
            raise IOError("telling position disabled by next() call")
        self.flush()
        position = self.buffer.tell()
        decoder = self._decoder
        if decoder is None or self._snapshot is None:
            if self._decoded_chars:
                # This should never happen.
                raise AssertionError("pending decoded text")
            return position

        # Skip backward to the snapshot point (see _read_chunk).
        dec_flags, next_input = self._snapshot
        position -= len(next_input)

        # How many decoded characters have been used up since the snapshot?
        chars_to_skip = self._decoded_chars_used
        if chars_to_skip == 0:
            # We haven't moved from the snapshot point.
            return self._pack_cookie(position, dec_flags)

        # Starting from the snapshot position, we will walk the decoder
        # forward until it gives us enough decoded characters.
        saved_state = decoder.getstate()
        try:
            # Note our initial start point.
            decoder.setstate((b'', dec_flags))
            start_pos = position
            start_flags, bytes_fed, chars_decoded = dec_flags, 0, 0
            need_eof = 0

            # Feed the decoder one byte at a time.  As we go, note the
            # nearest "safe start point" before the current location
            # (a point where the decoder has nothing buffered, so seek()
            # can safely start from there and advance to this location).
            for next_byte in next_input:
                bytes_fed += 1
                chars_decoded += len(decoder.decode(next_byte))
                dec_buffer, dec_flags = decoder.getstate()
                if not dec_buffer and chars_decoded <= chars_to_skip:
                    # Decoder buffer is empty, so this is a safe start point.
                    start_pos += bytes_fed
                    chars_to_skip -= chars_decoded
                    start_flags, bytes_fed, chars_decoded = dec_flags, 0, 0
                if chars_decoded >= chars_to_skip:
                    break
            else:
                # We didn't get enough decoded data; signal EOF to get more.
                chars_decoded += len(decoder.decode(b'', final=True))
                need_eof = 1
                if chars_decoded < chars_to_skip:
                    raise IOError("can't reconstruct logical file position")

            # The returned cookie corresponds to the last safe start point.
            return self._pack_cookie(
                start_pos, start_flags, bytes_fed, need_eof, chars_to_skip)
        finally:
            decoder.setstate(saved_state)

    def truncate(self, pos=None):
        self.flush()
        if pos is None:
            pos = self.tell()
        return self.buffer.truncate(pos)

    def detach(self):
        if self.buffer is None:
            raise ValueError("buffer is already detached")
        self.flush()
        buffer = self._buffer
        self._buffer = None
        return buffer

    def seek(self, cookie, whence=0):
        if self.closed:
            raise ValueError("tell on closed file")
        if not self._seekable:
            raise IOError("underlying stream is not seekable")
        if whence == 1: # seek relative to current position
            if cookie != 0:
                raise IOError("can't do nonzero cur-relative seeks")
            # Seeking to the current position should attempt to
            # sync the underlying buffer with the current position.
            whence = 0
            cookie = self.tell()
        if whence == 2: # seek relative to end of file
            if cookie != 0:
                raise IOError("can't do nonzero end-relative seeks")
            self.flush()
            position = self.buffer.seek(0, 2)
            self._set_decoded_chars('')
            self._snapshot = None
            if self._decoder:
                self._decoder.reset()
            return position
        if whence != 0:
            raise ValueError("invalid whence (%r, should be 0, 1 or 2)" %
                             (whence,))
        if cookie < 0:
            raise ValueError("negative seek position %r" % (cookie,))
        self.flush()

        # The strategy of seek() is to go back to the safe start point
        # and replay the effect of read(chars_to_skip) from there.
        start_pos, dec_flags, bytes_to_feed, need_eof, chars_to_skip = \
            self._unpack_cookie(cookie)

        # Seek back to the safe start point.
        self.buffer.seek(start_pos)
        self._set_decoded_chars('')
        self._snapshot = None

        # Restore the decoder to its state from the safe start point.
        if cookie == 0 and self._decoder:
            self._decoder.reset()
        elif self._decoder or dec_flags or chars_to_skip:
            self._decoder = self._decoder or self._get_decoder()
            self._decoder.setstate((b'', dec_flags))
            self._snapshot = (dec_flags, b'')

        if chars_to_skip:
            # Just like _read_chunk, feed the decoder and save a snapshot.
            input_chunk = self.buffer.read(bytes_to_feed)
            self._set_decoded_chars(
                self._decoder.decode(input_chunk, need_eof))
            self._snapshot = (dec_flags, input_chunk)

            # Skip chars_to_skip of the decoded characters.
            if len(self._decoded_chars) < chars_to_skip:
                raise IOError("can't restore logical file position")
            self._decoded_chars_used = chars_to_skip

        # Finally, reset the encoder (merely useful for proper BOM handling)
        try:
            encoder = self._encoder or self._get_encoder()
        except LookupError:
            # Sometimes the encoder doesn't exist
            pass
        else:
            if cookie != 0:
                encoder.setstate(0)
            else:
                encoder.reset()
        return cookie

    def read(self, n=None):
        self._checkReadable()
        if n is None:
            n = -1
        decoder = self._decoder or self._get_decoder()
        try:
            n.__index__
        except AttributeError:
            raise TypeError("an integer is required")
        if n < 0:
            # Read everything.
            result = (self._get_decoded_chars() +
                      decoder.decode(self.buffer.read(), final=True))
            self._set_decoded_chars('')
            self._snapshot = None
            return result
        else:
            # Keep reading chunks until we have n characters to return.
            eof = False
            result = self._get_decoded_chars(n)
            while len(result) < n and not eof:
                eof = not self._read_chunk()
                result += self._get_decoded_chars(n - len(result))
            return result

    def next(self):
        self._telling = False
        line = self.readline()
        if not line:
            self._snapshot = None
            self._telling = self._seekable
            raise StopIteration
        return line

    def readline(self, limit=None):
        if self.closed:
            raise ValueError("read from closed file")
        if limit is None:
            limit = -1
        elif not isinstance(limit, (int, long)):
            raise TypeError("limit must be an integer")

        # Grab all the decoded text (we will rewind any extra bits later).
        line = self._get_decoded_chars()

        start = 0
        # Make the decoder if it doesn't already exist.
        if not self._decoder:
            self._get_decoder()

        pos = endpos = None
        while True:
            if self._readtranslate:
                # Newlines are already translated, only search for \n
                pos = line.find('\n', start)
                if pos >= 0:
                    endpos = pos + 1
                    break
                else:
                    start = len(line)

            elif self._readuniversal:
                # Universal newline search. Find any of \r, \r\n, \n
                # The decoder ensures that \r\n are not split in two pieces

                # In C we'd look for these in parallel of course.
                nlpos = line.find("\n", start)
                crpos = line.find("\r", start)
                if crpos == -1:
                    if nlpos == -1:
                        # Nothing found
                        start = len(line)
                    else:
                        # Found \n
                        endpos = nlpos + 1
                        break
                elif nlpos == -1:
                    # Found lone \r
                    endpos = crpos + 1
                    break
                elif nlpos < crpos:
                    # Found \n
                    endpos = nlpos + 1
                    break
                elif nlpos == crpos + 1:
                    # Found \r\n
                    endpos = crpos + 2
                    break
                else:
                    # Found \r
                    endpos = crpos + 1
                    break
            else:
                # non-universal
                pos = line.find(self._readnl)
                if pos >= 0:
                    endpos = pos + len(self._readnl)
                    break

            if limit >= 0 and len(line) >= limit:
                endpos = limit  # reached length limit
                break

            # No line ending seen yet - get more data'
            while self._read_chunk():
                if self._decoded_chars:
                    break
            if self._decoded_chars:
                line += self._get_decoded_chars()
            else:
                # end of file
                self._set_decoded_chars('')
                self._snapshot = None
                return line

        if limit >= 0 and endpos > limit:
            endpos = limit  # don't exceed limit

        # Rewind _decoded_chars to just after the line ending we found.
        self._rewind_decoded_chars(len(line) - endpos)
        return line[:endpos]

    @property
    def newlines(self):
        return self._decoder.newlines if self._decoder else None


class StringIO(TextIOWrapper):
    """Text I/O implementation using an in-memory buffer.

    The initial_value argument sets the value of object.  The newline
    argument is like the one of TextIOWrapper's constructor.
    """

    def __init__(self, initial_value="", newline="\n"):
        super(StringIO, self).__init__(BytesIO(),
                                       encoding="utf-8",
                                       errors="strict",
                                       newline=newline)
        # Issue #5645: make universal newlines semantics the same as in the
        # C version, even under Windows.
        if newline is None:
            self._writetranslate = False
        if initial_value:
            if not isinstance(initial_value, unicode):
                initial_value = unicode(initial_value)
            self.write(initial_value)
            self.seek(0)

    def getvalue(self):
        self.flush()
        decoder = self._decoder or self._get_decoder()
        old_state = decoder.getstate()
        decoder.reset()
        try:
            return decoder.decode(self.buffer.getvalue(), final=True)
        finally:
            decoder.setstate(old_state)

    def __repr__(self):
        # TextIOWrapper tells the encoding in its repr. In StringIO,
        # that's an implementation detail.
        return object.__repr__(self)

    @property
    def errors(self):
        return None

    @property
    def encoding(self):
        return None

    def detach(self):
        # This doesn't make sense on StringIO.
        self._unsupported("detach")
                                      Û
”´[c           @   s6   d  d l  Z  e e  d É r( d  d l Tn
 d  d l Td S(   iˇˇˇˇNt   gettotalrefcount(   t   *(   t   syst   hasattrt   _sysconfigdata_dt   _sysconfigdata_nd(    (    (    s$   /usr/lib/python2.7/_sysconfigdata.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """Thread-local objects.

(Note that this module provides a Python version of the threading.local
 class.  Depending on the version of Python you're using, there may be a
 faster one available.  You should always import the `local` class from
 `threading`.)

Thread-local objects support the management of thread-local data.
If you have data that you want to be local to a thread, simply create
a thread-local object and use its attributes:

  >>> mydata = local()
  >>> mydata.number = 42
  >>> mydata.number
  42

You can also access the local-object's dictionary:

  >>> mydata.__dict__
  {'number': 42}
  >>> mydata.__dict__.setdefault('widgets', [])
  []
  >>> mydata.widgets
  []

What's important about thread-local objects is that their data are
local to a thread. If we access the data in a different thread:

  >>> log = []
  >>> def f():
  ...     items = mydata.__dict__.items()
  ...     items.sort()
  ...     log.append(items)
  ...     mydata.number = 11
  ...     log.append(mydata.number)

  >>> import threading
  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [[], 11]

we get different data.  Furthermore, changes made in the other thread
don't affect data seen in this thread:

  >>> mydata.number
  42

Of course, values you get from a local object, including a __dict__
attribute, are for whatever thread was current at the time the
attribute was read.  For that reason, you generally don't want to save
these values across threads, as they apply only to the thread they
came from.

You can create custom local objects by subclassing the local class:

  >>> class MyLocal(local):
  ...     number = 2
  ...     initialized = False
  ...     def __init__(self, **kw):
  ...         if self.initialized:
  ...             raise SystemError('__init__ called too many times')
  ...         self.initialized = True
  ...         self.__dict__.update(kw)
  ...     def squared(self):
  ...         return self.number ** 2

This can be useful to support default values, methods and
initialization.  Note that if you define an __init__ method, it will be
called each time the local object is used in a separate thread.  This
is necessary to initialize each thread's dictionary.

Now if we create a local object:

  >>> mydata = MyLocal(color='red')

Now we have a default number:

  >>> mydata.number
  2

an initial color:

  >>> mydata.color
  'red'
  >>> del mydata.color

And a method that operates on the data:

  >>> mydata.squared()
  4

As before, we can access the data in a separate thread:

  >>> log = []
  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [[('color', 'red'), ('initialized', True)], 11]

without affecting this thread's data:

  >>> mydata.number
  2
  >>> mydata.color
  Traceback (most recent call last):
  ...
  AttributeError: 'MyLocal' object has no attribute 'color'

Note that subclasses can define slots, but they are not thread
local. They are shared across threads:

  >>> class MyLocal(local):
  ...     __slots__ = 'number'

  >>> mydata = MyLocal()
  >>> mydata.number = 42
  >>> mydata.color = 'red'

So, the separate thread:

  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()

affects what we see:

  >>> mydata.number
  11

>>> del mydata
"""

__all__ = ["local"]

# We need to use objects from the threading module, but the threading
# module may also want to use our `local` class, if support for locals
# isn't compiled in to the `thread` module.  This creates potential problems
# with circular imports.  For that reason, we don't import `threading`
# until the bottom of this file (a hack sufficient to worm around the
# potential problems).  Note that almost all platforms do have support for
# locals in the `thread` module, and there is no circular import problem
# then, so problems introduced by fiddling the order of imports here won't
# manifest on most boxes.

class _localbase(object):
    __slots__ = '_local__key', '_local__args', '_local__lock'

    def __new__(cls, *args, **kw):
        self = object.__new__(cls)
        key = '_local__key', 'thread.local.' + str(id(self))
        object.__setattr__(self, '_local__key', key)
        object.__setattr__(self, '_local__args', (args, kw))
        object.__setattr__(self, '_local__lock', RLock())

        if (args or kw) and (cls.__init__ is object.__init__):
            raise TypeError("Initialization arguments are not supported")

        # We need to create the thread dict in anticipation of
        # __init__ being called, to make sure we don't call it
        # again ourselves.
        dict = object.__getattribute__(self, '__dict__')
        current_thread().__dict__[key] = dict

        return self

def _patch(self):
    key = object.__getattribute__(self, '_local__key')
    d = current_thread().__dict__.get(key)
    if d is None:
        d = {}
        current_thread().__dict__[key] = d
        object.__setattr__(self, '__dict__', d)

        # we have a new instance dict, so call out __init__ if we have
        # one
        cls = type(self)
        if cls.__init__ is not object.__init__:
            args, kw = object.__getattribute__(self, '_local__args')
            cls.__init__(self, *args, **kw)
    else:
        object.__setattr__(self, '__dict__', d)

class local(_localbase):

    def __getattribute__(self, name):
        lock = object.__getattribute__(self, '_local__lock')
        lock.acquire()
        try:
            _patch(self)
            return object.__getattribute__(self, name)
        finally:
            lock.release()

    def __setattr__(self, name, value):
        if name == '__dict__':
            raise AttributeError(
                "%r object attribute '__dict__' is read-only"
                % self.__class__.__name__)
        lock = object.__getattribute__(self, '_local__lock')
        lock.acquire()
        try:
            _patch(self)
            return object.__setattr__(self, name, value)
        finally:
            lock.release()

    def __delattr__(self, name):
        if name == '__dict__':
            raise AttributeError(
                "%r object attribute '__dict__' is read-only"
                % self.__class__.__name__)
        lock = object.__getattribute__(self, '_local__lock')
        lock.acquire()
        try:
            _patch(self)
            return object.__delattr__(self, name)
        finally:
            lock.release()

    def __del__(self):
        import threading

        key = object.__getattribute__(self, '_local__key')

        try:
            # We use the non-locking API since we might already hold the lock
            # (__del__ can be called at any point by the cyclic GC).
            threads = threading._enumerate()
        except:
            # If enumerating the current threads fails, as it seems to do
            # during shutdown, we'll skip cleanup under the assumption
            # that there is nothing to clean up.
            return

        for thread in threads:
            try:
                __dict__ = thread.__dict__
            except AttributeError:
                # Thread is dying, rest in peace.
                continue

            if key in __dict__:
                try:
                    del __dict__[key]
                except KeyError:
                    pass # didn't have anything in this thread

from threading import current_thread, RLock
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Û
”´[c           @  s‹  d  Z  d d l m Z m Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 y d d l
 m Z Wn! e k
 rõ d d l m Z n Xd d l Z d d l m Z m Z m Z m Z d d l	 m Z e Z d d Z d	 e f d
 Ñ  É  YZ d d e e e e d Ñ Z d f  d Ñ  É  YZ d f  d Ñ  É  YZ d e e f d Ñ  É  YZ  d f  d Ñ  É  YZ! e j! j" e! É d e! f d Ñ  É  YZ# e j# j" e# É d d l$ m% Z% e# j" e% É d e! f d Ñ  É  YZ& e j& j" e& É d e& f d Ñ  É  YZ' d e& f d Ñ  É  YZ( d e' f d Ñ  É  YZ) d  e' f d! Ñ  É  YZ* d" e& f d# Ñ  É  YZ+ d$ e* e) f d% Ñ  É  YZ, d& e! f d' Ñ  É  YZ- e j- j" e- É d( e j. f d) Ñ  É  YZ/ d* e- f d+ Ñ  É  YZ0 d, e0 f d- Ñ  É  YZ1 d S(.   u)   
Python implementation of the io module.
iˇˇˇˇ(   t   print_functiont   unicode_literalsN(   t   allocate_lock(   t   __all__t   SEEK_SETt   SEEK_CURt   SEEK_END(   t   EINTRi   i   t   BlockingIOErrorc           B  s   e  Z d  Z d d Ñ Z RS(   uC   Exception raised when I/O would block on a non-blocking I/O stream.i    c         C  sJ   t  t |  É j | | É t | t t f É s= t d É Ç n  | |  _ d  S(   Nu$   characters_written must be a integer(   t   supert   IOErrort   __init__t
   isinstancet   intt   longt	   TypeErrort   characters_written(   t   selft   errnot   strerrorR   (    (    s   /usr/lib/python2.7/_pyio.pyR   %   s    (   t   __name__t
   __module__t   __doc__R   (    (    (    s   /usr/lib/python2.7/_pyio.pyR   !   s   u   rc         C  s<  t  |  t t t f É s+ t d |  É Ç n  t  | t É sM t d | É Ç n  t  | t t f É su t d | É Ç n  | d k	 r§ t  | t É r§ t d | É Ç n  | d k	 r” t  | t É r” t d | É Ç n  t | É } | t d É st | É t | É k rt d | É Ç n  d | k } d | k }	 d	 | k }
 d
 | k } d | k } d | k } d | k rí|	 sz|
 rât d É Ç n  t	 } n  | r≠| r≠t d É Ç n  | |	 |
 d k r–t d É Ç n  | pﬂ|	 pﬂ|
 sÒt d É Ç n  | r| d k	 rt d É Ç n  | r3| d k	 r3t d É Ç n  | rT| d k	 rTt d É Ç n  t
 |  | rfd pid |	 rud pxd |
 rÖd	 pàd | rïd
 pòd | É } | } yyt } | d k s’| d k  r‰| j É  r‰d } t	 } n  | d k  rGt } y t j | j É  É j } Wn t j t f k
 r.qGX| d k rG| } qGn  | d k  rbt d É Ç n  | d k rá| rx| St d É Ç n  | rüt | | É } nF |	 s´|
 rΩt | | É } n( | r’t | | É } n t d | É Ç | } | rı| St | | | | | É } | } | | _ | SWn | j É  Ç  n Xd S(   uˆ  Open file and return a stream.  Raise IOError upon failure.

    file is either a text or byte string giving the name (and the path
    if the file isn't in the current working directory) of the file to
    be opened or an integer file descriptor of the file to be
    wrapped. (If a file descriptor is given, it is closed when the
    returned I/O object is closed, unless closefd is set to False.)

    mode is an optional string that specifies the mode in which the file
    is opened. It defaults to 'r' which means open for reading in text
    mode.  Other common values are 'w' for writing (truncating the file if
    it already exists), and 'a' for appending (which on some Unix systems,
    means that all writes append to the end of the file regardless of the
    current seek position). In text mode, if encoding is not specified the
    encoding used is platform dependent. (For reading and writing raw
    bytes use binary mode and leave encoding unspecified.) The available
    modes are:

    ========= ===============================================================
    Character Meaning
    --------- ---------------------------------------------------------------
    'r'       open for reading (default)
    'w'       open for writing, truncating the file first
    'a'       open for writing, appending to the end of the file if it exists
    'b'       binary mode
    't'       text mode (default)
    '+'       open a disk file for updating (reading and writing)
    'U'       universal newline mode (for backwards compatibility; unneeded
              for new code)
    ========= ===============================================================

    The default mode is 'rt' (open for reading text). For binary random
    access, the mode 'w+b' opens and truncates the file to 0 bytes, while
    'r+b' opens the file without truncation.

    Python distinguishes between files opened in binary and text modes,
    even when the underlying operating system doesn't. Files opened in
    binary mode (appending 'b' to the mode argument) return contents as
    bytes objects without any decoding. In text mode (the default, or when
    't' is appended to the mode argument), the contents of the file are
    returned as strings, the bytes having been first decoded using a
    platform-dependent encoding or using the specified encoding if given.

    buffering is an optional integer used to set the buffering policy.
    Pass 0 to switch buffering off (only allowed in binary mode), 1 to select
    line buffering (only usable in text mode), and an integer > 1 to indicate
    the size of a fixed-size chunk buffer.  When no buffering argument is
    given, the default buffering policy works as follows:

    * Binary files are buffered in fixed-size chunks; the size of the buffer
      is chosen using a heuristic trying to determine the underlying device's
      "block size" and falling back on `io.DEFAULT_BUFFER_SIZE`.
      On many systems, the buffer will typically be 4096 or 8192 bytes long.

    * "Interactive" text files (files for which isatty() returns True)
      use line buffering.  Other text files use the policy described above
      for binary files.

    encoding is the name of the encoding used to decode or encode the
    file. This should only be used in text mode. The default encoding is
    platform dependent, but any encoding supported by Python can be
    passed.  See the codecs module for the list of supported encodings.

    errors is an optional string that specifies how encoding errors are to
    be handled---this argument should not be used in binary mode. Pass
    'strict' to raise a ValueError exception if there is an encoding error
    (the default of None has the same effect), or pass 'ignore' to ignore
    errors. (Note that ignoring encoding errors can lead to data loss.)
    See the documentation for codecs.register for a list of the permitted
    encoding error strings.

    newline controls how universal newlines works (it only applies to text
    mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as
    follows:

    * On input, if newline is None, universal newlines mode is
      enabled. Lines in the input can end in '\n', '\r', or '\r\n', and
      these are translated into '\n' before being returned to the
      caller. If it is '', universal newline mode is enabled, but line
      endings are returned to the caller untranslated. If it has any of
      the other legal values, input lines are only terminated by the given
      string, and the line ending is returned to the caller untranslated.

    * On output, if newline is None, any '\n' characters written are
      translated to the system default line separator, os.linesep. If
      newline is '', no translation takes place. If newline is any of the
      other legal values, any '\n' characters written are translated to
      the given string.

    If closefd is False, the underlying file descriptor will be kept open
    when the file is closed. This does not work when a file name is given
    and must be True in that case.

    open() returns a file object whose type depends on the mode, and
    through which the standard file operations such as reading and writing
    are performed. When open() is used to open a file in a text mode ('w',
    'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open
    a file in a binary mode, the returned class varies: in read binary
    mode, it returns a BufferedReader; in write binary and append binary
    modes, it returns a BufferedWriter, and in read/write mode, it returns
    a BufferedRandom.

    It is also possible to use a string or bytearray as a file for both
    reading and writing. For strings StringIO can be used like a file
    opened in a text mode, and for bytes a BytesIO can be used like a file
    opened in a binary mode.
    u   invalid file: %ru   invalid mode: %ru   invalid buffering: %ru   invalid encoding: %ru   invalid errors: %ru   arwb+tUu   ru   wu   au   +u   tu   bu   Uu$   can't use U and writing mode at onceu'   can't have text and binary mode at oncei   u)   can't have read/write/append mode at onceu/   must have exactly one of read/write/append modeu-   binary mode doesn't take an encoding argumentu+   binary mode doesn't take an errors argumentu+   binary mode doesn't take a newline argumentu    i    iˇˇˇˇu   invalid buffering sizeu   can't have unbuffered text I/Ou   unknown mode: %rN(   R   t
   basestringR   R   R   t   Nonet   sett   lent
   ValueErrort   Truet   FileIOt   Falset   isattyt   DEFAULT_BUFFER_SIZEt   ost   fstatt   filenot
   st_blksizet   errort   AttributeErrort   BufferedRandomt   BufferedWritert   BufferedReadert   TextIOWrappert   modet   close(   t   fileR+   t	   bufferingt   encodingt   errorst   newlinet   closefdt   modest   readingt   writingt	   appendingt   updatingt   textt   binaryt   rawt   resultt   line_bufferingt   bst   buffer(    (    s   /usr/lib/python2.7/_pyio.pyt   open,   sò    o(	/	$		
t   DocDescriptorc           B  s   e  Z d  Z d Ñ  Z RS(   u%   Helper for builtins.open.__doc__
    c         C  s   d t  j S(   Nu\   open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True)

(   R?   R   (   R   t   objt   typ(    (    s   /usr/lib/python2.7/_pyio.pyt   __get__   s    (   R   R   R   RC   (    (    (    s   /usr/lib/python2.7/_pyio.pyR@   Ì   s   t   OpenWrapperc           B  s    e  Z d  Z e É  Z d Ñ  Z RS(   u∂   Wrapper for builtins.open

    Trick so that open won't become a bound method when stored
    as a class variable (as dbm.dumb does).

    See initstdio() in Python/pythonrun.c.
    c         O  s   t  | | é  S(   N(   R?   (   t   clst   argst   kwargs(    (    s   /usr/lib/python2.7/_pyio.pyt   __new__   s    (   R   R   R   R@   RH   (    (    (    s   /usr/lib/python2.7/_pyio.pyRD   ˆ   s   	t   UnsupportedOperationc           B  s   e  Z RS(    (   R   R   (    (    (    s   /usr/lib/python2.7/_pyio.pyRI     s   t   IOBasec           B  s  e  Z e j Z d  Ñ  Z d d Ñ Z d Ñ  Z d d Ñ Z	 d Ñ  Z
 e Z d Ñ  Z d Ñ  Z d Ñ  Z d d	 Ñ Z d
 Ñ  Z d d Ñ Z d Ñ  Z d d Ñ Z e d Ñ  É Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z  RS(   c         C  s    t  d |  j j | f É Ç d S(   u8   Internal: raise an exception for unsupported operations.u   %s.%s() not supportedN(   RI   t	   __class__R   (   R   t   name(    (    s   /usr/lib/python2.7/_pyio.pyt   _unsupported,  s    i    c         C  s   |  j  d É d S(   uæ  Change stream position.

        Change the stream position to byte offset pos. Argument pos is
        interpreted relative to the position indicated by whence.  Values
        for whence are:

        * 0 -- start of stream (the default); offset should be zero or positive
        * 1 -- current stream position; offset may be negative
        * 2 -- end of stream; offset is usually negative

        Return the new absolute position.
        u   seekN(   RM   (   R   t   post   whence(    (    s   /usr/lib/python2.7/_pyio.pyt   seek3  s    c         C  s   |  j  d d É S(   u   Return current stream position.i    i   (   RP   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   tellB  s    c         C  s   |  j  d É d S(   uå   Truncate file to size bytes.

        Size defaults to the current IO position as reported by tell().  Return
        the new size.
        u   truncateN(   RM   (   R   RN   (    (    s   /usr/lib/python2.7/_pyio.pyt   truncateF  s    c         C  s   |  j  É  d S(   uu   Flush write buffers, if applicable.

        This is not implemented for read-only and non-blocking streams.
        N(   t   _checkClosed(   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   flushP  s    c         C  s+   |  j  s' z |  j É  Wd t |  _  Xn  d S(   ui   Flush and close the IO object.

        This method has no effect if the file is already closed.
        N(   t   _IOBase__closedRT   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR,   Z  s    	c         C  s   y |  j  É  Wn n Xd S(   u   Destructor.  Calls close().N(   R,   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   __del__e  s    c         C  s   t  S(   u≠   Return whether object supports random access.

        If False, seek(), tell() and truncate() will raise IOError.
        This method may need to do a test seek().
        (   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   seekables  s    c         C  s1   |  j  É  s- t | d k r! d n | É Ç n  d S(   u;   Internal: raise an IOError if file is not seekable
        u   File or stream is not seekable.N(   RW   R
   R   (   R   t   msg(    (    s   /usr/lib/python2.7/_pyio.pyt   _checkSeekable{  s    c         C  s   t  S(   ud   Return whether object was opened for reading.

        If False, read() will raise IOError.
        (   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   readableÉ  s    c         C  s1   |  j  É  s- t | d k r! d n | É Ç n  d S(   u;   Internal: raise an IOError if file is not readable
        u   File or stream is not readable.N(   RZ   R
   R   (   R   RX   (    (    s   /usr/lib/python2.7/_pyio.pyt   _checkReadableä  s    c         C  s   t  S(   ut   Return whether object was opened for writing.

        If False, write() and truncate() will raise IOError.
        (   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   writableë  s    c         C  s1   |  j  É  s- t | d k r! d n | É Ç n  d S(   u;   Internal: raise an IOError if file is not writable
        u   File or stream is not writable.N(   R\   R
   R   (   R   RX   (    (    s   /usr/lib/python2.7/_pyio.pyt   _checkWritableò  s    c         C  s   |  j  S(   uÖ   closed: bool.  True iff the file has been closed.

        For backwards compatibility, this is a property, not a predicate.
        (   RU   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   closedü  s    c         C  s.   |  j  r* t | d k r d n | É Ç n  d S(   u7   Internal: raise a ValueError if file is closed
        u   I/O operation on closed file.N(   R^   R   R   (   R   RX   (    (    s   /usr/lib/python2.7/_pyio.pyRS   ß  s    	c         C  s   |  j  É  |  S(   u+   Context management protocol.  Returns self.(   RS   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt	   __enter__∞  s    
c         G  s   |  j  É  d S(   u+   Context management protocol.  Calls close()N(   R,   (   R   RF   (    (    s   /usr/lib/python2.7/_pyio.pyt   __exit__µ  s    c         C  s   |  j  d É d S(   uâ   Returns underlying file descriptor if one exists.

        An IOError is raised if the IO object does not use a file descriptor.
        u   filenoN(   RM   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR#   Ω  s    c         C  s   |  j  É  t S(   ui   Return whether this is an 'interactive' stream.

        Return False if it can't be determined.
        (   RS   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR   ƒ  s    
iˇˇˇˇc           s◊   t  à d É r$ á  á f d Ü  } n	 d Ñ  } à  d k rB d â  n$ t à  t t f É sf t d É Ç n  t É  } x[ à  d k  sê t | É à  k  rÃ à j | É  É } | s¨ Pn  | | 7} | j	 d É rr Pqr qr Wt
 | É S(	   u(  Read and return a line from the stream.

        If limit is specified, at most limit bytes will be read.

        The line terminator is always b'\n' for binary files; for text
        files, the newlines argument to open can be used to select the line
        terminator(s) recognized.
        u   peekc            sZ   à j  d É }  |  s d S|  j d É d p5 t |  É } à  d k rV t | à  É } n  | S(   Ni   s   
i    (   t   peekt   findR   t   min(   t	   readaheadt   n(   t   limitR   (    s   /usr/lib/python2.7/_pyio.pyt
   nreadaheadŸ  s    c           S  s   d S(   Ni   (    (    (    (    s   /usr/lib/python2.7/_pyio.pyRg   ‚  s    iˇˇˇˇu   limit must be an integeri    s   
N(   t   hasattrR   R   R   R   R   t	   bytearrayR   t   readt   endswitht   bytes(   R   Rf   Rg   t   rest   b(    (   Rf   R   s   /usr/lib/python2.7/_pyio.pyt   readlineŒ  s     
				!
c         C  s   |  j  É  |  S(   N(   RS   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   __iter__Ú  s    
c         C  s   |  j  É  } | s t Ç n  | S(   N(   Ro   t   StopIteration(   R   t   line(    (    s   /usr/lib/python2.7/_pyio.pyt   nextˆ  s    	c         C  s°   | d k	 r1 t | t t f É r1 t d É Ç n  | d k sI | d k rS t |  É Sd } g  } x; |  D]3 } | j | É | t | É 7} | | k rf Pqf qf W| S(   uÈ   Return a list of lines from the stream.

        hint can be specified to control the number of lines read: no more
        lines will be read if the total size (in bytes/characters) of all
        lines so far exceeds hint.
        u   integer or None expectedi    N(   R   R   R   R   R   t   listt   appendR   (   R   t   hintRe   t   linesRr   (    (    s   /usr/lib/python2.7/_pyio.pyt	   readlines¸  s    "
c         C  s,   |  j  É  x | D] } |  j | É q Wd  S(   N(   RS   t   write(   R   Rw   Rr   (    (    s   /usr/lib/python2.7/_pyio.pyt
   writelines  s    
N(!   R   R   t   abct   ABCMetat   __metaclass__RM   RP   RQ   R   RR   RT   R   RU   R,   RV   RW   RY   RZ   R[   R\   R]   t   propertyR^   RS   R_   R`   R#   R   Ro   Rp   Rs   Rx   Rz   (    (    (    s   /usr/lib/python2.7/_pyio.pyRJ     s4   	#		
											
$		t	   RawIOBasec           B  s5   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   u   Base class for raw binary I/O.iˇˇˇˇc         C  sm   | d k r d } n  | d k  r+ |  j É  St | j É  É } |  j | É } | d k r\ d S| | 3t | É S(   u°   Read and return up to n bytes.

        Returns an empty bytes object on EOF, or None if the object is
        set not to block and has no data to read.
        iˇˇˇˇi    N(   R   t   readallRi   t	   __index__t   readintoRl   (   R   Re   Rn   (    (    s   /usr/lib/python2.7/_pyio.pyRj   &  s    	
c         C  sQ   t  É  } x- t r8 |  j t É } | s+ Pn  | | 7} q W| rI t | É S| Sd S(   u+   Read until EOF, using multiple read() call.N(   Ri   R   Rj   R    Rl   (   R   Rm   t   data(    (    s   /usr/lib/python2.7/_pyio.pyRÄ   7  s    		
c         C  s   |  j  d É d S(   u¶   Read up to len(b) bytes into b.

        Returns number of bytes read (0 for EOF), or None if the object
        is set not to block and has no data to read.
        u   readintoN(   RM   (   R   Rn   (    (    s   /usr/lib/python2.7/_pyio.pyRÇ   E  s    c         C  s   |  j  d É d S(   u~   Write the given buffer to the IO stream.

        Returns the number of bytes written, which may be less than len(b).
        u   writeN(   RM   (   R   Rn   (    (    s   /usr/lib/python2.7/_pyio.pyRy   M  s    (   R   R   R   Rj   RÄ   RÇ   Ry   (    (    (    s   /usr/lib/python2.7/_pyio.pyR     s
   		(   R   t   BufferedIOBasec           B  sA   e  Z d  Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   u  Base class for buffered IO objects.

    The main difference with RawIOBase is that the read() method
    supports omitting the size argument, and does not have a default
    implementation that defers to readinto().

    In addition, read(), readinto() and write() may raise
    BlockingIOError if the underlying raw stream is in non-blocking
    mode and not ready; unlike their raw counterparts, they will never
    return None.

    A typical implementation should not inherit from a RawIOBase
    implementation, but wrap one.
    c         C  s   |  j  d É d S(   uã  Read and return up to n bytes.

        If the argument is omitted, None, or negative, reads and
        returns all data until EOF.

        If the argument is positive, and the underlying raw stream is
        not 'interactive', multiple raw reads may be issued to satisfy
        the byte count (unless EOF is reached first).  But for
        interactive raw streams (XXX and for pipes?), at most one raw
        read will be issued, and a short result does not imply that
        EOF is imminent.

        Returns an empty bytes array on EOF.

        Raises BlockingIOError if the underlying raw stream has no
        data at the moment.
        u   readN(   RM   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRj   j  s    c         C  s   |  j  d É d S(   u7   Read up to n bytes with at most one read() system call.u   read1N(   RM   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyt   read1~  s    c         C  sÜ   |  j  t | É É } t | É } y | | | *WnP t k
 rÅ } d d l } t | | j É sh | Ç n  | j d | É | | *n X| S(   u=  Read up to len(b) bytes into b.

        Like read(), this may issue multiple reads to the underlying raw
        stream, unless the latter is 'interactive'.

        Returns the number of bytes read (0 for EOF).

        Raises BlockingIOError if the underlying raw stream has no
        data at the moment.
        iˇˇˇˇNRn   (   Rj   R   R   t   arrayR   (   R   Rn   RÉ   Re   t   errRÜ   (    (    s   /usr/lib/python2.7/_pyio.pyRÇ   Ç  s    	c         C  s   |  j  d É d S(   u˘   Write the given buffer to the IO stream.

        Return the number of bytes written, which is always len(b).

        Raises BlockingIOError if the buffer is full and the
        underlying raw stream cannot accept more data at the moment.
        u   writeN(   RM   (   R   Rn   (    (    s   /usr/lib/python2.7/_pyio.pyRy   ò  s    c         C  s   |  j  d É d S(   u∞   
        Separate the underlying raw stream from the buffer and return it.

        After the raw stream has been detached, the buffer is in an unusable
        state.
        u   detachN(   RM   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   detach¢  s    N(	   R   R   R   R   Rj   RÖ   RÇ   Ry   Rà   (    (    (    s   /usr/lib/python2.7/_pyio.pyRÑ   Y  s   		
t   _BufferedIOMixinc           B  s≈   e  Z d  Z d Ñ  Z d d Ñ Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z e d Ñ  É Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   u›   A mixin implementation of BufferedIOBase with an underlying raw stream.

    This passes most requests on to the underlying raw stream.  It
    does *not* provide implementations of read(), readinto() or
    write().
    c         C  s   | |  _  d  S(   N(   t   _raw(   R   R:   (    (    s   /usr/lib/python2.7/_pyio.pyR   ∑  s    i    c         C  s4   |  j  j | | É } | d k  r0 t d É Ç n  | S(   Ni    u#   seek() returned an invalid position(   R:   RP   R
   (   R   RN   RO   t   new_position(    (    s   /usr/lib/python2.7/_pyio.pyRP   º  s    c         C  s.   |  j  j É  } | d k  r* t d É Ç n  | S(   Ni    u#   tell() returned an invalid position(   R:   RQ   R
   (   R   RN   (    (    s   /usr/lib/python2.7/_pyio.pyRQ   ¬  s    c         C  s5   |  j  É  | d  k r% |  j É  } n  |  j j | É S(   N(   RT   R   RQ   R:   RR   (   R   RN   (    (    s   /usr/lib/python2.7/_pyio.pyRR   »  s    
c         C  s)   |  j  r t d É Ç n  |  j j É  d  S(   Nu   flush of closed file(   R^   R   R:   RT   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRT   ÷  s    	c         C  s?   |  j  d  k	 r; |  j r; z |  j É  Wd  |  j  j É  Xn  d  S(   N(   R:   R   R^   RT   R,   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR,   €  s    c         C  s>   |  j  d  k r t d É Ç n  |  j É  |  j } d  |  _ | S(   Nu   raw stream already detached(   R:   R   R   RT   Rä   (   R   R:   (    (    s   /usr/lib/python2.7/_pyio.pyRà   „  s    
		c         C  s   |  j  j É  S(   N(   R:   RW   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRW   Ì  s    c         C  s   |  j  j É  S(   N(   R:   RZ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRZ     s    c         C  s   |  j  j É  S(   N(   R:   R\   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR\   Û  s    c         C  s   |  j  S(   N(   Rä   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR:   ˆ  s    c         C  s
   |  j  j S(   N(   R:   R^   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR^   ˙  s    c         C  s
   |  j  j S(   N(   R:   RL   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRL   ˛  s    c         C  s
   |  j  j S(   N(   R:   R+   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR+     s    c         C  sK   |  j  j } y |  j } Wn t k
 r6 d j | É SXd j | | É Sd  S(   Nu   <_pyio.{0}>u   <_pyio.{0} name={1!r}>(   RK   R   RL   t	   Exceptiont   format(   R   t   clsnameRL   (    (    s   /usr/lib/python2.7/_pyio.pyt   __repr__  s    c         C  s   |  j  j É  S(   N(   R:   R#   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR#     s    c         C  s   |  j  j É  S(   N(   R:   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR     s    N(   R   R   R   R   RP   RQ   R   RR   RT   R,   Rà   RW   RZ   R\   R~   R:   R^   RL   R+   Rè   R#   R   (    (    (    s   /usr/lib/python2.7/_pyio.pyRâ   Æ  s$   					
					t   BytesIOc           B  sÜ   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z	 d d Ñ Z
 d	 Ñ  Z d d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   u<   Buffered I/O implementation using an in-memory bytes buffer.c         C  s;   t  É  } | d  k	 r% | j | É n  | |  _ d |  _ d  S(   Ni    (   Ri   R   t   extendt   _buffert   _pos(   R   t   initial_bytest   buf(    (    s   /usr/lib/python2.7/_pyio.pyR     s
    		c         C  s%   |  j  r t d É Ç n  |  j j É  S(   Nu   __getstate__ on closed file(   R^   R   t   __dict__t   copy(   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   __getstate__#  s    	c         C  s%   |  j  r t d É Ç n  t |  j É S(   u8   Return the bytes value (contents) of the buffer
        u   getvalue on closed file(   R^   R   Rl   Rí   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   getvalue(  s    	c         C  sﬂ   |  j  r t d É Ç n  | d  k r- d } n  t | t t f É s` t d j t | É É É Ç n  | d k  r~ t	 |  j
 É } n  t	 |  j
 É |  j k rö d St t	 |  j
 É |  j | É } |  j
 |  j | !} | |  _ t | É S(   Nu   read from closed fileiˇˇˇˇu$   integer argument expected, got {0!r}i    t    (   R^   R   R   R   R   R   R   Rç   t   typeR   Rí   Rì   Rc   Rl   (   R   Re   t   newposRn   (    (    s   /usr/lib/python2.7/_pyio.pyRj   /  s    				c         C  s   |  j  | É S(   u"   This is the same as read.
        (   Rj   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRÖ   @  s    c         C  s¿   |  j  r t d É Ç n  t | t É r6 t d É Ç n  t | É } | d k rR d S|  j } | t |  j É k rô d | t |  j É } |  j | 7_ n  | |  j | | | +|  j | 7_ | S(   Nu   write to closed fileu$   can't write unicode to binary streami    s    (   R^   R   R   t   unicodeR   R   Rì   Rí   (   R   Rn   Re   RN   t   padding(    (    s   /usr/lib/python2.7/_pyio.pyRy   E  s    		i    c         C  sÊ   |  j  r t d É Ç n  y | j Wn t k
 rB t d É Ç n X| d k r} | d k  rq t d | f É Ç n  | |  _ nb | d k r• t d |  j | É |  _ n: | d k r” t d t |  j É | É |  _ n t d É Ç |  j S(   Nu   seek on closed fileu   an integer is requiredi    u   negative seek position %ri   i   u   invalid whence value(	   R^   R   RÅ   R&   R   Rì   t   maxR   Rí   (   R   RN   RO   (    (    s   /usr/lib/python2.7/_pyio.pyRP   W  s     	"c         C  s   |  j  r t d É Ç n  |  j S(   Nu   tell on closed file(   R^   R   Rì   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRQ   j  s    	c         C  sã   |  j  r t d É Ç n  | d  k r0 |  j } nM y | j Wn t k
 rZ t d É Ç n X| d k  r} t d | f É Ç n  |  j | 3| S(   Nu   truncate on closed fileu   an integer is requiredi    u   negative truncate position %r(   R^   R   R   Rì   RÅ   R&   R   Rí   (   R   RN   (    (    s   /usr/lib/python2.7/_pyio.pyRR   o  s    	
c         C  s   |  j  r t d É Ç n  t S(   Nu   I/O operation on closed file.(   R^   R   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRZ   ~  s    	c         C  s   |  j  r t d É Ç n  t S(   Nu   I/O operation on closed file.(   R^   R   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR\   É  s    	c         C  s   |  j  r t d É Ç n  t S(   Nu   I/O operation on closed file.(   R^   R   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRW   à  s    	N(   R   R   R   R   R   Rò   Rô   Rj   RÖ   Ry   RP   RQ   RR   RZ   R\   RW   (    (    (    s   /usr/lib/python2.7/_pyio.pyRê     s   							R)   c           B  sq   e  Z d  Z e d Ñ Z d Ñ  Z d d Ñ Z d d Ñ Z d d Ñ Z	 d d Ñ Z
 d Ñ  Z d	 Ñ  Z d d
 Ñ Z RS(   u  BufferedReader(raw[, buffer_size])

    A buffer for a readable, sequential BaseRawIO object.

    The constructor creates a BufferedReader for the given readable raw
    stream and buffer_size. If buffer_size is omitted, DEFAULT_BUFFER_SIZE
    is used.
    c         C  si   | j  É  s t d É Ç n  t j |  | É | d k rF t d É Ç n  | |  _ |  j É  t É  |  _ d S(   uM   Create a new buffered reader using the given readable raw IO object.
        u    "raw" argument must be readable.i    u   invalid buffer sizeN(	   RZ   R
   Râ   R   R   t   buffer_sizet   _reset_read_buft   Lockt
   _read_lock(   R   R:   R†   (    (    s   /usr/lib/python2.7/_pyio.pyR   ô  s    	
c         C  s   d |  _  d |  _ d  S(   NRö   i    (   t	   _read_buft	   _read_pos(   R   (    (    s   /usr/lib/python2.7/_pyio.pyR°   ¶  s    	c         C  sH   | d k	 r' | d k  r' t d É Ç n  |  j è |  j | É SWd QXd S(   uˆ   Read n bytes.

        Returns exactly n bytes of data unless the underlying raw IO
        stream reaches EOF or if the call would block in non-blocking
        mode. If n is negative, read until EOF or until read() would
        block.
        iˇˇˇˇu   invalid number of bytes to readN(   R   R   R£   t   _read_unlocked(   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRj   ™  s    
c         C  s  d } d } |  j } |  j } | d  k s6 | d k rÁ |  j É  | | g } d } x~ t r” y |  j j É  } Wn+ t k
 rú }	 |	 j t	 k rV Ç  qV qV n X| | k r≥ | } Pn  | t
 | É 7} | j | É qV Wd j | É pÊ | St
 | É | }
 | |
 k r!|  j | 7_ | | | | !S| | g } t |  j | É } xá |
 | k  r…y |  j j | É } Wn+ t k
 rí}	 |	 j t	 k rCÇ  qCqCn X| | k r©| } Pn  |
 t
 | É 7}
 | j | É qCWt | |
 É } d j | É } | | |  _ d |  _ | r| |  S| S(   NRö   iˇˇˇˇi    (   Rö   N(   R   R§   R•   R°   R   R:   Rj   R
   R   R   R   Ru   t   joinRü   R†   Rc   (   R   Re   t
   nodata_valt   empty_valuesRï   RN   t   chunkst   current_sizet   chunkt   et   availt   wantedt   out(    (    s   /usr/lib/python2.7/_pyio.pyR¶   ∑  sX    		
		i    c         C  s!   |  j  è |  j | É SWd QXd S(   uÈ   Returns buffered bytes without advancing the position.

        The argument indicates a desired minimal number of bytes; we
        do at most one raw read to satisfy it.  We never return more
        than self.buffer_size.
        N(   R£   t   _peek_unlocked(   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRa   Ô  s    
c         C  sŸ   t  | |  j É } t |  j É |  j } | | k  s@ | d k rÀ |  j | } xO t rû y |  j j | É } Wn+ t k
 rô } | j	 t
 k rP Ç  qP qP n XPqP W| rÀ |  j |  j | |  _ d |  _ qÀ n  |  j |  j S(   Ni    (   Rc   R†   R   R§   R•   R   R:   Rj   R
   R   R   (   R   Re   t   wantt   havet   to_readt   currentR≠   (    (    s   /usr/lib/python2.7/_pyio.pyR±   ˘  s     	c      	   C  sr   | d k  r t  d É Ç n  | d k r+ d S|  j è8 |  j d É |  j t | t |  j É |  j É É SWd QXd S(   u9   Reads up to n bytes, with at most one read() system call.i    u(   number of bytes to read must be positiveRö   i   N(   R   R£   R±   R¶   Rc   R   R§   R•   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRÖ     s    
c         C  s!   t  j |  É t |  j É |  j S(   N(   Râ   RQ   R   R§   R•   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRQ     s    c         C  sã   d | k o d k n s+ t  d É Ç n  |  j èQ | d k r^ | t |  j É |  j 8} n  t j |  | | É } |  j É  | SWd  QXd  S(   Ni    i   u   invalid whence valuei   (   R   R£   R   R§   R•   Râ   RP   R°   (   R   RN   RO   (    (    s   /usr/lib/python2.7/_pyio.pyRP     s    

N(   R   R   R   R    R   R°   R   Rj   R¶   Ra   R±   RÖ   RQ   RP   (    (    (    s   /usr/lib/python2.7/_pyio.pyR)   é  s   		8
		R(   c           B  s_   e  Z d  Z d Z e d
 d Ñ Z d Ñ  Z d
 d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d d	 Ñ Z RS(   u’   A buffer for a writeable sequential RawIO object.

    The constructor creates a BufferedWriter for the given writeable raw
    stream. If the buffer_size is not given, it defaults to
    DEFAULT_BUFFER_SIZE.
    i   c         C  sê   | j  É  s t d É Ç n  t j |  | É | d k rF t d É Ç n  | d  k	 rk t j d t |  j	 É n  | |  _
 t É  |  _ t É  |  _ d  S(   Nu    "raw" argument must be writable.i    u   invalid buffer sizeu   max_buffer_size is deprecated(   R\   R
   Râ   R   R   R   t   warningst   warnt   DeprecationWarningt   _warning_stack_offsetR†   Ri   t
   _write_bufR¢   t   _write_lock(   R   R:   R†   t   max_buffer_size(    (    s   /usr/lib/python2.7/_pyio.pyR   0  s    	c      	   C  sJ  |  j  r t d É Ç n  t | t É r6 t d É Ç n  |  j èt |  j É |  j k re |  j	 É  n  t |  j É } |  j j
 | É t |  j É | } t |  j É |  j k r<y |  j	 É  Wq<t k
 r8} t |  j É |  j k r9t |  j É |  j } | | 8} |  j |  j  |  _ t | j | j | É Ç q9q<Xn  | SWd  QXd  S(   Nu   write to closed fileu$   can't write unicode to binary stream(   R^   R   R   Rù   R   Rª   R   R∫   R†   t   _flush_unlockedRë   R   R   R   (   R   Rn   t   beforet   writtenR≠   t   overage(    (    s   /usr/lib/python2.7/_pyio.pyRy   ?  s(    	

"c         C  sL   |  j  è= |  j É  | d  k r2 |  j j É  } n  |  j j | É SWd  QXd  S(   N(   Rª   RΩ   R   R:   RQ   RR   (   R   RN   (    (    s   /usr/lib/python2.7/_pyio.pyRR   [  s
    

c         C  s   |  j  è |  j É  Wd  QXd  S(   N(   Rª   RΩ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRT   b  s    
c         C  sÌ   |  j  r t d É Ç n  xŒ |  j rË y |  j j |  j É } WnG t k
 r\ t d É Ç n+ t k
 rÜ } | j t	 k r Ç  q q n X| d  k r´ t t j d d É Ç n  | t |  j É k sÃ | d k  r€ t d É Ç n  |  j | 4q Wd  S(   Nu   flush of closed fileuH   self.raw should implement RawIOBase: it should not raise BlockingIOErroru)   write could not complete without blockingi    u*   write() returned incorrect number of bytes(   R^   R   R∫   R:   Ry   R   t   RuntimeErrorR
   R   R   R   t   EAGAINR   (   R   Re   R≠   (    (    s   /usr/lib/python2.7/_pyio.pyRΩ   f  s$    	!c         C  s   t  j |  É t |  j É S(   N(   Râ   RQ   R   R∫   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRQ   {  s    i    c         C  s\   d | k o d k n s+ t  d É Ç n  |  j è" |  j É  t j |  | | É SWd  QXd  S(   Ni    i   u   invalid whence(   R   Rª   RΩ   Râ   RP   (   R   RN   RO   (    (    s   /usr/lib/python2.7/_pyio.pyRP   ~  s
    

N(   R   R   R   Rπ   R    R   R   Ry   RR   RT   RΩ   RQ   RP   (    (    (    s   /usr/lib/python2.7/_pyio.pyR(   %  s   				t   BufferedRWPairc           B  så   e  Z d  Z e d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z RS(   uì  A buffered reader and writer object together.

    A buffered reader object and buffered writer object put together to
    form a sequential IO object that can read and write. This is typically
    used with a socket or two-way pipe.

    reader and writer are RawIOBase objects that are readable and
    writeable respectively. If the buffer_size is omitted it defaults to
    DEFAULT_BUFFER_SIZE.
    c         C  sÄ   | d k	 r" t j d t d É n  | j É  s= t d É Ç n  | j É  sX t d É Ç n  t | | É |  _ t	 | | É |  _
 d S(   uE   Constructor.

        The arguments are two RawIO instances.
        u   max_buffer_size is deprecatedi   u#   "reader" argument must be readable.u#   "writer" argument must be writable.N(   R   R∂   R∑   R∏   RZ   R
   R\   R)   t   readerR(   t   writer(   R   Rƒ   R≈   R†   Rº   (    (    s   /usr/lib/python2.7/_pyio.pyR   ñ  s    c         C  s%   | d  k r d } n  |  j j | É S(   Niˇˇˇˇ(   R   Rƒ   Rj   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRj   ®  s    	c         C  s   |  j  j | É S(   N(   Rƒ   RÇ   (   R   Rn   (    (    s   /usr/lib/python2.7/_pyio.pyRÇ   ≠  s    c         C  s   |  j  j | É S(   N(   R≈   Ry   (   R   Rn   (    (    s   /usr/lib/python2.7/_pyio.pyRy   ∞  s    i    c         C  s   |  j  j | É S(   N(   Rƒ   Ra   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRa   ≥  s    c         C  s   |  j  j | É S(   N(   Rƒ   RÖ   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRÖ   ∂  s    c         C  s   |  j  j É  S(   N(   Rƒ   RZ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRZ   π  s    c         C  s   |  j  j É  S(   N(   R≈   R\   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR\   º  s    c         C  s   |  j  j É  S(   N(   R≈   RT   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRT   ø  s    c         C  s&   z |  j  j É  Wd  |  j j É  Xd  S(   N(   R≈   R,   Rƒ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR,   ¬  s    c         C  s   |  j  j É  p |  j j É  S(   N(   Rƒ   R   R≈   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR   »  s    c         C  s
   |  j  j S(   N(   R≈   R^   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR^   À  s    N(   R   R   R   R    R   R   Rj   RÇ   Ry   Ra   RÖ   RZ   R\   RT   R,   R   R~   R^   (    (    (    s   /usr/lib/python2.7/_pyio.pyR√   Ü  s   								R'   c           B  sw   e  Z d  Z d Z e d d Ñ Z d d Ñ Z d Ñ  Z d d Ñ Z	 d d Ñ Z
 d Ñ  Z d d	 Ñ Z d
 Ñ  Z d Ñ  Z RS(   uÁ   A buffered interface to random access streams.

    The constructor creates a reader and writer for a seekable stream,
    raw, given in the first argument. If the buffer_size is omitted it
    defaults to DEFAULT_BUFFER_SIZE.
    i   c         C  s7   | j  É  t j |  | | É t j |  | | | É d  S(   N(   RY   R)   R   R(   (   R   R:   R†   Rº   (    (    s   /usr/lib/python2.7/_pyio.pyR   €  s    
i    c         C  s¬   d | k o d k n s+ t  d É Ç n  |  j É  |  j rt |  j è( |  j j |  j t |  j É d É Wd  QXn  |  j j | | É } |  j è |  j É  Wd  QX| d k  ræ t	 d É Ç n  | S(   Ni    i   u   invalid whencei   u    seek() returned invalid position(
   R   RT   R§   R£   R:   RP   R•   R   R°   R
   (   R   RN   RO   (    (    s   /usr/lib/python2.7/_pyio.pyRP   ·  s    
	
,
c         C  s'   |  j  r t j |  É St j |  É Sd  S(   N(   R∫   R(   RQ   R)   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRQ   Ú  s    	c         C  s+   | d  k r |  j É  } n  t j |  | É S(   N(   R   RQ   R(   RR   (   R   RN   (    (    s   /usr/lib/python2.7/_pyio.pyRR   ¯  s    c         C  s/   | d  k r d } n  |  j É  t j |  | É S(   Niˇˇˇˇ(   R   RT   R)   Rj   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRj   ˛  s    	
c         C  s   |  j  É  t j |  | É S(   N(   RT   R)   RÇ   (   R   Rn   (    (    s   /usr/lib/python2.7/_pyio.pyRÇ     s    
c         C  s   |  j  É  t j |  | É S(   N(   RT   R)   Ra   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRa     s    
c         C  s   |  j  É  t j |  | É S(   N(   RT   R)   RÖ   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRÖ     s    
c         C  sY   |  j  rI |  j è2 |  j j |  j t |  j  É d É |  j É  Wd  QXn  t j |  | É S(   Ni   (	   R§   R£   R:   RP   R•   R   R°   R(   Ry   (   R   Rn   (    (    s   /usr/lib/python2.7/_pyio.pyRy     s
    	
#N(   R   R   R   Rπ   R    R   R   RP   RQ   RR   Rj   RÇ   Ra   RÖ   Ry   (    (    (    s   /usr/lib/python2.7/_pyio.pyR'   –  s   			t
   TextIOBasec           B  sn   e  Z d  Z d d Ñ Z d Ñ  Z d
 d Ñ Z d Ñ  Z d Ñ  Z e	 d Ñ  É Z
 e	 d Ñ  É Z e	 d	 Ñ  É Z RS(   u‡   Base class for text I/O.

    This class provides a character and line based interface to stream
    I/O. There is no readinto method because Python's character strings
    are immutable. There is no public constructor.
    iˇˇˇˇc         C  s   |  j  d É d S(   u≥   Read at most n characters from stream.

        Read from underlying buffer until we have n characters or we hit EOF.
        If n is negative or omitted, read until EOF.
        u   readN(   RM   (   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyRj   "  s    c         C  s   |  j  d É d S(   u   Write string s to stream.u   writeN(   RM   (   R   t   s(    (    s   /usr/lib/python2.7/_pyio.pyRy   *  s    c         C  s   |  j  d É d S(   u   Truncate size to pos.u   truncateN(   RM   (   R   RN   (    (    s   /usr/lib/python2.7/_pyio.pyRR   .  s    c         C  s   |  j  d É d S(   u_   Read until newline or EOF.

        Returns an empty string if EOF is hit immediately.
        u   readlineN(   RM   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRo   2  s    c         C  s   |  j  d É d S(   u∑   
        Separate the underlying buffer from the TextIOBase and return it.

        After the underlying buffer has been detached, the TextIO is in an
        unusable state.
        u   detachN(   RM   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRà   9  s    c         C  s   d S(   u   Subclasses should override.N(   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR/   B  s    c         C  s   d S(   uí   Line endings translated so far.

        Only line endings translated during reading are considered.

        Subclasses should override.
        N(   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyt   newlinesG  s    c         C  s   d S(   uM   Error setting of the decoder or encoder.

        Subclasses should override.N(   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR0   Q  s    N(   R   R   R   Rj   Ry   R   RR   Ro   Rà   R~   R/   R»   R0   (    (    (    s   /usr/lib/python2.7/_pyio.pyR∆     s   				
t   IncrementalNewlineDecoderc           B  sb   e  Z d  Z d d Ñ Z e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Z	 d Z
 d	 Z e d
 Ñ  É Z RS(   u+  Codec used when reading a file in universal newlines mode.  It wraps
    another incremental decoder, translating \r\n and \r into \n.  It also
    records the types of newlines encountered.  When used with
    translate=False, it ensures that the newline sequence is returned in
    one piece.
    u   strictc         C  s>   t  j j |  d | É| |  _ | |  _ d |  _ t |  _ d  S(   NR0   i    (   t   codecst   IncrementalDecoderR   t	   translatet   decodert   seennlR   t	   pendingcr(   R   RÕ   RÃ   R0   (    (    s   /usr/lib/python2.7/_pyio.pyR   b  s
    			c         C  s4  |  j  d  k r | } n |  j  j | d | É} |  j r[ | sE | r[ d | } t |  _ n  | j d É rá | rá | d  } t |  _ n  | j d É } | j d É | } | j d É | } |  j | oœ |  j	 | o€ |  j
 B| oË |  j BO_ |  j r0| r| j d d É } n  | r0| j d d É } q0n  | S(   Nt   finalu   iˇˇˇˇu   
u   
(   RÕ   R   t   decodeRœ   R   Rk   R   t   countRŒ   t   _LFt   _CRt   _CRLFRÃ   t   replace(   R   t   inputR–   t   outputt   crlft   crt   lf(    (    s   /usr/lib/python2.7/_pyio.pyR—   i  s(    	

+	c         C  s]   |  j  d  k r d } d } n |  j  j É  \ } } | d K} |  j rS | d O} n  | | f S(   NRö   i    i   (   RÕ   R   t   getstateRœ   (   R   Rï   t   flag(    (    s   /usr/lib/python2.7/_pyio.pyR‹   à  s    	
	c         C  sO   | \ } } t  | d @É |  _ |  j d  k	 rK |  j j | | d ?f É n  d  S(   Ni   (   t   boolRœ   RÕ   R   t   setstate(   R   t   stateRï   R›   (    (    s   /usr/lib/python2.7/_pyio.pyRﬂ   ì  s    c         C  s5   d |  _  t |  _ |  j d  k	 r1 |  j j É  n  d  S(   Ni    (   RŒ   R   Rœ   RÕ   R   t   reset(   R   (    (    s   /usr/lib/python2.7/_pyio.pyR·   ô  s    		i   i   i   c      
   C  s#   d  d d d d d d d f |  j S(   Nu   
u   u   
(   u   u   
(   u   
u   
(   u   u   
(   u   u   
u   
(   R   RŒ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR»   £  s    (   R   R   R   R   R   R—   R‹   Rﬂ   R·   R”   R‘   R’   R~   R»   (    (    (    s   /usr/lib/python2.7/_pyio.pyR…   [  s   			R*   c           B  sÖ  e  Z d  Z d Z d# d# d# e d Ñ Z d Ñ  Z e d Ñ  É Z	 e d Ñ  É Z
 e d Ñ  É Z e d Ñ  É Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d# d Ñ Z d Ñ  Z d Ñ  Z d d d d d Ñ Z d Ñ  Z d Ñ  Z d# d Ñ Z  d Ñ  Z! d d Ñ Z" d# d Ñ Z# d  Ñ  Z$ d# d! Ñ Z% e d" Ñ  É Z& RS($   u˛  Character and line based layer over a BufferedIOBase object, buffer.

    encoding gives the name of the encoding that the stream will be
    decoded or encoded with. It defaults to locale.getpreferredencoding.

    errors determines the strictness of encoding and decoding (see the
    codecs.register) and defaults to "strict".

    newline can be None, '', '\n', '\r', or '\r\n'.  It controls the
    handling of line endings. If it is None, universal newlines is
    enabled.  With this enabled, on input, the lines endings '\n', '\r',
    or '\r\n' are translated to '\n' before being returned to the
    caller. Conversely, on output, '\n' is translated to the system
    default line separator, os.linesep. If newline is any other of its
    legal values, that newline becomes the newline when the file is read
    and it is returned untranslated. On output, '\n' is converted to the
    newline.

    If line_buffering is True, a call to flush is implied when a call to
    write contains a newline character.
    i   c   	      C  sF  | d  k	 r8 t | t É r8 t d t | É f É Ç n  | d k rZ t d | f É Ç n  | d  k rü y d d  l } Wn t k
 rè d } qü X| j É  } n  t | t É s¡ t d	 | É Ç n  t	 j
 r˝ t j | É j r˝ d
 } t j | | d d Én  | d  k rd } n" t | t É s4t d | É Ç n  | |  _ | |  _ | |  _ | |  _ | |  _ | d  k |  _ | |  _ | d k |  _ | pït j |  _ d  |  _ d  |  _ d |  _ d |  _ d  |  _ |  j  j! É  |  _" |  _# |  j" rB|  j$ É  rB|  j  j% É  } | d k rBy |  j& É  j' d É Wq?t( k
 r;q?XqBn  d  S(   Nu   illegal newline type: %ru    u   
u   u   
u   illegal newline value: %riˇˇˇˇu   asciiu   invalid encoding: %ruG   %r is not a text encoding; use codecs.open() to handle arbitrary codecst
   stackleveli   u   strictu   invalid errors: %ri    (   Nu    u   
u   u   
()   R   R   R   R   Rõ   R   t   localet   ImportErrort   getpreferredencodingt   syst   py3kwarningR    t   lookupt   _is_text_encodingR∂   t   warnpy3kRí   t   _line_bufferingt	   _encodingt   _errorst   _readuniversalt   _readtranslatet   _readnlt   _writetranslateR!   t   linesept   _writenlt   _encodert   _decodert   _decoded_charst   _decoded_chars_usedt	   _snapshotR>   RW   t	   _seekablet   _tellingR\   RQ   t   _get_encoderRﬂ   t   LookupError(	   R   R>   R/   R0   R1   R<   R„   RX   t   position(    (    s   /usr/lib/python2.7/_pyio.pyR      sR    
					
						c         C  sE   y |  j  } Wn t k
 r- d j |  j É SXd j | |  j É Sd  S(   Nu$   <_pyio.TextIOWrapper encoding='{0}'>u/   <_pyio.TextIOWrapper name={0!r} encoding='{1}'>(   RL   Rå   Rç   R/   (   R   RL   (    (    s   /usr/lib/python2.7/_pyio.pyRè   	  s    c         C  s   |  j  S(   N(   RÏ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR/     s    c         C  s   |  j  S(   N(   RÌ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR0     s    c         C  s   |  j  S(   N(   RÎ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR<     s    c         C  s   |  j  S(   N(   Rí   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR>     s    c         C  s   |  j  r t d É Ç n  |  j S(   Nu   I/O operation on closed file.(   R^   R   R˘   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRW   "  s    	c         C  s   |  j  j É  S(   N(   R>   RZ   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRZ   '  s    c         C  s   |  j  j É  S(   N(   R>   R\   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR\   *  s    c         C  s   |  j  j É  |  j |  _ d  S(   N(   R>   RT   R˘   R˙   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRT   -  s    c         C  s?   |  j  d  k	 r; |  j r; z |  j É  Wd  |  j  j É  Xn  d  S(   N(   R>   R   R^   RT   R,   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR,   1  s    c         C  s
   |  j  j S(   N(   R>   R^   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR^   8  s    c         C  s
   |  j  j S(   N(   R>   RL   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRL   <  s    c         C  s   |  j  j É  S(   N(   R>   R#   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR#   @  s    c         C  s   |  j  j É  S(   N(   R>   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR   C  s    c         C  s"  |  j  r t d É Ç n  t | t É s@ t d | j j É Ç n  t | É } |  j s^ |  j	 og d | k } | r† |  j r† |  j
 d k r† | j d |  j
 É } n  |  j p≤ |  j É  } | j | É } |  j j | É |  j	 r¸ | sÔ d | k r¸ |  j É  n  d  |  _ |  j r|  j j É  n  | S(   Nu   write to closed fileu   can't write %s to text streamu   
u   (   R^   R   R   Rù   R   RK   R   R   RÒ   RÎ   RÛ   R÷   RÙ   R˚   t   encodeR>   Ry   RT   R   R¯   Rı   R·   (   R   R«   t   lengtht   haslft   encoderRn   (    (    s   /usr/lib/python2.7/_pyio.pyRy   F  s$    			c         C  s+   t  j |  j É } | |  j É |  _ |  j S(   N(   R    t   getincrementalencoderRÏ   RÌ   RÙ   (   R   t   make_encoder(    (    s   /usr/lib/python2.7/_pyio.pyR˚   [  s    c         C  sL   t  j |  j É } | |  j É } |  j r? t | |  j É } n  | |  _ | S(   N(   R    t   getincrementaldecoderRÏ   RÌ   RÓ   R…   RÔ   Rı   (   R   t   make_decoderRÕ   (    (    s   /usr/lib/python2.7/_pyio.pyt   _get_decoder`  s    		c         C  s   | |  _  d |  _ d S(   u   Set the _decoded_chars buffer.i    N(   Rˆ   R˜   (   R   t   chars(    (    s   /usr/lib/python2.7/_pyio.pyt   _set_decoded_charsk  s    	c         C  sR   |  j  } | d k r% |  j | } n |  j | | | !} |  j  t | É 7_  | S(   u'   Advance into the _decoded_chars buffer.N(   R˜   R   Rˆ   R   (   R   Re   t   offsetR  (    (    s   /usr/lib/python2.7/_pyio.pyt   _get_decoded_charsp  s    	c         C  s1   |  j  | k  r t d É Ç n  |  j  | 8_  d S(   u!   Rewind the _decoded_chars buffer.u"   rewind decoded_chars out of boundsN(   R˜   t   AssertionError(   R   Re   (    (    s   /usr/lib/python2.7/_pyio.pyt   _rewind_decoded_charsz  s    c         C  sõ   |  j  d k r t d É Ç n  |  j r? |  j  j É  \ } } n  |  j j |  j É } | } |  j |  j  j	 | | É É |  j rñ | | | f |  _
 n  | S(   uQ   
        Read and decode the next chunk of data from the BufferedReader.
        u
   no decoderN(   Rı   R   R   R˙   R‹   R>   RÖ   t   _CHUNK_SIZER  R—   R¯   (   R   t
   dec_buffert	   dec_flagst   input_chunkt   eof(    (    s   /usr/lib/python2.7/_pyio.pyt   _read_chunkÄ  s    		i    c         C  s*   | | d >B| d >B| d >Bt  | É d >BS(   Ni@   iÄ   i¿   i   (   Rﬁ   (   R   R˝   R  t   bytes_to_feedt   need_eoft   chars_to_skip(    (    s   /usr/lib/python2.7/_pyio.pyt   _pack_cookie¢  s    c         C  sg   t  | d É \ } } t  | d É \ } } t  | d É \ } } t  | d É \ } } | | | | | f S(   Ni   i@   l            l            l            l            (   t   divmod(   R   t   bigintt   restR˝   R  R  R  R  (    (    s   /usr/lib/python2.7/_pyio.pyt   _unpack_cookie¨  s
    c         C  s  |  j  s t d É Ç n  |  j s0 t d É Ç n  |  j É  |  j j É  } |  j } | d  k sm |  j d  k râ |  j	 rÖ t
 d É Ç n  | S|  j \ } } | t | É 8} |  j } | d k rÕ |  j | | É S| j É  } z$| j d | f É | } | d d } }	 }
 d } x— | D]â } |	 d 7}	 |
 t | j | É É 7}
 | j É  \ } } | rè|
 | k rè| |	 7} | |
 8} | d d } }	 }
 n  |
 | k rPqqW|
 t | j d d t ÉÉ 7}
 d } |
 | k  r„t d É Ç n  |  j | | |	 | | É SWd  | j | É Xd  S(	   Nu!   underlying stream is not seekableu(   telling position disabled by next() callu   pending decoded texti    Rö   i   R–   u'   can't reconstruct logical file position(   R˘   R
   R˙   RT   R>   RQ   Rı   R   R¯   Rˆ   R  R   R˜   R  R‹   Rﬂ   R—   R   (   R   R˝   RÕ   R  t
   next_inputR  t   saved_statet	   start_post   start_flagst	   bytes_fedt   chars_decodedR  t	   next_byteR  (    (    s   /usr/lib/python2.7/_pyio.pyRQ   ≥  sN    		
			


c         C  s5   |  j  É  | d  k r% |  j É  } n  |  j j | É S(   N(   RT   R   RQ   R>   RR   (   R   RN   (    (    s   /usr/lib/python2.7/_pyio.pyRR   Ò  s    
c         C  s>   |  j  d  k r t d É Ç n  |  j É  |  j } d  |  _ | S(   Nu   buffer is already detached(   R>   R   R   RT   Rí   (   R   R>   (    (    s   /usr/lib/python2.7/_pyio.pyRà   ˜  s    
		c         C  sª  |  j  r t d É Ç n  |  j s0 t d É Ç n  | d k rl | d k rW t d É Ç n  d } |  j É  } n  | d k rÂ | d k rì t d É Ç n  |  j É  |  j j d d É } |  j d É d  |  _
 |  j r· |  j j É  n  | S| d k rt d	 | f É Ç n  | d k  r)t d
 | f É Ç n  |  j É  |  j | É \ } } } } } |  j j | É |  j d É d  |  _
 | d k rú|  j rú|  j j É  nU |  j s±| s±| rÒ|  j p√|  j É  |  _ |  j j d | f É | d f |  _
 n  | rd|  j j | É }	 |  j |  j j |	 | É É | |	 f |  _
 t |  j É | k  rXt d É Ç n  | |  _ n  y |  j py|  j É  }
 Wn t k
 rên' X| d k r≠|
 j d É n
 |
 j É  | S(   Nu   tell on closed fileu!   underlying stream is not seekablei   i    u#   can't do nonzero cur-relative seeksi   u#   can't do nonzero end-relative seeksu    u(   invalid whence (%r, should be 0, 1 or 2)u   negative seek position %rRö   u#   can't restore logical file position(   R^   R   R˘   R
   RQ   RT   R>   RP   R  R   R¯   Rı   R·   R  R  Rﬂ   Rj   R—   R   Rˆ   R˜   RÙ   R˚   R¸   (   R   t   cookieRO   R˝   R  R  R  R  R  R  R  (    (    s   /usr/lib/python2.7/_pyio.pyRP   ˇ  sf    		
		
	
c         C  s  |  j  É  | d  k r d } n  |  j p1 |  j É  } y | j Wn t k
 r^ t d É Ç n X| d k  r≠ |  j É  | j |  j	 j
 É  d t É} |  j d É d  |  _ | St } |  j | É } xG t | É | k  r| r|  j É  } | |  j | t | É É 7} q≈ W| Sd  S(   Niˇˇˇˇu   an integer is requiredi    R–   u    (   R[   R   Rı   R  RÅ   R&   R   R
  R—   R>   Rj   R   R  R¯   R   R   R  (   R   Re   RÕ   R;   R  (    (    s   /usr/lib/python2.7/_pyio.pyRj   G  s(    
			!c         C  s=   t  |  _ |  j É  } | s9 d  |  _ |  j |  _ t Ç n  | S(   N(   R   R˙   Ro   R   R¯   R˘   Rq   (   R   Rr   (    (    s   /usr/lib/python2.7/_pyio.pyRs   `  s    			c         C  sâ  |  j  r t d É Ç n  | d  k r- d } n$ t | t t f É sQ t d É Ç n  |  j É  } d } |  j sy |  j	 É  n  d  } } x√t
 rH|  j r– | j d | É } | d k r¡ | d } Pq«t | É } n˜ |  j rí| j d | É } | j d | É } | d k r2| d k r$t | É } qè| d } Pq«| d k rL| d } Pq«| | k  rf| d } Pq«| | d k rÑ| d } Pq«| d } Pn5 | j |  j É } | d k r«| t |  j É } Pn  | d k rÔt | É | k rÔ| } Pn  x |  j É  r|  j rÚPqÚqÚW|  j r+| |  j É  7} qÜ |  j d	 É d  |  _ | SqÜ W| d k rj| | k rj| } n  |  j t | É | É | |  S(
   Nu   read from closed fileiˇˇˇˇu   limit must be an integeri    u   
i   u   i   u    (   R^   R   R   R   R   R   R   R
  Rı   R  R   RÔ   Rb   R   RÓ   R   R  Rˆ   R  R¯   R  (   R   Rf   Rr   t   startRN   t   endpost   nlpost   crpos(    (    s   /usr/lib/python2.7/_pyio.pyRo   i  sp    			
		
	




				c         C  s   |  j  r |  j  j Sd  S(   N(   Rı   R»   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR»   ¡  s    N('   R   R   R   R  R   R   R   Rè   R~   R/   R0   R<   R>   RW   RZ   R\   RT   R,   R^   RL   R#   R   Ry   R˚   R  R  R
  R  R  R  R  RQ   RR   Rà   RP   Rj   Rs   Ro   R»   (    (    (    s   /usr/lib/python2.7/_pyio.pyR*   ∞  sH   	>													
		"			>	H		Xt   StringIOc           B  sV   e  Z d  Z d d d Ñ Z d Ñ  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z d Ñ  Z	 RS(	   uª   Text I/O implementation using an in-memory buffer.

    The initial_value argument sets the value of object.  The newline
    argument is like the one of TextIOWrapper's constructor.
    u    u   
c         C  sà   t  t |  É j t É  d d d d d | É| d  k rC t |  _ n  | rÑ t | t É sg t | É } n  |  j	 | É |  j
 d É n  d  S(   NR/   u   utf-8R0   u   strictR1   i    (   R	   R'  R   Rê   R   R   RÒ   R   Rù   Ry   RP   (   R   t   initial_valueR1   (    (    s   /usr/lib/python2.7/_pyio.pyR   Õ  s    c         C  sj   |  j  É  |  j p |  j É  } | j É  } | j É  z  | j |  j j É  d t ÉSWd  | j	 | É Xd  S(   NR–   (
   RT   Rı   R  R‹   R·   R—   R>   Rô   R   Rﬂ   (   R   RÕ   t	   old_state(    (    s   /usr/lib/python2.7/_pyio.pyRô   ‹  s    

 c         C  s   t  j |  É S(   N(   t   objectRè   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRè   Ê  s    c         C  s   d  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR0   Î  s    c         C  s   d  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyR/   Ô  s    c         C  s   |  j  d É d  S(   Nu   detach(   RM   (   R   (    (    s   /usr/lib/python2.7/_pyio.pyRà   Û  s    (
   R   R   R   R   Rô   Rè   R~   R0   R/   Rà   (    (    (    s   /usr/lib/python2.7/_pyio.pyR'  ∆  s   	
	(2   R   t
   __future__R    R   R!   R{   R    RÊ   R∂   R   t   threadR   R¢   R‰   t   dummy_threadt   ioR   R   R   R   R   Rõ   R}   R    R
   R   R   R   R?   R@   RD   R   RI   RJ   t   registerR   t   _ioR   RÑ   Râ   Rê   R)   R(   R√   R'   R∆   RÀ   R…   R*   R'  (    (    (    s   /usr/lib/python2.7/_pyio.pyt   <module>   sZ   "
ø	ˇ <RjvóaJI?Uˇ ˇ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """Strptime-related classes and functions.

CLASSES:
    LocaleTime -- Discovers and stores locale-specific time information
    TimeRE -- Creates regexes for pattern matching a string of text containing
                time information

FUNCTIONS:
    _getlang -- Figure out what language is being used for the locale
    strptime -- Calculates the time struct represented by the passed-in string

"""
import time
import locale
import calendar
from re import compile as re_compile
from re import IGNORECASE
from re import escape as re_escape
from datetime import date as datetime_date
try:
    from thread import allocate_lock as _thread_allocate_lock
except:
    from dummy_thread import allocate_lock as _thread_allocate_lock

__all__ = []

def _getlang():
    # Figure out what the current language is set to.
    return locale.getlocale(locale.LC_TIME)

class LocaleTime(object):
    """Stores and handles locale-specific information related to time.

    ATTRIBUTES:
        f_weekday -- full weekday names (7-item list)
        a_weekday -- abbreviated weekday names (7-item list)
        f_month -- full month names (13-item list; dummy value in [0], which
                    is added by code)
        a_month -- abbreviated month names (13-item list, dummy value in
                    [0], which is added by code)
        am_pm -- AM/PM representation (2-item list)
        LC_date_time -- format string for date/time representation (string)
        LC_date -- format string for date representation (string)
        LC_time -- format string for time representation (string)
        timezone -- daylight- and non-daylight-savings timezone representation
                    (2-item list of sets)
        lang -- Language used by instance (2-item tuple)
    """

    def __init__(self):
        """Set all attributes.

        Order of methods called matters for dependency reasons.

        The locale language is set at the offset and then checked again before
        exiting.  This is to make sure that the attributes were not set with a
        mix of information from more than one locale.  This would most likely
        happen when using threads where one thread calls a locale-dependent
        function while another thread changes the locale while the function in
        the other thread is still running.  Proper coding would call for
        locks to prevent changing the locale while locale-dependent code is
        running.  The check here is done in case someone does not think about
        doing this.

        Only other possible issue is if someone changed the timezone and did
        not call tz.tzset .  That is an issue for the programmer, though,
        since changing the timezone is worthless without that call.

        """
        self.lang = _getlang()
        self.__calc_weekday()
        self.__calc_month()
        self.__calc_am_pm()
        self.__calc_timezone()
        self.__calc_date_time()
        if _getlang() != self.lang:
            raise ValueError("locale changed during initialization")
        if time.tzname != self.tzname or time.daylight != self.daylight:
            raise ValueError("timezone changed during initialization")

    def __pad(self, seq, front):
        # Add '' to seq to either the front (is True), else the back.
        seq = list(seq)
        if front:
            seq.insert(0, '')
        else:
            seq.append('')
        return seq

    def __calc_weekday(self):
        # Set self.a_weekday and self.f_weekday using the calendar
        # module.
        a_weekday = [calendar.day_abbr[i].lower() for i in range(7)]
        f_weekday = [calendar.day_name[i].lower() for i in range(7)]
        self.a_weekday = a_weekday
        self.f_weekday = f_weekday

    def __calc_month(self):
        # Set self.f_month and self.a_month using the calendar module.
        a_month = [calendar.month_abbr[i].lower() for i in range(13)]
        f_month = [calendar.month_name[i].lower() for i in range(13)]
        self.a_month = a_month
        self.f_month = f_month

    def __calc_am_pm(self):
        # Set self.am_pm by using time.strftime().

        # The magic date (1999,3,17,hour,44,55,2,76,0) is not really that
        # magical; just happened to have used it everywhere else where a
        # static date was needed.
        am_pm = []
        for hour in (01,22):
            time_tuple = time.struct_time((1999,3,17,hour,44,55,2,76,0))
            am_pm.append(time.strftime("%p", time_tuple).lower())
        self.am_pm = am_pm

    def __calc_date_time(self):
        # Set self.date_time, self.date, & self.time by using
        # time.strftime().

        # Use (1999,3,17,22,44,55,2,76,0) for magic date because the amount of
        # overloaded numbers is minimized.  The order in which searches for
        # values within the format string is very important; it eliminates
        # possible ambiguity for what something represents.
        time_tuple = time.struct_time((1999,3,17,22,44,55,2,76,0))
        date_time = [None, None, None]
        date_time[0] = time.strftime("%c", time_tuple).lower()
        date_time[1] = time.strftime("%x", time_tuple).lower()
        date_time[2] = time.strftime("%X", time_tuple).lower()
        replacement_pairs = [('%', '%%'), (self.f_weekday[2], '%A'),
                    (self.f_month[3], '%B'), (self.a_weekday[2], '%a'),
                    (self.a_month[3], '%b'), (self.am_pm[1], '%p'),
                    ('1999', '%Y'), ('99', '%y'), ('22', '%H'),
                    ('44', '%M'), ('55', '%S'), ('76', '%j'),
                    ('17', '%d'), ('03', '%m'), ('3', '%m'),
                    # '3' needed for when no leading zero.
                    ('2', '%w'), ('10', '%I')]
        replacement_pairs.extend([(tz, "%Z") for tz_values in self.timezone
                                                for tz in tz_values])
        for offset,directive in ((0,'%c'), (1,'%x'), (2,'%X')):
            current_format = date_time[offset]
            for old, new in replacement_pairs:
                # Must deal with possible lack of locale info
                # manifesting itself as the empty string (e.g., Swedish's
                # lack of AM/PM info) or a platform returning a tuple of empty
                # strings (e.g., MacOS 9 having timezone as ('','')).
                if old:
                    current_format = current_format.replace(old, new)
            # If %W is used, then Sunday, 2005-01-03 will fall on week 0 since
            # 2005-01-03 occurs before the first Monday of the year.  Otherwise
            # %U is used.
            time_tuple = time.struct_time((1999,1,3,1,1,1,6,3,0))
            if '00' in time.strftime(directive, time_tuple):
                U_W = '%W'
            else:
                U_W = '%U'
            date_time[offset] = current_format.replace('11', U_W)
        self.LC_date_time = date_time[0]
        self.LC_date = date_time[1]
        self.LC_time = date_time[2]

    def __calc_timezone(self):
        # Set self.timezone by using time.tzname.
        # Do not worry about possibility of time.tzname[0] == time.tzname[1]
        # and time.daylight; handle that in strptime.
        try:
            time.tzset()
        except AttributeError:
            pass
        self.tzname = time.tzname
        self.daylight = time.daylight
        no_saving = frozenset(["utc", "gmt", self.tzname[0].lower()])
        if self.daylight:
            has_saving = frozenset([self.tzname[1].lower()])
        else:
            has_saving = frozenset()
        self.timezone = (no_saving, has_saving)


class TimeRE(dict):
    """Handle conversion from format directives to regexes."""

    def __init__(self, locale_time=None):
        """Create keys/values.

        Order of execution is important for dependency reasons.

        """
        if locale_time:
            self.locale_time = locale_time
        else:
            self.locale_time = LocaleTime()
        base = super(TimeRE, self)
        base.__init__({
            # The " \d" part of the regex is to make %c from ANSI C work
            'd': r"(?P<d>3[0-1]|[1-2]\d|0[1-9]|[1-9]| [1-9])",
            'f': r"(?P<f>[0-9]{1,6})",
            'H': r"(?P<H>2[0-3]|[0-1]\d|\d)",
            'I': r"(?P<I>1[0-2]|0[1-9]|[1-9])",
            'j': r"(?P<j>36[0-6]|3[0-5]\d|[1-2]\d\d|0[1-9]\d|00[1-9]|[1-9]\d|0[1-9]|[1-9])",
            'm': r"(?P<m>1[0-2]|0[1-9]|[1-9])",
            'M': r"(?P<M>[0-5]\d|\d)",
            'S': r"(?P<S>6[0-1]|[0-5]\d|\d)",
            'U': r"(?P<U>5[0-3]|[0-4]\d|\d)",
            'w': r"(?P<w>[0-6])",
            # W is set below by using 'U'
            'y': r"(?P<y>\d\d)",
            #XXX: Does 'Y' need to worry about having less or more than
            #     4 digits?
            'Y': r"(?P<Y>\d\d\d\d)",
            'A': self.__seqToRE(self.locale_time.f_weekday, 'A'),
            'a': self.__seqToRE(self.locale_time.a_weekday, 'a'),
            'B': self.__seqToRE(self.locale_time.f_month[1:], 'B'),
            'b': self.__seqToRE(self.locale_time.a_month[1:], 'b'),
            'p': self.__seqToRE(self.locale_time.am_pm, 'p'),
            'Z': self.__seqToRE((tz for tz_names in self.locale_time.timezone
                                        for tz in tz_names),
                                'Z'),
            '%': '%'})
        base.__setitem__('W', base.__getitem__('U').replace('U', 'W'))
        base.__setitem__('c', self.pattern(self.locale_time.LC_date_time))
        base.__setitem__('x', self.pattern(self.locale_time.LC_date))
        base.__setitem__('X', self.pattern(self.locale_time.LC_time))

    def __seqToRE(self, to_convert, directive):
        """Convert a list to a regex string for matching a directive.

        Want possible matching values to be from longest to shortest.  This
        prevents the possibility of a match occurring for a value that also
        a substring of a larger value that should have matched (e.g., 'abc'
        matching when 'abcdef' should have been the match).

        """
        to_convert = sorted(to_convert, key=len, reverse=True)
        for value in to_convert:
            if value != '':
                break
        else:
            return ''
        regex = '|'.join(re_escape(stuff) for stuff in to_convert)
        regex = '(?P<%s>%s' % (directive, regex)
        return '%s)' % regex

    def pattern(self, format):
        """Return regex pattern for the format string.

        Need to make sure that any characters that might be interpreted as
        regex syntax are escaped.

        """
        processed_format = ''
        # The sub() call escapes all characters that might be misconstrued
        # as regex syntax.  Cannot use re.escape since we have to deal with
        # format directives (%m, etc.).
        regex_chars = re_compile(r"([\\.^$*+?\(\){}\[\]|])")
        format = regex_chars.sub(r"\\\1", format)
        whitespace_replacement = re_compile('\s+')
        format = whitespace_replacement.sub('\s+', format)
        while '%' in format:
            directive_index = format.index('%')+1
            processed_format = "%s%s%s" % (processed_format,
                                           format[:directive_index-1],
                                           self[format[directive_index]])
            format = format[directive_index+1:]
        return "%s%s" % (processed_format, format)

    def compile(self, format):
        """Return a compiled re object for the format string."""
        return re_compile(self.pattern(format), IGNORECASE)

_cache_lock = _thread_allocate_lock()
# DO NOT modify _TimeRE_cache or _regex_cache without acquiring the cache lock
# first!
_TimeRE_cache = TimeRE()
_CACHE_MAX_SIZE = 5 # Max number of regexes stored in _regex_cache
_regex_cache = {}

def _calc_julian_from_U_or_W(year, week_of_year, day_of_week, week_starts_Mon):
    """Calculate the Julian day based on the year, week of the year, and day of
    the week, with week_start_day representing whether the week of the year
    assumes the week starts on Sunday or Monday (6 or 0)."""
    first_weekday = datetime_date(year, 1, 1).weekday()
    # If we are dealing with the %U directive (week starts on Sunday), it's
    # easier to just shift the view to Sunday being the first day of the
    # week.
    if not week_starts_Mon:
        first_weekday = (first_weekday + 1) % 7
        day_of_week = (day_of_week + 1) % 7
    # Need to watch out for a week 0 (when the first day of the year is not
    # the same as that specified by %U or %W).
    week_0_length = (7 - first_weekday) % 7
    if week_of_year == 0:
        return 1 + day_of_week - first_weekday
    else:
        days_to_week = week_0_length + (7 * (week_of_year - 1))
        return 1 + days_to_week + day_of_week


def _strptime(data_string, format="%a %b %d %H:%M:%S %Y"):
    """Return a time struct based on the input string and the format string."""
    global _TimeRE_cache, _regex_cache
    with _cache_lock:
        locale_time = _TimeRE_cache.locale_time
        if (_getlang() != locale_time.lang or
            time.tzname != locale_time.tzname or
            time.daylight != locale_time.daylight):
            _TimeRE_cache = TimeRE()
            _regex_cache.clear()
            locale_time = _TimeRE_cache.locale_time
        if len(_regex_cache) > _CACHE_MAX_SIZE:
            _regex_cache.clear()
        format_regex = _regex_cache.get(format)
        if not format_regex:
            try:
                format_regex = _TimeRE_cache.compile(format)
            # KeyError raised when a bad format is found; can be specified as
            # \\, in which case it was a stray % but with a space after it
            except KeyError, err:
                bad_directive = err.args[0]
                if bad_directive == "\\":
                    bad_directive = "%"
                del err
                raise ValueError("'%s' is a bad directive in format '%s'" %
                                    (bad_directive, format))
            # IndexError only occurs when the format string is "%"
            except IndexError:
                raise ValueError("stray %% in format '%s'" % format)
            _regex_cache[format] = format_regex
    found = format_regex.match(data_string)
    if not found:
        raise ValueError("time data %r does not match format %r" %
                         (data_string, format))
    if len(data_string) != found.end():
        raise ValueError("unconverted data remains: %s" %
                          data_string[found.end():])

    year = None
    month = day = 1
    hour = minute = second = fraction = 0
    tz = -1
    # Default to -1 to signify that values not known; not critical to have,
    # though
    week_of_year = -1
    week_of_year_start = -1
    # weekday and julian defaulted to None so as to signal need to calculate
    # values
    weekday = julian = None
    found_dict = found.groupdict()
    for group_key in found_dict.iterkeys():
        # Directives not explicitly handled below:
        #   c, x, X
        #      handled by making out of other directives
        #   U, W
        #      worthless without day of the week
        if group_key == 'y':
            year = int(found_dict['y'])
            # Open Group specification for strptime() states that a %y
            #value in the range of [00, 68] is in the century 2000, while
            #[69,99] is in the century 1900
            if year <= 68:
                year += 2000
            else:
                year += 1900
        elif group_key == 'Y':
            year = int(found_dict['Y'])
        elif group_key == 'm':
            month = int(found_dict['m'])
        elif group_key == 'B':
            month = locale_time.f_month.index(found_dict['B'].lower())
        elif group_key == 'b':
            month = locale_time.a_month.index(found_dict['b'].lower())
        elif group_key == 'd':
            day = int(found_dict['d'])
        elif group_key == 'H':
            hour = int(found_dict['H'])
        elif group_key == 'I':
            hour = int(found_dict['I'])
            ampm = found_dict.get('p', '').lower()
            # If there was no AM/PM indicator, we'll treat this like AM
            if ampm in ('', locale_time.am_pm[0]):
                # We're in AM so the hour is correct unless we're
                # looking at 12 midnight.
                # 12 midnight == 12 AM == hour 0
                if hour == 12:
                    hour = 0
            elif ampm == locale_time.am_pm[1]:
                # We're in PM so we need to add 12 to the hour unless
                # we're looking at 12 noon.
                # 12 noon == 12 PM == hour 12
                if hour != 12:
                    hour += 12
        elif group_key == 'M':
            minute = int(found_dict['M'])
        elif group_key == 'S':
            second = int(found_dict['S'])
        elif group_key == 'f':
            s = found_dict['f']
            # Pad to always return microseconds.
            s += "0" * (6 - len(s))
            fraction = int(s)
        elif group_key == 'A':
            weekday = locale_time.f_weekday.index(found_dict['A'].lower())
        elif group_key == 'a':
            weekday = locale_time.a_weekday.index(found_dict['a'].lower())
        elif group_key == 'w':
            weekday = int(found_dict['w'])
            if weekday == 0:
                weekday = 6
            else:
                weekday -= 1
        elif group_key == 'j':
            julian = int(found_dict['j'])
        elif group_key in ('U', 'W'):
            week_of_year = int(found_dict[group_key])
            if group_key == 'U':
                # U starts week on Sunday.
                week_of_year_start = 6
            else:
                # W starts week on Monday.
                week_of_year_start = 0
        elif group_key == 'Z':
            # Since -1 is default value only need to worry about setting tz if
            # it can be something other than -1.
            found_zone = found_dict['Z'].lower()
            for value, tz_values in enumerate(locale_time.timezone):
                if found_zone in tz_values:
                    # Deal with bad locale setup where timezone names are the
                    # same and yet time.daylight is true; too ambiguous to
                    # be able to tell what timezone has daylight savings
                    if (time.tzname[0] == time.tzname[1] and
                       time.daylight and found_zone not in ("utc", "gmt")):
                        break
                    else:
                        tz = value
                        break
    leap_year_fix = False
    if year is None and month == 2 and day == 29:
        year = 1904  # 1904 is first leap year of 20th century
        leap_year_fix = True
    elif year is None:
        year = 1900
    # If we know the week of the year and what day of that week, we can figure
    # out the Julian day of the year.
    if julian is None and week_of_year != -1 and weekday is not None:
        week_starts_Mon = True if week_of_year_start == 0 else False
        julian = _calc_julian_from_U_or_W(year, week_of_year, weekday,
                                            week_starts_Mon)
        if julian <= 0:
            year -= 1
            yday = 366 if calendar.isleap(year) else 365
            julian += yday
    # Cannot pre-calculate datetime_date() since can change in Julian
    # calculation and thus could have different value for the day of the week
    # calculation.
    if julian is None:
        # Need to add 1 to result since first day of the year is 1, not 0.
        julian = datetime_date(year, month, day).toordinal() - \
                  datetime_date(year, 1, 1).toordinal() + 1
    else:  # Assume that if they bothered to include Julian day it will
           # be accurate.
        datetime_result = datetime_date.fromordinal((julian - 1) + datetime_date(year, 1, 1).toordinal())
        year = datetime_result.year
        month = datetime_result.month
        day = datetime_result.day
    if weekday is None:
        weekday = datetime_date(year, month, day).weekday()
    if leap_year_fix:
        # the caller didn't supply a year but asked for Feb 29th. We couldn't
        # use the default of 1900 for computations. We set it back to ensure
        # that February 29th is smaller than March 1st.
        year = 1900

    return (time.struct_time((year, month, day,
                              hour, minute, second,
                              weekday, julian, tz)), fraction)

def _strptime_time(data_string, format="%a %b %d %H:%M:%S %Y"):
    return _strptime(data_string, format)[0]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   s^   d  Z  d g Z d e f d Ñ  É  YZ d Ñ  Z d e f d Ñ  É  YZ d d l m Z m Z d S(	   s¯  Thread-local objects.

(Note that this module provides a Python version of the threading.local
 class.  Depending on the version of Python you're using, there may be a
 faster one available.  You should always import the `local` class from
 `threading`.)

Thread-local objects support the management of thread-local data.
If you have data that you want to be local to a thread, simply create
a thread-local object and use its attributes:

  >>> mydata = local()
  >>> mydata.number = 42
  >>> mydata.number
  42

You can also access the local-object's dictionary:

  >>> mydata.__dict__
  {'number': 42}
  >>> mydata.__dict__.setdefault('widgets', [])
  []
  >>> mydata.widgets
  []

What's important about thread-local objects is that their data are
local to a thread. If we access the data in a different thread:

  >>> log = []
  >>> def f():
  ...     items = mydata.__dict__.items()
  ...     items.sort()
  ...     log.append(items)
  ...     mydata.number = 11
  ...     log.append(mydata.number)

  >>> import threading
  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [[], 11]

we get different data.  Furthermore, changes made in the other thread
don't affect data seen in this thread:

  >>> mydata.number
  42

Of course, values you get from a local object, including a __dict__
attribute, are for whatever thread was current at the time the
attribute was read.  For that reason, you generally don't want to save
these values across threads, as they apply only to the thread they
came from.

You can create custom local objects by subclassing the local class:

  >>> class MyLocal(local):
  ...     number = 2
  ...     initialized = False
  ...     def __init__(self, **kw):
  ...         if self.initialized:
  ...             raise SystemError('__init__ called too many times')
  ...         self.initialized = True
  ...         self.__dict__.update(kw)
  ...     def squared(self):
  ...         return self.number ** 2

This can be useful to support default values, methods and
initialization.  Note that if you define an __init__ method, it will be
called each time the local object is used in a separate thread.  This
is necessary to initialize each thread's dictionary.

Now if we create a local object:

  >>> mydata = MyLocal(color='red')

Now we have a default number:

  >>> mydata.number
  2

an initial color:

  >>> mydata.color
  'red'
  >>> del mydata.color

And a method that operates on the data:

  >>> mydata.squared()
  4

As before, we can access the data in a separate thread:

  >>> log = []
  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [[('color', 'red'), ('initialized', True)], 11]

without affecting this thread's data:

  >>> mydata.number
  2
  >>> mydata.color
  Traceback (most recent call last):
  ...
  AttributeError: 'MyLocal' object has no attribute 'color'

Note that subclasses can define slots, but they are not thread
local. They are shared across threads:

  >>> class MyLocal(local):
  ...     __slots__ = 'number'

  >>> mydata = MyLocal()
  >>> mydata.number = 42
  >>> mydata.color = 'red'

So, the separate thread:

  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()

affects what we see:

  >>> mydata.number
  11

>>> del mydata
t   localt
   _localbasec           B   s   e  Z d Z d Ñ  Z RS(   t   _local__keyt   _local__argst   _local__lockc         O   s¿   t  j |  É } d d t t | É É f } t  j | d | É t  j | d | | f É t  j | d t É  É | sy | rö |  j t  j k rö t d É Ç n  t  j | d É } | t	 É  j
 | <| S(   NR   s   thread.local.R   R   s*   Initialization arguments are not supportedt   __dict__(   t   objectt   __new__t   strt   idt   __setattr__t   RLockt   __init__t	   TypeErrort   __getattribute__t   current_threadR   (   t   clst   argst   kwt   selft   keyt   dict(    (    s&   /usr/lib/python2.7/_threading_local.pyR   ó   s    (   R   R   R   (   t   __name__t
   __module__t	   __slots__R   (    (    (    s&   /usr/lib/python2.7/_threading_local.pyR   î   s   c         C   s¬   t  j |  d É } t É  j j | É } | d  k r´ i  } | t É  j | <t  j |  d | É t |  É } | j t  j k	 ræ t  j |  d É \ } } | j |  | | é qæ n t  j |  d | É d  S(   NR   R   R   (	   R   R   R   R   t   gett   NoneR
   t   typeR   (   R   R   t   dR   R   R   (    (    s&   /usr/lib/python2.7/_threading_local.pyt   _patch©   s    c           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sL   t  j |  d É } | j É  z t |  É t  j |  | É SWd  | j É  Xd  S(   NR   (   R   R   t   acquireR   t   release(   R   t   namet   lock(    (    s&   /usr/lib/python2.7/_threading_local.pyR   º   s    

c         C   st   | d k r% t  d |  j j É Ç n  t j |  d É } | j É  z! t |  É t j |  | | É SWd  | j É  Xd  S(   NR   s+   %r object attribute '__dict__' is read-onlyR   (	   t   AttributeErrort	   __class__R   R   R   R   R   R
   R   (   R   R    t   valueR!   (    (    s&   /usr/lib/python2.7/_threading_local.pyR
   ≈   s    

c         C   sq   | d k r% t  d |  j j É Ç n  t j |  d É } | j É  z t |  É t j |  | É SWd  | j É  Xd  S(   NR   s+   %r object attribute '__dict__' is read-onlyR   (	   R"   R#   R   R   R   R   R   t   __delattr__R   (   R   R    R!   (    (    s&   /usr/lib/python2.7/_threading_local.pyR%   “   s    

c         C   s†   d d  l  } t j |  d É } y | j É  } Wn d  SXx` | D]X } y | j } Wn t k
 ri q@ n X| | k r@ y | | =Wqò t k
 rî qò Xq@ q@ Wd  S(   NiˇˇˇˇR   (   t	   threadingR   R   t
   _enumerateR   R"   t   KeyError(   R   R&   R   t   threadst   threadR   (    (    s&   /usr/lib/python2.7/_threading_local.pyt   __del__ﬂ   s     (   R   R   R   R
   R%   R+   (    (    (    s&   /usr/lib/python2.7/_threading_local.pyR    ∫   s   				iˇˇˇˇ(   R   R   N(	   t   __doc__t   __all__R   R   R   R    R&   R   R   (    (    (    s&   /usr/lib/python2.7/_threading_local.pyt   <module>Ü   s
   		A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   s  d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l m Z	 d d l
 m Z y d d l m Z Wn d d l m Z n Xg  Z d Ñ  Z d	 e f d
 Ñ  É  YZ d e f d Ñ  É  YZ e É  Z e É  a d Z i  a d Ñ  Z d d Ñ Z d d Ñ Z d S(   så  Strptime-related classes and functions.

CLASSES:
    LocaleTime -- Discovers and stores locale-specific time information
    TimeRE -- Creates regexes for pattern matching a string of text containing
                time information

FUNCTIONS:
    _getlang -- Figure out what language is being used for the locale
    strptime -- Calculates the time struct represented by the passed-in string

iˇˇˇˇN(   t   compile(   t
   IGNORECASE(   t   escape(   t   date(   t   allocate_lockc           C   s   t  j t  j É S(   N(   t   localet	   getlocalet   LC_TIME(    (    (    s   /usr/lib/python2.7/_strptime.pyt   _getlang   s    t
   LocaleTimec           B   sM   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   sk  Stores and handles locale-specific information related to time.

    ATTRIBUTES:
        f_weekday -- full weekday names (7-item list)
        a_weekday -- abbreviated weekday names (7-item list)
        f_month -- full month names (13-item list; dummy value in [0], which
                    is added by code)
        a_month -- abbreviated month names (13-item list, dummy value in
                    [0], which is added by code)
        am_pm -- AM/PM representation (2-item list)
        LC_date_time -- format string for date/time representation (string)
        LC_date -- format string for date representation (string)
        LC_time -- format string for time representation (string)
        timezone -- daylight- and non-daylight-savings timezone representation
                    (2-item list of sets)
        lang -- Language used by instance (2-item tuple)
    c         C   sñ   t  É  |  _ |  j É  |  j É  |  j É  |  j É  |  j É  t  É  |  j k r_ t d É Ç n  t j	 |  j	 k sÉ t j
 |  j
 k rí t d É Ç n  d S(   sπ  Set all attributes.

        Order of methods called matters for dependency reasons.

        The locale language is set at the offset and then checked again before
        exiting.  This is to make sure that the attributes were not set with a
        mix of information from more than one locale.  This would most likely
        happen when using threads where one thread calls a locale-dependent
        function while another thread changes the locale while the function in
        the other thread is still running.  Proper coding would call for
        locks to prevent changing the locale while locale-dependent code is
        running.  The check here is done in case someone does not think about
        doing this.

        Only other possible issue is if someone changed the timezone and did
        not call tz.tzset .  That is an issue for the programmer, though,
        since changing the timezone is worthless without that call.

        s$   locale changed during initializations&   timezone changed during initializationN(   R   t   langt   _LocaleTime__calc_weekdayt   _LocaleTime__calc_montht   _LocaleTime__calc_am_pmt   _LocaleTime__calc_timezonet   _LocaleTime__calc_date_timet
   ValueErrort   timet   tznamet   daylight(   t   self(    (    s   /usr/lib/python2.7/_strptime.pyt   __init__2   s    




$c         C   s6   t  | É } | r% | j d d É n | j d É | S(   Ni    t    (   t   listt   insertt   append(   R   t   seqt   front(    (    s   /usr/lib/python2.7/_strptime.pyt   __padQ   s
    c         C   sn   g  t  d É D] } t j | j É  ^ q } g  t  d É D] } t j | j É  ^ q9 } | |  _ | |  _ d  S(   Ni   (   t   ranget   calendart   day_abbrt   lowert   day_namet	   a_weekdayt	   f_weekday(   R   t   iR"   R#   (    (    s   /usr/lib/python2.7/_strptime.pyt   __calc_weekdayZ   s    ,,	c         C   sn   g  t  d É D] } t j | j É  ^ q } g  t  d É D] } t j | j É  ^ q9 } | |  _ | |  _ d  S(   Ni   (   R   R   t
   month_abbrR    t
   month_namet   a_montht   f_month(   R   R$   R(   R)   (    (    s   /usr/lib/python2.7/_strptime.pyt   __calc_monthb   s    ,,	c         C   sm   g  } xW d D]O } t  j d d d | d d d d	 d
 f	 É } | j t  j d | É j É  É q W| |  _ d  S(   Ni   i   iœ  i   i   i,   i7   i   iL   i    s   %p(   i   i   (   R   t   struct_timeR   t   strftimeR    t   am_pm(   R   R-   t   hourt
   time_tuple(    (    s   /usr/lib/python2.7/_strptime.pyt   __calc_am_pmi   s
    *#c         C   sı  t  j d0 É } d  d  d  g } t  j d
 | É j É  | d	 <t  j d | É j É  | d <t  j d | É j É  | d <d1 |  j d d f |  j d d f |  j d d f |  j d d f |  j	 d d f d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< g } | j
 g  |  j D] } | D] } | d* f ^ qq¸ É x• d= d> d? f D]î \ } } | | } x/ | D]' \ }	 }
 |	 rO| j |	 |
 É } qOqOWt  j d@ É } d, t  j | | É k r™d- } n d. } | j d/ | É | | <q2W| d	 |  _ | d |  _ | d |  _ d  S(A   Niœ  i   i   i   i,   i7   i   iL   i    s   %cs   %xi   s   %Xt   %s   %%s   %As   %Bs   %as   %bs   %pt   1999s   %Yt   99s   %yt   22s   %Ht   44s   %Mt   55s   %St   76s   %jt   17s   %dt   03s   %mt   3t   2s   %wt   10s   %Is   %Zi   t   00s   %Ws   %Ut   11(	   iœ  i   i   i   i,   i7   i   iL   i    (   R1   s   %%(   R2   s   %Y(   R3   s   %y(   R4   s   %H(   R5   s   %M(   R6   s   %S(   R7   s   %j(   R8   s   %d(   R9   s   %m(   R:   s   %m(   R;   s   %w(   R<   s   %I(   i    s   %c(   i   s   %x(   i   s   %X(	   iœ  i   i   i   i   i   i   i   i    (   R   R+   t   NoneR,   R    R#   R)   R"   R(   R-   t   extendt   timezonet   replacet   LC_date_timet   LC_datet   LC_time(   R   R/   t	   date_timet   replacement_pairst	   tz_valuest   tzt   offsett	   directivet   current_formatt   oldt   newt   U_W(    (    s   /usr/lib/python2.7/_strptime.pyt   __calc_date_timeu   s6      			 
	c         C   s†   y t  j É  Wn t k
 r! n Xt  j |  _ t  j |  _ t d d |  j d j É  g É } |  j rÑ t |  j d j É  g É } n	 t É  } | | f |  _ d  S(   Nt   utct   gmti    i   (   R   t   tzsett   AttributeErrorR   R   t	   frozensetR    RA   (   R   t	   no_savingt
   has_saving(    (    s   /usr/lib/python2.7/_strptime.pyt   __calc_timezone¢   s    "		(
   t   __name__t
   __module__t   __doc__R   t   _LocaleTime__padR   R   R   R   R   (    (    (    s   /usr/lib/python2.7/_strptime.pyR	      s   							-t   TimeREc           B   s5   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s4   Handle conversion from format directives to regexes.c         C   s√  | r | |  _  n t É  |  _  t t |  É } | j i d d 6d d 6d d 6d d 6d	 d
 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6|  j |  j  j d É d 6|  j |  j  j d É d 6|  j |  j  j d d É d 6|  j |  j  j	 d d É d 6|  j |  j  j
 d É d 6|  j d Ñ  |  j  j DÉ d  É d  6d! d! 6É | j d" | j d É j d d" É É | j d# |  j |  j  j É É | j d$ |  j |  j  j É É | j d% |  j |  j  j É É d& S('   s^   Create keys/values.

        Order of execution is important for dependency reasons.

        s)   (?P<d>3[0-1]|[1-2]\d|0[1-9]|[1-9]| [1-9])t   ds   (?P<f>[0-9]{1,6})t   fs   (?P<H>2[0-3]|[0-1]\d|\d)t   Hs   (?P<I>1[0-2]|0[1-9]|[1-9])t   IsG   (?P<j>36[0-6]|3[0-5]\d|[1-2]\d\d|0[1-9]\d|00[1-9]|[1-9]\d|0[1-9]|[1-9])t   js   (?P<m>1[0-2]|0[1-9]|[1-9])t   ms   (?P<M>[0-5]\d|\d)t   Ms   (?P<S>6[0-1]|[0-5]\d|\d)t   Ss   (?P<U>5[0-3]|[0-4]\d|\d)t   Us   (?P<w>[0-6])t   ws   (?P<y>\d\d)t   ys   (?P<Y>\d\d\d\d)t   Yt   At   ai   t   Bt   bt   pc         s   s"   |  ] } | D] } | Vq q d  S(   N(    (   t   .0t   tz_namesRI   (    (    s   /usr/lib/python2.7/_strptime.pys	   <genexpr>ÿ   s    t   ZR1   t   Wt   ct   xt   XN(   t   locale_timeR	   t   superR]   R   t   _TimeRE__seqToRER#   R"   R)   R(   R-   RA   t   __setitem__t   __getitem__RB   t   patternRC   RD   RE   (   R   Rv   t   base(    (    s   /usr/lib/python2.7/_strptime.pyR   ∑   s:    	
%c         C   sn   t  | d t d t É} x" | D] } | d k r Pq q Wd Sd j d Ñ  | DÉ É } d | | f } d | S(   se  Convert a list to a regex string for matching a directive.

        Want possible matching values to be from longest to shortest.  This
        prevents the possibility of a match occurring for a value that also
        a substring of a larger value that should have matched (e.g., 'abc'
        matching when 'abcdef' should have been the match).

        t   keyt   reverseR   t   |c         s   s   |  ] } t  | É Vq d  S(   N(   t	   re_escape(   Ro   t   stuff(    (    s   /usr/lib/python2.7/_strptime.pys	   <genexpr>   s    s	   (?P<%s>%ss   %s)(   t   sortedt   lent   Truet   join(   R   t
   to_convertRK   t   valuet   regex(    (    s   /usr/lib/python2.7/_strptime.pyt	   __seqToRE·   s    	c         C   sß   d } t  d É } | j d | É } t  d É } | j d | É } xT d | k rò | j d É d } d | | | d  |  | | f } | | d } qE Wd | | f S(	   s£   Return regex pattern for the format string.

        Need to make sure that any characters that might be interpreted as
        regex syntax are escaped.

        R   s   ([\\.^$*+?\(\){}\[\]|])s   \\\1s   \s+R1   i   s   %s%s%ss   %s%s(   t
   re_compilet   subt   index(   R   t   formatt   processed_formatt   regex_charst   whitespace_replacementt   directive_index(    (    s   /usr/lib/python2.7/_strptime.pyR{   Ù   s    c         C   s   t  |  j | É t É S(   s2   Return a compiled re object for the format string.(   Rä   R{   R   (   R   Rç   (    (    s   /usr/lib/python2.7/_strptime.pyR      s    N(   RY   RZ   R[   R?   R   Rx   R{   R    (    (    (    s   /usr/lib/python2.7/_strptime.pyR]   ¥   s
   *		i   c         C   sÖ   t  |  d d É j É  } | s= | d d } | d d } n  d | d } | d k rc d | | S| d | d } d | | Sd S(   sŒ   Calculate the Julian day based on the year, week of the year, and day of
    the week, with week_start_day representing whether the week of the year
    assumes the week starts on Sunday or Monday (6 or 0).i   i   i    N(   t   datetime_datet   weekday(   t   yeart   week_of_yeart   day_of_weekt   week_starts_Mont   first_weekdayt   week_0_lengtht   days_to_week(    (    s   /usr/lib/python2.7/_strptime.pyt   _calc_julian_from_U_or_W  s    s   %a %b %d %H:%M:%S %Yc         C   sX  t  è(t j } t É  | j k sF t j | j k sF t j | j k re t É  a t	 j
 É  t j } n  t t	 É t k rÑ t	 j
 É  n  t	 j | É } | s*y t j | É } Wnn t k
 r¸ } | j d } | d k r‡ d } n  ~ t d | | f É Ç n! t k
 rt d | É Ç n X| t	 | <n  Wd QX| j |  É } | s^t d |  | f É Ç n  t |  É | j É  k rìt d |  | j É  É Ç n  d } d	 } }	 d }
 } } } d
 } d
 } d
 } d } } | j É  } xØ| j É  D]°} | d k r2t | d É } | d k r%| d 7} qã| d 7} qÍ| d k rQt | d É } qÍ| d k rpt | d É } qÍ| d k rõ| j j | d j É  É } qÍ| d k r∆| j j | d j É  É } qÍ| d k rÂt | d É }	 qÍ| d k rt | d É }
 qÍ| d k rõt | d É }
 | j d d É j É  } | d | j d f k ri|
 d k ròd }
 qòqã| | j d	 k rã|
 d k rò|
 d 7}
 qòqãqÍ| d k r∫t | d É } qÍ| d k rŸt | d É } qÍ| d k r| d } | d d t | É 7} t | É } qÍ| d k rA| j j | d j É  É } qÍ| d k rl| j j | d j É  É } qÍ| d  k r™t | d  É } | d k rùd } qã| d	 8} qÍ| d! k r…t | d! É } qÍ| d, k rt | | É } | d" k r˙d } qãd } qÍ| d$ k rÍ| d$ j É  } xi t  | j! É D]U \ } } | | k r/t j d t j d	 k rzt j rz| d- k rzPqÑ| } Pq/q/WqÍqÍWt" } | d k r»| d' k r»|	 d( k r»d) } t# } n | d k r›d } n  | d k ro| d
 k ro| d k	 ro| d k rt# n t" } t$ | | | | É } | d k ro| d	 8} t% j& | É rYd* n d+ } | | 7} qon  | d k r∞t' | | |	 É j( É  t' | d	 d	 É j( É  d	 } nD t' j) | d	 t' | d	 d	 É j( É  É } | j* } | j+ } | j, }	 | d k rt' | | |	 É j- É  } n  | r*d } n  t j. | | |	 |
 | | | | | f	 É | f S(.   sE   Return a time struct based on the input string and the format string.i    s   \R1   s&   '%s' is a bad directive in format '%s's   stray %% in format '%s'Ns%   time data %r does not match format %rs   unconverted data remains: %si   iˇˇˇˇRh   iD   i–  il  Ri   Rc   Rl   Rm   R^   R`   Ra   Rn   R   i   Rd   Re   R_   t   0i   Rj   Rk   Rg   Rb   Rf   Rr   Rq   RQ   RR   i   i   ip  in  im  (   Rf   Rr   (   RQ   RR   (/   t   _cache_lockt   _TimeRE_cacheRv   R   R
   R   R   R   R]   t   _regex_cachet   clearRÉ   t   _CACHE_MAX_SIZEt   getR    t   KeyErrort   argsR   t
   IndexErrort   matcht   endR?   t	   groupdictt   iterkeyst   intR)   Rå   R    R(   R-   R#   R"   t	   enumerateRA   t   FalseRÑ   Rõ   R   t   isleapRí   t	   toordinalt   fromordinalRî   t   montht   dayRì   R+   (   t   data_stringRç   Rv   t   format_regext   errt   bad_directivet   foundRî   R∞   R±   R.   t   minutet   secondt   fractionRI   Rï   t   week_of_year_startRì   t   juliant
   found_dictt	   group_keyt   ampmt   st
   found_zoneRá   RH   t   leap_year_fixRó   t   ydayt   datetime_result(    (    s   /usr/lib/python2.7/_strptime.pyt	   _strptime+  s¸    		
	


			$		$	
5)					c         C   s   t  |  | É d S(   Ni    (   Rƒ   (   R≤   Rç   (    (    s   /usr/lib/python2.7/_strptime.pyt   _strptime_time›  s    (   R[   R   R   R   t   reR    Rä   R   R   RÄ   t   datetimeR   Rí   t   threadR   t   _thread_allocate_lockt   dummy_threadt   __all__R   t   objectR	   t   dictR]   Rù   Rû   R°   Rü   Rõ   Rƒ   R≈   (    (    (    s   /usr/lib/python2.7/_strptime.pyt   <module>   s,   	ï[			≤                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Access WeakSet through the weakref module.
# This code is separated-out because it is needed
# by abc.py to load everything else at startup.

from _weakref import ref

__all__ = ['WeakSet']


class _IterationGuard(object):
    # This context manager registers itself in the current iterators of the
    # weak container, such as to delay all removals until the context manager
    # exits.
    # This technique should be relatively thread-safe (since sets are).

    def __init__(self, weakcontainer):
        # Don't create cycles
        self.weakcontainer = ref(weakcontainer)

    def __enter__(self):
        w = self.weakcontainer()
        if w is not None:
            w._iterating.add(self)
        return self

    def __exit__(self, e, t, b):
        w = self.weakcontainer()
        if w is not None:
            s = w._iterating
            s.remove(self)
            if not s:
                w._commit_removals()


class WeakSet(object):
    def __init__(self, data=None):
        self.data = set()
        def _remove(item, selfref=ref(self)):
            self = selfref()
            if self is not None:
                if self._iterating:
                    self._pending_removals.append(item)
                else:
                    self.data.discard(item)
        self._remove = _remove
        # A list of keys to be removed
        self._pending_removals = []
        self._iterating = set()
        if data is not None:
            self.update(data)

    def _commit_removals(self):
        l = self._pending_removals
        discard = self.data.discard
        while l:
            discard(l.pop())

    def __iter__(self):
        with _IterationGuard(self):
            for itemref in self.data:
                item = itemref()
                if item is not None:
                    # Caveat: the iterator will keep a strong reference to
                    # `item` until it is resumed or closed.
                    yield item

    def __len__(self):
        return len(self.data) - len(self._pending_removals)

    def __contains__(self, item):
        try:
            wr = ref(item)
        except TypeError:
            return False
        return wr in self.data

    def __reduce__(self):
        return (self.__class__, (list(self),),
                getattr(self, '__dict__', None))

    __hash__ = None

    def add(self, item):
        if self._pending_removals:
            self._commit_removals()
        self.data.add(ref(item, self._remove))

    def clear(self):
        if self._pending_removals:
            self._commit_removals()
        self.data.clear()

    def copy(self):
        return self.__class__(self)

    def pop(self):
        if self._pending_removals:
            self._commit_removals()
        while True:
            try:
                itemref = self.data.pop()
            except KeyError:
                raise KeyError('pop from empty WeakSet')
            item = itemref()
            if item is not None:
                return item

    def remove(self, item):
        if self._pending_removals:
            self._commit_removals()
        self.data.remove(ref(item))

    def discard(self, item):
        if self._pending_removals:
            self._commit_removals()
        self.data.discard(ref(item))

    def update(self, other):
        if self._pending_removals:
            self._commit_removals()
        for element in other:
            self.add(element)

    def __ior__(self, other):
        self.update(other)
        return self

    def difference(self, other):
        newset = self.copy()
        newset.difference_update(other)
        return newset
    __sub__ = difference

    def difference_update(self, other):
        self.__isub__(other)
    def __isub__(self, other):
        if self._pending_removals:
            self._commit_removals()
        if self is other:
            self.data.clear()
        else:
            self.data.difference_update(ref(item) for item in other)
        return self

    def intersection(self, other):
        return self.__class__(item for item in other if item in self)
    __and__ = intersection

    def intersection_update(self, other):
        self.__iand__(other)
    def __iand__(self, other):
        if self._pending_removals:
            self._commit_removals()
        self.data.intersection_update(ref(item) for item in other)
        return self

    def issubset(self, other):
        return self.data.issubset(ref(item) for item in other)
    __le__ = issubset

    def __lt__(self, other):
        return self.data < set(ref(item) for item in other)

    def issuperset(self, other):
        return self.data.issuperset(ref(item) for item in other)
    __ge__ = issuperset

    def __gt__(self, other):
        return self.data > set(ref(item) for item in other)

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self.data == set(ref(item) for item in other)

    def __ne__(self, other):
        opposite = self.__eq__(other)
        if opposite is NotImplemented:
            return NotImplemented
        return not opposite

    def symmetric_difference(self, other):
        newset = self.copy()
        newset.symmetric_difference_update(other)
        return newset
    __xor__ = symmetric_difference

    def symmetric_difference_update(self, other):
        self.__ixor__(other)
    def __ixor__(self, other):
        if self._pending_removals:
            self._commit_removals()
        if self is other:
            self.data.clear()
        else:
            self.data.symmetric_difference_update(ref(item, self._remove) for item in other)
        return self

    def union(self, other):
        return self.__class__(e for s in (self, other) for e in s)
    __or__ = union

    def isdisjoint(self, other):
        return len(self.intersection(other)) == 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   sI   d  d l  m Z d g Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(   iˇˇˇˇ(   t   reft   WeakSett   _IterationGuardc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   t  | É |  _ d  S(   N(   R    t   weakcontainer(   t   selfR   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __init__   s    c         C   s/   |  j  É  } | d  k	 r+ | j j |  É n  |  S(   N(   R   t   Nonet
   _iteratingt   add(   R   t   w(    (    s!   /usr/lib/python2.7/_weakrefset.pyt	   __enter__   s    c         C   sH   |  j  É  } | d  k	 rD | j } | j |  É | sD | j É  qD n  d  S(   N(   R   R   R   t   removet   _commit_removals(   R   t   et   tt   bR	   t   s(    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __exit__   s    	(   t   __name__t
   __module__R   R
   R   (    (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   
   s   		c           B   sL  e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" e" Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& e& Z' d Ñ  Z( RS(    c         C   s\   t  É  |  _ t |  É d Ñ } | |  _ g  |  _ t  É  |  _ | d  k	 rX |  j | É n  d  S(   Nc         S   sH   | É  } | d  k	 rD | j r1 | j j |  É qD | j j |  É n  d  S(   N(   R   R   t   _pending_removalst   appendt   datat   discard(   t   itemt   selfrefR   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   _remove&   s
    		(   t   setR   R    R   R   R   R   t   update(   R   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   $   s    		c         C   s6   |  j  } |  j j } x | r1 | | j É  É q Wd  S(   N(   R   R   R   t   pop(   R   t   lR   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   4   s    		c         c   sH   t  |  É è6 x. |  j D]# } | É  } | d  k	 r | Vq q WWd  QXd  S(   N(   R   R   R   (   R   t   itemrefR   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __iter__:   s
    	c         C   s   t  |  j É t  |  j É S(   N(   t   lenR   R   (   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __len__C   s    c         C   s2   y t  | É } Wn t k
 r$ t SX| |  j k S(   N(   R    t	   TypeErrort   FalseR   (   R   R   t   wr(    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __contains__F   s
    c         C   s%   |  j  t |  É f t |  d d  É f S(   Nt   __dict__(   t	   __class__t   listt   getattrR   (   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt
   __reduce__M   s    c         C   s6   |  j  r |  j É  n  |  j j t | |  j É É d  S(   N(   R   R   R   R   R    R   (   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   S   s    	c         C   s'   |  j  r |  j É  n  |  j j É  d  S(   N(   R   R   R   t   clear(   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR,   X   s    	c         C   s   |  j  |  É S(   N(   R(   (   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   copy]   s    c         C   ss   |  j  r |  j É  n  xV t rn y |  j j É  } Wn t k
 rQ t d É Ç n X| É  } | d  k	 r | Sq Wd  S(   Ns   pop from empty WeakSet(   R   R   t   TrueR   R   t   KeyErrorR   (   R   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   `   s    			c         C   s0   |  j  r |  j É  n  |  j j t | É É d  S(   N(   R   R   R   R   R    (   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   l   s    	c         C   s0   |  j  r |  j É  n  |  j j t | É É d  S(   N(   R   R   R   R   R    (   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   q   s    	c         C   s8   |  j  r |  j É  n  x | D] } |  j | É q Wd  S(   N(   R   R   R   (   R   t   othert   element(    (    s!   /usr/lib/python2.7/_weakrefset.pyR   v   s    	c         C   s   |  j  | É |  S(   N(   R   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __ior__|   s    c         C   s   |  j  É  } | j | É | S(   N(   R-   t   difference_update(   R   R0   t   newset(    (    s!   /usr/lib/python2.7/_weakrefset.pyt
   differenceÄ   s    c         C   s   |  j  | É d  S(   N(   t   __isub__(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR3   Ü   s    c         C   sP   |  j  r |  j É  n  |  | k r2 |  j j É  n |  j j d Ñ  | DÉ É |  S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   t   .0R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>é   s    (   R   R   R   R,   R3   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR6   à   s    	c            s   à  j  á  f d Ü  | DÉ É S(   Nc         3   s!   |  ] } | à  k r | Vq d  S(   N(    (   R7   R   (   R   (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>í   s    (   R(   (   R   R0   (    (   R   s!   /usr/lib/python2.7/_weakrefset.pyt   intersectionë   s    c         C   s   |  j  | É d  S(   N(   t   __iand__(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   intersection_updateï   s    c         C   s4   |  j  r |  j É  n  |  j j d Ñ  | DÉ É |  S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>ö   s    (   R   R   R   R:   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR9   ó   s    	c         C   s   |  j  j d Ñ  | DÉ É S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>û   s    (   R   t   issubset(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR;   ù   s    c         C   s   |  j  t d Ñ  | DÉ É k  S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>¢   s    (   R   R   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __lt__°   s    c         C   s   |  j  j d Ñ  | DÉ É S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>•   s    (   R   t
   issuperset(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR=   §   s    c         C   s   |  j  t d Ñ  | DÉ É k S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>©   s    (   R   R   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __gt__®   s    c         C   s3   t  | |  j É s t S|  j t d Ñ  | DÉ É k S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>Æ   s    (   t
   isinstanceR(   t   NotImplementedR   R   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __eq__´   s    c         C   s$   |  j  | É } | t k r t S| S(   N(   RA   R@   (   R   R0   t   opposite(    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __ne__∞   s    c         C   s   |  j  É  } | j | É | S(   N(   R-   t   symmetric_difference_update(   R   R0   R4   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   symmetric_difference∂   s    c         C   s   |  j  | É d  S(   N(   t   __ixor__(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyRD   º   s    c            sV   à  j  r à  j É  n  à  | k r2 à  j j É  n  à  j j á  f d Ü  | DÉ É à  S(   Nc         3   s!   |  ] } t  | à  j É Vq d  S(   N(   R    R   (   R7   R   (   R   (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>ƒ   s    (   R   R   R   R,   RD   (   R   R0   (    (   R   s!   /usr/lib/python2.7/_weakrefset.pyRF   æ   s    	 c         C   s   |  j  d Ñ  |  | f DÉ É S(   Nc         s   s"   |  ] } | D] } | Vq q d  S(   N(    (   R7   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>»   s    (   R(   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   union«   s    c         C   s   t  |  j | É É d k S(   Ni    (   R!   R8   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt
   isdisjointÀ   s    N()   R   R   R   R   R   R    R"   R&   R+   t   __hash__R   R,   R-   R   R   R   R   R2   R5   t   __sub__R3   R6   R8   t   __and__R:   R9   R;   t   __le__R<   R=   t   __ge__R>   RA   RC   RE   t   __xor__RD   RF   RG   t   __or__RH   (    (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   #   sL   																																N(   t   _weakrefR    t   __all__t   objectR   R   (    (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
import webbrowser

webbrowser.open("http://xkcd.com/353/")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Abstract Base Classes (ABCs) according to PEP 3119."""

import types

from _weakrefset import WeakSet

# Instance of old-style class
class _C: pass
_InstanceType = type(_C())


def abstractmethod(funcobj):
    """A decorator indicating abstract methods.

    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract methods are overridden.
    The abstract methods can be called using any of the normal
    'super' call mechanisms.

    Usage:

        class C:
            __metaclass__ = ABCMeta
            @abstractmethod
            def my_abstract_method(self, ...):
                ...
    """
    funcobj.__isabstractmethod__ = True
    return funcobj


class abstractproperty(property):
    """A decorator indicating abstract properties.

    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract properties are overridden.
    The abstract properties can be called using any of the normal
    'super' call mechanisms.

    Usage:

        class C:
            __metaclass__ = ABCMeta
            @abstractproperty
            def my_abstract_property(self):
                ...

    This defines a read-only property; you can also define a read-write
    abstract property using the 'long' form of property declaration:

        class C:
            __metaclass__ = ABCMeta
            def getx(self): ...
            def setx(self, value): ...
            x = abstractproperty(getx, setx)
    """
    __isabstractmethod__ = True


class ABCMeta(type):

    """Metaclass for defining Abstract Base Classes (ABCs).

    Use this metaclass to create an ABC.  An ABC can be subclassed
    directly, and then acts as a mix-in class.  You can also register
    unrelated concrete classes (even built-in classes) and unrelated
    ABCs as 'virtual subclasses' -- these and their descendants will
    be considered subclasses of the registering ABC by the built-in
    issubclass() function, but the registering ABC won't show up in
    their MRO (Method Resolution Order) nor will method
    implementations defined by the registering ABC be callable (not
    even via super()).

    """

    # A global counter that is incremented each time a class is
    # registered as a virtual subclass of anything.  It forces the
    # negative cache to be cleared before its next use.
    _abc_invalidation_counter = 0

    def __new__(mcls, name, bases, namespace):
        cls = super(ABCMeta, mcls).__new__(mcls, name, bases, namespace)
        # Compute set of abstract method names
        abstracts = set(name
                     for name, value in namespace.items()
                     if getattr(value, "__isabstractmethod__", False))
        for base in bases:
            for name in getattr(base, "__abstractmethods__", set()):
                value = getattr(cls, name, None)
                if getattr(value, "__isabstractmethod__", False):
                    abstracts.add(name)
        cls.__abstractmethods__ = frozenset(abstracts)
        # Set up inheritance registry
        cls._abc_registry = WeakSet()
        cls._abc_cache = WeakSet()
        cls._abc_negative_cache = WeakSet()
        cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
        return cls

    def register(cls, subclass):
        """Register a virtual subclass of an ABC."""
        if not isinstance(subclass, (type, types.ClassType)):
            raise TypeError("Can only register classes")
        if issubclass(subclass, cls):
            return  # Already a subclass
        # Subtle: test for cycles *after* testing for "already a subclass";
        # this means we allow X.register(X) and interpret it as a no-op.
        if issubclass(cls, subclass):
            # This would create a cycle, which is bad for the algorithm below
            raise RuntimeError("Refusing to create an inheritance cycle")
        cls._abc_registry.add(subclass)
        ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache

    def _dump_registry(cls, file=None):
        """Debug helper to print the ABC registry."""
        print >> file, "Class: %s.%s" % (cls.__module__, cls.__name__)
        print >> file, "Inv.counter: %s" % ABCMeta._abc_invalidation_counter
        for name in sorted(cls.__dict__.keys()):
            if name.startswith("_abc_"):
                value = getattr(cls, name)
                print >> file, "%s: %r" % (name, value)

    def __instancecheck__(cls, instance):
        """Override for isinstance(instance, cls)."""
        # Inline the cache checking when it's simple.
        subclass = getattr(instance, '__class__', None)
        if subclass is not None and subclass in cls._abc_cache:
            return True
        subtype = type(instance)
        # Old-style instances
        if subtype is _InstanceType:
            subtype = subclass
        if subtype is subclass or subclass is None:
            if (cls._abc_negative_cache_version ==
                ABCMeta._abc_invalidation_counter and
                subtype in cls._abc_negative_cache):
                return False
            # Fall back to the subclass check.
            return cls.__subclasscheck__(subtype)
        return (cls.__subclasscheck__(subclass) or
                cls.__subclasscheck__(subtype))

    def __subclasscheck__(cls, subclass):
        """Override for issubclass(subclass, cls)."""
        # Check cache
        if subclass in cls._abc_cache:
            return True
        # Check negative cache; may have to invalidate
        if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
            # Invalidate the negative cache
            cls._abc_negative_cache = WeakSet()
            cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
        elif subclass in cls._abc_negative_cache:
            return False
        # Check the subclass hook
        ok = cls.__subclasshook__(subclass)
        if ok is not NotImplemented:
            assert isinstance(ok, bool)
            if ok:
                cls._abc_cache.add(subclass)
            else:
                cls._abc_negative_cache.add(subclass)
            return ok
        # Check if it's a direct subclass
        if cls in getattr(subclass, '__mro__', ()):
            cls._abc_cache.add(subclass)
            return True
        # Check if it's a subclass of a registered class (recursive)
        for rcls in cls._abc_registry:
            if issubclass(subclass, rcls):
                cls._abc_cache.add(subclass)
                return True
        # Check if it's a subclass of a subclass (recursive)
        for scls in cls.__subclasses__():
            if issubclass(subclass, scls):
                cls._abc_cache.add(subclass)
                return True
        # No dice; update negative cache
        cls._abc_negative_cache.add(subclass)
        return False
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   s}   d  Z  d d l Z d d l m Z d d d Ñ  É  YZ e e É  É Z d Ñ  Z d e f d Ñ  É  YZ	 d	 e f d
 Ñ  É  YZ
 d S(   s3   Abstract Base Classes (ABCs) according to PEP 3119.iˇˇˇˇN(   t   WeakSett   _Cc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/abc.pyR      s    c         C   s   t  |  _ |  S(   sÔ  A decorator indicating abstract methods.

    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract methods are overridden.
    The abstract methods can be called using any of the normal
    'super' call mechanisms.

    Usage:

        class C:
            __metaclass__ = ABCMeta
            @abstractmethod
            def my_abstract_method(self, ...):
                ...
    (   t   Truet   __isabstractmethod__(   t   funcobj(    (    s   /usr/lib/python2.7/abc.pyt   abstractmethod   s    	t   abstractpropertyc           B   s   e  Z d  Z e Z RS(   s/  A decorator indicating abstract properties.

    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract properties are overridden.
    The abstract properties can be called using any of the normal
    'super' call mechanisms.

    Usage:

        class C:
            __metaclass__ = ABCMeta
            @abstractproperty
            def my_abstract_property(self):
                ...

    This defines a read-only property; you can also define a read-write
    abstract property using the 'long' form of property declaration:

        class C:
            __metaclass__ = ABCMeta
            def getx(self): ...
            def setx(self, value): ...
            x = abstractproperty(getx, setx)
    (   R   R   t   __doc__R   R   (    (    (    s   /usr/lib/python2.7/abc.pyR   $   s   t   ABCMetac           B   sD   e  Z d  Z d Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z	 RS(   si  Metaclass for defining Abstract Base Classes (ABCs).

    Use this metaclass to create an ABC.  An ABC can be subclassed
    directly, and then acts as a mix-in class.  You can also register
    unrelated concrete classes (even built-in classes) and unrelated
    ABCs as 'virtual subclasses' -- these and their descendants will
    be considered subclasses of the registering ABC by the built-in
    issubclass() function, but the registering ABC won't show up in
    their MRO (Method Resolution Order) nor will method
    implementations defined by the registering ABC be callable (not
    even via super()).

    i    c         C   sÂ   t  t |  É j |  | | | É } t d Ñ  | j É  DÉ É } xb | D]Z } xQ t | d t É  É D]: } t | | d  É } t | d t É r` | j | É q` q` WqD Wt	 | É | _
 t É  | _ t É  | _ t É  | _ t j | _ | S(   Nc         s   s-   |  ]# \ } } t  | d  t É r | Vq d S(   R   N(   t   getattrt   False(   t   .0t   namet   value(    (    s   /usr/lib/python2.7/abc.pys	   <genexpr>Y   s   	t   __abstractmethods__R   (   t   superR
   t   __new__t   sett   itemsR   t   NoneR   t   addt	   frozensetR   R    t   _abc_registryt
   _abc_cachet   _abc_negative_cachet   _abc_invalidation_countert   _abc_negative_cache_version(   t   mclsR   t   basest	   namespacet   clst	   abstractst   baseR   (    (    s   /usr/lib/python2.7/abc.pyR   V   s    !	c         C   s{   t  | t t j f É s' t d É Ç n  t | |  É r: d St |  | É rX t d É Ç n  |  j j | É t	 j
 d 7_
 d S(   s&   Register a virtual subclass of an ABC.s   Can only register classesNs'   Refusing to create an inheritance cyclei   (   t
   isinstancet   typet   typest	   ClassTypet	   TypeErrort
   issubclasst   RuntimeErrorR   R   R
   R   (   R    t   subclass(    (    s   /usr/lib/python2.7/abc.pyt   registeri   s    c         C   sÑ   | d |  j  |  j f IJ| d t j IJxR t |  j j É  É D]; } | j d É rA t |  | É } | d | | f IJqA qA Wd S(   s'   Debug helper to print the ABC registry.s   Class: %s.%ss   Inv.counter: %st   _abc_s   %s: %rN(	   R   R   R
   R   t   sortedt   __dict__t   keyst
   startswithR   (   R    t   fileR   R   (    (    s   /usr/lib/python2.7/abc.pyt   _dump_registryw   s    c         C   s∏   t  | d d É } | d k	 r1 | |  j k r1 t St | É } | t k rR | } n  | | k sj | d k rú |  j t j k rè | |  j	 k rè t
 S|  j | É S|  j | É p∑ |  j | É S(   s'   Override for isinstance(instance, cls).t	   __class__N(   R   R   R   R   R$   t   _InstanceTypeR   R
   R   R   R   t   __subclasscheck__(   R    t   instanceR*   t   subtype(    (    s   /usr/lib/python2.7/abc.pyt   __instancecheck__Ä   s    	c         C   sa  | |  j  k r t S|  j t j k  r@ t É  |  _ t j |  _ n | |  j k rS t S|  j | É } | t	 k	 r∞ t
 | t É sÉ t Ç | rú |  j  j | É n |  j j | É | S|  t | d d É k r‹ |  j  j | É t Sx4 |  j D]) } t | | É rÊ |  j  j | É t SqÊ Wx7 |  j É  D]) } t | | É r |  j  j | É t Sq W|  j j | É t S(   s'   Override for issubclass(subclass, cls).t   __mro__(    (   R   R   R   R
   R   R    R   R   t   __subclasshook__t   NotImplementedR#   t   boolt   AssertionErrorR   R   R   R(   t   __subclasses__(   R    R*   t   okt   rclst   scls(    (    s   /usr/lib/python2.7/abc.pyR5   î   s6    N(
   R   R   R	   R   R   R+   R   R2   R8   R5   (    (    (    s   /usr/lib/python2.7/abc.pyR
   A   s   				(    (   R	   R%   t   _weakrefsetR    R   R$   R4   R   t   propertyR   R
   (    (    (    s   /usr/lib/python2.7/abc.pyt   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """Stuff to parse AIFF-C and AIFF files.

Unless explicitly stated otherwise, the description below is true
both for AIFF-C files and AIFF files.

An AIFF-C file has the following structure.

  +-----------------+
  | FORM            |
  +-----------------+
  | <size>          |
  +----+------------+
  |    | AIFC       |
  |    +------------+
  |    | <chunks>   |
  |    |    .       |
  |    |    .       |
  |    |    .       |
  +----+------------+

An AIFF file has the string "AIFF" instead of "AIFC".

A chunk consists of an identifier (4 bytes) followed by a size (4 bytes,
big endian order), followed by the data.  The size field does not include
the size of the 8 byte header.

The following chunk types are recognized.

  FVER
      <version number of AIFF-C defining document> (AIFF-C only).
  MARK
      <# of markers> (2 bytes)
      list of markers:
          <marker ID> (2 bytes, must be > 0)
          <position> (4 bytes)
          <marker name> ("pstring")
  COMM
      <# of channels> (2 bytes)
      <# of sound frames> (4 bytes)
      <size of the samples> (2 bytes)
      <sampling frequency> (10 bytes, IEEE 80-bit extended
          floating point)
      in AIFF-C files only:
      <compression type> (4 bytes)
      <human-readable version of compression type> ("pstring")
  SSND
      <offset> (4 bytes, not used by this program)
      <blocksize> (4 bytes, not used by this program)
      <sound data>

A pstring consists of 1 byte length, a string of characters, and 0 or 1
byte pad to make the total length even.

Usage.

Reading AIFF files:
  f = aifc.open(file, 'r')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods read(), seek(), and close().
In some types of audio files, if the setpos() method is not used,
the seek() method is not necessary.

This returns an instance of a class with the following public methods:
  getnchannels()  -- returns number of audio channels (1 for
             mono, 2 for stereo)
  getsampwidth()  -- returns sample width in bytes
  getframerate()  -- returns sampling frequency
  getnframes()    -- returns number of audio frames
  getcomptype()   -- returns compression type ('NONE' for AIFF files)
  getcompname()   -- returns human-readable version of
             compression type ('not compressed' for AIFF files)
  getparams() -- returns a tuple consisting of all of the
             above in the above order
  getmarkers()    -- get the list of marks in the audio file or None
             if there are no marks
  getmark(id) -- get mark with the specified id (raises an error
             if the mark does not exist)
  readframes(n)   -- returns at most n frames of audio
  rewind()    -- rewind to the beginning of the audio stream
  setpos(pos) -- seek to the specified position
  tell()      -- return the current position
  close()     -- close the instance (make it unusable)
The position returned by tell(), the position given to setpos() and
the position of marks are all compatible and have nothing to do with
the actual position in the file.
The close() method is called automatically when the class instance
is destroyed.

Writing AIFF files:
  f = aifc.open(file, 'w')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods write(), tell(), seek(), and
close().

This returns an instance of a class with the following public methods:
  aiff()      -- create an AIFF file (AIFF-C default)
  aifc()      -- create an AIFF-C file
  setnchannels(n) -- set the number of channels
  setsampwidth(n) -- set the sample width
  setframerate(n) -- set the frame rate
  setnframes(n)   -- set the number of frames
  setcomptype(type, name)
          -- set the compression type and the
             human-readable compression type
  setparams(tuple)
          -- set all parameters at once
  setmark(id, pos, name)
          -- add specified mark to the list of marks
  tell()      -- return current position in output file (useful
             in combination with setmark())
  writeframesraw(data)
          -- write audio frames without pathing up the
             file header
  writeframes(data)
          -- write audio frames and patch up the file header
  close()     -- patch up the file header and close the
             output file
You should set the parameters before the first writeframesraw or
writeframes.  The total number of frames does not need to be set,
but when it is set to the correct value, the header does not have to
be patched up.
It is best to first set all parameters, perhaps possibly the
compression type, and then write audio frames using writeframesraw.
When all frames have been written, either call writeframes('') or
close() to patch up the sizes in the header.
Marks can be added anytime.  If there are any marks, you must call
close() after all frames have been written.
The close() method is called automatically when the class instance
is destroyed.

When a file is opened with the extension '.aiff', an AIFF file is
written, otherwise an AIFF-C file is written.  This default can be
changed by calling aiff() or aifc() before the first writeframes or
writeframesraw.
"""

import struct
import __builtin__

__all__ = ["Error","open","openfp"]

class Error(Exception):
    pass

_AIFC_version = 0xA2805140L     # Version 1 of AIFF-C

def _read_long(file):
    try:
        return struct.unpack('>l', file.read(4))[0]
    except struct.error:
        raise EOFError

def _read_ulong(file):
    try:
        return struct.unpack('>L', file.read(4))[0]
    except struct.error:
        raise EOFError

def _read_short(file):
    try:
        return struct.unpack('>h', file.read(2))[0]
    except struct.error:
        raise EOFError

def _read_ushort(file):
    try:
        return struct.unpack('>H', file.read(2))[0]
    except struct.error:
        raise EOFError

def _read_string(file):
    length = ord(file.read(1))
    if length == 0:
        data = ''
    else:
        data = file.read(length)
    if length & 1 == 0:
        dummy = file.read(1)
    return data

_HUGE_VAL = 1.79769313486231e+308 # See <limits.h>

def _read_float(f): # 10 bytes
    expon = _read_short(f) # 2 bytes
    sign = 1
    if expon < 0:
        sign = -1
        expon = expon + 0x8000
    himant = _read_ulong(f) # 4 bytes
    lomant = _read_ulong(f) # 4 bytes
    if expon == himant == lomant == 0:
        f = 0.0
    elif expon == 0x7FFF:
        f = _HUGE_VAL
    else:
        expon = expon - 16383
        f = (himant * 0x100000000L + lomant) * pow(2.0, expon - 63)
    return sign * f

def _write_short(f, x):
    f.write(struct.pack('>h', x))

def _write_ushort(f, x):
    f.write(struct.pack('>H', x))

def _write_long(f, x):
    f.write(struct.pack('>l', x))

def _write_ulong(f, x):
    f.write(struct.pack('>L', x))

def _write_string(f, s):
    if len(s) > 255:
        raise ValueError("string exceeds maximum pstring length")
    f.write(struct.pack('B', len(s)))
    f.write(s)
    if len(s) & 1 == 0:
        f.write(chr(0))

def _write_float(f, x):
    import math
    if x < 0:
        sign = 0x8000
        x = x * -1
    else:
        sign = 0
    if x == 0:
        expon = 0
        himant = 0
        lomant = 0
    else:
        fmant, expon = math.frexp(x)
        if expon > 16384 or fmant >= 1 or fmant != fmant: # Infinity or NaN
            expon = sign|0x7FFF
            himant = 0
            lomant = 0
        else:                   # Finite
            expon = expon + 16382
            if expon < 0:           # denormalized
                fmant = math.ldexp(fmant, expon)
                expon = 0
            expon = expon | sign
            fmant = math.ldexp(fmant, 32)
            fsmant = math.floor(fmant)
            himant = long(fsmant)
            fmant = math.ldexp(fmant - fsmant, 32)
            fsmant = math.floor(fmant)
            lomant = long(fsmant)
    _write_ushort(f, expon)
    _write_ulong(f, himant)
    _write_ulong(f, lomant)

from chunk import Chunk

class Aifc_read:
    # Variables used in this class:
    #
    # These variables are available to the user though appropriate
    # methods of this class:
    # _file -- the open file with methods read(), close(), and seek()
    #       set through the __init__() method
    # _nchannels -- the number of audio channels
    #       available through the getnchannels() method
    # _nframes -- the number of audio frames
    #       available through the getnframes() method
    # _sampwidth -- the number of bytes per audio sample
    #       available through the getsampwidth() method
    # _framerate -- the sampling frequency
    #       available through the getframerate() method
    # _comptype -- the AIFF-C compression type ('NONE' if AIFF)
    #       available through the getcomptype() method
    # _compname -- the human-readable AIFF-C compression type
    #       available through the getcomptype() method
    # _markers -- the marks in the audio file
    #       available through the getmarkers() and getmark()
    #       methods
    # _soundpos -- the position in the audio stream
    #       available through the tell() method, set through the
    #       setpos() method
    #
    # These variables are used internally only:
    # _version -- the AIFF-C version number
    # _decomp -- the decompressor from builtin module cl
    # _comm_chunk_read -- 1 iff the COMM chunk has been read
    # _aifc -- 1 iff reading an AIFF-C file
    # _ssnd_seek_needed -- 1 iff positioned correctly in audio
    #       file for readframes()
    # _ssnd_chunk -- instantiation of a chunk class for the SSND chunk
    # _framesize -- size of one frame in the file

    def initfp(self, file):
        self._version = 0
        self._decomp = None
        self._convert = None
        self._markers = []
        self._soundpos = 0
        self._file = file
        chunk = Chunk(file)
        if chunk.getname() != 'FORM':
            raise Error, 'file does not start with FORM id'
        formdata = chunk.read(4)
        if formdata == 'AIFF':
            self._aifc = 0
        elif formdata == 'AIFC':
            self._aifc = 1
        else:
            raise Error, 'not an AIFF or AIFF-C file'
        self._comm_chunk_read = 0
        while 1:
            self._ssnd_seek_needed = 1
            try:
                chunk = Chunk(self._file)
            except EOFError:
                break
            chunkname = chunk.getname()
            if chunkname == 'COMM':
                self._read_comm_chunk(chunk)
                self._comm_chunk_read = 1
            elif chunkname == 'SSND':
                self._ssnd_chunk = chunk
                dummy = chunk.read(8)
                self._ssnd_seek_needed = 0
            elif chunkname == 'FVER':
                self._version = _read_ulong(chunk)
            elif chunkname == 'MARK':
                self._readmark(chunk)
            chunk.skip()
        if not self._comm_chunk_read or not self._ssnd_chunk:
            raise Error, 'COMM chunk and/or SSND chunk missing'
        if self._aifc and self._decomp:
            import cl
            params = [cl.ORIGINAL_FORMAT, 0,
                  cl.BITS_PER_COMPONENT, self._sampwidth * 8,
                  cl.FRAME_RATE, self._framerate]
            if self._nchannels == 1:
                params[1] = cl.MONO
            elif self._nchannels == 2:
                params[1] = cl.STEREO_INTERLEAVED
            else:
                raise Error, 'cannot compress more than 2 channels'
            self._decomp.SetParams(params)

    def __init__(self, f):
        if type(f) == type(''):
            f = __builtin__.open(f, 'rb')
        # else, assume it is an open file object already
        self.initfp(f)

    #
    # User visible methods.
    #
    def getfp(self):
        return self._file

    def rewind(self):
        self._ssnd_seek_needed = 1
        self._soundpos = 0

    def close(self):
        decomp = self._decomp
        try:
            if decomp:
                self._decomp = None
                decomp.CloseDecompressor()
        finally:
            self._file.close()

    def tell(self):
        return self._soundpos

    def getnchannels(self):
        return self._nchannels

    def getnframes(self):
        return self._nframes

    def getsampwidth(self):
        return self._sampwidth

    def getframerate(self):
        return self._framerate

    def getcomptype(self):
        return self._comptype

    def getcompname(self):
        return self._compname

##  def getversion(self):
##      return self._version

    def getparams(self):
        return self.getnchannels(), self.getsampwidth(), \
              self.getframerate(), self.getnframes(), \
              self.getcomptype(), self.getcompname()

    def getmarkers(self):
        if len(self._markers) == 0:
            return None
        return self._markers

    def getmark(self, id):
        for marker in self._markers:
            if id == marker[0]:
                return marker
        raise Error, 'marker %r does not exist' % (id,)

    def setpos(self, pos):
        if pos < 0 or pos > self._nframes:
            raise Error, 'position not in range'
        self._soundpos = pos
        self._ssnd_seek_needed = 1

    def readframes(self, nframes):
        if self._ssnd_seek_needed:
            self._ssnd_chunk.seek(0)
            dummy = self._ssnd_chunk.read(8)
            pos = self._soundpos * self._framesize
            if pos:
                self._ssnd_chunk.seek(pos + 8)
            self._ssnd_seek_needed = 0
        if nframes == 0:
            return ''
        data = self._ssnd_chunk.read(nframes * self._framesize)
        if self._convert and data:
            data = self._convert(data)
        self._soundpos = self._soundpos + len(data) // (self._nchannels * self._sampwidth)
        return data

    #
    # Internal methods.
    #

    def _decomp_data(self, data):
        import cl
        dummy = self._decomp.SetParam(cl.FRAME_BUFFER_SIZE,
                          len(data) * 2)
        return self._decomp.Decompress(len(data) // self._nchannels,
                           data)

    def _ulaw2lin(self, data):
        import audioop
        return audioop.ulaw2lin(data, 2)

    def _adpcm2lin(self, data):
        import audioop
        if not hasattr(self, '_adpcmstate'):
            # first time
            self._adpcmstate = None
        data, self._adpcmstate = audioop.adpcm2lin(data, 2,
                               self._adpcmstate)
        return data

    def _read_comm_chunk(self, chunk):
        self._nchannels = _read_short(chunk)
        self._nframes = _read_long(chunk)
        self._sampwidth = (_read_short(chunk) + 7) // 8
        self._framerate = int(_read_float(chunk))
        self._framesize = self._nchannels * self._sampwidth
        if self._aifc:
            #DEBUG: SGI's soundeditor produces a bad size :-(
            kludge = 0
            if chunk.chunksize == 18:
                kludge = 1
                print 'Warning: bad COMM chunk size'
                chunk.chunksize = 23
            #DEBUG end
            self._comptype = chunk.read(4)
            #DEBUG start
            if kludge:
                length = ord(chunk.file.read(1))
                if length & 1 == 0:
                    length = length + 1
                chunk.chunksize = chunk.chunksize + length
                chunk.file.seek(-1, 1)
            #DEBUG end
            self._compname = _read_string(chunk)
            if self._comptype != 'NONE':
                if self._comptype == 'G722':
                    try:
                        import audioop
                    except ImportError:
                        pass
                    else:
                        self._convert = self._adpcm2lin
                        self._sampwidth = 2
                        return
                # for ULAW and ALAW try Compression Library
                try:
                    import cl
                except ImportError:
                    if self._comptype in ('ULAW', 'ulaw'):
                        try:
                            import audioop
                            self._convert = self._ulaw2lin
                            self._sampwidth = 2
                            return
                        except ImportError:
                            pass
                    raise Error, 'cannot read compressed AIFF-C files'
                if self._comptype in ('ULAW', 'ulaw'):
                    scheme = cl.G711_ULAW
                elif self._comptype in ('ALAW', 'alaw'):
                    scheme = cl.G711_ALAW
                else:
                    raise Error, 'unsupported compression type'
                self._decomp = cl.OpenDecompressor(scheme)
                self._convert = self._decomp_data
                self._sampwidth = 2
        else:
            self._comptype = 'NONE'
            self._compname = 'not compressed'

    def _readmark(self, chunk):
        nmarkers = _read_short(chunk)
        # Some files appear to contain invalid counts.
        # Cope with this by testing for EOF.
        try:
            for i in range(nmarkers):
                id = _read_short(chunk)
                pos = _read_long(chunk)
                name = _read_string(chunk)
                if pos or name:
                    # some files appear to have
                    # dummy markers consisting of
                    # a position 0 and name ''
                    self._markers.append((id, pos, name))
        except EOFError:
            print 'Warning: MARK chunk contains only',
            print len(self._markers),
            if len(self._markers) == 1: print 'marker',
            else: print 'markers',
            print 'instead of', nmarkers

class Aifc_write:
    # Variables used in this class:
    #
    # These variables are user settable through appropriate methods
    # of this class:
    # _file -- the open file with methods write(), close(), tell(), seek()
    #       set through the __init__() method
    # _comptype -- the AIFF-C compression type ('NONE' in AIFF)
    #       set through the setcomptype() or setparams() method
    # _compname -- the human-readable AIFF-C compression type
    #       set through the setcomptype() or setparams() method
    # _nchannels -- the number of audio channels
    #       set through the setnchannels() or setparams() method
    # _sampwidth -- the number of bytes per audio sample
    #       set through the setsampwidth() or setparams() method
    # _framerate -- the sampling frequency
    #       set through the setframerate() or setparams() method
    # _nframes -- the number of audio frames written to the header
    #       set through the setnframes() or setparams() method
    # _aifc -- whether we're writing an AIFF-C file or an AIFF file
    #       set through the aifc() method, reset through the
    #       aiff() method
    #
    # These variables are used internally only:
    # _version -- the AIFF-C version number
    # _comp -- the compressor from builtin module cl
    # _nframeswritten -- the number of audio frames actually written
    # _datalength -- the size of the audio samples written to the header
    # _datawritten -- the size of the audio samples actually written

    def __init__(self, f):
        if type(f) == type(''):
            filename = f
            f = __builtin__.open(f, 'wb')
        else:
            # else, assume it is an open file object already
            filename = '???'
        self.initfp(f)
        if filename[-5:] == '.aiff':
            self._aifc = 0
        else:
            self._aifc = 1

    def initfp(self, file):
        self._file = file
        self._version = _AIFC_version
        self._comptype = 'NONE'
        self._compname = 'not compressed'
        self._comp = None
        self._convert = None
        self._nchannels = 0
        self._sampwidth = 0
        self._framerate = 0
        self._nframes = 0
        self._nframeswritten = 0
        self._datawritten = 0
        self._datalength = 0
        self._markers = []
        self._marklength = 0
        self._aifc = 1      # AIFF-C is default

    def __del__(self):
        if self._file:
            self.close()

    #
    # User visible methods.
    #
    def aiff(self):
        if self._nframeswritten:
            raise Error, 'cannot change parameters after starting to write'
        self._aifc = 0

    def aifc(self):
        if self._nframeswritten:
            raise Error, 'cannot change parameters after starting to write'
        self._aifc = 1

    def setnchannels(self, nchannels):
        if self._nframeswritten:
            raise Error, 'cannot change parameters after starting to write'
        if nchannels < 1:
            raise Error, 'bad # of channels'
        self._nchannels = nchannels

    def getnchannels(self):
        if not self._nchannels:
            raise Error, 'number of channels not set'
        return self._nchannels

    def setsampwidth(self, sampwidth):
        if self._nframeswritten:
            raise Error, 'cannot change parameters after starting to write'
        if sampwidth < 1 or sampwidth > 4:
            raise Error, 'bad sample width'
        self._sampwidth = sampwidth

    def getsampwidth(self):
        if not self._sampwidth:
            raise Error, 'sample width not set'
        return self._sampwidth

    def setframerate(self, framerate):
        if self._nframeswritten:
            raise Error, 'cannot change parameters after starting to write'
        if framerate <= 0:
            raise Error, 'bad frame rate'
        self._framerate = framerate

    def getframerate(self):
        if not self._framerate:
            raise Error, 'frame rate not set'
        return self._framerate

    def setnframes(self, nframes):
        if self._nframeswritten:
            raise Error, 'cannot change parameters after starting to write'
        self._nframes = nframes

    def getnframes(self):
        return self._nframeswritten

    def setcomptype(self, comptype, compname):
        if self._nframeswritten:
            raise Error, 'cannot change parameters after starting to write'
        if comptype not in ('NONE', 'ULAW', 'ulaw', 'ALAW', 'alaw', 'G722'):
            raise Error, 'unsupported compression type'
        self._comptype = comptype
        self._compname = compname

    def getcomptype(self):
        return self._comptype

    def getcompname(self):
        return self._compname

##  def setversion(self, version):
##      if self._nframeswritten:
##          raise Error, 'cannot change parameters after starting to write'
##      self._version = version

    def setparams(self, info):
        nchannels, sampwidth, framerate, nframes, comptype, compname = info
        if self._nframeswritten:
            raise Error, 'cannot change parameters after starting to write'
        if comptype not in ('NONE', 'ULAW', 'ulaw', 'ALAW', 'alaw', 'G722'):
            raise Error, 'unsupported compression type'
        self.setnchannels(nchannels)
        self.setsampwidth(sampwidth)
        self.setframerate(framerate)
        self.setnframes(nframes)
        self.setcomptype(comptype, compname)

    def getparams(self):
        if not self._nchannels or not self._sampwidth or not self._framerate:
            raise Error, 'not all parameters set'
        return self._nchannels, self._sampwidth, self._framerate, \
              self._nframes, self._comptype, self._compname

    def setmark(self, id, pos, name):
        if id <= 0:
            raise Error, 'marker ID must be > 0'
        if pos < 0:
            raise Error, 'marker position must be >= 0'
        if type(name) != type(''):
            raise Error, 'marker name must be a string'
        for i in range(len(self._markers)):
            if id == self._markers[i][0]:
                self._markers[i] = id, pos, name
                return
        self._markers.append((id, pos, name))

    def getmark(self, id):
        for marker in self._markers:
            if id == marker[0]:
                return marker
        raise Error, 'marker %r does not exist' % (id,)

    def getmarkers(self):
        if len(self._markers) == 0:
            return None
        return self._markers

    def tell(self):
        return self._nframeswritten

    def writeframesraw(self, data):
        self._ensure_header_written(len(data))
        nframes = len(data) // (self._sampwidth * self._nchannels)
        if self._convert:
            data = self._convert(data)
        self._file.write(data)
        self._nframeswritten = self._nframeswritten + nframes
        self._datawritten = self._datawritten + len(data)

    def writeframes(self, data):
        self.writeframesraw(data)
        if self._nframeswritten != self._nframes or \
              self._datalength != self._datawritten:
            self._patchheader()

    def close(self):
        if self._file is None:
            return
        try:
            self._ensure_header_written(0)
            if self._datawritten & 1:
                # quick pad to even size
                self._file.write(chr(0))
                self._datawritten = self._datawritten + 1
            self._writemarkers()
            if self._nframeswritten != self._nframes or \
                  self._datalength != self._datawritten or \
                  self._marklength:
                self._patchheader()
            if self._comp:
                self._comp.CloseCompressor()
                self._comp = None
        finally:
            # Prevent ref cycles
            self._convert = None
            f = self._file
            self._file = None
            f.close()

    #
    # Internal methods.
    #

    def _comp_data(self, data):
        import cl
        dummy = self._comp.SetParam(cl.FRAME_BUFFER_SIZE, len(data))
        dummy = self._comp.SetParam(cl.COMPRESSED_BUFFER_SIZE, len(data))
        return self._comp.Compress(self._nframes, data)

    def _lin2ulaw(self, data):
        import audioop
        return audioop.lin2ulaw(data, 2)

    def _lin2adpcm(self, data):
        import audioop
        if not hasattr(self, '_adpcmstate'):
            self._adpcmstate = None
        data, self._adpcmstate = audioop.lin2adpcm(data, 2,
                               self._adpcmstate)
        return data

    def _ensure_header_written(self, datasize):
        if not self._nframeswritten:
            if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw'):
                if not self._sampwidth:
                    self._sampwidth = 2
                if self._sampwidth != 2:
                    raise Error, 'sample width must be 2 when compressing with ULAW or ALAW'
            if self._comptype == 'G722':
                if not self._sampwidth:
                    self._sampwidth = 2
                if self._sampwidth != 2:
                    raise Error, 'sample width must be 2 when compressing with G7.22 (ADPCM)'
            if not self._nchannels:
                raise Error, '# channels not specified'
            if not self._sampwidth:
                raise Error, 'sample width not specified'
            if not self._framerate:
                raise Error, 'sampling rate not specified'
            self._write_header(datasize)

    def _init_compression(self):
        if self._comptype == 'G722':
            self._convert = self._lin2adpcm
            return
        try:
            import cl
        except ImportError:
            if self._comptype in ('ULAW', 'ulaw'):
                try:
                    import audioop
                    self._convert = self._lin2ulaw
                    return
                except ImportError:
                    pass
            raise Error, 'cannot write compressed AIFF-C files'
        if self._comptype in ('ULAW', 'ulaw'):
            scheme = cl.G711_ULAW
        elif self._comptype in ('ALAW', 'alaw'):
            scheme = cl.G711_ALAW
        else:
            raise Error, 'unsupported compression type'
        self._comp = cl.OpenCompressor(scheme)
        params = [cl.ORIGINAL_FORMAT, 0,
              cl.BITS_PER_COMPONENT, self._sampwidth * 8,
              cl.FRAME_RATE, self._framerate,
              cl.FRAME_BUFFER_SIZE, 100,
              cl.COMPRESSED_BUFFER_SIZE, 100]
        if self._nchannels == 1:
            params[1] = cl.MONO
        elif self._nchannels == 2:
            params[1] = cl.STEREO_INTERLEAVED
        else:
            raise Error, 'cannot compress more than 2 channels'
        self._comp.SetParams(params)
        # the compressor produces a header which we ignore
        dummy = self._comp.Compress(0, '')
        self._convert = self._comp_data

    def _write_header(self, initlength):
        if self._aifc and self._comptype != 'NONE':
            self._init_compression()
        self._file.write('FORM')
        if not self._nframes:
            self._nframes = initlength // (self._nchannels * self._sampwidth)
        self._datalength = self._nframes * self._nchannels * self._sampwidth
        if self._datalength & 1:
            self._datalength = self._datalength + 1
        if self._aifc:
            if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw'):
                self._datalength = self._datalength // 2
                if self._datalength & 1:
                    self._datalength = self._datalength + 1
            elif self._comptype == 'G722':
                self._datalength = (self._datalength + 3) // 4
                if self._datalength & 1:
                    self._datalength = self._datalength + 1
        try:
            self._form_length_pos = self._file.tell()
        except (AttributeError, IOError):
            self._form_length_pos = None
        commlength = self._write_form_length(self._datalength)
        if self._aifc:
            self._file.write('AIFC')
            self._file.write('FVER')
            _write_ulong(self._file, 4)
            _write_ulong(self._file, self._version)
        else:
            self._file.write('AIFF')
        self._file.write('COMM')
        _write_ulong(self._file, commlength)
        _write_short(self._file, self._nchannels)
        if self._form_length_pos is not None:
            self._nframes_pos = self._file.tell()
        _write_ulong(self._file, self._nframes)
        if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw', 'G722'):
            _write_short(self._file, 8)
        else:
            _write_short(self._file, self._sampwidth * 8)
        _write_float(self._file, self._framerate)
        if self._aifc:
            self._file.write(self._comptype)
            _write_string(self._file, self._compname)
        self._file.write('SSND')
        if self._form_length_pos is not None:
            self._ssnd_length_pos = self._file.tell()
        _write_ulong(self._file, self._datalength + 8)
        _write_ulong(self._file, 0)
        _write_ulong(self._file, 0)

    def _write_form_length(self, datalength):
        if self._aifc:
            commlength = 18 + 5 + len(self._compname)
            if commlength & 1:
                commlength = commlength + 1
            verslength = 12
        else:
            commlength = 18
            verslength = 0
        _write_ulong(self._file, 4 + verslength + self._marklength + \
                     8 + commlength + 16 + datalength)
        return commlength

    def _patchheader(self):
        curpos = self._file.tell()
        if self._datawritten & 1:
            datalength = self._datawritten + 1
            self._file.write(chr(0))
        else:
            datalength = self._datawritten
        if datalength == self._datalength and \
              self._nframes == self._nframeswritten and \
              self._marklength == 0:
            self._file.seek(curpos, 0)
            return
        self._file.seek(self._form_length_pos, 0)
        dummy = self._write_form_length(datalength)
        self._file.seek(self._nframes_pos, 0)
        _write_ulong(self._file, self._nframeswritten)
        self._file.seek(self._ssnd_length_pos, 0)
        _write_ulong(self._file, datalength + 8)
        self._file.seek(curpos, 0)
        self._nframes = self._nframeswritten
        self._datalength = datalength

    def _writemarkers(self):
        if len(self._markers) == 0:
            return
        self._file.write('MARK')
        length = 2
        for marker in self._markers:
            id, pos, name = marker
            length = length + len(name) + 1 + 6
            if len(name) & 1 == 0:
                length = length + 1
        _write_ulong(self._file, length)
        self._marklength = length + 8
        _write_short(self._file, len(self._markers))
        for marker in self._markers:
            id, pos, name = marker
            _write_short(self._file, id)
            _write_ulong(self._file, pos)
            _write_string(self._file, name)

def open(f, mode=None):
    if mode is None:
        if hasattr(f, 'mode'):
            mode = f.mode
        else:
            mode = 'rb'
    if mode in ('r', 'rb'):
        return Aifc_read(f)
    elif mode in ('w', 'wb'):
        return Aifc_write(f)
    else:
        raise Error, "mode must be 'r', 'rb', 'w', or 'wb'"

openfp = open # B/W compatibility

if __name__ == '__main__':
    import sys
    if not sys.argv[1:]:
        sys.argv.append('/usr/demos/data/audio/bach.aiff')
    fn = sys.argv[1]
    f = open(fn, 'r')
    try:
        print "Reading", fn
        print "nchannels =", f.getnchannels()
        print "nframes   =", f.getnframes()
        print "sampwidth =", f.getsampwidth()
        print "framerate =", f.getframerate()
        print "comptype  =", f.getcomptype()
        print "compname  =", f.getcompname()
        if sys.argv[2:]:
            gn = sys.argv[2]
            print "Writing", gn
            g = open(gn, 'w')
            try:
                g.setparams(f.getparams())
                while 1:
                    data = f.readframes(1024)
                    if not data:
                        break
                    g.writeframes(data)
            finally:
                g.close()
            print "Done."
    finally:
        f.close()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   s   d  d l  Z  e  j d É d S(   iˇˇˇˇNs   http://xkcd.com/353/(   t
   webbrowsert   open(    (    (    s!   /usr/lib/python2.7/antigravity.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sa  d  Z  d d l Z d d l Z d d d g Z d e f d Ñ  É  YZ d Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z	 d Ñ  Z
 d Ñ  Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d l m Z d f  d Ñ  É  YZ d f  d Ñ  É  YZ e d Ñ Z e Z e d k r]d d l Z e j d r<e j j d É n  e j d Z e e d É Z  zÙ d Ge GHd  Ge  j! É  GHd! Ge  j" É  GHd" Ge  j# É  GHd# Ge  j$ É  GHd$ Ge  j% É  GHd% Ge  j& É  GHe j d& rKe j d& Z' d' Ge' GHe e' d( É Z( zE e( j) e  j* É  É x+ e  j+ d) É Z, e, r#Pn  e( j- e, É q	WWd e( j. É  Xd* GHn  Wd e  j. É  Xn  d S(+   sD  Stuff to parse AIFF-C and AIFF files.

Unless explicitly stated otherwise, the description below is true
both for AIFF-C files and AIFF files.

An AIFF-C file has the following structure.

  +-----------------+
  | FORM            |
  +-----------------+
  | <size>          |
  +----+------------+
  |    | AIFC       |
  |    +------------+
  |    | <chunks>   |
  |    |    .       |
  |    |    .       |
  |    |    .       |
  +----+------------+

An AIFF file has the string "AIFF" instead of "AIFC".

A chunk consists of an identifier (4 bytes) followed by a size (4 bytes,
big endian order), followed by the data.  The size field does not include
the size of the 8 byte header.

The following chunk types are recognized.

  FVER
      <version number of AIFF-C defining document> (AIFF-C only).
  MARK
      <# of markers> (2 bytes)
      list of markers:
          <marker ID> (2 bytes, must be > 0)
          <position> (4 bytes)
          <marker name> ("pstring")
  COMM
      <# of channels> (2 bytes)
      <# of sound frames> (4 bytes)
      <size of the samples> (2 bytes)
      <sampling frequency> (10 bytes, IEEE 80-bit extended
          floating point)
      in AIFF-C files only:
      <compression type> (4 bytes)
      <human-readable version of compression type> ("pstring")
  SSND
      <offset> (4 bytes, not used by this program)
      <blocksize> (4 bytes, not used by this program)
      <sound data>

A pstring consists of 1 byte length, a string of characters, and 0 or 1
byte pad to make the total length even.

Usage.

Reading AIFF files:
  f = aifc.open(file, 'r')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods read(), seek(), and close().
In some types of audio files, if the setpos() method is not used,
the seek() method is not necessary.

This returns an instance of a class with the following public methods:
  getnchannels()  -- returns number of audio channels (1 for
             mono, 2 for stereo)
  getsampwidth()  -- returns sample width in bytes
  getframerate()  -- returns sampling frequency
  getnframes()    -- returns number of audio frames
  getcomptype()   -- returns compression type ('NONE' for AIFF files)
  getcompname()   -- returns human-readable version of
             compression type ('not compressed' for AIFF files)
  getparams() -- returns a tuple consisting of all of the
             above in the above order
  getmarkers()    -- get the list of marks in the audio file or None
             if there are no marks
  getmark(id) -- get mark with the specified id (raises an error
             if the mark does not exist)
  readframes(n)   -- returns at most n frames of audio
  rewind()    -- rewind to the beginning of the audio stream
  setpos(pos) -- seek to the specified position
  tell()      -- return the current position
  close()     -- close the instance (make it unusable)
The position returned by tell(), the position given to setpos() and
the position of marks are all compatible and have nothing to do with
the actual position in the file.
The close() method is called automatically when the class instance
is destroyed.

Writing AIFF files:
  f = aifc.open(file, 'w')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods write(), tell(), seek(), and
close().

This returns an instance of a class with the following public methods:
  aiff()      -- create an AIFF file (AIFF-C default)
  aifc()      -- create an AIFF-C file
  setnchannels(n) -- set the number of channels
  setsampwidth(n) -- set the sample width
  setframerate(n) -- set the frame rate
  setnframes(n)   -- set the number of frames
  setcomptype(type, name)
          -- set the compression type and the
             human-readable compression type
  setparams(tuple)
          -- set all parameters at once
  setmark(id, pos, name)
          -- add specified mark to the list of marks
  tell()      -- return current position in output file (useful
             in combination with setmark())
  writeframesraw(data)
          -- write audio frames without pathing up the
             file header
  writeframes(data)
          -- write audio frames and patch up the file header
  close()     -- patch up the file header and close the
             output file
You should set the parameters before the first writeframesraw or
writeframes.  The total number of frames does not need to be set,
but when it is set to the correct value, the header does not have to
be patched up.
It is best to first set all parameters, perhaps possibly the
compression type, and then write audio frames using writeframesraw.
When all frames have been written, either call writeframes('') or
close() to patch up the sizes in the header.
Marks can be added anytime.  If there are any marks, you must call
close() after all frames have been written.
The close() method is called automatically when the class instance
is destroyed.

When a file is opened with the extension '.aiff', an AIFF file is
written, otherwise an AIFF-C file is written.  This default can be
changed by calling aiff() or aifc() before the first writeframes or
writeframesraw.
iˇˇˇˇNt   Errort   opent   openfpc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/aifc.pyR    é   s   l   @Q E c         C   sB   y! t  j d |  j d É É d SWn t  j k
 r= t Ç n Xd  S(   Ns   >li   i    (   t   structt   unpackt   readt   errort   EOFError(   t   file(    (    s   /usr/lib/python2.7/aifc.pyt
   _read_longì   s    !c         C   sB   y! t  j d |  j d É É d SWn t  j k
 r= t Ç n Xd  S(   Ns   >Li   i    (   R   R   R   R   R	   (   R
   (    (    s   /usr/lib/python2.7/aifc.pyt   _read_ulongô   s    !c         C   sB   y! t  j d |  j d É É d SWn t  j k
 r= t Ç n Xd  S(   Ns   >hi   i    (   R   R   R   R   R	   (   R
   (    (    s   /usr/lib/python2.7/aifc.pyt   _read_shortü   s    !c         C   sB   y! t  j d |  j d É É d SWn t  j k
 r= t Ç n Xd  S(   Ns   >Hi   i    (   R   R   R   R   R	   (   R
   (    (    s   /usr/lib/python2.7/aifc.pyt   _read_ushort•   s    !c         C   s_   t  |  j d É É } | d k r* d } n |  j | É } | d @d k r[ |  j d É } n  | S(   Ni   i    t    (   t   ordR   (   R
   t   lengtht   datat   dummy(    (    s   /usr/lib/python2.7/aifc.pyt   _read_string´   s    	g‚ˇˇˇˇˇÔc         C   sø   t  |  É } d } | d k  r1 d } | d } n  t |  É } t |  É } | | k ok | k ok d k n ry d }  n> | d k ré t }  n) | d } | d | t d	 | d
 É }  | |  S(   Ni   i    iˇˇˇˇi Ä  g        iˇ  iˇ?  l        g       @i?   (   R   R   t	   _HUGE_VALt   pow(   t   ft   expont   signt   himantt   lomant(    (    s   /usr/lib/python2.7/aifc.pyt   _read_float∑   s    '		
c         C   s   |  j  t j d | É É d  S(   Ns   >h(   t   writeR   t   pack(   R   t   x(    (    s   /usr/lib/python2.7/aifc.pyt   _write_short»   s    c         C   s   |  j  t j d | É É d  S(   Ns   >H(   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/aifc.pyt   _write_ushortÀ   s    c         C   s   |  j  t j d | É É d  S(   Ns   >l(   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/aifc.pyt   _write_longŒ   s    c         C   s   |  j  t j d | É É d  S(   Ns   >L(   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/aifc.pyt   _write_ulong—   s    c         C   s}   t  | É d k r! t d É Ç n  |  j t j d t  | É É É |  j | É t  | É d @d k ry |  j t d É É n  d  S(   Niˇ   s%   string exceeds maximum pstring lengtht   Bi   i    (   t   lent
   ValueErrorR   R   R   t   chr(   R   t   s(    (    s   /usr/lib/python2.7/aifc.pyt   _write_string‘   s    c   	      C   sh  d d  l  } | d k  r+ d } | d } n d } | d k rR d } d } d } nÎ | j | É \ } } | d k sã | d k sã | | k r§ | d B} d } d } nô | d } | d k  r’ | j | | É } d } n  | | B} | j | d É } | j | É } t | É } | j | | d É } | j | É } t | É } t |  | É t |  | É t |  | É d  S(	   Niˇˇˇˇi    i Ä  i @  i   iˇ  i˛?  i    (   t   matht   frexpt   ldexpt   floort   longR!   R#   (	   R   R   R*   R   R   R   R   t   fmantt   fsmant(    (    s   /usr/lib/python2.7/aifc.pyt   _write_float‹   s8    	$
	
	
(   t   Chunkt	   Aifc_readc           B   sŒ   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sU  d |  _  d  |  _ d  |  _ g  |  _ d |  _ | |  _ t | É } | j É  d k r` t	 d Ç n  | j
 d É } | d k rá d |  _ n! | d k rü d |  _ n	 t	 d Ç d |  _ x⁄ d |  _ y t |  j É } Wn t k
 r‰ Pn X| j É  } | d	 k r|  j | É d |  _ nj | d
 k rF| |  _ | j
 d É } d |  _ n: | d k rdt | É |  _  n | d k rÄ|  j | É n  | j É  q¥ W|  j s¢|  j rÆt	 d Ç n  |  j rQ|  j rQd d  l } | j d | j |  j d | j |  j g } |  j d k r| j | d <n( |  j d k r5| j | d <n	 t	 d Ç |  j j | É n  d  S(   Ni    t   FORMs    file does not start with FORM idi   t   AIFFt   AIFCi   s   not an AIFF or AIFF-C filet   COMMt   SSNDi   t   FVERt   MARKs$   COMM chunk and/or SSND chunk missingiˇˇˇˇi   s$   cannot compress more than 2 channels(   t   _versiont   Nonet   _decompt   _convertt   _markerst	   _soundpost   _fileR2   t   getnameR    R   t   _aifct   _comm_chunk_readt   _ssnd_seek_neededR	   t   _read_comm_chunkt   _ssnd_chunkR   t	   _readmarkt   skipt   clt   ORIGINAL_FORMATt   BITS_PER_COMPONENTt
   _sampwidtht
   FRAME_RATEt
   _frameratet
   _nchannelst   MONOt   STEREO_INTERLEAVEDt	   SetParams(   t   selfR
   t   chunkt   formdatat	   chunknameR   RJ   t   params(    (    s   /usr/lib/python2.7/aifc.pyt   initfp#  s`    												c         C   s>   t  | É t  d É k r- t j | d É } n  |  j | É d  S(   NR   t   rb(   t   typet   __builtin__R   RY   (   RT   R   (    (    s   /usr/lib/python2.7/aifc.pyt   __init__W  s    c         C   s   |  j  S(   N(   RA   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   getfp`  s    c         C   s   d |  _  d |  _ d  S(   Ni   i    (   RE   R@   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   rewindc  s    	c         C   s>   |  j  } z  | r( d  |  _  | j É  n  Wd  |  j j É  Xd  S(   N(   R=   R<   t   CloseDecompressorRA   t   close(   RT   t   decomp(    (    s   /usr/lib/python2.7/aifc.pyRa   g  s    		c         C   s   |  j  S(   N(   R@   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   tellp  s    c         C   s   |  j  S(   N(   RP   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   getnchannelss  s    c         C   s   |  j  S(   N(   t   _nframes(   RT   (    (    s   /usr/lib/python2.7/aifc.pyt
   getnframesv  s    c         C   s   |  j  S(   N(   RM   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   getsampwidthy  s    c         C   s   |  j  S(   N(   RO   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   getframerate|  s    c         C   s   |  j  S(   N(   t	   _comptype(   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   getcomptype  s    c         C   s   |  j  S(   N(   t	   _compname(   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   getcompnameÇ  s    c         C   s:   |  j  É  |  j É  |  j É  |  j É  |  j É  |  j É  f S(   N(   Rd   Rg   Rh   Rf   Rj   Rl   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt	   getparamsà  s    c         C   s    t  |  j É d k r d  S|  j S(   Ni    (   R%   R?   R<   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt
   getmarkersç  s    c         C   s<   x% |  j  D] } | | d k r
 | Sq
 Wt d | f Ç d  S(   Ni    s   marker %r does not exist(   R?   R    (   RT   t   idt   marker(    (    s   /usr/lib/python2.7/aifc.pyt   getmarkí  s    c         C   s=   | d k  s | |  j  k r' t d Ç n  | |  _ d |  _ d  S(   Ni    s   position not in rangei   (   Re   R    R@   RE   (   RT   t   pos(    (    s   /usr/lib/python2.7/aifc.pyt   setposò  s    	c         C   s÷   |  j  rd |  j j d É |  j j d É } |  j |  j } | rX |  j j | d É n  d |  _  n  | d k rt d S|  j j | |  j É } |  j rÆ | rÆ |  j | É } n  |  j t | É |  j |  j	 |  _ | S(   Ni    i   R   (
   RE   RG   t   seekR   R@   t
   _framesizeR>   R%   RP   RM   (   RT   t   nframesR   Rr   R   (    (    s   /usr/lib/python2.7/aifc.pyt
   readframesû  s    	$c         C   sN   d d  l  } |  j j | j t | É d É } |  j j t | É |  j | É S(   Niˇˇˇˇi   (   RJ   R=   t   SetParamt   FRAME_BUFFER_SIZER%   t
   DecompressRP   (   RT   R   RJ   R   (    (    s   /usr/lib/python2.7/aifc.pyt   _decomp_data≤  s
    c         C   s   d d  l  } | j | d É S(   Niˇˇˇˇi   (   t   audioopt   ulaw2lin(   RT   R   R|   (    (    s   /usr/lib/python2.7/aifc.pyt	   _ulaw2linπ  s    c         C   sL   d d  l  } t |  d É s' d  |  _ n  | j | d |  j É \ } |  _ | S(   Niˇˇˇˇt   _adpcmstatei   (   R|   t   hasattrR<   R   t	   adpcm2lin(   RT   R   R|   (    (    s   /usr/lib/python2.7/aifc.pyt
   _adpcm2linΩ  s    c         C   sp  t  | É |  _ t | É |  _ t  | É d d |  _ t t | É É |  _ |  j |  j |  _ |  j	 rZd } | j
 d k rí d } d GHd | _
 n  | j d É |  _ | rt | j j d É É } | d @d k rﬂ | d } n  | j
 | | _
 | j j d	 d É n  t | É |  _ |  j d
 k rl|  j d k rry d	 d  l } Wn t k
 rUqrX|  j |  _ d |  _ d  Sn  y d	 d  l } Wni t k
 rÌ|  j d k r·y) d	 d  l } |  j |  _ d |  _ d  SWq·t k
 r›q·Xn  t d Ç n X|  j d k r	| j } n$ |  j d k r$| j } n	 t d Ç | j | É |  _ |  j |  _ d |  _ qln d
 |  _ d |  _ d  S(   Ni   i   i    i   i   s   Warning: bad COMM chunk sizei   i   iˇˇˇˇt   NONEt   G722i   t   ULAWt   ulaws#   cannot read compressed AIFF-C filest   ALAWt   alaws   unsupported compression types   not compressed(   RÖ   RÜ   (   RÖ   RÜ   (   Rá   Rà   (   R   RP   R   Re   RM   t   intR   RO   Ru   RC   t	   chunksizeR   Ri   R   R
   Rt   R   Rk   R|   t   ImportErrorRÇ   R>   RJ   R~   R    t	   G711_ULAWt	   G711_ALAWt   OpenDecompressorR=   R{   (   RT   RU   t   kludgeR   R|   RJ   t   scheme(    (    s   /usr/lib/python2.7/aifc.pyRF   ∆  sd    					c         C   s≈   t  | É } yg x` t | É D]R } t  | É } t | É } t | É } | sR | r |  j j | | | f É q q WWnK t k
 r¿ d Gt |  j É Gt |  j É d k r∞ d Gn d Gd G| GHn Xd  S(   Ns!   Warning: MARK chunk contains onlyi   Rp   t   markerss
   instead of(   R   t   rangeR   R   R?   t   appendR	   R%   (   RT   RU   t   nmarkerst   iRo   Rr   t   name(    (    s   /usr/lib/python2.7/aifc.pyRH     s    $ (   R   R   RY   R]   R^   R_   Ra   Rc   Rd   Rf   Rg   Rh   Rj   Rl   Rm   Rn   Rq   Rs   Rw   R{   R~   RÇ   RF   RH   (    (    (    s   /usr/lib/python2.7/aifc.pyR3   ˇ   s,   $	4																							<t
   Aifc_writec           B   s:  e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d  Ñ  Z" d! Ñ  Z# RS("   c         C   so   t  | É t  d É k r3 | } t j | d É } n d } |  j | É | d d k rb d |  _ n	 d |  _ d  S(   NR   t   wbs   ???i˚ˇˇˇs   .aiffi    i   (   R[   R\   R   RY   RC   (   RT   R   t   filename(    (    s   /usr/lib/python2.7/aifc.pyR]   5  s    c         C   sî   | |  _  t |  _ d |  _ d |  _ d  |  _ d  |  _ d |  _ d |  _	 d |  _
 d |  _ d |  _ d |  _ d |  _ g  |  _ d |  _ d |  _ d  S(   NRÉ   s   not compressedi    i   (   RA   t   _AIFC_versionR;   Ri   Rk   R<   t   _compR>   RP   RM   RO   Re   t   _nframeswrittent   _datawrittent   _datalengthR?   t   _marklengthRC   (   RT   R
   (    (    s   /usr/lib/python2.7/aifc.pyRY   B  s     															c         C   s   |  j  r |  j É  n  d  S(   N(   RA   Ra   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   __del__T  s    	c         C   s"   |  j  r t d Ç n  d |  _ d  S(   Ns0   cannot change parameters after starting to writei    (   Rú   R    RC   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   aiff[  s    	c         C   s"   |  j  r t d Ç n  d |  _ d  S(   Ns0   cannot change parameters after starting to writei   (   Rú   R    RC   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyt   aifc`  s    	c         C   s:   |  j  r t d Ç n  | d k  r- t d Ç n  | |  _ d  S(   Ns0   cannot change parameters after starting to writei   s   bad # of channels(   Rú   R    RP   (   RT   t	   nchannels(    (    s   /usr/lib/python2.7/aifc.pyt   setnchannelse  s
    	c         C   s   |  j  s t d Ç n  |  j  S(   Ns   number of channels not set(   RP   R    (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRd   l  s    	c         C   sF   |  j  r t d Ç n  | d k  s- | d k r9 t d Ç n  | |  _ d  S(   Ns0   cannot change parameters after starting to writei   i   s   bad sample width(   Rú   R    RM   (   RT   t	   sampwidth(    (    s   /usr/lib/python2.7/aifc.pyt   setsampwidthq  s
    	c         C   s   |  j  s t d Ç n  |  j  S(   Ns   sample width not set(   RM   R    (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRg   x  s    	c         C   s:   |  j  r t d Ç n  | d k r- t d Ç n  | |  _ d  S(   Ns0   cannot change parameters after starting to writei    s   bad frame rate(   Rú   R    RO   (   RT   t	   framerate(    (    s   /usr/lib/python2.7/aifc.pyt   setframerate}  s
    	c         C   s   |  j  s t d Ç n  |  j  S(   Ns   frame rate not set(   RO   R    (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRh   Ñ  s    	c         C   s"   |  j  r t d Ç n  | |  _ d  S(   Ns0   cannot change parameters after starting to write(   Rú   R    Re   (   RT   Rv   (    (    s   /usr/lib/python2.7/aifc.pyt
   setnframesâ  s    	c         C   s   |  j  S(   N(   Rú   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRf   é  s    c         C   sC   |  j  r t d Ç n  | d	 k r- t d Ç n  | |  _ | |  _ d  S(
   Ns0   cannot change parameters after starting to writeRÉ   RÖ   RÜ   Rá   Rà   RÑ   s   unsupported compression type(   RÉ   RÖ   RÜ   Rá   Rà   RÑ   (   Rú   R    Ri   Rk   (   RT   t   comptypet   compname(    (    s   /usr/lib/python2.7/aifc.pyt   setcomptypeë  s    		c         C   s   |  j  S(   N(   Ri   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRj   ô  s    c         C   s   |  j  S(   N(   Rk   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRl   ú  s    c         C   sç   | \ } } } } } } |  j  r- t d Ç n  | d	 k rE t d Ç n  |  j | É |  j | É |  j | É |  j | É |  j | | É d  S(
   Ns0   cannot change parameters after starting to writeRÉ   RÖ   RÜ   Rá   Rà   RÑ   s   unsupported compression type(   RÉ   RÖ   RÜ   Rá   Rà   RÑ   (   Rú   R    R§   R¶   R®   R©   R¨   (   RT   t   infoR£   R•   Rß   Rv   R™   R´   (    (    s   /usr/lib/python2.7/aifc.pyt	   setparams§  s    	c         C   sR   |  j  s |  j s |  j r* t d Ç n  |  j  |  j |  j |  j |  j |  j f S(   Ns   not all parameters set(   RP   RM   RO   R    Re   Ri   Rk   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRm   ∞  s    c         C   s¬   | d k r t  d Ç n  | d k  r0 t  d Ç n  t | É t d É k rT t  d Ç n  xN t t |  j É É D]7 } | |  j | d k rj | | | f |  j | <d  Sqj W|  j j | | | f É d  S(   Ni    s   marker ID must be > 0s   marker position must be >= 0R   s   marker name must be a string(   R    R[   Rí   R%   R?   Rì   (   RT   Ro   Rr   Rñ   Rï   (    (    s   /usr/lib/python2.7/aifc.pyt   setmark∂  s    c         C   s<   x% |  j  D] } | | d k r
 | Sq
 Wt d | f Ç d  S(   Ni    s   marker %r does not exist(   R?   R    (   RT   Ro   Rp   (    (    s   /usr/lib/python2.7/aifc.pyRq   √  s    c         C   s    t  |  j É d k r d  S|  j S(   Ni    (   R%   R?   R<   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRn   …  s    c         C   s   |  j  S(   N(   Rú   (   RT   (    (    s   /usr/lib/python2.7/aifc.pyRc   Œ  s    c         C   sÇ   |  j  t | É É t | É |  j |  j } |  j rH |  j | É } n  |  j j | É |  j | |  _ |  j t | É |  _ d  S(   N(	   t   _ensure_header_writtenR%   RM   RP   R>   RA   R   Rú   Rù   (   RT   R   Rv   (    (    s   /usr/lib/python2.7/aifc.pyt   writeframesraw—  s    	c         C   sB   |  j  | É |  j |  j k s1 |  j |  j k r> |  j É  n  d  S(   N(   R±   Rú   Re   Rû   Rù   t   _patchheader(   RT   R   (    (    s   /usr/lib/python2.7/aifc.pyt   writeframes⁄  s    c         C   sÌ   |  j  d  k r d  Sz≠ |  j d É |  j d @rY |  j  j t d É É |  j d |  _ n  |  j É  |  j |  j k sê |  j	 |  j k sê |  j
 rù |  j É  n  |  j rø |  j j É  d  |  _ n  Wd  d  |  _ |  j  } d  |  _  | j É  Xd  S(   Ni    i   (   RA   R<   R∞   Rù   R   R'   t   _writemarkersRú   Re   Rû   Rü   R≤   Rõ   t   CloseCompressorR>   Ra   (   RT   R   (    (    s   /usr/lib/python2.7/aifc.pyRa   ‡  s&    
					c         C   s^   d d  l  } |  j j | j t | É É } |  j j | j t | É É } |  j j |  j | É S(   Niˇˇˇˇ(   RJ   Rõ   Rx   Ry   R%   t   COMPRESSED_BUFFER_SIZEt   CompressRe   (   RT   R   RJ   R   (    (    s   /usr/lib/python2.7/aifc.pyt
   _comp_data¸  s    c         C   s   d d  l  } | j | d É S(   Niˇˇˇˇi   (   R|   t   lin2ulaw(   RT   R   R|   (    (    s   /usr/lib/python2.7/aifc.pyt	   _lin2ulaw  s    c         C   sL   d d  l  } t |  d É s' d  |  _ n  | j | d |  j É \ } |  _ | S(   NiˇˇˇˇR   i   (   R|   RÄ   R<   R   t	   lin2adpcm(   RT   R   R|   (    (    s   /usr/lib/python2.7/aifc.pyt
   _lin2adpcm  s    c         C   s‡   |  j  s‹ |  j d k rK |  j s- d |  _ n  |  j d k rK t d Ç qK n  |  j d k rç |  j so d |  _ n  |  j d k rç t d Ç qç n  |  j s¢ t d	 Ç n  |  j s∑ t d
 Ç n  |  j sÃ t d Ç n  |  j | É n  d  S(   NRÖ   RÜ   Rá   Rà   i   s9   sample width must be 2 when compressing with ULAW or ALAWRÑ   s:   sample width must be 2 when compressing with G7.22 (ADPCM)s   # channels not specifieds   sample width not specifieds   sampling rate not specified(   RÖ   RÜ   Rá   Rà   (   Rú   Ri   RM   R    RP   RO   t   _write_header(   RT   t   datasize(    (    s   /usr/lib/python2.7/aifc.pyR∞     s$    						c      
   C   sú  |  j  d k r |  j |  _ d  Sy d d  l } Wn` t k
 rë |  j  d k rÖ y  d d  l } |  j |  _ d  SWqÖ t k
 rÅ qÖ Xn  t d Ç n X|  j  d k r≠ | j } n$ |  j  d k r» | j	 } n	 t d Ç | j
 | É |  _ | j d	 | j |  j d
 | j |  j | j d | j d g
 } |  j d k r?| j | d <n( |  j d k r^| j | d <n	 t d Ç |  j j | É |  j j d	 d É } |  j |  _ d  S(   NRÑ   iˇˇˇˇRÖ   RÜ   s$   cannot write compressed AIFF-C filesRá   Rà   s   unsupported compression typei    i   id   i   i   s$   cannot compress more than 2 channelsR   (   RÖ   RÜ   (   RÖ   RÜ   (   Rá   Rà   (   Ri   Rº   R>   RJ   Rã   R|   R∫   R    Rå   Rç   t   OpenCompressorRõ   RK   RL   RM   RN   RO   Ry   R∂   RP   RQ   RR   RS   R∑   R∏   (   RT   RJ   R|   Rê   RX   R   (    (    s   /usr/lib/python2.7/aifc.pyt   _init_compression"  sB    				c         C   s'  |  j  r% |  j d k r% |  j É  n  |  j j d É |  j sX | |  j |  j |  _ n  |  j |  j |  j |  _ |  j d @rí |  j d |  _ n  |  j  r&|  j d k r› |  j d |  _ |  j d @r#|  j d |  _ q#q&|  j d	 k r&|  j d
 d |  _ |  j d @r#|  j d |  _ q#q&n  y |  j j	 É  |  _
 Wn  t t f k
 r^d  |  _
 n X|  j |  j É } |  j  r¿|  j j d É |  j j d É t |  j d É t |  j |  j É n |  j j d É |  j j d É t |  j | É t |  j |  j É |  j
 d  k	 r'|  j j	 É  |  _ n  t |  j |  j É |  j d k r\t |  j d É n t |  j |  j d É t |  j |  j É |  j  r∏|  j j |  j É t |  j |  j É n  |  j j d É |  j
 d  k	 rÏ|  j j	 É  |  _ n  t |  j |  j d É t |  j d É t |  j d É d  S(   NRÉ   R4   i   RÖ   RÜ   Rá   Rà   i   RÑ   i   i   R6   R9   R5   R7   i   R8   i    (   RÖ   RÜ   Rá   Rà   (   RÖ   RÜ   Rá   Rà   RÑ   (   RC   Ri   R¿   RA   R   Re   RP   RM   Rû   Rc   t   _form_length_post   AttributeErrort   IOErrorR<   t   _write_form_lengthR#   R;   R    t   _nframes_posR1   RO   R)   Rk   t   _ssnd_length_pos(   RT   t
   initlengtht
   commlength(    (    s   /usr/lib/python2.7/aifc.pyRΩ   H  s^    				c         C   sw   |  j  r< d	 t |  j É } | d @r3 | d } n  d } n d } d } t |  j d | |  j d | d | É | S(
   Ni   i   i   i   i    i   i   i   i   (   RC   R%   Rk   R#   RA   Rü   (   RT   t
   datalengthR»   t
   verslength(    (    s   /usr/lib/python2.7/aifc.pyRƒ   {  s    	
		"c         C   s6  |  j  j É  } |  j d @rB |  j d } |  j  j t d É É n	 |  j } | |  j k rí |  j |  j k rí |  j d k rí |  j  j	 | d É d  S|  j  j	 |  j
 d É |  j | É } |  j  j	 |  j d É t |  j  |  j É |  j  j	 |  j d É t |  j  | d É |  j  j	 | d É |  j |  _ | |  _ d  S(   Ni   i    i   (   RA   Rc   Rù   R   R'   Rû   Re   Rú   Rü   Rt   R¡   Rƒ   R≈   R#   R∆   (   RT   t   curposR…   R   (    (    s   /usr/lib/python2.7/aifc.pyR≤   à  s&    	c         C   s  t  |  j É d k r d  S|  j j d É d } x[ |  j D]P } | \ } } } | t  | É d d } t  | É d @d k r9 | d } q9 q9 Wt |  j | É | d |  _ t |  j t  |  j É É xP |  j D]E } | \ } } } t |  j | É t |  j | É t |  j | É qÕ Wd  S(   Ni    R:   i   i   i   i   (   R%   R?   RA   R   R#   Rü   R    R)   (   RT   R   Rp   Ro   Rr   Rñ   (    (    s   /usr/lib/python2.7/aifc.pyR¥   û  s"    ($   R   R   R]   RY   R†   R°   R¢   R§   Rd   R¶   Rg   R®   Rh   R©   Rf   R¨   Rj   Rl   RÆ   Rm   RØ   Rq   Rn   Rc   R±   R≥   Ra   R∏   R∫   Rº   R∞   R¿   RΩ   Rƒ   R≤   R¥   (    (    (    s   /usr/lib/python2.7/aifc.pyRó     sD   																															&	3		c         C   si   | d  k r0 t |  d É r' |  j } q0 d } n  | d k rF t |  É S| d k r\ t |  É St d Ç d  S(	   Nt   modeRZ   t   rt   wRò   s$   mode must be 'r', 'rb', 'w', or 'wb'(   RÕ   RZ   (   RŒ   Rò   (   R<   RÄ   RÃ   R3   Ró   R    (   R   RÃ   (    (    s   /usr/lib/python2.7/aifc.pyR   ±  s    	

t   __main__i   s   /usr/demos/data/audio/bach.aiffRÕ   t   Readings   nchannels =s   nframes   =s   sampwidth =s   framerate =s   comptype  =s   compname  =i   t   WritingRŒ   i   s   Done.(/   t   __doc__R   R\   t   __all__t	   ExceptionR    Rö   R   R   R   R   R   R   R   R    R!   R"   R#   R)   R1   RU   R2   R3   Ró   R<   R   R   R   t   syst   argvRì   t   fnR   Rd   Rf   Rg   Rh   Rj   Rl   t   gnt   gRÆ   Rm   Rw   R   R≥   Ra   (    (    (    s   /usr/lib/python2.7/aifc.pyt   <module>á   sj   					
							!ˇ ˇ õ		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """Generic interface to all dbm clones.

Instead of

        import dbm
        d = dbm.open(file, 'w', 0666)

use

        import anydbm
        d = anydbm.open(file, 'w')

The returned object is a dbhash, gdbm, dbm or dumbdbm object,
dependent on the type of database being opened (determined by whichdb
module) in the case of an existing dbm. If the dbm does not exist and
the create or new flag ('c' or 'n') was specified, the dbm type will
be determined by the availability of the modules (tested in the above
order).

It has the following interface (key and data are strings):

        d[key] = data   # store data at key (may override data at
                        # existing key)
        data = d[key]   # retrieve data at key (raise KeyError if no
                        # such key)
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = key in d   # true if the key exists
        list = d.keys() # return a list of all existing keys (slow!)

Future versions may change the order in which implementations are
tested for existence, and add interfaces to other dbm-like
implementations.
"""

class error(Exception):
    pass

_names = ['dbhash', 'gdbm', 'dbm', 'dumbdbm']
_errors = [error]
_defaultmod = None

for _name in _names:
    try:
        _mod = __import__(_name)
    except ImportError:
        continue
    if not _defaultmod:
        _defaultmod = _mod
    _errors.append(_mod.error)

if not _defaultmod:
    raise ImportError, "no dbm clone found; tried %s" % _names

error = tuple(_errors)

def open(file, flag='r', mode=0666):
    """Open or create database at path given by *file*.

    Optional argument *flag* can be 'r' (default) for read-only access, 'w'
    for read-write access of an existing database, 'c' for read-write access
    to a new or existing database, and 'n' for read-write access to a new
    database.

    Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it
    only if it doesn't exist; and 'n' always creates a new database.
    """

    # guess the type of an existing database
    from whichdb import whichdb
    result=whichdb(file)
    if result is None:
        # db doesn't exist
        if 'c' in flag or 'n' in flag:
            # file doesn't exist and the new
            # flag was used so use default type
            mod = _defaultmod
        else:
            raise error, "need 'c' or 'n' flag to open new db"
    elif result == "":
        # db type cannot be determined
        raise error, "db type could not be determined"
    else:
        mod = __import__(result)
    return mod.open(file, flag, mode)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   s…   d  Z  d e f d Ñ  É  YZ d d d d g Z e g Z d Z xT e D]L Z y e e É Z	 Wn e
 k
 rp qD n Xe sÄ e	 Z n  e j e	 j É qD We s™ e
 d e Ç n  e e É Z d d	 d
 Ñ Z d S(   sé  Generic interface to all dbm clones.

Instead of

        import dbm
        d = dbm.open(file, 'w', 0666)

use

        import anydbm
        d = anydbm.open(file, 'w')

The returned object is a dbhash, gdbm, dbm or dumbdbm object,
dependent on the type of database being opened (determined by whichdb
module) in the case of an existing dbm. If the dbm does not exist and
the create or new flag ('c' or 'n') was specified, the dbm type will
be determined by the availability of the modules (tested in the above
order).

It has the following interface (key and data are strings):

        d[key] = data   # store data at key (may override data at
                        # existing key)
        data = d[key]   # retrieve data at key (raise KeyError if no
                        # such key)
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = key in d   # true if the key exists
        list = d.keys() # return a list of all existing keys (slow!)

Future versions may change the order in which implementations are
tested for existence, and add interfaces to other dbm-like
implementations.
t   errorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/anydbm.pyR    $   s   t   dbhasht   gdbmt   dbmt   dumbdbms   no dbm clone found; tried %st   ri∂  c         C   så   d d l  m  } | |  É } | d k rU d | k s@ d | k rI t } qy t d Ç n$ | d k rm t d Ç n t | É } | j |  | | É S(	   s∂  Open or create database at path given by *file*.

    Optional argument *flag* can be 'r' (default) for read-only access, 'w'
    for read-write access of an existing database, 'c' for read-write access
    to a new or existing database, and 'n' for read-write access to a new
    database.

    Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it
    only if it doesn't exist; and 'n' always creates a new database.
    iˇˇˇˇ(   t   whichdbt   ct   ns#   need 'c' or 'n' flag to open new dbt    s   db type could not be determinedN(   R   t   Nonet   _defaultmodR    t
   __import__t   open(   t   filet   flagt   modeR   t   resultt   mod(    (    s   /usr/lib/python2.7/anydbm.pyR   9   s    	N(   t   __doc__t	   ExceptionR    t   _namest   _errorsR   R   t   _nameR   t   _modt   ImportErrort   appendt   tupleR   (    (    (    s   /usr/lib/python2.7/anydbm.pyt   <module>"   s    		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Metadata-Version: 1.0
Name: argparse
Version: 1.2.1
Summary: Python command-line parsing library
Author: Steven Bethard
Author-email: steven.bethard@gmail.com
License: Python Software Foundation License
Platform: any
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Author: Steven J. Bethard <steven.bethard@gmail.com>.

"""Command-line parsing library

This module is an optparse-inspired command-line parsing library that:

    - handles both optional and positional arguments
    - produces highly informative usage messages
    - supports parsers that dispatch to sub-parsers

The following is a simple usage example that sums integers from the
command-line and writes the result to a file::

    parser = argparse.ArgumentParser(
        description='sum the integers at the command line')
    parser.add_argument(
        'integers', metavar='int', nargs='+', type=int,
        help='an integer to be summed')
    parser.add_argument(
        '--log', default=sys.stdout, type=argparse.FileType('w'),
        help='the file where the sum should be written')
    args = parser.parse_args()
    args.log.write('%s' % sum(args.integers))
    args.log.close()

The module contains the following public classes:

    - ArgumentParser -- The main entry point for command-line parsing. As the
        example above shows, the add_argument() method is used to populate
        the parser with actions for optional and positional arguments. Then
        the parse_args() method is invoked to convert the args at the
        command-line into an object with attributes.

    - ArgumentError -- The exception raised by ArgumentParser objects when
        there are errors with the parser's actions. Errors raised while
        parsing the command-line are caught by ArgumentParser and emitted
        as command-line messages.

    - FileType -- A factory for defining types of files to be created. As the
        example above shows, instances of FileType are typically passed as
        the type= argument of add_argument() calls.

    - Action -- The base class for parser actions. Typically actions are
        selected by passing strings like 'store_true' or 'append_const' to
        the action= argument of add_argument(). However, for greater
        customization of ArgumentParser actions, subclasses of Action may
        be defined and passed as the action= argument.

    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
        ArgumentDefaultsHelpFormatter -- Formatter classes which
        may be passed as the formatter_class= argument to the
        ArgumentParser constructor. HelpFormatter is the default,
        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
        not to change the formatting for help text, and
        ArgumentDefaultsHelpFormatter adds information about argument defaults
        to the help.

All other classes in this module are considered implementation details.
(Also note that HelpFormatter and RawDescriptionHelpFormatter are only
considered public as object names -- the API of the formatter objects is
still considered an implementation detail.)
"""

__version__ = '1.1'
__all__ = [
    'ArgumentParser',
    'ArgumentError',
    'ArgumentTypeError',
    'FileType',
    'HelpFormatter',
    'ArgumentDefaultsHelpFormatter',
    'RawDescriptionHelpFormatter',
    'RawTextHelpFormatter',
    'Namespace',
    'Action',
    'ONE_OR_MORE',
    'OPTIONAL',
    'PARSER',
    'REMAINDER',
    'SUPPRESS',
    'ZERO_OR_MORE',
]


import collections as _collections
import copy as _copy
import os as _os
import re as _re
import sys as _sys
import textwrap as _textwrap

from gettext import gettext as _


def _callable(obj):
    return hasattr(obj, '__call__') or hasattr(obj, '__bases__')


SUPPRESS = '==SUPPRESS=='

OPTIONAL = '?'
ZERO_OR_MORE = '*'
ONE_OR_MORE = '+'
PARSER = 'A...'
REMAINDER = '...'
_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'

# =============================
# Utility functions and classes
# =============================

class _AttributeHolder(object):
    """Abstract base class that provides __repr__.

    The __repr__ method returns a string in the format::
        ClassName(attr=name, attr=name, ...)
    The attributes are determined either by a class-level attribute,
    '_kwarg_names', or by inspecting the instance __dict__.
    """

    def __repr__(self):
        type_name = type(self).__name__
        arg_strings = []
        for arg in self._get_args():
            arg_strings.append(repr(arg))
        for name, value in self._get_kwargs():
            arg_strings.append('%s=%r' % (name, value))
        return '%s(%s)' % (type_name, ', '.join(arg_strings))

    def _get_kwargs(self):
        return sorted(self.__dict__.items())

    def _get_args(self):
        return []


def _ensure_value(namespace, name, value):
    if getattr(namespace, name, None) is None:
        setattr(namespace, name, value)
    return getattr(namespace, name)


# ===============
# Formatting Help
# ===============

class HelpFormatter(object):
    """Formatter for generating usage messages and argument help strings.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def __init__(self,
                 prog,
                 indent_increment=2,
                 max_help_position=24,
                 width=None):

        # default setting for width
        if width is None:
            try:
                width = int(_os.environ['COLUMNS'])
            except (KeyError, ValueError):
                width = 80
            width -= 2

        self._prog = prog
        self._indent_increment = indent_increment
        self._max_help_position = max_help_position
        self._max_help_position = min(max_help_position,
                                      max(width - 20, indent_increment * 2))
        self._width = width

        self._current_indent = 0
        self._level = 0
        self._action_max_length = 0

        self._root_section = self._Section(self, None)
        self._current_section = self._root_section

        self._whitespace_matcher = _re.compile(r'\s+')
        self._long_break_matcher = _re.compile(r'\n\n\n+')

    # ===============================
    # Section and indentation methods
    # ===============================
    def _indent(self):
        self._current_indent += self._indent_increment
        self._level += 1

    def _dedent(self):
        self._current_indent -= self._indent_increment
        assert self._current_indent >= 0, 'Indent decreased below 0.'
        self._level -= 1

    class _Section(object):

        def __init__(self, formatter, parent, heading=None):
            self.formatter = formatter
            self.parent = parent
            self.heading = heading
            self.items = []

        def format_help(self):
            # format the indented section
            if self.parent is not None:
                self.formatter._indent()
            join = self.formatter._join_parts
            for func, args in self.items:
                func(*args)
            item_help = join([func(*args) for func, args in self.items])
            if self.parent is not None:
                self.formatter._dedent()

            # return nothing if the section was empty
            if not item_help:
                return ''

            # add the heading if the section was non-empty
            if self.heading is not SUPPRESS and self.heading is not None:
                current_indent = self.formatter._current_indent
                heading = '%*s%s:\n' % (current_indent, '', self.heading)
            else:
                heading = ''

            # join the section-initial newline, the heading and the help
            return join(['\n', heading, item_help, '\n'])

    def _add_item(self, func, args):
        self._current_section.items.append((func, args))

    # ========================
    # Message building methods
    # ========================
    def start_section(self, heading):
        self._indent()
        section = self._Section(self, self._current_section, heading)
        self._add_item(section.format_help, [])
        self._current_section = section

    def end_section(self):
        self._current_section = self._current_section.parent
        self._dedent()

    def add_text(self, text):
        if text is not SUPPRESS and text is not None:
            self._add_item(self._format_text, [text])

    def add_usage(self, usage, actions, groups, prefix=None):
        if usage is not SUPPRESS:
            args = usage, actions, groups, prefix
            self._add_item(self._format_usage, args)

    def add_argument(self, action):
        if action.help is not SUPPRESS:

            # find all invocations
            get_invocation = self._format_action_invocation
            invocations = [get_invocation(action)]
            for subaction in self._iter_indented_subactions(action):
                invocations.append(get_invocation(subaction))

            # update the maximum item length
            invocation_length = max([len(s) for s in invocations])
            action_length = invocation_length + self._current_indent
            self._action_max_length = max(self._action_max_length,
                                          action_length)

            # add the item to the list
            self._add_item(self._format_action, [action])

    def add_arguments(self, actions):
        for action in actions:
            self.add_argument(action)

    # =======================
    # Help-formatting methods
    # =======================
    def format_help(self):
        help = self._root_section.format_help()
        if help:
            help = self._long_break_matcher.sub('\n\n', help)
            help = help.strip('\n') + '\n'
        return help

    def _join_parts(self, part_strings):
        return ''.join([part
                        for part in part_strings
                        if part and part is not SUPPRESS])

    def _format_usage(self, usage, actions, groups, prefix):
        if prefix is None:
            prefix = _('usage: ')

        # if usage is specified, use that
        if usage is not None:
            usage = usage % dict(prog=self._prog)

        # if no optionals or positionals are available, usage is just prog
        elif usage is None and not actions:
            usage = '%(prog)s' % dict(prog=self._prog)

        # if optionals and positionals are available, calculate usage
        elif usage is None:
            prog = '%(prog)s' % dict(prog=self._prog)

            # split optionals from positionals
            optionals = []
            positionals = []
            for action in actions:
                if action.option_strings:
                    optionals.append(action)
                else:
                    positionals.append(action)

            # build full usage string
            format = self._format_actions_usage
            action_usage = format(optionals + positionals, groups)
            usage = ' '.join([s for s in [prog, action_usage] if s])

            # wrap the usage parts if it's too long
            text_width = self._width - self._current_indent
            if len(prefix) + len(usage) > text_width:

                # break usage into wrappable parts
                part_regexp = r'\(.*?\)+|\[.*?\]+|\S+'
                opt_usage = format(optionals, groups)
                pos_usage = format(positionals, groups)
                opt_parts = _re.findall(part_regexp, opt_usage)
                pos_parts = _re.findall(part_regexp, pos_usage)
                assert ' '.join(opt_parts) == opt_usage
                assert ' '.join(pos_parts) == pos_usage

                # helper for wrapping lines
                def get_lines(parts, indent, prefix=None):
                    lines = []
                    line = []
                    if prefix is not None:
                        line_len = len(prefix) - 1
                    else:
                        line_len = len(indent) - 1
                    for part in parts:
                        if line_len + 1 + len(part) > text_width and line:
                            lines.append(indent + ' '.join(line))
                            line = []
                            line_len = len(indent) - 1
                        line.append(part)
                        line_len += len(part) + 1
                    if line:
                        lines.append(indent + ' '.join(line))
                    if prefix is not None:
                        lines[0] = lines[0][len(indent):]
                    return lines

                # if prog is short, follow it with optionals or positionals
                if len(prefix) + len(prog) <= 0.75 * text_width:
                    indent = ' ' * (len(prefix) + len(prog) + 1)
                    if opt_parts:
                        lines = get_lines([prog] + opt_parts, indent, prefix)
                        lines.extend(get_lines(pos_parts, indent))
                    elif pos_parts:
                        lines = get_lines([prog] + pos_parts, indent, prefix)
                    else:
                        lines = [prog]

                # if prog is long, put it on its own line
                else:
                    indent = ' ' * len(prefix)
                    parts = opt_parts + pos_parts
                    lines = get_lines(parts, indent)
                    if len(lines) > 1:
                        lines = []
                        lines.extend(get_lines(opt_parts, indent))
                        lines.extend(get_lines(pos_parts, indent))
                    lines = [prog] + lines

                # join lines into usage
                usage = '\n'.join(lines)

        # prefix with 'usage:'
        return '%s%s\n\n' % (prefix, usage)

    def _format_actions_usage(self, actions, groups):
        # find group indices and identify actions in groups
        group_actions = set()
        inserts = {}
        for group in groups:
            try:
                start = actions.index(group._group_actions[0])
            except ValueError:
                continue
            else:
                end = start + len(group._group_actions)
                if actions[start:end] == group._group_actions:
                    for action in group._group_actions:
                        group_actions.add(action)
                    if not group.required:
                        if start in inserts:
                            inserts[start] += ' ['
                        else:
                            inserts[start] = '['
                        inserts[end] = ']'
                    else:
                        if start in inserts:
                            inserts[start] += ' ('
                        else:
                            inserts[start] = '('
                        inserts[end] = ')'
                    for i in range(start + 1, end):
                        inserts[i] = '|'

        # collect all actions format strings
        parts = []
        for i, action in enumerate(actions):

            # suppressed arguments are marked with None
            # remove | separators for suppressed arguments
            if action.help is SUPPRESS:
                parts.append(None)
                if inserts.get(i) == '|':
                    inserts.pop(i)
                elif inserts.get(i + 1) == '|':
                    inserts.pop(i + 1)

            # produce all arg strings
            elif not action.option_strings:
                part = self._format_args(action, action.dest)

                # if it's in a group, strip the outer []
                if action in group_actions:
                    if part[0] == '[' and part[-1] == ']':
                        part = part[1:-1]

                # add the action string to the list
                parts.append(part)

            # produce the first way to invoke the option in brackets
            else:
                option_string = action.option_strings[0]

                # if the Optional doesn't take a value, format is:
                #    -s or --long
                if action.nargs == 0:
                    part = '%s' % option_string

                # if the Optional takes a value, format is:
                #    -s ARGS or --long ARGS
                else:
                    default = action.dest.upper()
                    args_string = self._format_args(action, default)
                    part = '%s %s' % (option_string, args_string)

                # make it look optional if it's not required or in a group
                if not action.required and action not in group_actions:
                    part = '[%s]' % part

                # add the action string to the list
                parts.append(part)

        # insert things at the necessary indices
        for i in sorted(inserts, reverse=True):
            parts[i:i] = [inserts[i]]

        # join all the action items with spaces
        text = ' '.join([item for item in parts if item is not None])

        # clean up separators for mutually exclusive groups
        open = r'[\[(]'
        close = r'[\])]'
        text = _re.sub(r'(%s) ' % open, r'\1', text)
        text = _re.sub(r' (%s)' % close, r'\1', text)
        text = _re.sub(r'%s *%s' % (open, close), r'', text)
        text = _re.sub(r'\(([^|]*)\)', r'\1', text)
        text = text.strip()

        # return the text
        return text

    def _format_text(self, text):
        if '%(prog)' in text:
            text = text % dict(prog=self._prog)
        text_width = max(self._width - self._current_indent, 11)
        indent = ' ' * self._current_indent
        return self._fill_text(text, text_width, indent) + '\n\n'

    def _format_action(self, action):
        # determine the required width and the entry label
        help_position = min(self._action_max_length + 2,
                            self._max_help_position)
        help_width = max(self._width - help_position, 11)
        action_width = help_position - self._current_indent - 2
        action_header = self._format_action_invocation(action)

        # ho nelp; start on same line and add a final newline
        if not action.help:
            tup = self._current_indent, '', action_header
            action_header = '%*s%s\n' % tup

        # short action name; start on the same line and pad two spaces
        elif len(action_header) <= action_width:
            tup = self._current_indent, '', action_width, action_header
            action_header = '%*s%-*s  ' % tup
            indent_first = 0

        # long action name; start on the next line
        else:
            tup = self._current_indent, '', action_header
            action_header = '%*s%s\n' % tup
            indent_first = help_position

        # collect the pieces of the action help
        parts = [action_header]

        # if there was help for the action, add lines of help text
        if action.help:
            help_text = self._expand_help(action)
            help_lines = self._split_lines(help_text, help_width)
            parts.append('%*s%s\n' % (indent_first, '', help_lines[0]))
            for line in help_lines[1:]:
                parts.append('%*s%s\n' % (help_position, '', line))

        # or add a newline if the description doesn't end with one
        elif not action_header.endswith('\n'):
            parts.append('\n')

        # if there are any sub-actions, add their help as well
        for subaction in self._iter_indented_subactions(action):
            parts.append(self._format_action(subaction))

        # return a single string
        return self._join_parts(parts)

    def _format_action_invocation(self, action):
        if not action.option_strings:
            metavar, = self._metavar_formatter(action, action.dest)(1)
            return metavar

        else:
            parts = []

            # if the Optional doesn't take a value, format is:
            #    -s, --long
            if action.nargs == 0:
                parts.extend(action.option_strings)

            # if the Optional takes a value, format is:
            #    -s ARGS, --long ARGS
            else:
                default = action.dest.upper()
                args_string = self._format_args(action, default)
                for option_string in action.option_strings:
                    parts.append('%s %s' % (option_string, args_string))

            return ', '.join(parts)

    def _metavar_formatter(self, action, default_metavar):
        if action.metavar is not None:
            result = action.metavar
        elif action.choices is not None:
            choice_strs = [str(choice) for choice in action.choices]
            result = '{%s}' % ','.join(choice_strs)
        else:
            result = default_metavar

        def format(tuple_size):
            if isinstance(result, tuple):
                return result
            else:
                return (result, ) * tuple_size
        return format

    def _format_args(self, action, default_metavar):
        get_metavar = self._metavar_formatter(action, default_metavar)
        if action.nargs is None:
            result = '%s' % get_metavar(1)
        elif action.nargs == OPTIONAL:
            result = '[%s]' % get_metavar(1)
        elif action.nargs == ZERO_OR_MORE:
            result = '[%s [%s ...]]' % get_metavar(2)
        elif action.nargs == ONE_OR_MORE:
            result = '%s [%s ...]' % get_metavar(2)
        elif action.nargs == REMAINDER:
            result = '...'
        elif action.nargs == PARSER:
            result = '%s ...' % get_metavar(1)
        else:
            formats = ['%s' for _ in range(action.nargs)]
            result = ' '.join(formats) % get_metavar(action.nargs)
        return result

    def _expand_help(self, action):
        params = dict(vars(action), prog=self._prog)
        for name in list(params):
            if params[name] is SUPPRESS:
                del params[name]
        for name in list(params):
            if hasattr(params[name], '__name__'):
                params[name] = params[name].__name__
        if params.get('choices') is not None:
            choices_str = ', '.join([str(c) for c in params['choices']])
            params['choices'] = choices_str
        return self._get_help_string(action) % params

    def _iter_indented_subactions(self, action):
        try:
            get_subactions = action._get_subactions
        except AttributeError:
            pass
        else:
            self._indent()
            for subaction in get_subactions():
                yield subaction
            self._dedent()

    def _split_lines(self, text, width):
        text = self._whitespace_matcher.sub(' ', text).strip()
        return _textwrap.wrap(text, width)

    def _fill_text(self, text, width, indent):
        text = self._whitespace_matcher.sub(' ', text).strip()
        return _textwrap.fill(text, width, initial_indent=indent,
                                           subsequent_indent=indent)

    def _get_help_string(self, action):
        return action.help


class RawDescriptionHelpFormatter(HelpFormatter):
    """Help message formatter which retains any formatting in descriptions.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _fill_text(self, text, width, indent):
        return ''.join([indent + line for line in text.splitlines(True)])


class RawTextHelpFormatter(RawDescriptionHelpFormatter):
    """Help message formatter which retains formatting of all help text.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _split_lines(self, text, width):
        return text.splitlines()


class ArgumentDefaultsHelpFormatter(HelpFormatter):
    """Help message formatter which adds default values to argument help.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _get_help_string(self, action):
        help = action.help
        if '%(default)' not in action.help:
            if action.default is not SUPPRESS:
                defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]
                if action.option_strings or action.nargs in defaulting_nargs:
                    help += ' (default: %(default)s)'
        return help


# =====================
# Options and Arguments
# =====================

def _get_action_name(argument):
    if argument is None:
        return None
    elif argument.option_strings:
        return  '/'.join(argument.option_strings)
    elif argument.metavar not in (None, SUPPRESS):
        return argument.metavar
    elif argument.dest not in (None, SUPPRESS):
        return argument.dest
    else:
        return None


class ArgumentError(Exception):
    """An error from creating or using an argument (optional or positional).

    The string value of this exception is the message, augmented with
    information about the argument that caused it.
    """

    def __init__(self, argument, message):
        self.argument_name = _get_action_name(argument)
        self.message = message

    def __str__(self):
        if self.argument_name is None:
            format = '%(message)s'
        else:
            format = 'argument %(argument_name)s: %(message)s'
        return format % dict(message=self.message,
                             argument_name=self.argument_name)


class ArgumentTypeError(Exception):
    """An error from trying to convert a command line string to a type."""
    pass


# ==============
# Action classes
# ==============

class Action(_AttributeHolder):
    """Information about how to convert command line strings to Python objects.

    Action objects are used by an ArgumentParser to represent the information
    needed to parse a single argument from one or more strings from the
    command line. The keyword arguments to the Action constructor are also
    all attributes of Action instances.

    Keyword Arguments:

        - option_strings -- A list of command-line option strings which
            should be associated with this action.

        - dest -- The name of the attribute to hold the created object(s)

        - nargs -- The number of command-line arguments that should be
            consumed. By default, one argument will be consumed and a single
            value will be produced.  Other values include:
                - N (an integer) consumes N arguments (and produces a list)
                - '?' consumes zero or one arguments
                - '*' consumes zero or more arguments (and produces a list)
                - '+' consumes one or more arguments (and produces a list)
            Note that the difference between the default and nargs=1 is that
            with the default, a single value will be produced, while with
            nargs=1, a list containing a single value will be produced.

        - const -- The value to be produced if the option is specified and the
            option uses an action that takes no values.

        - default -- The value to be produced if the option is not specified.

        - type -- A callable that accepts a single string argument, and
            returns the converted value.  The standard Python types str, int,
            float, and complex are useful examples of such callables.  If None,
            str is used.

        - choices -- A container of values that should be allowed. If not None,
            after a command-line argument has been converted to the appropriate
            type, an exception will be raised if it is not a member of this
            collection.

        - required -- True if the action must always be specified at the
            command line. This is only meaningful for optional command-line
            arguments.

        - help -- The help string describing the argument.

        - metavar -- The name to be used for the option's argument with the
            help string. If None, the 'dest' value will be used as the name.
    """

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        self.option_strings = option_strings
        self.dest = dest
        self.nargs = nargs
        self.const = const
        self.default = default
        self.type = type
        self.choices = choices
        self.required = required
        self.help = help
        self.metavar = metavar

    def _get_kwargs(self):
        names = [
            'option_strings',
            'dest',
            'nargs',
            'const',
            'default',
            'type',
            'choices',
            'help',
            'metavar',
        ]
        return [(name, getattr(self, name)) for name in names]

    def __call__(self, parser, namespace, values, option_string=None):
        raise NotImplementedError(_('.__call__() not defined'))


class _StoreAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        if nargs == 0:
            raise ValueError('nargs for store actions must be > 0; if you '
                             'have nothing to store, actions such as store '
                             'true or store const may be more appropriate')
        if const is not None and nargs != OPTIONAL:
            raise ValueError('nargs must be %r to supply const' % OPTIONAL)
        super(_StoreAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=nargs,
            const=const,
            default=default,
            type=type,
            choices=choices,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values)


class _StoreConstAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 const,
                 default=None,
                 required=False,
                 help=None,
                 metavar=None):
        super(_StoreConstAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            const=const,
            default=default,
            required=required,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, self.const)


class _StoreTrueAction(_StoreConstAction):

    def __init__(self,
                 option_strings,
                 dest,
                 default=False,
                 required=False,
                 help=None):
        super(_StoreTrueAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            const=True,
            default=default,
            required=required,
            help=help)


class _StoreFalseAction(_StoreConstAction):

    def __init__(self,
                 option_strings,
                 dest,
                 default=True,
                 required=False,
                 help=None):
        super(_StoreFalseAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            const=False,
            default=default,
            required=required,
            help=help)


class _AppendAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        if nargs == 0:
            raise ValueError('nargs for append actions must be > 0; if arg '
                             'strings are not supplying the value to append, '
                             'the append const action may be more appropriate')
        if const is not None and nargs != OPTIONAL:
            raise ValueError('nargs must be %r to supply const' % OPTIONAL)
        super(_AppendAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=nargs,
            const=const,
            default=default,
            type=type,
            choices=choices,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        items = _copy.copy(_ensure_value(namespace, self.dest, []))
        items.append(values)
        setattr(namespace, self.dest, items)


class _AppendConstAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 const,
                 default=None,
                 required=False,
                 help=None,
                 metavar=None):
        super(_AppendConstAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            const=const,
            default=default,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        items = _copy.copy(_ensure_value(namespace, self.dest, []))
        items.append(self.const)
        setattr(namespace, self.dest, items)


class _CountAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 default=None,
                 required=False,
                 help=None):
        super(_CountAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            default=default,
            required=required,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        new_count = _ensure_value(namespace, self.dest, 0) + 1
        setattr(namespace, self.dest, new_count)


class _HelpAction(Action):

    def __init__(self,
                 option_strings,
                 dest=SUPPRESS,
                 default=SUPPRESS,
                 help=None):
        super(_HelpAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            default=default,
            nargs=0,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        parser.print_help()
        parser.exit()


class _VersionAction(Action):

    def __init__(self,
                 option_strings,
                 version=None,
                 dest=SUPPRESS,
                 default=SUPPRESS,
                 help="show program's version number and exit"):
        super(_VersionAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            default=default,
            nargs=0,
            help=help)
        self.version = version

    def __call__(self, parser, namespace, values, option_string=None):
        version = self.version
        if version is None:
            version = parser.version
        formatter = parser._get_formatter()
        formatter.add_text(version)
        parser.exit(message=formatter.format_help())


class _SubParsersAction(Action):

    class _ChoicesPseudoAction(Action):

        def __init__(self, name, help):
            sup = super(_SubParsersAction._ChoicesPseudoAction, self)
            sup.__init__(option_strings=[], dest=name, help=help)

    def __init__(self,
                 option_strings,
                 prog,
                 parser_class,
                 dest=SUPPRESS,
                 help=None,
                 metavar=None):

        self._prog_prefix = prog
        self._parser_class = parser_class
        self._name_parser_map = _collections.OrderedDict()
        self._choices_actions = []

        super(_SubParsersAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=PARSER,
            choices=self._name_parser_map,
            help=help,
            metavar=metavar)

    def add_parser(self, name, **kwargs):
        # set prog from the existing prefix
        if kwargs.get('prog') is None:
            kwargs['prog'] = '%s %s' % (self._prog_prefix, name)

        # create a pseudo-action to hold the choice help
        if 'help' in kwargs:
            help = kwargs.pop('help')
            choice_action = self._ChoicesPseudoAction(name, help)
            self._choices_actions.append(choice_action)

        # create the parser and add it to the map
        parser = self._parser_class(**kwargs)
        self._name_parser_map[name] = parser
        return parser

    def _get_subactions(self):
        return self._choices_actions

    def __call__(self, parser, namespace, values, option_string=None):
        parser_name = values[0]
        arg_strings = values[1:]

        # set the parser name if requested
        if self.dest is not SUPPRESS:
            setattr(namespace, self.dest, parser_name)

        # select the parser
        try:
            parser = self._name_parser_map[parser_name]
        except KeyError:
            tup = parser_name, ', '.join(self._name_parser_map)
            msg = _('unknown parser %r (choices: %s)') % tup
            raise ArgumentError(self, msg)

        # parse all the remaining options into the namespace
        # store any unrecognized options on the object, so that the top
        # level parser can decide what to do with them

        # In case this subparser defines new defaults, we parse them
        # in a new namespace object and then update the original
        # namespace for the relevant parts.
        subnamespace, arg_strings = parser.parse_known_args(arg_strings, None)
        for key, value in vars(subnamespace).items():
            setattr(namespace, key, value)

        if arg_strings:
            vars(namespace).setdefault(_UNRECOGNIZED_ARGS_ATTR, [])
            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)


# ==============
# Type classes
# ==============

class FileType(object):
    """Factory for creating file object types

    Instances of FileType are typically passed as type= arguments to the
    ArgumentParser add_argument() method.

    Keyword Arguments:
        - mode -- A string indicating how the file is to be opened. Accepts the
            same values as the builtin open() function.
        - bufsize -- The file's desired buffer size. Accepts the same values as
            the builtin open() function.
    """

    def __init__(self, mode='r', bufsize=-1):
        self._mode = mode
        self._bufsize = bufsize

    def __call__(self, string):
        # the special argument "-" means sys.std{in,out}
        if string == '-':
            if 'r' in self._mode:
                return _sys.stdin
            elif 'w' in self._mode:
                return _sys.stdout
            else:
                msg = _('argument "-" with mode %r') % self._mode
                raise ValueError(msg)

        # all other arguments are used as file names
        try:
            return open(string, self._mode, self._bufsize)
        except IOError as e:
            message = _("can't open '%s': %s")
            raise ArgumentTypeError(message % (string, e))

    def __repr__(self):
        args = self._mode, self._bufsize
        args_str = ', '.join(repr(arg) for arg in args if arg != -1)
        return '%s(%s)' % (type(self).__name__, args_str)

# ===========================
# Optional and Positional Parsing
# ===========================

class Namespace(_AttributeHolder):
    """Simple object for storing attributes.

    Implements equality by attribute names and values, and provides a simple
    string representation.
    """

    def __init__(self, **kwargs):
        for name in kwargs:
            setattr(self, name, kwargs[name])

    __hash__ = None

    def __eq__(self, other):
        if not isinstance(other, Namespace):
            return NotImplemented
        return vars(self) == vars(other)

    def __ne__(self, other):
        if not isinstance(other, Namespace):
            return NotImplemented
        return not (self == other)

    def __contains__(self, key):
        return key in self.__dict__


class _ActionsContainer(object):

    def __init__(self,
                 description,
                 prefix_chars,
                 argument_default,
                 conflict_handler):
        super(_ActionsContainer, self).__init__()

        self.description = description
        self.argument_default = argument_default
        self.prefix_chars = prefix_chars
        self.conflict_handler = conflict_handler

        # set up registries
        self._registries = {}

        # register actions
        self.register('action', None, _StoreAction)
        self.register('action', 'store', _StoreAction)
        self.register('action', 'store_const', _StoreConstAction)
        self.register('action', 'store_true', _StoreTrueAction)
        self.register('action', 'store_false', _StoreFalseAction)
        self.register('action', 'append', _AppendAction)
        self.register('action', 'append_const', _AppendConstAction)
        self.register('action', 'count', _CountAction)
        self.register('action', 'help', _HelpAction)
        self.register('action', 'version', _VersionAction)
        self.register('action', 'parsers', _SubParsersAction)

        # raise an exception if the conflict handler is invalid
        self._get_handler()

        # action storage
        self._actions = []
        self._option_string_actions = {}

        # groups
        self._action_groups = []
        self._mutually_exclusive_groups = []

        # defaults storage
        self._defaults = {}

        # determines whether an "option" looks like a negative number
        self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')

        # whether or not there are any optionals that look like negative
        # numbers -- uses a list so it can be shared and edited
        self._has_negative_number_optionals = []

    # ====================
    # Registration methods
    # ====================
    def register(self, registry_name, value, object):
        registry = self._registries.setdefault(registry_name, {})
        registry[value] = object

    def _registry_get(self, registry_name, value, default=None):
        return self._registries[registry_name].get(value, default)

    # ==================================
    # Namespace default accessor methods
    # ==================================
    def set_defaults(self, **kwargs):
        self._defaults.update(kwargs)

        # if these defaults match any existing arguments, replace
        # the previous default on the object with the new one
        for action in self._actions:
            if action.dest in kwargs:
                action.default = kwargs[action.dest]

    def get_default(self, dest):
        for action in self._actions:
            if action.dest == dest and action.default is not None:
                return action.default
        return self._defaults.get(dest, None)


    # =======================
    # Adding argument actions
    # =======================
    def add_argument(self, *args, **kwargs):
        """
        add_argument(dest, ..., name=value, ...)
        add_argument(option_string, option_string, ..., name=value, ...)
        """

        # if no positional args are supplied or only one is supplied and
        # it doesn't look like an option string, parse a positional
        # argument
        chars = self.prefix_chars
        if not args or len(args) == 1 and args[0][0] not in chars:
            if args and 'dest' in kwargs:
                raise ValueError('dest supplied twice for positional argument')
            kwargs = self._get_positional_kwargs(*args, **kwargs)

        # otherwise, we're adding an optional argument
        else:
            kwargs = self._get_optional_kwargs(*args, **kwargs)

        # if no default was supplied, use the parser-level default
        if 'default' not in kwargs:
            dest = kwargs['dest']
            if dest in self._defaults:
                kwargs['default'] = self._defaults[dest]
            elif self.argument_default is not None:
                kwargs['default'] = self.argument_default

        # create the action object, and add it to the parser
        action_class = self._pop_action_class(kwargs)
        if not _callable(action_class):
            raise ValueError('unknown action "%s"' % (action_class,))
        action = action_class(**kwargs)

        # raise an error if the action type is not callable
        type_func = self._registry_get('type', action.type, action.type)
        if not _callable(type_func):
            raise ValueError('%r is not callable' % (type_func,))

        # raise an error if the metavar does not match the type
        if hasattr(self, "_get_formatter"):
            try:
                self._get_formatter()._format_args(action, None)
            except TypeError:
                raise ValueError("length of metavar tuple does not match nargs")

        return self._add_action(action)

    def add_argument_group(self, *args, **kwargs):
        group = _ArgumentGroup(self, *args, **kwargs)
        self._action_groups.append(group)
        return group

    def add_mutually_exclusive_group(self, **kwargs):
        group = _MutuallyExclusiveGroup(self, **kwargs)
        self._mutually_exclusive_groups.append(group)
        return group

    def _add_action(self, action):
        # resolve any conflicts
        self._check_conflict(action)

        # add to actions list
        self._actions.append(action)
        action.container = self

        # index the action by any option strings it has
        for option_string in action.option_strings:
            self._option_string_actions[option_string] = action

        # set the flag if any option strings look like negative numbers
        for option_string in action.option_strings:
            if self._negative_number_matcher.match(option_string):
                if not self._has_negative_number_optionals:
                    self._has_negative_number_optionals.append(True)

        # return the created action
        return action

    def _remove_action(self, action):
        self._actions.remove(action)

    def _add_container_actions(self, container):
        # collect groups by titles
        title_group_map = {}
        for group in self._action_groups:
            if group.title in title_group_map:
                msg = _('cannot merge actions - two groups are named %r')
                raise ValueError(msg % (group.title))
            title_group_map[group.title] = group

        # map each action to its group
        group_map = {}
        for group in container._action_groups:

            # if a group with the title exists, use that, otherwise
            # create a new group matching the container's group
            if group.title not in title_group_map:
                title_group_map[group.title] = self.add_argument_group(
                    title=group.title,
                    description=group.description,
                    conflict_handler=group.conflict_handler)

            # map the actions to their new group
            for action in group._group_actions:
                group_map[action] = title_group_map[group.title]

        # add container's mutually exclusive groups
        # NOTE: if add_mutually_exclusive_group ever gains title= and
        # description= then this code will need to be expanded as above
        for group in container._mutually_exclusive_groups:
            mutex_group = self.add_mutually_exclusive_group(
                required=group.required)

            # map the actions to their new mutex group
            for action in group._group_actions:
                group_map[action] = mutex_group

        # add all actions to this container or their group
        for action in container._actions:
            group_map.get(action, self)._add_action(action)

    def _get_positional_kwargs(self, dest, **kwargs):
        # make sure required is not specified
        if 'required' in kwargs:
            msg = _("'required' is an invalid argument for positionals")
            raise TypeError(msg)

        # mark positional arguments as required if at least one is
        # always required
        if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:
            kwargs['required'] = True
        if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:
            kwargs['required'] = True

        # return the keyword arguments with no option strings
        return dict(kwargs, dest=dest, option_strings=[])

    def _get_optional_kwargs(self, *args, **kwargs):
        # determine short and long option strings
        option_strings = []
        long_option_strings = []
        for option_string in args:
            # error on strings that don't start with an appropriate prefix
            if not option_string[0] in self.prefix_chars:
                msg = _('invalid option string %r: '
                        'must start with a character %r')
                tup = option_string, self.prefix_chars
                raise ValueError(msg % tup)

            # strings starting with two prefix characters are long options
            option_strings.append(option_string)
            if option_string[0] in self.prefix_chars:
                if len(option_string) > 1:
                    if option_string[1] in self.prefix_chars:
                        long_option_strings.append(option_string)

        # infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'
        dest = kwargs.pop('dest', None)
        if dest is None:
            if long_option_strings:
                dest_option_string = long_option_strings[0]
            else:
                dest_option_string = option_strings[0]
            dest = dest_option_string.lstrip(self.prefix_chars)
            if not dest:
                msg = _('dest= is required for options like %r')
                raise ValueError(msg % option_string)
            dest = dest.replace('-', '_')

        # return the updated keyword arguments
        return dict(kwargs, dest=dest, option_strings=option_strings)

    def _pop_action_class(self, kwargs, default=None):
        action = kwargs.pop('action', default)
        return self._registry_get('action', action, action)

    def _get_handler(self):
        # determine function from conflict handler string
        handler_func_name = '_handle_conflict_%s' % self.conflict_handler
        try:
            return getattr(self, handler_func_name)
        except AttributeError:
            msg = _('invalid conflict_resolution value: %r')
            raise ValueError(msg % self.conflict_handler)

    def _check_conflict(self, action):

        # find all options that conflict with this option
        confl_optionals = []
        for option_string in action.option_strings:
            if option_string in self._option_string_actions:
                confl_optional = self._option_string_actions[option_string]
                confl_optionals.append((option_string, confl_optional))

        # resolve any conflicts
        if confl_optionals:
            conflict_handler = self._get_handler()
            conflict_handler(action, confl_optionals)

    def _handle_conflict_error(self, action, conflicting_actions):
        message = _('conflicting option string(s): %s')
        conflict_string = ', '.join([option_string
                                     for option_string, action
                                     in conflicting_actions])
        raise ArgumentError(action, message % conflict_string)

    def _handle_conflict_resolve(self, action, conflicting_actions):

        # remove all conflicting options
        for option_string, action in conflicting_actions:

            # remove the conflicting option
            action.option_strings.remove(option_string)
            self._option_string_actions.pop(option_string, None)

            # if the option now has no option string, remove it from the
            # container holding it
            if not action.option_strings:
                action.container._remove_action(action)


class _ArgumentGroup(_ActionsContainer):

    def __init__(self, container, title=None, description=None, **kwargs):
        # add any missing keyword arguments by checking the container
        update = kwargs.setdefault
        update('conflict_handler', container.conflict_handler)
        update('prefix_chars', container.prefix_chars)
        update('argument_default', container.argument_default)
        super_init = super(_ArgumentGroup, self).__init__
        super_init(description=description, **kwargs)

        # group attributes
        self.title = title
        self._group_actions = []

        # share most attributes with the container
        self._registries = container._registries
        self._actions = container._actions
        self._option_string_actions = container._option_string_actions
        self._defaults = container._defaults
        self._has_negative_number_optionals = \
            container._has_negative_number_optionals
        self._mutually_exclusive_groups = container._mutually_exclusive_groups

    def _add_action(self, action):
        action = super(_ArgumentGroup, self)._add_action(action)
        self._group_actions.append(action)
        return action

    def _remove_action(self, action):
        super(_ArgumentGroup, self)._remove_action(action)
        self._group_actions.remove(action)


class _MutuallyExclusiveGroup(_ArgumentGroup):

    def __init__(self, container, required=False):
        super(_MutuallyExclusiveGroup, self).__init__(container)
        self.required = required
        self._container = container

    def _add_action(self, action):
        if action.required:
            msg = _('mutually exclusive arguments must be optional')
            raise ValueError(msg)
        action = self._container._add_action(action)
        self._group_actions.append(action)
        return action

    def _remove_action(self, action):
        self._container._remove_action(action)
        self._group_actions.remove(action)


class ArgumentParser(_AttributeHolder, _ActionsContainer):
    """Object for parsing command line strings into Python objects.

    Keyword Arguments:
        - prog -- The name of the program (default: sys.argv[0])
        - usage -- A usage message (default: auto-generated from arguments)
        - description -- A description of what the program does
        - epilog -- Text following the argument descriptions
        - parents -- Parsers whose arguments should be copied into this one
        - formatter_class -- HelpFormatter class for printing help messages
        - prefix_chars -- Characters that prefix optional arguments
        - fromfile_prefix_chars -- Characters that prefix files containing
            additional arguments
        - argument_default -- The default value for all arguments
        - conflict_handler -- String indicating how to handle conflicts
        - add_help -- Add a -h/-help option
    """

    def __init__(self,
                 prog=None,
                 usage=None,
                 description=None,
                 epilog=None,
                 version=None,
                 parents=[],
                 formatter_class=HelpFormatter,
                 prefix_chars='-',
                 fromfile_prefix_chars=None,
                 argument_default=None,
                 conflict_handler='error',
                 add_help=True):

        if version is not None:
            import warnings
            warnings.warn(
                """The "version" argument to ArgumentParser is deprecated. """
                """Please use """
                """"add_argument(..., action='version', version="N", ...)" """
                """instead""", DeprecationWarning)

        superinit = super(ArgumentParser, self).__init__
        superinit(description=description,
                  prefix_chars=prefix_chars,
                  argument_default=argument_default,
                  conflict_handler=conflict_handler)

        # default setting for prog
        if prog is None:
            prog = _os.path.basename(_sys.argv[0])

        self.prog = prog
        self.usage = usage
        self.epilog = epilog
        self.version = version
        self.formatter_class = formatter_class
        self.fromfile_prefix_chars = fromfile_prefix_chars
        self.add_help = add_help

        add_group = self.add_argument_group
        self._positionals = add_group(_('positional arguments'))
        self._optionals = add_group(_('optional arguments'))
        self._subparsers = None

        # register types
        def identity(string):
            return string
        self.register('type', None, identity)

        # add help and version arguments if necessary
        # (using explicit default to override global argument_default)
        default_prefix = '-' if '-' in prefix_chars else prefix_chars[0]
        if self.add_help:
            self.add_argument(
                default_prefix+'h', default_prefix*2+'help',
                action='help', default=SUPPRESS,
                help=_('show this help message and exit'))
        if self.version:
            self.add_argument(
                default_prefix+'v', default_prefix*2+'version',
                action='version', default=SUPPRESS,
                version=self.version,
                help=_("show program's version number and exit"))

        # add parent arguments and defaults
        for parent in parents:
            self._add_container_actions(parent)
            try:
                defaults = parent._defaults
            except AttributeError:
                pass
            else:
                self._defaults.update(defaults)

    # =======================
    # Pretty __repr__ methods
    # =======================
    def _get_kwargs(self):
        names = [
            'prog',
            'usage',
            'description',
            'version',
            'formatter_class',
            'conflict_handler',
            'add_help',
        ]
        return [(name, getattr(self, name)) for name in names]

    # ==================================
    # Optional/Positional adding methods
    # ==================================
    def add_subparsers(self, **kwargs):
        if self._subparsers is not None:
            self.error(_('cannot have multiple subparser arguments'))

        # add the parser class to the arguments if it's not present
        kwargs.setdefault('parser_class', type(self))

        if 'title' in kwargs or 'description' in kwargs:
            title = _(kwargs.pop('title', 'subcommands'))
            description = _(kwargs.pop('description', None))
            self._subparsers = self.add_argument_group(title, description)
        else:
            self._subparsers = self._positionals

        # prog defaults to the usage message of this parser, skipping
        # optional arguments and with no "usage:" prefix
        if kwargs.get('prog') is None:
            formatter = self._get_formatter()
            positionals = self._get_positional_actions()
            groups = self._mutually_exclusive_groups
            formatter.add_usage(self.usage, positionals, groups, '')
            kwargs['prog'] = formatter.format_help().strip()

        # create the parsers action and add it to the positionals list
        parsers_class = self._pop_action_class(kwargs, 'parsers')
        action = parsers_class(option_strings=[], **kwargs)
        self._subparsers._add_action(action)

        # return the created parsers action
        return action

    def _add_action(self, action):
        if action.option_strings:
            self._optionals._add_action(action)
        else:
            self._positionals._add_action(action)
        return action

    def _get_optional_actions(self):
        return [action
                for action in self._actions
                if action.option_strings]

    def _get_positional_actions(self):
        return [action
                for action in self._actions
                if not action.option_strings]

    # =====================================
    # Command line argument parsing methods
    # =====================================
    def parse_args(self, args=None, namespace=None):
        args, argv = self.parse_known_args(args, namespace)
        if argv:
            msg = _('unrecognized arguments: %s')
            self.error(msg % ' '.join(argv))
        return args

    def parse_known_args(self, args=None, namespace=None):
        if args is None:
            # args default to the system args
            args = _sys.argv[1:]
        else:
            # make sure that args are mutable
            args = list(args)

        # default Namespace built from parser defaults
        if namespace is None:
            namespace = Namespace()

        # add any action defaults that aren't present
        for action in self._actions:
            if action.dest is not SUPPRESS:
                if not hasattr(namespace, action.dest):
                    if action.default is not SUPPRESS:
                        setattr(namespace, action.dest, action.default)

        # add any parser defaults that aren't present
        for dest in self._defaults:
            if not hasattr(namespace, dest):
                setattr(namespace, dest, self._defaults[dest])

        # parse the arguments and exit if there are any errors
        try:
            namespace, args = self._parse_known_args(args, namespace)
            if hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR):
                args.extend(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))
                delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)
            return namespace, args
        except ArgumentError:
            err = _sys.exc_info()[1]
            self.error(str(err))

    def _parse_known_args(self, arg_strings, namespace):
        # replace arg strings that are file references
        if self.fromfile_prefix_chars is not None:
            arg_strings = self._read_args_from_files(arg_strings)

        # map all mutually exclusive arguments to the other arguments
        # they can't occur with
        action_conflicts = {}
        for mutex_group in self._mutually_exclusive_groups:
            group_actions = mutex_group._group_actions
            for i, mutex_action in enumerate(mutex_group._group_actions):
                conflicts = action_conflicts.setdefault(mutex_action, [])
                conflicts.extend(group_actions[:i])
                conflicts.extend(group_actions[i + 1:])

        # find all option indices, and determine the arg_string_pattern
        # which has an 'O' if there is an option at an index,
        # an 'A' if there is an argument, or a '-' if there is a '--'
        option_string_indices = {}
        arg_string_pattern_parts = []
        arg_strings_iter = iter(arg_strings)
        for i, arg_string in enumerate(arg_strings_iter):

            # all args after -- are non-options
            if arg_string == '--':
                arg_string_pattern_parts.append('-')
                for arg_string in arg_strings_iter:
                    arg_string_pattern_parts.append('A')

            # otherwise, add the arg to the arg strings
            # and note the index if it was an option
            else:
                option_tuple = self._parse_optional(arg_string)
                if option_tuple is None:
                    pattern = 'A'
                else:
                    option_string_indices[i] = option_tuple
                    pattern = 'O'
                arg_string_pattern_parts.append(pattern)

        # join the pieces together to form the pattern
        arg_strings_pattern = ''.join(arg_string_pattern_parts)

        # converts arg strings to the appropriate and then takes the action
        seen_actions = set()
        seen_non_default_actions = set()

        def take_action(action, argument_strings, option_string=None):
            seen_actions.add(action)
            argument_values = self._get_values(action, argument_strings)

            # error if this argument is not allowed with other previously
            # seen arguments, assuming that actions that use the default
            # value don't really count as "present"
            if argument_values is not action.default:
                seen_non_default_actions.add(action)
                for conflict_action in action_conflicts.get(action, []):
                    if conflict_action in seen_non_default_actions:
                        msg = _('not allowed with argument %s')
                        action_name = _get_action_name(conflict_action)
                        raise ArgumentError(action, msg % action_name)

            # take the action if we didn't receive a SUPPRESS value
            # (e.g. from a default)
            if argument_values is not SUPPRESS:
                action(self, namespace, argument_values, option_string)

        # function to convert arg_strings into an optional action
        def consume_optional(start_index):

            # get the optional identified at this index
            option_tuple = option_string_indices[start_index]
            action, option_string, explicit_arg = option_tuple

            # identify additional optionals in the same arg string
            # (e.g. -xyz is the same as -x -y -z if no args are required)
            match_argument = self._match_argument
            action_tuples = []
            while True:

                # if we found no optional action, skip it
                if action is None:
                    extras.append(arg_strings[start_index])
                    return start_index + 1

                # if there is an explicit argument, try to match the
                # optional's string arguments to only this
                if explicit_arg is not None:
                    arg_count = match_argument(action, 'A')

                    # if the action is a single-dash option and takes no
                    # arguments, try to parse more single-dash options out
                    # of the tail of the option string
                    chars = self.prefix_chars
                    if arg_count == 0 and option_string[1] not in chars:
                        action_tuples.append((action, [], option_string))
                        char = option_string[0]
                        option_string = char + explicit_arg[0]
                        new_explicit_arg = explicit_arg[1:] or None
                        optionals_map = self._option_string_actions
                        if option_string in optionals_map:
                            action = optionals_map[option_string]
                            explicit_arg = new_explicit_arg
                        else:
                            msg = _('ignored explicit argument %r')
                            raise ArgumentError(action, msg % explicit_arg)

                    # if the action expect exactly one argument, we've
                    # successfully matched the option; exit the loop
                    elif arg_count == 1:
                        stop = start_index + 1
                        args = [explicit_arg]
                        action_tuples.append((action, args, option_string))
                        break

                    # error if a double-dash option did not use the
                    # explicit argument
                    else:
                        msg = _('ignored explicit argument %r')
                        raise ArgumentError(action, msg % explicit_arg)

                # if there is no explicit argument, try to match the
                # optional's string arguments with the following strings
                # if successful, exit the loop
                else:
                    start = start_index + 1
                    selected_patterns = arg_strings_pattern[start:]
                    arg_count = match_argument(action, selected_patterns)
                    stop = start + arg_count
                    args = arg_strings[start:stop]
                    action_tuples.append((action, args, option_string))
                    break

            # add the Optional to the list and return the index at which
            # the Optional's string args stopped
            assert action_tuples
            for action, args, option_string in action_tuples:
                take_action(action, args, option_string)
            return stop

        # the list of Positionals left to be parsed; this is modified
        # by consume_positionals()
        positionals = self._get_positional_actions()

        # function to convert arg_strings into positional actions
        def consume_positionals(start_index):
            # match as many Positionals as possible
            match_partial = self._match_arguments_partial
            selected_pattern = arg_strings_pattern[start_index:]
            arg_counts = match_partial(positionals, selected_pattern)

            # slice off the appropriate arg strings for each Positional
            # and add the Positional and its args to the list
            for action, arg_count in zip(positionals, arg_counts):
                args = arg_strings[start_index: start_index + arg_count]
                start_index += arg_count
                take_action(action, args)

            # slice off the Positionals that we just parsed and return the
            # index at which the Positionals' string args stopped
            positionals[:] = positionals[len(arg_counts):]
            return start_index

        # consume Positionals and Optionals alternately, until we have
        # passed the last option string
        extras = []
        start_index = 0
        if option_string_indices:
            max_option_string_index = max(option_string_indices)
        else:
            max_option_string_index = -1
        while start_index <= max_option_string_index:

            # consume any Positionals preceding the next option
            next_option_string_index = min([
                index
                for index in option_string_indices
                if index >= start_index])
            if start_index != next_option_string_index:
                positionals_end_index = consume_positionals(start_index)

                # only try to parse the next optional if we didn't consume
                # the option string during the positionals parsing
                if positionals_end_index > start_index:
                    start_index = positionals_end_index
                    continue
                else:
                    start_index = positionals_end_index

            # if we consumed all the positionals we could and we're not
            # at the index of an option string, there were extra arguments
            if start_index not in option_string_indices:
                strings = arg_strings[start_index:next_option_string_index]
                extras.extend(strings)
                start_index = next_option_string_index

            # consume the next optional and any arguments for it
            start_index = consume_optional(start_index)

        # consume any positionals following the last Optional
        stop_index = consume_positionals(start_index)

        # if we didn't consume all the argument strings, there were extras
        extras.extend(arg_strings[stop_index:])

        # if we didn't use all the Positional objects, there were too few
        # arg strings supplied.
        if positionals:
            self.error(_('too few arguments'))

        # make sure all required actions were present, and convert defaults.
        for action in self._actions:
            if action not in seen_actions:
                if action.required:
                    name = _get_action_name(action)
                    self.error(_('argument %s is required') % name)
                else:
                    # Convert action default now instead of doing it before
                    # parsing arguments to avoid calling convert functions
                    # twice (which may fail) if the argument was given, but
                    # only if it was defined already in the namespace
                    if (action.default is not None and
                            isinstance(action.default, basestring) and
                            hasattr(namespace, action.dest) and
                            action.default is getattr(namespace, action.dest)):
                        setattr(namespace, action.dest,
                                self._get_value(action, action.default))

        # make sure all required groups had one option present
        for group in self._mutually_exclusive_groups:
            if group.required:
                for action in group._group_actions:
                    if action in seen_non_default_actions:
                        break

                # if no actions were used, report the error
                else:
                    names = [_get_action_name(action)
                             for action in group._group_actions
                             if action.help is not SUPPRESS]
                    msg = _('one of the arguments %s is required')
                    self.error(msg % ' '.join(names))

        # return the updated namespace and the extra arguments
        return namespace, extras

    def _read_args_from_files(self, arg_strings):
        # expand arguments referencing files
        new_arg_strings = []
        for arg_string in arg_strings:

            # for regular arguments, just add them back into the list
            if not arg_string or arg_string[0] not in self.fromfile_prefix_chars:
                new_arg_strings.append(arg_string)

            # replace arguments referencing files with the file content
            else:
                try:
                    args_file = open(arg_string[1:])
                    try:
                        arg_strings = []
                        for arg_line in args_file.read().splitlines():
                            for arg in self.convert_arg_line_to_args(arg_line):
                                arg_strings.append(arg)
                        arg_strings = self._read_args_from_files(arg_strings)
                        new_arg_strings.extend(arg_strings)
                    finally:
                        args_file.close()
                except IOError:
                    err = _sys.exc_info()[1]
                    self.error(str(err))

        # return the modified argument list
        return new_arg_strings

    def convert_arg_line_to_args(self, arg_line):
        return [arg_line]

    def _match_argument(self, action, arg_strings_pattern):
        # match the pattern for this action to the arg strings
        nargs_pattern = self._get_nargs_pattern(action)
        match = _re.match(nargs_pattern, arg_strings_pattern)

        # raise an exception if we weren't able to find a match
        if match is None:
            nargs_errors = {
                None: _('expected one argument'),
                OPTIONAL: _('expected at most one argument'),
                ONE_OR_MORE: _('expected at least one argument'),
            }
            default = _('expected %s argument(s)') % action.nargs
            msg = nargs_errors.get(action.nargs, default)
            raise ArgumentError(action, msg)

        # return the number of arguments matched
        return len(match.group(1))

    def _match_arguments_partial(self, actions, arg_strings_pattern):
        # progressively shorten the actions list by slicing off the
        # final actions until we find a match
        result = []
        for i in range(len(actions), 0, -1):
            actions_slice = actions[:i]
            pattern = ''.join([self._get_nargs_pattern(action)
                               for action in actions_slice])
            match = _re.match(pattern, arg_strings_pattern)
            if match is not None:
                result.extend([len(string) for string in match.groups()])
                break

        # return the list of arg string counts
        return result

    def _parse_optional(self, arg_string):
        # if it's an empty string, it was meant to be a positional
        if not arg_string:
            return None

        # if it doesn't start with a prefix, it was meant to be positional
        if not arg_string[0] in self.prefix_chars:
            return None

        # if the option string is present in the parser, return the action
        if arg_string in self._option_string_actions:
            action = self._option_string_actions[arg_string]
            return action, arg_string, None

        # if it's just a single character, it was meant to be positional
        if len(arg_string) == 1:
            return None

        # if the option string before the "=" is present, return the action
        if '=' in arg_string:
            option_string, explicit_arg = arg_string.split('=', 1)
            if option_string in self._option_string_actions:
                action = self._option_string_actions[option_string]
                return action, option_string, explicit_arg

        # search through all possible prefixes of the option string
        # and all actions in the parser for possible interpretations
        option_tuples = self._get_option_tuples(arg_string)

        # if multiple actions match, the option string was ambiguous
        if len(option_tuples) > 1:
            options = ', '.join([option_string
                for action, option_string, explicit_arg in option_tuples])
            tup = arg_string, options
            self.error(_('ambiguous option: %s could match %s') % tup)

        # if exactly one action matched, this segmentation is good,
        # so return the parsed action
        elif len(option_tuples) == 1:
            option_tuple, = option_tuples
            return option_tuple

        # if it was not found as an option, but it looks like a negative
        # number, it was meant to be positional
        # unless there are negative-number-like options
        if self._negative_number_matcher.match(arg_string):
            if not self._has_negative_number_optionals:
                return None

        # if it contains a space, it was meant to be a positional
        if ' ' in arg_string:
            return None

        # it was meant to be an optional but there is no such option
        # in this parser (though it might be a valid option in a subparser)
        return None, arg_string, None

    def _get_option_tuples(self, option_string):
        result = []

        # option strings starting with two prefix characters are only
        # split at the '='
        chars = self.prefix_chars
        if option_string[0] in chars and option_string[1] in chars:
            if '=' in option_string:
                option_prefix, explicit_arg = option_string.split('=', 1)
            else:
                option_prefix = option_string
                explicit_arg = None
            for option_string in self._option_string_actions:
                if option_string.startswith(option_prefix):
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, explicit_arg
                    result.append(tup)

        # single character options can be concatenated with their arguments
        # but multiple character options always have to have their argument
        # separate
        elif option_string[0] in chars and option_string[1] not in chars:
            option_prefix = option_string
            explicit_arg = None
            short_option_prefix = option_string[:2]
            short_explicit_arg = option_string[2:]

            for option_string in self._option_string_actions:
                if option_string == short_option_prefix:
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, short_explicit_arg
                    result.append(tup)
                elif option_string.startswith(option_prefix):
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, explicit_arg
                    result.append(tup)

        # shouldn't ever get here
        else:
            self.error(_('unexpected option string: %s') % option_string)

        # return the collected option tuples
        return result

    def _get_nargs_pattern(self, action):
        # in all examples below, we have to allow for '--' args
        # which are represented as '-' in the pattern
        nargs = action.nargs

        # the default (None) is assumed to be a single argument
        if nargs is None:
            nargs_pattern = '(-*A-*)'

        # allow zero or one arguments
        elif nargs == OPTIONAL:
            nargs_pattern = '(-*A?-*)'

        # allow zero or more arguments
        elif nargs == ZERO_OR_MORE:
            nargs_pattern = '(-*[A-]*)'

        # allow one or more arguments
        elif nargs == ONE_OR_MORE:
            nargs_pattern = '(-*A[A-]*)'

        # allow any number of options or arguments
        elif nargs == REMAINDER:
            nargs_pattern = '([-AO]*)'

        # allow one argument followed by any number of options or arguments
        elif nargs == PARSER:
            nargs_pattern = '(-*A[-AO]*)'

        # all others should be integers
        else:
            nargs_pattern = '(-*%s-*)' % '-*'.join('A' * nargs)

        # if this is an optional action, -- is not allowed
        if action.option_strings:
            nargs_pattern = nargs_pattern.replace('-*', '')
            nargs_pattern = nargs_pattern.replace('-', '')

        # return the pattern
        return nargs_pattern

    # ========================
    # Value conversion methods
    # ========================
    def _get_values(self, action, arg_strings):
        # for everything but PARSER, REMAINDER args, strip out first '--'
        if action.nargs not in [PARSER, REMAINDER]:
            try:
                arg_strings.remove('--')
            except ValueError:
                pass

        # optional argument produces a default when not present
        if not arg_strings and action.nargs == OPTIONAL:
            if action.option_strings:
                value = action.const
            else:
                value = action.default
            if isinstance(value, basestring):
                value = self._get_value(action, value)
                self._check_value(action, value)

        # when nargs='*' on a positional, if there were no command-line
        # args, use the default if it is anything other than None
        elif (not arg_strings and action.nargs == ZERO_OR_MORE and
              not action.option_strings):
            if action.default is not None:
                value = action.default
            else:
                value = arg_strings
            self._check_value(action, value)

        # single argument or optional argument produces a single value
        elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:
            arg_string, = arg_strings
            value = self._get_value(action, arg_string)
            self._check_value(action, value)

        # REMAINDER arguments convert all values, checking none
        elif action.nargs == REMAINDER:
            value = [self._get_value(action, v) for v in arg_strings]

        # PARSER arguments convert all values, but check only the first
        elif action.nargs == PARSER:
            value = [self._get_value(action, v) for v in arg_strings]
            self._check_value(action, value[0])

        # all other types of nargs produce a list
        else:
            value = [self._get_value(action, v) for v in arg_strings]
            for v in value:
                self._check_value(action, v)

        # return the converted value
        return value

    def _get_value(self, action, arg_string):
        type_func = self._registry_get('type', action.type, action.type)
        if not _callable(type_func):
            msg = _('%r is not callable')
            raise ArgumentError(action, msg % type_func)

        # convert the value to the appropriate type
        try:
            result = type_func(arg_string)

        # ArgumentTypeErrors indicate errors
        except ArgumentTypeError:
            name = getattr(action.type, '__name__', repr(action.type))
            msg = str(_sys.exc_info()[1])
            raise ArgumentError(action, msg)

        # TypeErrors or ValueErrors also indicate errors
        except (TypeError, ValueError):
            name = getattr(action.type, '__name__', repr(action.type))
            msg = _('invalid %s value: %r')
            raise ArgumentError(action, msg % (name, arg_string))

        # return the converted value
        return result

    def _check_value(self, action, value):
        # converted value must be one of the choices (if specified)
        if action.choices is not None and value not in action.choices:
            tup = value, ', '.join(map(repr, action.choices))
            msg = _('invalid choice: %r (choose from %s)') % tup
            raise ArgumentError(action, msg)

    # =======================
    # Help-formatting methods
    # =======================
    def format_usage(self):
        formatter = self._get_formatter()
        formatter.add_usage(self.usage, self._actions,
                            self._mutually_exclusive_groups)
        return formatter.format_help()

    def format_help(self):
        formatter = self._get_formatter()

        # usage
        formatter.add_usage(self.usage, self._actions,
                            self._mutually_exclusive_groups)

        # description
        formatter.add_text(self.description)

        # positionals, optionals and user-defined groups
        for action_group in self._action_groups:
            formatter.start_section(action_group.title)
            formatter.add_text(action_group.description)
            formatter.add_arguments(action_group._group_actions)
            formatter.end_section()

        # epilog
        formatter.add_text(self.epilog)

        # determine help from format above
        return formatter.format_help()

    def format_version(self):
        import warnings
        warnings.warn(
            'The format_version method is deprecated -- the "version" '
            'argument to ArgumentParser is no longer supported.',
            DeprecationWarning)
        formatter = self._get_formatter()
        formatter.add_text(self.version)
        return formatter.format_help()

    def _get_formatter(self):
        return self.formatter_class(prog=self.prog)

    # =====================
    # Help-printing methods
    # =====================
    def print_usage(self, file=None):
        if file is None:
            file = _sys.stdout
        self._print_message(self.format_usage(), file)

    def print_help(self, file=None):
        if file is None:
            file = _sys.stdout
        self._print_message(self.format_help(), file)

    def print_version(self, file=None):
        import warnings
        warnings.warn(
            'The print_version method is deprecated -- the "version" '
            'argument to ArgumentParser is no longer supported.',
            DeprecationWarning)
        self._print_message(self.format_version(), file)

    def _print_message(self, message, file=None):
        if message:
            if file is None:
                file = _sys.stderr
            file.write(message)

    # ===============
    # Exiting methods
    # ===============
    def exit(self, status=0, message=None):
        if message:
            self._print_message(message, _sys.stderr)
        _sys.exit(status)

    def error(self, message):
        """error(message: string)

        Prints a usage message incorporating the message to stderr and
        exits.

        If you override this in a subclass, it should not return -- it
        should either exit or raise an exception.
        """
        self.print_usage(_sys.stderr)
        self.exit(2, _('%s: error: %s\n') % (self.prog, message))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # -*- coding: utf-8 -*-
"""
    ast
    ~~~

    The `ast` module helps Python applications to process trees of the Python
    abstract syntax grammar.  The abstract syntax itself might change with
    each Python release; this module helps to find out programmatically what
    the current grammar looks like and allows modifications of it.

    An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
    a flag to the `compile()` builtin function or by using the `parse()`
    function from this module.  The result will be a tree of objects whose
    classes all inherit from `ast.AST`.

    A modified abstract syntax tree can be compiled into a Python code object
    using the built-in `compile()` function.

    Additionally various helper functions are provided that make working with
    the trees simpler.  The main intention of the helper functions and this
    module in general is to provide an easy to use interface for libraries
    that work tightly with the python syntax (template engines for example).


    :copyright: Copyright 2008 by Armin Ronacher.
    :license: Python License.
"""
from _ast import *
from _ast import __version__


def parse(source, filename='<unknown>', mode='exec'):
    """
    Parse the source into an AST node.
    Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
    """
    return compile(source, filename, mode, PyCF_ONLY_AST)


def literal_eval(node_or_string):
    """
    Safely evaluate an expression node or a string containing a Python
    expression.  The string or node provided may only consist of the following
    Python literal structures: strings, numbers, tuples, lists, dicts, booleans,
    and None.
    """
    _safe_names = {'None': None, 'True': True, 'False': False}
    if isinstance(node_or_string, basestring):
        node_or_string = parse(node_or_string, mode='eval')
    if isinstance(node_or_string, Expression):
        node_or_string = node_or_string.body
    def _convert(node):
        if isinstance(node, Str):
            return node.s
        elif isinstance(node, Num):
            return node.n
        elif isinstance(node, Tuple):
            return tuple(map(_convert, node.elts))
        elif isinstance(node, List):
            return list(map(_convert, node.elts))
        elif isinstance(node, Dict):
            return dict((_convert(k), _convert(v)) for k, v
                        in zip(node.keys, node.values))
        elif isinstance(node, Name):
            if node.id in _safe_names:
                return _safe_names[node.id]
        elif isinstance(node, BinOp) and \
             isinstance(node.op, (Add, Sub)) and \
             isinstance(node.right, Num) and \
             isinstance(node.right.n, complex) and \
             isinstance(node.left, Num) and \
             isinstance(node.left.n, (int, long, float)):
            left = node.left.n
            right = node.right.n
            if isinstance(node.op, Add):
                return left + right
            else:
                return left - right
        raise ValueError('malformed string')
    return _convert(node_or_string)


def dump(node, annotate_fields=True, include_attributes=False):
    """
    Return a formatted dump of the tree in *node*.  This is mainly useful for
    debugging purposes.  The returned string will show the names and the values
    for fields.  This makes the code impossible to evaluate, so if evaluation is
    wanted *annotate_fields* must be set to False.  Attributes such as line
    numbers and column offsets are not dumped by default.  If this is wanted,
    *include_attributes* can be set to True.
    """
    def _format(node):
        if isinstance(node, AST):
            fields = [(a, _format(b)) for a, b in iter_fields(node)]
            rv = '%s(%s' % (node.__class__.__name__, ', '.join(
                ('%s=%s' % field for field in fields)
                if annotate_fields else
                (b for a, b in fields)
            ))
            if include_attributes and node._attributes:
                rv += fields and ', ' or ' '
                rv += ', '.join('%s=%s' % (a, _format(getattr(node, a)))
                                for a in node._attributes)
            return rv + ')'
        elif isinstance(node, list):
            return '[%s]' % ', '.join(_format(x) for x in node)
        return repr(node)
    if not isinstance(node, AST):
        raise TypeError('expected AST, got %r' % node.__class__.__name__)
    return _format(node)


def copy_location(new_node, old_node):
    """
    Copy source location (`lineno` and `col_offset` attributes) from
    *old_node* to *new_node* if possible, and return *new_node*.
    """
    for attr in 'lineno', 'col_offset':
        if attr in old_node._attributes and attr in new_node._attributes \
           and hasattr(old_node, attr):
            setattr(new_node, attr, getattr(old_node, attr))
    return new_node


def fix_missing_locations(node):
    """
    When you compile a node tree with compile(), the compiler expects lineno and
    col_offset attributes for every node that supports them.  This is rather
    tedious to fill in for generated nodes, so this helper adds these attributes
    recursively where not already set, by setting them to the values of the
    parent node.  It works recursively starting at *node*.
    """
    def _fix(node, lineno, col_offset):
        if 'lineno' in node._attributes:
            if not hasattr(node, 'lineno'):
                node.lineno = lineno
            else:
                lineno = node.lineno
        if 'col_offset' in node._attributes:
            if not hasattr(node, 'col_offset'):
                node.col_offset = col_offset
            else:
                col_offset = node.col_offset
        for child in iter_child_nodes(node):
            _fix(child, lineno, col_offset)
    _fix(node, 1, 0)
    return node


def increment_lineno(node, n=1):
    """
    Increment the line number of each node in the tree starting at *node* by *n*.
    This is useful to "move code" to a different location in a file.
    """
    for child in walk(node):
        if 'lineno' in child._attributes:
            child.lineno = getattr(child, 'lineno', 0) + n
    return node


def iter_fields(node):
    """
    Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
    that is present on *node*.
    """
    for field in node._fields:
        try:
            yield field, getattr(node, field)
        except AttributeError:
            pass


def iter_child_nodes(node):
    """
    Yield all direct child nodes of *node*, that is, all fields that are nodes
    and all items of fields that are lists of nodes.
    """
    for name, field in iter_fields(node):
        if isinstance(field, AST):
            yield field
        elif isinstance(field, list):
            for item in field:
                if isinstance(item, AST):
                    yield item


def get_docstring(node, clean=True):
    """
    Return the docstring for the given node or None if no docstring can
    be found.  If the node provided does not have docstrings a TypeError
    will be raised.
    """
    if not isinstance(node, (FunctionDef, ClassDef, Module)):
        raise TypeError("%r can't have docstrings" % node.__class__.__name__)
    if node.body and isinstance(node.body[0], Expr) and \
       isinstance(node.body[0].value, Str):
        if clean:
            import inspect
            return inspect.cleandoc(node.body[0].value.s)
        return node.body[0].value.s


def walk(node):
    """
    Recursively yield all descendant nodes in the tree starting at *node*
    (including *node* itself), in no specified order.  This is useful if you
    only want to modify nodes in place and don't care about the context.
    """
    from collections import deque
    todo = deque([node])
    while todo:
        node = todo.popleft()
        todo.extend(iter_child_nodes(node))
        yield node


class NodeVisitor(object):
    """
    A node visitor base class that walks the abstract syntax tree and calls a
    visitor function for every node found.  This function may return a value
    which is forwarded by the `visit` method.

    This class is meant to be subclassed, with the subclass adding visitor
    methods.

    Per default the visitor functions for the nodes are ``'visit_'`` +
    class name of the node.  So a `TryFinally` node visit function would
    be `visit_TryFinally`.  This behavior can be changed by overriding
    the `visit` method.  If no visitor function exists for a node
    (return value `None`) the `generic_visit` visitor is used instead.

    Don't use the `NodeVisitor` if you want to apply changes to nodes during
    traversing.  For this a special visitor exists (`NodeTransformer`) that
    allows modifications.
    """

    def visit(self, node):
        """Visit a node."""
        method = 'visit_' + node.__class__.__name__
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        """Called if no explicit visitor function exists for a node."""
        for field, value in iter_fields(node):
            if isinstance(value, list):
                for item in value:
                    if isinstance(item, AST):
                        self.visit(item)
            elif isinstance(value, AST):
                self.visit(value)


class NodeTransformer(NodeVisitor):
    """
    A :class:`NodeVisitor` subclass that walks the abstract syntax tree and
    allows modification of nodes.

    The `NodeTransformer` will walk the AST and use the return value of the
    visitor methods to replace or remove the old node.  If the return value of
    the visitor method is ``None``, the node will be removed from its location,
    otherwise it is replaced with the return value.  The return value may be the
    original node in which case no replacement takes place.

    Here is an example transformer that rewrites all occurrences of name lookups
    (``foo``) to ``data['foo']``::

       class RewriteName(NodeTransformer):

           def visit_Name(self, node):
               return copy_location(Subscript(
                   value=Name(id='data', ctx=Load()),
                   slice=Index(value=Str(s=node.id)),
                   ctx=node.ctx
               ), node)

    Keep in mind that if the node you're operating on has child nodes you must
    either transform the child nodes yourself or call the :meth:`generic_visit`
    method for the node first.

    For nodes that were part of a collection of statements (that applies to all
    statement nodes), the visitor may also return a list of nodes rather than
    just a single node.

    Usually you use the transformer like this::

       node = YourTransformer().visit(node)
    """

    def generic_visit(self, node):
        for field, old_value in iter_fields(node):
            old_value = getattr(node, field, None)
            if isinstance(old_value, list):
                new_values = []
                for value in old_value:
                    if isinstance(value, AST):
                        value = self.visit(value)
                        if value is None:
                            continue
                        elif not isinstance(value, AST):
                            new_values.extend(value)
                            continue
                    new_values.append(value)
                old_value[:] = new_values
            elif isinstance(old_value, AST):
                new_node = self.visit(old_value)
                if new_node is None:
                    delattr(node, field)
                else:
                    setattr(node, field, new_node)
        return node
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   sº   d  Z  d d l Td d l m Z d d d Ñ Z d Ñ  Z e e d Ñ Z d	 Ñ  Z d
 Ñ  Z	 d d Ñ Z
 d Ñ  Z d Ñ  Z e d Ñ Z d Ñ  Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(   sH  
    ast
    ~~~

    The `ast` module helps Python applications to process trees of the Python
    abstract syntax grammar.  The abstract syntax itself might change with
    each Python release; this module helps to find out programmatically what
    the current grammar looks like and allows modifications of it.

    An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
    a flag to the `compile()` builtin function or by using the `parse()`
    function from this module.  The result will be a tree of objects whose
    classes all inherit from `ast.AST`.

    A modified abstract syntax tree can be compiled into a Python code object
    using the built-in `compile()` function.

    Additionally various helper functions are provided that make working with
    the trees simpler.  The main intention of the helper functions and this
    module in general is to provide an easy to use interface for libraries
    that work tightly with the python syntax (template engines for example).


    :copyright: Copyright 2008 by Armin Ronacher.
    :license: Python License.
iˇˇˇˇ(   t   *(   t   __version__s	   <unknown>t   execc         C   s   t  |  | | t É S(   sn   
    Parse the source into an AST node.
    Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
    (   t   compilet   PyCF_ONLY_AST(   t   sourcet   filenamet   mode(    (    s   /usr/lib/python2.7/ast.pyt   parse    s    c            sv   i d d 6t d 6t d 6â t |  t É r? t |  d d É}  n  t |  t É rZ |  j }  n  á  á f d Ü  â  à  |  É S(   s˙   
    Safely evaluate an expression node or a string containing a Python
    expression.  The string or node provided may only consist of the following
    Python literal structures: strings, numbers, tuples, lists, dicts, booleans,
    and None.
    t   Nonet   Truet   FalseR   t   evalc            s•  t  |  t É r |  j St  |  t É r, |  j St  |  t É rQ t t à  |  j É É St  |  t	 É rv t
 t à  |  j É É St  |  t É rÆ t á  f d Ü  t |  j |  j É DÉ É St  |  t É r⁄ |  j à k rïà |  j Snª t  |  t É rït  |  j t t f É rït  |  j t É rït  |  j j t É rït  |  j t É rït  |  j j t t t f É rï|  j j } |  j j } t  |  j t É rä| | S| | Sn  t d É Ç d  S(   Nc         3   s-   |  ]# \ } } à  | É à  | É f Vq d  S(   N(    (   t   .0t   kt   v(   t   _convert(    s   /usr/lib/python2.7/ast.pys	   <genexpr>>   s    s   malformed string(   t
   isinstancet   Strt   st   Numt   nt   Tuplet   tuplet   mapt   eltst   Listt   listt   Dictt   dictt   zipt   keyst   valuest   Namet   idt   BinOpt   opt   Addt   Subt   rightt   complext   leftt   intt   longt   floatt
   ValueError(   t   nodeR)   R'   (   R   t   _safe_names(    s   /usr/lib/python2.7/ast.pyR   4   s4    N(   R	   R
   R   R   t
   basestringR   t
   Expressiont   body(   t   node_or_string(    (   R   R/   s   /usr/lib/python2.7/ast.pyt   literal_eval(   s    c            sG   á  á á f d Ü  â  t  |  t É s= t d |  j j É Ç n  à  |  É S(   sª  
    Return a formatted dump of the tree in *node*.  This is mainly useful for
    debugging purposes.  The returned string will show the names and the values
    for fields.  This makes the code impossible to evaluate, so if evaluation is
    wanted *annotate_fields* must be set to False.  Attributes such as line
    numbers and column offsets are not dumped by default.  If this is wanted,
    *include_attributes* can be set to True.
    c            s  t  à  t É rÿ g  t à  É D] \ } } | à | É f ^ q } d à  j j d j à rh d Ñ  | DÉ n d Ñ  | DÉ É f } à r– à  j r– | | rù d p† d 7} | d j á á  f d Ü  à  j DÉ É 7} n  | d St  à  t É rd d j á f d	 Ü  à  DÉ É St à  É S(
   Ns   %s(%ss   , c         s   s   |  ] } d  | Vq d S(   s   %s=%sN(    (   R   t   field(    (    s   /usr/lib/python2.7/ast.pys	   <genexpr>`   s    c         s   s   |  ] \ } } | Vq d  S(   N(    (   R   t   at   b(    (    s   /usr/lib/python2.7/ast.pys	   <genexpr>b   s    t    c         3   s.   |  ]$ } d  | à  t  à | É É f Vq d S(   s   %s=%sN(   t   getattr(   R   R6   (   t   _formatR.   (    s   /usr/lib/python2.7/ast.pys	   <genexpr>f   s   t   )s   [%s]c         3   s   |  ] } à  | É Vq d  S(   N(    (   R   t   x(   R:   (    s   /usr/lib/python2.7/ast.pys	   <genexpr>j   s    (	   R   t   ASTt   iter_fieldst	   __class__t   __name__t   joint   _attributesR   t   repr(   R.   R6   R7   t   fieldst   rv(   R:   t   annotate_fieldst   include_attributes(   R.   s   /usr/lib/python2.7/ast.pyR:   \   s    1!s   expected AST, got %r(   R   R=   t	   TypeErrorR?   R@   (   R.   RF   RG   (    (   R:   RF   RG   s   /usr/lib/python2.7/ast.pyt   dumpS   s    	c         C   s^   xW d D]O } | | j  k r | |  j  k r t | | É r t |  | t | | É É q q W|  S(   sã   
    Copy source location (`lineno` and `col_offset` attributes) from
    *old_node* to *new_node* if possible, and return *new_node*.
    t   linenot
   col_offset(   RJ   RK   (   RB   t   hasattrt   setattrR9   (   t   new_nodet   old_nodet   attr(    (    s   /usr/lib/python2.7/ast.pyt   copy_locationq   s
     c            s#   á  f d Ü  â  à  |  d d É |  S(   s{  
    When you compile a node tree with compile(), the compiler expects lineno and
    col_offset attributes for every node that supports them.  This is rather
    tedious to fill in for generated nodes, so this helper adds these attributes
    recursively where not already set, by setting them to the values of the
    parent node.  It works recursively starting at *node*.
    c            só   d |  j  k r6 t |  d É s* | |  _ q6 |  j } n  d |  j  k rl t |  d É s` | |  _ ql |  j } n  x$ t |  É D] } à  | | | É qy Wd  S(   NRJ   RK   (   RB   RL   RJ   RK   t   iter_child_nodes(   R.   RJ   RK   t   child(   t   _fix(    s   /usr/lib/python2.7/ast.pyRT   Ö   s    i   i    (    (   R.   (    (   RT   s   /usr/lib/python2.7/ast.pyt   fix_missing_locations}   s    i   c         C   sF   x? t  |  É D]1 } d | j k r t | d d É | | _ q q W|  S(   sú   
    Increment the line number of each node in the tree starting at *node* by *n*.
    This is useful to "move code" to a different location in a file.
    RJ   i    (   t   walkRB   R9   RJ   (   R.   R   RS   (    (    s   /usr/lib/python2.7/ast.pyt   increment_linenoñ   s     c         c   sD   x= |  j  D]2 } y | t |  | É f VWq
 t k
 r; q
 Xq
 Wd S(   ss   
    Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
    that is present on *node*.
    N(   t   _fieldsR9   t   AttributeError(   R.   R5   (    (    s   /usr/lib/python2.7/ast.pyR>   °   s
    c         c   sr   xk t  |  É D]] \ } } t | t É r0 | Vq t | t É r x( | D] } t | t É rF | VqF qF Wq q Wd S(   sâ   
    Yield all direct child nodes of *node*, that is, all fields that are nodes
    and all items of fields that are lists of nodes.
    N(   R>   R   R=   R   (   R.   t   nameR5   t   item(    (    s   /usr/lib/python2.7/ast.pyRR   ≠   s    c         C   s™   t  |  t t t f É s1 t d |  j j É Ç n  |  j r¶ t  |  j d t É r¶ t  |  j d j	 t
 É r¶ | rï d d l } | j |  j d j	 j É S|  j d j	 j Sd S(   s™   
    Return the docstring for the given node or None if no docstring can
    be found.  If the node provided does not have docstrings a TypeError
    will be raised.
    s   %r can't have docstringsi    iˇˇˇˇN(   R   t   FunctionDeft   ClassDeft   ModuleRH   R?   R@   R2   t   Exprt   valueR   t   inspectt   cleandocR   (   R.   t   cleanRa   (    (    s   /usr/lib/python2.7/ast.pyt   get_docstringª   s    c         c   sT   d d l  m } | |  g É } x. | rO | j É  }  | j t |  É É |  Vq" Wd S(   sÂ   
    Recursively yield all descendant nodes in the tree starting at *node*
    (including *node* itself), in no specified order.  This is useful if you
    only want to modify nodes in place and don't care about the context.
    iˇˇˇˇ(   t   dequeN(   t   collectionsRe   t   popleftt   extendRR   (   R.   Re   t   todo(    (    s   /usr/lib/python2.7/ast.pyRV   À   s    	t   NodeVisitorc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s<  
    A node visitor base class that walks the abstract syntax tree and calls a
    visitor function for every node found.  This function may return a value
    which is forwarded by the `visit` method.

    This class is meant to be subclassed, with the subclass adding visitor
    methods.

    Per default the visitor functions for the nodes are ``'visit_'`` +
    class name of the node.  So a `TryFinally` node visit function would
    be `visit_TryFinally`.  This behavior can be changed by overriding
    the `visit` method.  If no visitor function exists for a node
    (return value `None`) the `generic_visit` visitor is used instead.

    Don't use the `NodeVisitor` if you want to apply changes to nodes during
    traversing.  For this a special visitor exists (`NodeTransformer`) that
    allows modifications.
    c         C   s/   d | j  j } t |  | |  j É } | | É S(   s   Visit a node.t   visit_(   R?   R@   R9   t   generic_visit(   t   selfR.   t   methodt   visitor(    (    s   /usr/lib/python2.7/ast.pyt   visitÌ   s    c         C   sÇ   x{ t  | É D]m \ } } t | t É r[ xO | D]% } t | t É r/ |  j | É q/ q/ Wq t | t É r |  j | É q q Wd S(   s9   Called if no explicit visitor function exists for a node.N(   R>   R   R   R=   Rp   (   Rm   R.   R5   R`   R[   (    (    s   /usr/lib/python2.7/ast.pyRl   Û   s    (   R@   t
   __module__t   __doc__Rp   Rl   (    (    (    s   /usr/lib/python2.7/ast.pyRj   Ÿ   s   	t   NodeTransformerc           B   s   e  Z d  Z d Ñ  Z RS(   s\  
    A :class:`NodeVisitor` subclass that walks the abstract syntax tree and
    allows modification of nodes.

    The `NodeTransformer` will walk the AST and use the return value of the
    visitor methods to replace or remove the old node.  If the return value of
    the visitor method is ``None``, the node will be removed from its location,
    otherwise it is replaced with the return value.  The return value may be the
    original node in which case no replacement takes place.

    Here is an example transformer that rewrites all occurrences of name lookups
    (``foo``) to ``data['foo']``::

       class RewriteName(NodeTransformer):

           def visit_Name(self, node):
               return copy_location(Subscript(
                   value=Name(id='data', ctx=Load()),
                   slice=Index(value=Str(s=node.id)),
                   ctx=node.ctx
               ), node)

    Keep in mind that if the node you're operating on has child nodes you must
    either transform the child nodes yourself or call the :meth:`generic_visit`
    method for the node first.

    For nodes that were part of a collection of statements (that applies to all
    statement nodes), the visitor may also return a list of nodes rather than
    just a single node.

    Usually you use the transformer like this::

       node = YourTransformer().visit(node)
    c         C   s  xt  | É D]˝ \ } } t | | d  É } t | t É rΩ g  } xp | D]h } t | t É r¢ |  j | É } | d  k r} qG q¢ t | t É s¢ | j | É qG q¢ n  | j | É qG W| | (q t | t É r |  j | É } | d  k r˜ t	 | | É q
t
 | | | É q q W| S(   N(   R>   R9   R	   R   R   R=   Rp   Rh   t   appendt   delattrRM   (   Rm   R.   R5   t	   old_valuet
   new_valuesR`   RN   (    (    s   /usr/lib/python2.7/ast.pyRl   "  s(    	
(   R@   Rq   Rr   Rl   (    (    (    s   /usr/lib/python2.7/ast.pyRs   ˛   s   "N(   Rr   t   _astR   R   R4   R
   R   RI   RQ   RU   RW   R>   RR   Rd   RV   t   objectRj   Rs   (    (    (    s   /usr/lib/python2.7/ast.pyt   <module>   s   
	+					%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # -*- Mode: Python; tab-width: 4 -*-
#       Id: asynchat.py,v 2.26 2000/09/07 22:29:26 rushing Exp
#       Author: Sam Rushing <rushing@nightmare.com>

# ======================================================================
# Copyright 1996 by Sam Rushing
#
#                         All Rights Reserved
#
# Permission to use, copy, modify, and distribute this software and
# its documentation for any purpose and without fee is hereby
# granted, provided that the above copyright notice appear in all
# copies and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of Sam
# Rushing not be used in advertising or publicity pertaining to
# distribution of the software without specific, written prior
# permission.
#
# SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
# NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# ======================================================================

r"""A class supporting chat-style (command/response) protocols.

This class adds support for 'chat' style protocols - where one side
sends a 'command', and the other sends a response (examples would be
the common internet protocols - smtp, nntp, ftp, etc..).

The handle_read() method looks at the input stream for the current
'terminator' (usually '\r\n' for single-line responses, '\r\n.\r\n'
for multi-line output), calling self.found_terminator() on its
receipt.

for example:
Say you build an async nntp client using this class.  At the start
of the connection, you'll have self.terminator set to '\r\n', in
order to process the single-line greeting.  Just before issuing a
'LIST' command you'll set it to '\r\n.\r\n'.  The output of the LIST
command will be accumulated (using your own 'collect_incoming_data'
method) up to the terminator, and then control will be returned to
you - by calling your self.found_terminator() method.
"""

import asyncore
import errno
import socket
from collections import deque
from sys import py3kwarning
from warnings import filterwarnings, catch_warnings

_BLOCKING_IO_ERRORS = (errno.EAGAIN, errno.EALREADY, errno.EINPROGRESS,
                       errno.EWOULDBLOCK)


class async_chat (asyncore.dispatcher):
    """This is an abstract class.  You must derive from this class, and add
    the two methods collect_incoming_data() and found_terminator()"""

    # these are overridable defaults

    ac_in_buffer_size       = 4096
    ac_out_buffer_size      = 4096

    def __init__ (self, sock=None, map=None):
        # for string terminator matching
        self.ac_in_buffer = ''

        # we use a list here rather than cStringIO for a few reasons...
        # del lst[:] is faster than sio.truncate(0)
        # lst = [] is faster than sio.truncate(0)
        # cStringIO will be gaining unicode support in py3k, which
        # will negatively affect the performance of bytes compared to
        # a ''.join() equivalent
        self.incoming = []

        # we toss the use of the "simple producer" and replace it with
        # a pure deque, which the original fifo was a wrapping of
        self.producer_fifo = deque()
        asyncore.dispatcher.__init__ (self, sock, map)

    def collect_incoming_data(self, data):
        raise NotImplementedError("must be implemented in subclass")

    def _collect_incoming_data(self, data):
        self.incoming.append(data)

    def _get_data(self):
        d = ''.join(self.incoming)
        del self.incoming[:]
        return d

    def found_terminator(self):
        raise NotImplementedError("must be implemented in subclass")

    def set_terminator (self, term):
        "Set the input delimiter.  Can be a fixed string of any length, an integer, or None"
        self.terminator = term

    def get_terminator (self):
        return self.terminator

    # grab some more data from the socket,
    # throw it to the collector method,
    # check for the terminator,
    # if found, transition to the next state.

    def handle_read (self):

        try:
            data = self.recv (self.ac_in_buffer_size)
        except socket.error, why:
            if why.args[0] in _BLOCKING_IO_ERRORS:
                return
            self.handle_error()
            return

        self.ac_in_buffer = self.ac_in_buffer + data

        # Continue to search for self.terminator in self.ac_in_buffer,
        # while calling self.collect_incoming_data.  The while loop
        # is necessary because we might read several data+terminator
        # combos with a single recv(4096).

        while self.ac_in_buffer:
            lb = len(self.ac_in_buffer)
            terminator = self.get_terminator()
            if not terminator:
                # no terminator, collect it all
                self.collect_incoming_data (self.ac_in_buffer)
                self.ac_in_buffer = ''
            elif isinstance(terminator, int) or isinstance(terminator, long):
                # numeric terminator
                n = terminator
                if lb < n:
                    self.collect_incoming_data (self.ac_in_buffer)
                    self.ac_in_buffer = ''
                    self.terminator = self.terminator - lb
                else:
                    self.collect_incoming_data (self.ac_in_buffer[:n])
                    self.ac_in_buffer = self.ac_in_buffer[n:]
                    self.terminator = 0
                    self.found_terminator()
            else:
                # 3 cases:
                # 1) end of buffer matches terminator exactly:
                #    collect data, transition
                # 2) end of buffer matches some prefix:
                #    collect data to the prefix
                # 3) end of buffer does not match any prefix:
                #    collect data
                terminator_len = len(terminator)
                index = self.ac_in_buffer.find(terminator)
                if index != -1:
                    # we found the terminator
                    if index > 0:
                        # don't bother reporting the empty string (source of subtle bugs)
                        self.collect_incoming_data (self.ac_in_buffer[:index])
                    self.ac_in_buffer = self.ac_in_buffer[index+terminator_len:]
                    # This does the Right Thing if the terminator is changed here.
                    self.found_terminator()
                else:
                    # check for a prefix of the terminator
                    index = find_prefix_at_end (self.ac_in_buffer, terminator)
                    if index:
                        if index != lb:
                            # we found a prefix, collect up to the prefix
                            self.collect_incoming_data (self.ac_in_buffer[:-index])
                            self.ac_in_buffer = self.ac_in_buffer[-index:]
                        break
                    else:
                        # no prefix, collect it all
                        self.collect_incoming_data (self.ac_in_buffer)
                        self.ac_in_buffer = ''

    def handle_write (self):
        self.initiate_send()

    def handle_close (self):
        self.close()

    def push (self, data):
        sabs = self.ac_out_buffer_size
        if len(data) > sabs:
            for i in xrange(0, len(data), sabs):
                self.producer_fifo.append(data[i:i+sabs])
        else:
            self.producer_fifo.append(data)
        self.initiate_send()

    def push_with_producer (self, producer):
        self.producer_fifo.append(producer)
        self.initiate_send()

    def readable (self):
        "predicate for inclusion in the readable for select()"
        # cannot use the old predicate, it violates the claim of the
        # set_terminator method.

        # return (len(self.ac_in_buffer) <= self.ac_in_buffer_size)
        return 1

    def writable (self):
        "predicate for inclusion in the writable for select()"
        return self.producer_fifo or (not self.connected)

    def close_when_done (self):
        "automatically close this channel once the outgoing queue is empty"
        self.producer_fifo.append(None)

    def initiate_send(self):
        while self.producer_fifo and self.connected:
            first = self.producer_fifo[0]
            # handle empty string/buffer or None entry
            if not first:
                del self.producer_fifo[0]
                if first is None:
                    self.handle_close()
                    return

            # handle classic producer behavior
            obs = self.ac_out_buffer_size
            try:
                with catch_warnings():
                    if py3kwarning:
                        filterwarnings("ignore", ".*buffer", DeprecationWarning)
                    data = buffer(first, 0, obs)
            except TypeError:
                data = first.more()
                if data:
                    self.producer_fifo.appendleft(data)
                else:
                    del self.producer_fifo[0]
                continue

            # send the data
            try:
                num_sent = self.send(data)
            except socket.error:
                self.handle_error()
                return

            if num_sent:
                if num_sent < len(data) or obs < len(first):
                    self.producer_fifo[0] = first[num_sent:]
                else:
                    del self.producer_fifo[0]
            # we tried to send some actual data
            return

    def discard_buffers (self):
        # Emergencies only!
        self.ac_in_buffer = ''
        del self.incoming[:]
        self.producer_fifo.clear()

class simple_producer:

    def __init__ (self, data, buffer_size=512):
        self.data = data
        self.buffer_size = buffer_size

    def more (self):
        if len (self.data) > self.buffer_size:
            result = self.data[:self.buffer_size]
            self.data = self.data[self.buffer_size:]
            return result
        else:
            result = self.data
            self.data = ''
            return result

class fifo:
    def __init__ (self, list=None):
        if not list:
            self.list = deque()
        else:
            self.list = deque(list)

    def __len__ (self):
        return len(self.list)

    def is_empty (self):
        return not self.list

    def first (self):
        return self.list[0]

    def push (self, data):
        self.list.append(data)

    def pop (self):
        if self.list:
            return (1, self.list.popleft())
        else:
            return (0, None)

# Given 'haystack', see if any prefix of 'needle' is at its end.  This
# assumes an exact match has already been checked.  Return the number of
# characters matched.
# for example:
# f_p_a_e ("qwerty\r", "\r\n") => 1
# f_p_a_e ("qwertydkjf", "\r\n") => 0
# f_p_a_e ("qwerty\r\n", "\r\n") => <undefined>

# this could maybe be made faster with a computed regex?
# [answer: no; circa Python-2.0, Jan 2001]
# new python:   28961/s
# old python:   18307/s
# re:        12820/s
# regex:     14035/s

def find_prefix_at_end (haystack, needle):
    l = len(needle) - 1
    while l and not haystack.endswith(needle[:l]):
        l -= 1
    return l
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   s    d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 m
 Z
 e j e j e j e j f Z d e j f d Ñ  É  YZ d d d	 Ñ  É  YZ d
 d d Ñ  É  YZ d Ñ  Z d S(   s•  A class supporting chat-style (command/response) protocols.

This class adds support for 'chat' style protocols - where one side
sends a 'command', and the other sends a response (examples would be
the common internet protocols - smtp, nntp, ftp, etc..).

The handle_read() method looks at the input stream for the current
'terminator' (usually '\r\n' for single-line responses, '\r\n.\r\n'
for multi-line output), calling self.found_terminator() on its
receipt.

for example:
Say you build an async nntp client using this class.  At the start
of the connection, you'll have self.terminator set to '\r\n', in
order to process the single-line greeting.  Just before issuing a
'LIST' command you'll set it to '\r\n.\r\n'.  The output of the LIST
command will be accumulated (using your own 'collect_incoming_data'
method) up to the terminator, and then control will be returned to
you - by calling your self.found_terminator() method.
iˇˇˇˇN(   t   deque(   t   py3kwarning(   t   filterwarningst   catch_warningst
   async_chatc           B   sπ   e  Z d  Z d Z d Z d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sá   This is an abstract class.  You must derive from this class, and add
    the two methods collect_incoming_data() and found_terminator()i   c         C   s8   d |  _  g  |  _ t É  |  _ t j j |  | | É d  S(   Nt    (   t   ac_in_buffert   incomingR    t   producer_fifot   asyncoret
   dispatchert   __init__(   t   selft   sockt   map(    (    s   /usr/lib/python2.7/asynchat.pyR   E   s    		c         C   s   t  d É Ç d  S(   Ns   must be implemented in subclass(   t   NotImplementedError(   R   t   data(    (    s   /usr/lib/python2.7/asynchat.pyt   collect_incoming_dataV   s    c         C   s   |  j  j | É d  S(   N(   R   t   append(   R   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   _collect_incoming_dataY   s    c         C   s   d j  |  j É } |  j 2| S(   NR   (   t   joinR   (   R   t   d(    (    s   /usr/lib/python2.7/asynchat.pyt	   _get_data\   s    c         C   s   t  d É Ç d  S(   Ns   must be implemented in subclass(   R   (   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   found_terminatora   s    c         C   s   | |  _  d S(   sR   Set the input delimiter.  Can be a fixed string of any length, an integer, or NoneN(   t
   terminator(   R   t   term(    (    s   /usr/lib/python2.7/asynchat.pyt   set_terminatord   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   get_terminatorh   s    c         C   s   y |  j  |  j É } Wn8 t j k
 rP } | j d t k rB d  S|  j É  d  SX|  j | |  _ x∏|  j rt |  j É } |  j	 É  } | s™ |  j
 |  j É d |  _ qd t | t É s» t | t É r@| } | | k  r|  j
 |  j É d |  _ |  j | |  _ q|  j
 |  j |  É |  j | |  _ d |  _ |  j É  qd t | É } |  j j | É } | d k rÆ| d k rç|  j
 |  j |  É n  |  j | | |  _ |  j É  qd t |  j | É } | rˇ| | k r˚|  j
 |  j |  É |  j | |  _ n  Pqd |  j
 |  j É d |  _ qd Wd  S(   Ni    R   iˇˇˇˇ(   t   recvt   ac_in_buffer_sizet   sockett   errort   argst   _BLOCKING_IO_ERRORSt   handle_errorR   t   lenR   R   t
   isinstancet   intt   longR   R   t   findt   find_prefix_at_end(   R   R   t   whyt   lbR   t   nt   terminator_lent   index(    (    s   /usr/lib/python2.7/asynchat.pyt   handle_readp   sN    
			c         C   s   |  j  É  d  S(   N(   t   initiate_send(   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   handle_write¥   s    c         C   s   |  j  É  d  S(   N(   t   close(   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   handle_close∑   s    c         C   sz   |  j  } t | É | k r\ xN t d t | É | É D]! } |  j j | | | | !É q4 Wn |  j j | É |  j É  d  S(   Ni    (   t   ac_out_buffer_sizeR#   t   xrangeR   R   R/   (   R   R   t   sabst   i(    (    s   /usr/lib/python2.7/asynchat.pyt   push∫   s    	"c         C   s   |  j  j | É |  j É  d  S(   N(   R   R   R/   (   R   t   producer(    (    s   /usr/lib/python2.7/asynchat.pyt   push_with_producer√   s    c         C   s   d S(   s4   predicate for inclusion in the readable for select()i   (    (   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   readable«   s    c         C   s   |  j  p |  j S(   s4   predicate for inclusion in the writable for select()(   R   t	   connected(   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   writableœ   s    c         C   s   |  j  j d É d S(   sA   automatically close this channel once the outgoing queue is emptyN(   R   R   t   None(   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   close_when_done”   s    c         C   sf  x_|  j  ra|  j ra|  j  d } | sO |  j  d =| d  k rO |  j É  d  Sn  |  j } y? t É  è0 t r~ t d d t É n  t	 | d | É } Wd  QXWnC t
 k
 r‹ | j É  } | rÃ |  j  j | É q |  j  d =q n Xy |  j | É } Wn t j k
 r|  j É  d  SX| r]| t | É k  s<| t | É k  rP| | |  j  d <q]|  j  d =n  d  SWd  S(   Ni    t   ignores   .*buffer(   R   R;   R=   R2   R3   R   R   R   t   DeprecationWarningt   buffert	   TypeErrort   moret
   appendleftt   sendR   R   R"   R#   (   R   t   firstt   obsR   t   num_sent(    (    s   /usr/lib/python2.7/asynchat.pyR/   ◊   s:    

	


$c         C   s!   d |  _  |  j 2|  j j É  d  S(   NR   (   R   R   R   t   clear(   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   discard_buffersˇ   s    	N(   t   __name__t
   __module__t   __doc__R   R3   R=   R   R   R   R   R   R   R   R.   R0   R2   R7   R9   R:   R<   R>   R/   RJ   (    (    (    s   /usr/lib/python2.7/asynchat.pyR   <   s(   							D									(t   simple_producerc           B   s   e  Z d  d Ñ Z d Ñ  Z RS(   i   c         C   s   | |  _  | |  _ d  S(   N(   R   t   buffer_size(   R   R   RO   (    (    s   /usr/lib/python2.7/asynchat.pyR     s    	c         C   sY   t  |  j É |  j k r? |  j |  j  } |  j |  j |  _ | S|  j } d |  _ | Sd  S(   NR   (   R#   R   RO   (   R   t   result(    (    s   /usr/lib/python2.7/asynchat.pyRC     s    		(   RK   RL   R   RC   (    (    (    s   /usr/lib/python2.7/asynchat.pyRN     s   t   fifoc           B   sA   e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s(   | s t  É  |  _ n t  | É |  _ d  S(   N(   R    t   list(   R   RR   (    (    s   /usr/lib/python2.7/asynchat.pyR     s    c         C   s   t  |  j É S(   N(   R#   RR   (   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   __len__  s    c         C   s   |  j  S(   N(   RR   (   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   is_empty  s    c         C   s   |  j  d S(   Ni    (   RR   (   R   (    (    s   /usr/lib/python2.7/asynchat.pyRF   "  s    c         C   s   |  j  j | É d  S(   N(   RR   R   (   R   R   (    (    s   /usr/lib/python2.7/asynchat.pyR7   %  s    c         C   s$   |  j  r d |  j  j É  f Sd Sd  S(   Ni   i    (   i    N(   RR   t   popleftR=   (   R   (    (    s   /usr/lib/python2.7/asynchat.pyt   pop(  s    	N(	   RK   RL   R=   R   RS   RT   RF   R7   RV   (    (    (    s   /usr/lib/python2.7/asynchat.pyRQ     s   				c         C   s?   t  | É d } x( | r: |  j | |  É r: | d 8} q W| S(   Ni   (   R#   t   endswith(   t   haystackt   needlet   l(    (    s   /usr/lib/python2.7/asynchat.pyR(   =  s    (    (    (   RM   R	   t   errnoR   t   collectionsR    t   sysR   t   warningsR   R   t   EAGAINt   EALREADYt   EINPROGRESSt   EWOULDBLOCKR!   R
   R   RN   RQ   R(   (    (    (    s   /usr/lib/python2.7/asynchat.pyt   <module>/   s   …(                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   s¿   d  Z  d g Z d d l Z g  Z d Ñ  Z d Ñ  Z e e d É rR e e j É n  e e _ e d k rº d Ñ  Z	 d	 Ñ  Z
 d d
 Ñ Z e e	 É e e
 d É e e d d É e e d É n  d S(   sú   
atexit.py - allow programmer to define multiple exit functions to be executed
upon normal program termination.

One public function, register, is defined.
t   registeriˇˇˇˇNc          C   sπ   d }  xÖ t rç t j É  \ } } } y | | | é  Wq	 t k
 rT t j É  }  q	 d d l } t j d IJ| j É  t j É  }  q	 Xq	 W|  d k	 rµ |  d |  d |  d Ç n  d S(   sâ   run any registered exit functions

    _exithandlers is traversed in reverse order so functions are executed
    last in, first out.
    iˇˇˇˇNs   Error in atexit._run_exitfuncs:i    i   i   (	   t   Nonet   _exithandlerst   popt
   SystemExitt   syst   exc_infot	   tracebackt   stderrt	   print_exc(   R   t   funct   targst   kargsR   (    (    s   /usr/lib/python2.7/atexit.pyt   _run_exitfuncs   s    	
c         O   s   t  j |  | | f É |  S(   s  register a function to be executed upon normal program termination

    func - function to be called at exit
    targs - optional arguments to pass to func
    kargs - optional keyword arguments to pass to func

    func is returned to facilitate usage as a decorator.
    (   R   t   append(   R
   R   R   (    (    s   /usr/lib/python2.7/atexit.pyR    %   s    	t   exitfunct   __main__c           C   s	   d GHd  S(   Ns
   running x1(    (    (    (    s   /usr/lib/python2.7/atexit.pyt   x17   s    c         C   s   d |  f GHd  S(   Ns   running x2(%r)(    (   t   n(    (    s   /usr/lib/python2.7/atexit.pyt   x29   s    c         C   s   d |  | f GHd  S(   Ns   running x3(%r, kwd=%r)(    (   R   t   kwd(    (    s   /usr/lib/python2.7/atexit.pyt   x3;   s    i   i   t   bars   no kwd args(   t   __doc__t   __all__R   R   R   R    t   hasattrR   t   __name__R   R   R   R   (    (    (    s   /usr/lib/python2.7/atexit.pyt   <module>   s    						
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """Bisection algorithms."""

def insort_right(a, x, lo=0, hi=None):
    """Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the right of the rightmost x.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if x < a[mid]: hi = mid
        else: lo = mid+1
    a.insert(lo, x)

insort = insort_right   # backward compatibility

def bisect_right(a, x, lo=0, hi=None):
    """Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e <= x, and all e in
    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will
    insert just after the rightmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if x < a[mid]: hi = mid
        else: lo = mid+1
    return lo

bisect = bisect_right   # backward compatibility

def insort_left(a, x, lo=0, hi=None):
    """Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the left of the leftmost x.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x: lo = mid+1
        else: hi = mid
    a.insert(lo, x)


def bisect_left(a, x, lo=0, hi=None):
    """Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in
    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will
    insert just before the leftmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x: lo = mid+1
        else: hi = mid
    return lo

# Overwrite above definitions with a fast C implementation
try:
    from _bisect import *
except ImportError:
    pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Û
”´[c           @   sˆ  d  Z  d Z d d d d d d d d	 d
 d d d d d d d g Z d d l Z d d l Z d d l Z d d l	 Z
 d d l Z d d l Z d d l m Z d Ñ  Z d Z d Z d Z d Z d Z d Z d Z d e f d Ñ  É  YZ d Ñ  Z d e f d  Ñ  É  YZ d e f d! Ñ  É  YZ d	 e f d" Ñ  É  YZ d e f d# Ñ  É  YZ d$ Ñ  Z  d e! f d% Ñ  É  YZ" d e! f d& Ñ  É  YZ# d e f d' Ñ  É  YZ$ d( e$ f d) Ñ  É  YZ% d* e$ f d+ Ñ  É  YZ& d, e& f d- Ñ  É  YZ' d. e& f d/ Ñ  É  YZ( d0 e$ f d1 Ñ  É  YZ) d2 e$ f d3 Ñ  É  YZ* d4 e$ f d5 Ñ  É  YZ+ d6 e$ f d7 Ñ  É  YZ, d8 e$ f d9 Ñ  É  YZ- d: e$ f d; Ñ  É  YZ. d e f d< Ñ  É  YZ/ d
 e f d= Ñ  É  YZ0 d> e f d? Ñ  É  YZ1 d@ e1 f dA Ñ  É  YZ2 dB e2 f dC Ñ  É  YZ3 d e e1 f dD Ñ  É  YZ4 d S(E   s˚
  Command-line parsing library

This module is an optparse-inspired command-line parsing library that:

    - handles both optional and positional arguments
    - produces highly informative usage messages
    - supports parsers that dispatch to sub-parsers

The following is a simple usage example that sums integers from the
command-line and writes the result to a file::

    parser = argparse.ArgumentParser(
        description='sum the integers at the command line')
    parser.add_argument(
        'integers', metavar='int', nargs='+', type=int,
        help='an integer to be summed')
    parser.add_argument(
        '--log', default=sys.stdout, type=argparse.FileType('w'),
        help='the file where the sum should be written')
    args = parser.parse_args()
    args.log.write('%s' % sum(args.integers))
    args.log.close()

The module contains the following public classes:

    - ArgumentParser -- The main entry point for command-line parsing. As the
        example above shows, the add_argument() method is used to populate
        the parser with actions for optional and positional arguments. Then
        the parse_args() method is invoked to convert the args at the
        command-line into an object with attributes.

    - ArgumentError -- The exception raised by ArgumentParser objects when
        there are errors with the parser's actions. Errors raised while
        parsing the command-line are caught by ArgumentParser and emitted
        as command-line messages.

    - FileType -- A factory for defining types of files to be created. As the
        example above shows, instances of FileType are typically passed as
        the type= argument of add_argument() calls.

    - Action -- The base class for parser actions. Typically actions are
        selected by passing strings like 'store_true' or 'append_const' to
        the action= argument of add_argument(). However, for greater
        customization of ArgumentParser actions, subclasses of Action may
        be defined and passed as the action= argument.

    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
        ArgumentDefaultsHelpFormatter -- Formatter classes which
        may be passed as the formatter_class= argument to the
        ArgumentParser constructor. HelpFormatter is the default,
        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
        not to change the formatting for help text, and
        ArgumentDefaultsHelpFormatter adds information about argument defaults
        to the help.

All other classes in this module are considered implementation details.
(Also note that HelpFormatter and RawDescriptionHelpFormatter are only
considered public as object names -- the API of the formatter objects is
still considered an implementation detail.)
s   1.1t   ArgumentParsert   ArgumentErrort   ArgumentTypeErrort   FileTypet   HelpFormattert   ArgumentDefaultsHelpFormattert   RawDescriptionHelpFormattert   RawTextHelpFormattert	   Namespacet   Actiont   ONE_OR_MOREt   OPTIONALt   PARSERt	   REMAINDERt   SUPPRESSt   ZERO_OR_MOREiˇˇˇˇN(   t   gettextc         C   s   t  |  d É p t  |  d É S(   Nt   __call__t	   __bases__(   t   hasattr(   t   obj(    (    s   /usr/lib/python2.7/argparse.pyt	   _callable_   s    s   ==SUPPRESS==t   ?t   *t   +s   A...s   ...t   _unrecognized_argst   _AttributeHolderc           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s  Abstract base class that provides __repr__.

    The __repr__ method returns a string in the format::
        ClassName(attr=name, attr=name, ...)
    The attributes are determined either by a class-level attribute,
    '_kwarg_names', or by inspecting the instance __dict__.
    c         C   sä   t  |  É j } g  } x' |  j É  D] } | j t | É É q" Wx1 |  j É  D]# \ } } | j d | | f É qL Wd | d j | É f S(   Ns   %s=%rs   %s(%s)s   , (   t   typet   __name__t	   _get_argst   appendt   reprt   _get_kwargst   join(   t   selft	   type_namet   arg_stringst   argt   namet   value(    (    s   /usr/lib/python2.7/argparse.pyt   __repr__y   s    c         C   s   t  |  j j É  É S(   N(   t   sortedt   __dict__t   items(   R"   (    (    s   /usr/lib/python2.7/argparse.pyR    Ç   s    c         C   s   g  S(   N(    (   R"   (    (    s   /usr/lib/python2.7/argparse.pyR   Ö   s    (   R   t
   __module__t   __doc__R(   R    R   (    (    (    s   /usr/lib/python2.7/argparse.pyR   p   s   			c         C   s8   t  |  | d  É d  k r+ t |  | | É n  t  |  | É S(   N(   t   getattrt   Nonet   setattr(   t	   namespaceR&   R'   (    (    s   /usr/lib/python2.7/argparse.pyt   _ensure_valueâ   s    c           B   s  e  Z d  Z d d d d Ñ Z d Ñ  Z d Ñ  Z d e f d Ñ  É  YZ d Ñ  Z	 d	 Ñ  Z
 d
 Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s◊   Formatter for generating usage messages and argument help strings.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    i   i   c         C   s˚   | d  k rP y t t j d É } Wn t t f k
 rB d } n X| d 8} n  | |  _ | |  _ | |  _ t	 | t
 | d | d É É |  _ | |  _ d |  _ d |  _ d |  _ |  j |  d  É |  _ |  j |  _ t j d É |  _ t j d É |  _ d  S(   Nt   COLUMNSiP   i   i   i    s   \s+s   \n\n\n+(   R/   t   intt   _ost   environt   KeyErrort
   ValueErrort   _progt   _indent_incrementt   _max_help_positiont   mint   maxt   _widtht   _current_indentt   _levelt   _action_max_lengtht   _Sectiont   _root_sectiont   _current_sectiont   _ret   compilet   _whitespace_matchert   _long_break_matcher(   R"   t   progt   indent_incrementt   max_help_positiont   width(    (    s   /usr/lib/python2.7/argparse.pyt   __init__ö   s&    
							c         C   s%   |  j  |  j 7_  |  j d 7_ d  S(   Ni   (   R?   R:   R@   (   R"   (    (    s   /usr/lib/python2.7/argparse.pyt   _indentº   s    c         C   s@   |  j  |  j 8_  |  j  d k s- t d É Ç |  j d 8_ d  S(   Ni    s   Indent decreased below 0.i   (   R?   R:   t   AssertionErrorR@   (   R"   (    (    s   /usr/lib/python2.7/argparse.pyt   _dedent¿   s    RB   c           B   s   e  Z d d  Ñ Z d Ñ  Z RS(   c         C   s(   | |  _  | |  _ | |  _ g  |  _ d  S(   N(   t	   formattert   parentt   headingR+   (   R"   RQ   RR   RS   (    (    s   /usr/lib/python2.7/argparse.pyRM   «   s    			c         C   s  |  j  d  k	 r |  j j É  n  |  j j } x! |  j D] \ } } | | å  q5 W| g  |  j D] \ } } | | å  ^ q\ É } |  j  d  k	 rú |  j j É  n  | s¶ d S|  j t k	 rÈ |  j d  k	 rÈ |  j j	 } d | d |  j f } n d } | d | | d g É S(   Nt    s   %*s%s:
s   
(
   RR   R/   RQ   RN   t   _join_partsR+   RP   RS   R   R?   (   R"   R!   t   funct   argst	   item_helpt   current_indentRS   (    (    s   /usr/lib/python2.7/argparse.pyt   format_helpÕ   s    .N(   R   R,   R/   RM   RZ   (    (    (    s   /usr/lib/python2.7/argparse.pyRB   ≈   s   c         C   s   |  j  j j | | f É d  S(   N(   RD   R+   R   (   R"   RV   RW   (    (    s   /usr/lib/python2.7/argparse.pyt	   _add_itemÊ   s    c         C   sB   |  j  É  |  j |  |  j | É } |  j | j g  É | |  _ d  S(   N(   RN   RB   RD   R[   RZ   (   R"   RS   t   section(    (    s   /usr/lib/python2.7/argparse.pyt   start_sectionÏ   s    
c         C   s   |  j  j |  _  |  j É  d  S(   N(   RD   RR   RP   (   R"   (    (    s   /usr/lib/python2.7/argparse.pyt   end_sectionÚ   s    c         C   s5   | t  k	 r1 | d  k	 r1 |  j |  j | g É n  d  S(   N(   R   R/   R[   t   _format_text(   R"   t   text(    (    s   /usr/lib/python2.7/argparse.pyt   add_textˆ   s    c         C   s8   | t  k	 r4 | | | | f } |  j |  j | É n  d  S(   N(   R   R[   t   _format_usage(   R"   t   usaget   actionst   groupst   prefixRW   (    (    s   /usr/lib/python2.7/argparse.pyt	   add_usage˙   s    c         C   s∏   | j  t k	 r¥ |  j } | | É g } x* |  j | É D] } | j | | É É q7 Wt g  | D] } t | É ^ q^ É } | |  j } t |  j | É |  _ |  j	 |  j
 | g É n  d  S(   N(   t   helpR   t   _format_action_invocationt   _iter_indented_subactionsR   R=   t   lenR?   RA   R[   t   _format_action(   R"   t   actiont   get_invocationt   invocationst	   subactiont   st   invocation_lengtht   action_length(    (    s   /usr/lib/python2.7/argparse.pyt   add_argumentˇ   s    	%	c         C   s"   x | D] } |  j  | É q Wd  S(   N(   Rt   (   R"   Rd   Rm   (    (    s   /usr/lib/python2.7/argparse.pyt   add_arguments  s    c         C   sD   |  j  j É  } | r@ |  j j d | É } | j d É d } n  | S(   Ns   

s   
(   RC   RZ   RH   t   subt   strip(   R"   Rh   (    (    s   /usr/lib/python2.7/argparse.pyRZ     s
    c         C   s2   d j  g  | D] } | r | t k	 r | ^ q É S(   NRT   (   R!   R   (   R"   t   part_stringst   part(    (    s   /usr/lib/python2.7/argparse.pyRU     s    	
c            s  | d  k r t d É } n  | d  k	 r@ | t d |  j É } nÕ| d  k rl | rl d t d |  j É } n°| d  k rd t d |  j É } g  } g  } x4 | D], } | j r¿ | j | É q° | j | É q° W|  j }	 |	 | | | É }
 d j g  | |
 g D] } | r | ^ q É } |  j |  j	 â  t
 | É t
 | É à  k rd } |	 | | É } |	 | | É } t j | | É } t j | | É } d j | É | k s™t Ç d j | É | k s≈t Ç d  á  f d Ü } t
 | É t
 | É d à  k r{d t
 | É t
 | É d } | rM| | g | | | É } | j | | | É É q¯| ro| | g | | | É } q¯| g } n} d t
 | É } | | } | | | É } t
 | É d k rÎg  } | j | | | É É | j | | | É É n  | g | } d	 j | É } qn  d
 | | f S(   Ns   usage: RI   s   %(prog)st    s   \(.*?\)+|\[.*?\]+|\S+c            s  g  } g  } | d  k	 r+ t | É d } n t | É d } xÇ |  D]z } | d t | É à  k rõ | rõ | j | d j | É É g  } t | É d } n  | j | É | t | É d 7} qB W| r„ | j | d j | É É n  | d  k	 r
| d t | É | d <n  | S(   Ni   Rz   i    (   R/   Rk   R   R!   (   t   partst   indentRf   t   linest   linet   line_lenRy   (   t
   text_width(    s   /usr/lib/python2.7/argparse.pyt	   get_linesP  s"     g      Ë?i   s   
s   %s%s

(   R/   t   _t   dictR9   t   option_stringsR   t   _format_actions_usageR!   R>   R?   Rk   RE   t   findallRO   t   extend(   R"   Rc   Rd   Re   Rf   RI   t	   optionalst   positionalsRm   t   formatt   action_usageRq   t   part_regexpt	   opt_usaget	   pos_usaget	   opt_partst	   pos_partsRÅ   R|   R}   R{   (    (   RÄ   s   /usr/lib/python2.7/argparse.pyRb   $  sZ    		. 
c         C   s§  t  É  } i  } x&| D]} y | j | j d É } Wn t k
 rL q q X| t | j É } | | | !| j k r x | j D] } | j | É qÄ W| j s÷ | | k rø | | c d 7<n
 d | | <d | | <n3 | | k rı | | c d 7<n
 d | | <d | | <x( t | d | É D] }	 d	 | |	 <qWq q Wg  }
 xÇt | É D]t\ }	 } | j	 t
 k r»|
 j d  É | j |	 É d	 k rò| j |	 É qø| j |	 d É d	 k rø| j |	 d É qøqK| j s5|  j | | j É } | | k r%| d d k r%| d
 d k r%| d d
 !} q%n  |
 j | É qK| j d } | j d k r^d | } n1 | j j É  } |  j | | É } d | | f } | j r≤| | k r≤d | } n  |
 j | É qKWx. t | d t ÉD] }	 | |	 g |
 |	 |	 +q÷Wd j g  |
 D] } | d  k	 r| ^ qÉ } d } d } t j d | d | É } t j d | d | É } t j d | | f d | É } t j d d | É } | j É  } | S(   Ni    s    [t   [t   ]s    (t   (t   )i   t   |iˇˇˇˇs   %ss   %s %ss   [%s]t   reverseRz   s   [\[(]s   [\])]s   (%s) s   \1s    (%s)s   %s *%sRT   s   \(([^|]*)\)(   t   sett   indext   _group_actionsR8   Rk   t   addt   requiredt   ranget	   enumerateRh   R   R   R/   t   gett   popRÑ   t   _format_argst   destt   nargst   upperR)   t   TrueR!   RE   Rv   Rw   (   R"   Rd   Re   t   group_actionst   insertst   groupt   startt   endRm   t   iR{   Ry   t   option_stringt   defaultt   args_stringt   itemR`   t   opent   close(    (    s   /usr/lib/python2.7/argparse.pyRÖ   Ä  sp    		


	 .c         C   sb   d | k r% | t  d |  j É } n  t |  j |  j d É } d |  j } |  j | | | É d S(   Ns   %(prog)RI   i   Rz   s   

(   RÉ   R9   R=   R>   R?   t
   _fill_text(   R"   R`   RÄ   R|   (    (    s   /usr/lib/python2.7/argparse.pyR_   ‡  s
    c         C   s≤  t  |  j d |  j É } t |  j | d É } | |  j d } |  j | É } | j sw |  j d | f } d | } n\ t | É | k r± |  j d | | f } d | } d } n" |  j d | f } d | } | } | g } | j rV|  j	 | É }	 |  j
 |	 | É }
 | j d | d |
 d f É xN |
 d D]  } | j d | d | f É q/Wn | j d É su| j d É n  x- |  j | É D] } | j |  j | É É qÖW|  j | É S(	   Ni   i   RT   s   %*s%s
s	   %*s%-*s  i    i   s   
(   R<   RA   R;   R=   R>   R?   Ri   Rh   Rk   t   _expand_helpt   _split_linesR   t   endswithRj   Rl   RU   (   R"   Rm   t   help_positiont
   help_widtht   action_widtht   action_headert   tupt   indent_firstR{   t	   help_textt
   help_linesR~   Rp   (    (    s   /usr/lib/python2.7/argparse.pyRl   Á  s6    	
	
		!c         C   s∞   | j  s+ |  j | | j É d É \ } | Sg  } | j d k rS | j | j  É nL | j j É  } |  j | | É } x( | j  D] } | j d | | f É q~ Wd j | É Sd  S(   Ni   i    s   %s %ss   , (	   RÑ   t   _metavar_formatterR°   R¢   Rá   R£   R†   R   R!   (   R"   Rm   t   metavarR{   R¨   R≠   R´   (    (    s   /usr/lib/python2.7/argparse.pyRi     s    	c            s{   | j  d  k	 r | j  â  nM | j d  k	 rb g  | j D] } t | É ^ q4 } d d j | É â  n | â  á  f d Ü  } | S(   Ns   {%s}t   ,c            s"   t  à  t É r à  Sà  f |  Sd  S(   N(   t
   isinstancet   tuple(   t
   tuple_size(   t   result(    s   /usr/lib/python2.7/argparse.pyRä   6  s    (   Ræ   R/   t   choicest   strR!   (   R"   Rm   t   default_metavart   choicet   choice_strsRä   (    (   R√   s   /usr/lib/python2.7/argparse.pyRΩ   -  s    "c         C   s  |  j  | | É } | j d  k r4 d | d É } nﬁ | j t k rV d | d É } nº | j t k rx d | d É } nö | j t k rö d | d É } nx | j t k r≤ d } n` | j t k r‘ d | d É } n> g  t | j É D] } d ^ q‰ } d	 j	 | É | | j É } | S(
   Ns   %si   s   [%s]s   [%s [%s ...]]i   s   %s [%s ...]s   ...s   %s ...Rz   (
   RΩ   R¢   R/   R   R   R
   R   R   Rú   R!   (   R"   Rm   R∆   t   get_metavarR√   RÇ   t   formats(    (    s   /usr/lib/python2.7/argparse.pyR†   =  s     	"c         C   sÈ   t  t | É d |  j É} x. t | É D]  } | | t k r( | | =q( q( Wx; t | É D]- } t | | d É rY | | j | | <qY qY W| j d É d  k	 rÿ d j	 g  | d D] } t
 | É ^ q∞ É } | | d <n  |  j | É | S(   NRI   R   Rƒ   s   , (   RÉ   t   varsR9   t   listR   R   R   Rû   R/   R!   R≈   t   _get_help_string(   R"   Rm   t   paramsR&   t   ct   choices_str(    (    s   /usr/lib/python2.7/argparse.pyR≤   P  s    ,c         c   sR   y | j  } Wn t k
 r  n. X|  j É  x | É  D] } | Vq5 W|  j É  d  S(   N(   t   _get_subactionst   AttributeErrorRN   RP   (   R"   Rm   t   get_subactionsRp   (    (    s   /usr/lib/python2.7/argparse.pyRj   ]  s    
	c         C   s+   |  j  j d | É j É  } t j | | É S(   NRz   (   RG   Rv   Rw   t	   _textwrapt   wrap(   R"   R`   RL   (    (    s   /usr/lib/python2.7/argparse.pyR≥   h  s    c         C   s7   |  j  j d | É j É  } t j | | d | d | ÉS(   NRz   t   initial_indentt   subsequent_indent(   RG   Rv   Rw   R‘   t   fill(   R"   R`   RL   R|   (    (    s   /usr/lib/python2.7/argparse.pyR±   l  s    c         C   s   | j  S(   N(   Rh   (   R"   Rm   (    (    s   /usr/lib/python2.7/argparse.pyRÕ   q  s    N(   R   R,   R-   R/   RM   RN   RP   t   objectRB   R[   R]   R^   Ra   Rg   Rt   Ru   RZ   RU   Rb   RÖ   R_   Rl   Ri   RΩ   R†   R≤   Rj   R≥   R±   RÕ   (    (    (    s   /usr/lib/python2.7/argparse.pyR   ì   s8   		!									\	`		/							c           B   s   e  Z d  Z d Ñ  Z RS(   sŸ   Help message formatter which retains any formatting in descriptions.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    c         C   s-   d j  g  | j t É D] } | | ^ q É S(   NRT   (   R!   t
   splitlinesR§   (   R"   R`   RL   R|   R~   (    (    s   /usr/lib/python2.7/argparse.pyR±   |  s    (   R   R,   R-   R±   (    (    (    s   /usr/lib/python2.7/argparse.pyR   u  s   c           B   s   e  Z d  Z d Ñ  Z RS(   s÷   Help message formatter which retains formatting of all help text.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    c         C   s
   | j  É  S(   N(   R⁄   (   R"   R`   RL   (    (    s   /usr/lib/python2.7/argparse.pyR≥   á  s    (   R   R,   R-   R≥   (    (    (    s   /usr/lib/python2.7/argparse.pyR   Ä  s   c           B   s   e  Z d  Z d Ñ  Z RS(   s◊   Help message formatter which adds default values to argument help.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    c         C   sb   | j  } d | j  k r^ | j t k	 r^ t t g } | j sK | j | k r[ | d 7} q[ q^ n  | S(   Ns
   %(default)s    (default: %(default)s)(   Rh   R¨   R   R   R   RÑ   R¢   (   R"   Rm   Rh   t   defaulting_nargs(    (    s   /usr/lib/python2.7/argparse.pyRÕ   í  s    	(   R   R,   R-   RÕ   (    (    (    s   /usr/lib/python2.7/argparse.pyR   ã  s   c         C   si   |  d  k r d  S|  j r) d j |  j É S|  j d  t f k rE |  j S|  j d  t f k ra |  j Sd  Sd  S(   Nt   /(   R/   RÑ   R!   Ræ   R   R°   (   t   argument(    (    s   /usr/lib/python2.7/argparse.pyt   _get_action_name†  s    	c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sƒ   An error from creating or using an argument (optional or positional).

    The string value of this exception is the message, augmented with
    information about the argument that caused it.
    c         C   s   t  | É |  _ | |  _ d  S(   N(   Rﬁ   t   argument_namet   message(   R"   R›   R‡   (    (    s   /usr/lib/python2.7/argparse.pyRM   ¥  s    c         C   s;   |  j  d  k r d } n d } | t d |  j d |  j  É S(   Ns   %(message)ss'   argument %(argument_name)s: %(message)sR‡   Rﬂ   (   Rﬂ   R/   RÉ   R‡   (   R"   Rä   (    (    s   /usr/lib/python2.7/argparse.pyt   __str__∏  s
    	(   R   R,   R-   RM   R·   (    (    (    s   /usr/lib/python2.7/argparse.pyR   ≠  s   	c           B   s   e  Z d  Z RS(   s@   An error from trying to convert a command line string to a type.(   R   R,   R-   (    (    (    s   /usr/lib/python2.7/argparse.pyR   ¡  s   c        	   B   sD   e  Z d  Z d d d d d e d d d Ñ Z d Ñ  Z d d Ñ Z RS(   s\	  Information about how to convert command line strings to Python objects.

    Action objects are used by an ArgumentParser to represent the information
    needed to parse a single argument from one or more strings from the
    command line. The keyword arguments to the Action constructor are also
    all attributes of Action instances.

    Keyword Arguments:

        - option_strings -- A list of command-line option strings which
            should be associated with this action.

        - dest -- The name of the attribute to hold the created object(s)

        - nargs -- The number of command-line arguments that should be
            consumed. By default, one argument will be consumed and a single
            value will be produced.  Other values include:
                - N (an integer) consumes N arguments (and produces a list)
                - '?' consumes zero or one arguments
                - '*' consumes zero or more arguments (and produces a list)
                - '+' consumes one or more arguments (and produces a list)
            Note that the difference between the default and nargs=1 is that
            with the default, a single value will be produced, while with
            nargs=1, a list containing a single value will be produced.

        - const -- The value to be produced if the option is specified and the
            option uses an action that takes no values.

        - default -- The value to be produced if the option is not specified.

        - type -- A callable that accepts a single string argument, and
            returns the converted value.  The standard Python types str, int,
            float, and complex are useful examples of such callables.  If None,
            str is used.

        - choices -- A container of values that should be allowed. If not None,
            after a command-line argument has been converted to the appropriate
            type, an exception will be raised if it is not a member of this
            collection.

        - required -- True if the action must always be specified at the
            command line. This is only meaningful for optional command-line
            arguments.

        - help -- The help string describing the argument.

        - metavar -- The name to be used for the option's argument with the
            help string. If None, the 'dest' value will be used as the name.
    c         C   s^   | |  _  | |  _ | |  _ | |  _ | |  _ | |  _ | |  _ | |  _ |	 |  _ |
 |  _	 d  S(   N(
   RÑ   R°   R¢   t   constR¨   R   Rƒ   Rõ   Rh   Ræ   (   R"   RÑ   R°   R¢   R‚   R¨   R   Rƒ   Rõ   Rh   Ræ   (    (    s   /usr/lib/python2.7/argparse.pyRM   ˝  s    									c      	   C   sG   d d d d d d d d d	 g	 } g  | D] } | t  |  | É f ^ q( S(
   NRÑ   R°   R¢   R‚   R¨   R   Rƒ   Rh   Ræ   (   R.   (   R"   t   namesR&   (    (    s   /usr/lib/python2.7/argparse.pyR      s    	c         C   s   t  t d É É Ç d  S(   Ns   .__call__() not defined(   t   NotImplementedErrorRÇ   (   R"   t   parserR1   t   valuesR´   (    (    s   /usr/lib/python2.7/argparse.pyR   !  s    N(   R   R,   R-   R/   t   FalseRM   R    R   (    (    (    s   /usr/lib/python2.7/argparse.pyR	      s   1	t   _StoreActionc        	   B   s5   e  Z d d d d d e d d d  Ñ Z d d Ñ Z RS(   c         C   sô   | d k r t  d É Ç n  | d  k	 rF | t k rF t  d t É Ç n  t t |  É j d | d | d | d | d | d	 | d
 | d | d |	 d |
 É 
d  S(   Ni    sÑ   nargs for store actions must be > 0; if you have nothing to store, actions such as store true or store const may be more appropriates    nargs must be %r to supply constRÑ   R°   R¢   R‚   R¨   R   Rƒ   Rõ   Rh   Ræ   (   R8   R/   R   t   superRË   RM   (   R"   RÑ   R°   R¢   R‚   R¨   R   Rƒ   Rõ   Rh   Ræ   (    (    s   /usr/lib/python2.7/argparse.pyRM   '  s    c         C   s   t  | |  j | É d  S(   N(   R0   R°   (   R"   RÂ   R1   RÊ   R´   (    (    s   /usr/lib/python2.7/argparse.pyR   D  s    N(   R   R,   R/   RÁ   RM   R   (    (    (    s   /usr/lib/python2.7/argparse.pyRË   %  s   t   _StoreConstActionc           B   s)   e  Z d e d d d  Ñ Z d d Ñ Z RS(   c         C   sA   t  t |  É j d | d | d d d | d | d | d | É d  S(	   NRÑ   R°   R¢   i    R‚   R¨   Rõ   Rh   (   RÈ   RÍ   RM   (   R"   RÑ   R°   R‚   R¨   Rõ   Rh   Ræ   (    (    s   /usr/lib/python2.7/argparse.pyRM   J  s    c         C   s   t  | |  j |  j É d  S(   N(   R0   R°   R‚   (   R"   RÂ   R1   RÊ   R´   (    (    s   /usr/lib/python2.7/argparse.pyR   [  s    N(   R   R,   R/   RÁ   RM   R   (    (    (    s   /usr/lib/python2.7/argparse.pyRÍ   H  s
   
t   _StoreTrueActionc           B   s   e  Z e e d d  Ñ Z RS(   c         C   s;   t  t |  É j d | d | d t d | d | d | É d  S(   NRÑ   R°   R‚   R¨   Rõ   Rh   (   RÈ   RÎ   RM   R§   (   R"   RÑ   R°   R¨   Rõ   Rh   (    (    s   /usr/lib/python2.7/argparse.pyRM   a  s    N(   R   R,   RÁ   R/   RM   (    (    (    s   /usr/lib/python2.7/argparse.pyRÎ   _  s   t   _StoreFalseActionc           B   s   e  Z e e d d  Ñ Z RS(   c         C   s;   t  t |  É j d | d | d t d | d | d | É d  S(   NRÑ   R°   R‚   R¨   Rõ   Rh   (   RÈ   RÏ   RM   RÁ   (   R"   RÑ   R°   R¨   Rõ   Rh   (    (    s   /usr/lib/python2.7/argparse.pyRM   r  s    N(   R   R,   R§   RÁ   R/   RM   (    (    (    s   /usr/lib/python2.7/argparse.pyRÏ   p  s   t   _AppendActionc        	   B   s5   e  Z d d d d d e d d d  Ñ Z d d Ñ Z RS(   c         C   sô   | d k r t  d É Ç n  | d  k	 rF | t k rF t  d t É Ç n  t t |  É j d | d | d | d | d | d	 | d
 | d | d |	 d |
 É 
d  S(   Ni    sã   nargs for append actions must be > 0; if arg strings are not supplying the value to append, the append const action may be more appropriates    nargs must be %r to supply constRÑ   R°   R¢   R‚   R¨   R   Rƒ   Rõ   Rh   Ræ   (   R8   R/   R   RÈ   RÌ   RM   (   R"   RÑ   R°   R¢   R‚   R¨   R   Rƒ   Rõ   Rh   Ræ   (    (    s   /usr/lib/python2.7/argparse.pyRM   É  s    c         C   sB   t  j t | |  j g  É É } | j | É t | |  j | É d  S(   N(   t   _copyt   copyR2   R°   R   R0   (   R"   RÂ   R1   RÊ   R´   R+   (    (    s   /usr/lib/python2.7/argparse.pyR   †  s    N(   R   R,   R/   RÁ   RM   R   (    (    (    s   /usr/lib/python2.7/argparse.pyRÌ   Å  s   t   _AppendConstActionc           B   s)   e  Z d e d d d  Ñ Z d d Ñ Z RS(   c         C   sG   t  t |  É j d | d | d d d | d | d | d | d	 | É d  S(
   NRÑ   R°   R¢   i    R‚   R¨   Rõ   Rh   Ræ   (   RÈ   R   RM   (   R"   RÑ   R°   R‚   R¨   Rõ   Rh   Ræ   (    (    s   /usr/lib/python2.7/argparse.pyRM   ®  s    c         C   sE   t  j t | |  j g  É É } | j |  j É t | |  j | É d  S(   N(   RÓ   RÔ   R2   R°   R   R‚   R0   (   R"   RÂ   R1   RÊ   R´   R+   (    (    s   /usr/lib/python2.7/argparse.pyR   ∫  s    N(   R   R,   R/   RÁ   RM   R   (    (    (    s   /usr/lib/python2.7/argparse.pyR   ¶  s
   t   _CountActionc           B   s&   e  Z d e d d  Ñ Z d d Ñ Z RS(   c         C   s;   t  t |  É j d | d | d d d | d | d | É d  S(   NRÑ   R°   R¢   i    R¨   Rõ   Rh   (   RÈ   RÒ   RM   (   R"   RÑ   R°   R¨   Rõ   Rh   (    (    s   /usr/lib/python2.7/argparse.pyRM   ¬  s    c         C   s0   t  | |  j d É d } t | |  j | É d  S(   Ni    i   (   R2   R°   R0   (   R"   RÂ   R1   RÊ   R´   t	   new_count(    (    s   /usr/lib/python2.7/argparse.pyR   –  s    N(   R   R,   R/   RÁ   RM   R   (    (    (    s   /usr/lib/python2.7/argparse.pyRÒ   ¿  s   	t   _HelpActionc           B   s&   e  Z e e d d  Ñ Z d d Ñ Z RS(   c         C   s5   t  t |  É j d | d | d | d d d | É d  S(   NRÑ   R°   R¨   R¢   i    Rh   (   RÈ   RÛ   RM   (   R"   RÑ   R°   R¨   Rh   (    (    s   /usr/lib/python2.7/argparse.pyRM   ◊  s    c         C   s   | j  É  | j É  d  S(   N(   t
   print_helpt   exit(   R"   RÂ   R1   RÊ   R´   (    (    s   /usr/lib/python2.7/argparse.pyR   „  s    
N(   R   R,   R   R/   RM   R   (    (    (    s   /usr/lib/python2.7/argparse.pyRÛ   ’  s   t   _VersionActionc           B   s)   e  Z d e e d  d Ñ Z d d Ñ Z RS(   s&   show program's version number and exitc         C   s>   t  t |  É j d | d | d | d d d | É | |  _ d  S(   NRÑ   R°   R¨   R¢   i    Rh   (   RÈ   Rˆ   RM   t   version(   R"   RÑ   R˜   R°   R¨   Rh   (    (    s   /usr/lib/python2.7/argparse.pyRM   Í  s    c         C   sT   |  j  } | d  k r! | j  } n  | j É  } | j | É | j d | j É  É d  S(   NR‡   (   R˜   R/   t   _get_formatterRa   Rı   RZ   (   R"   RÂ   R1   RÊ   R´   R˜   RQ   (    (    s   /usr/lib/python2.7/argparse.pyR   ¯  s    	N(   R   R,   R/   R   RM   R   (    (    (    s   /usr/lib/python2.7/argparse.pyRˆ   Ë  s
   	t   _SubParsersActionc           B   sN   e  Z d  e f d Ñ  É  YZ e d d d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z	 RS(   t   _ChoicesPseudoActionc           B   s   e  Z d  Ñ  Z RS(   c         C   s2   t  t j |  É } | j d g  d | d | É d  S(   NRÑ   R°   Rh   (   RÈ   R˘   R˙   RM   (   R"   R&   Rh   t   sup(    (    s   /usr/lib/python2.7/argparse.pyRM     s    (   R   R,   RM   (    (    (    s   /usr/lib/python2.7/argparse.pyR˙     s   c         C   sh   | |  _  | |  _ t j É  |  _ g  |  _ t t |  É j d | d | d t	 d |  j d | d | É d  S(   NRÑ   R°   R¢   Rƒ   Rh   Ræ   (
   t   _prog_prefixt   _parser_classt   _collectionst   OrderedDictt   _name_parser_mapt   _choices_actionsRÈ   R˘   RM   R   (   R"   RÑ   RI   t   parser_classR°   Rh   Ræ   (    (    s   /usr/lib/python2.7/argparse.pyRM   	  s    				c         K   sè   | j  d É d  k r/ d |  j | f | d <n  d | k ro | j d É } |  j | | É } |  j j | É n  |  j | ç  } | |  j | <| S(   NRI   s   %s %sRh   (	   Rû   R/   R¸   Rü   R˙   R  R   R˝   R   (   R"   R&   t   kwargsRh   t   choice_actionRÂ   (    (    s   /usr/lib/python2.7/argparse.pyt
   add_parser  s    c         C   s   |  j  S(   N(   R  (   R"   (    (    s   /usr/lib/python2.7/argparse.pyR—   .  s    c         C   s  | d } | d } |  j  t k	 r9 t | |  j  | É n  y |  j | } WnH t k
 rî | d j |  j É f } t d É | } t |  | É Ç n X| j | d  É \ }	 } x0 t
 |	 É j É  D] \ }
 } t | |
 | É q¿ W| rt
 | É j t g  É t | t É j | É n  d  S(   Ni    i   s   , s   unknown parser %r (choices: %s)(   R°   R   R0   R   R7   R!   RÇ   R   t   parse_known_argsR/   RÀ   R+   t
   setdefaultt   _UNRECOGNIZED_ARGS_ATTRR.   Rá   (   R"   RÂ   R1   RÊ   R´   t   parser_nameR$   Rπ   t   msgt   subnamespacet   keyR'   (    (    s   /usr/lib/python2.7/argparse.pyR   1  s     

	N(
   R   R,   R	   R˙   R   R/   RM   R  R—   R   (    (    (    s   /usr/lib/python2.7/argparse.pyR˘     s   
		c           B   s/   e  Z d  Z d d d Ñ Z d Ñ  Z d Ñ  Z RS(   s∏  Factory for creating file object types

    Instances of FileType are typically passed as type= arguments to the
    ArgumentParser add_argument() method.

    Keyword Arguments:
        - mode -- A string indicating how the file is to be opened. Accepts the
            same values as the builtin open() function.
        - bufsize -- The file's desired buffer size. Accepts the same values as
            the builtin open() function.
    t   riˇˇˇˇc         C   s   | |  _  | |  _ d  S(   N(   t   _modet   _bufsize(   R"   t   modet   bufsize(    (    s   /usr/lib/python2.7/argparse.pyRM   b  s    	c         C   s∞   | d k rZ d |  j  k r" t j Sd |  j  k r8 t j St d É |  j  } t | É Ç n  y t | |  j  |  j É SWn5 t k
 r´ } t d É } t	 | | | f É Ç n Xd  S(   Nt   -R  t   ws   argument "-" with mode %rs   can't open '%s': %s(
   R  t   _syst   stdint   stdoutRÇ   R8   RØ   R  t   IOErrorR   (   R"   t   stringR
  t   eR‡   (    (    s   /usr/lib/python2.7/argparse.pyR   f  s    c         C   sB   |  j  |  j f } d j d Ñ  | DÉ É } d t |  É j | f S(   Ns   , c         s   s'   |  ] } | d  k r t  | É Vq d S(   iˇˇˇˇN(   R   (   t   .0R%   (    (    s   /usr/lib/python2.7/argparse.pys	   <genexpr>z  s    s   %s(%s)(   R  R  R!   R   R   (   R"   RW   t   args_str(    (    s   /usr/lib/python2.7/argparse.pyR(   x  s    (   R   R,   R-   RM   R   R(   (    (    (    s   /usr/lib/python2.7/argparse.pyR   U  s   	c           B   s8   e  Z d  Z d Ñ  Z d Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sì   Simple object for storing attributes.

    Implements equality by attribute names and values, and provides a simple
    string representation.
    c         K   s)   x" | D] } t  |  | | | É q Wd  S(   N(   R0   (   R"   R  R&   (    (    s   /usr/lib/python2.7/argparse.pyRM   à  s    c         C   s)   t  | t É s t St |  É t | É k S(   N(   R¿   R   t   NotImplementedRÀ   (   R"   t   other(    (    s   /usr/lib/python2.7/argparse.pyt   __eq__é  s    c         C   s   t  | t É s t S|  | k S(   N(   R¿   R   R  (   R"   R  (    (    s   /usr/lib/python2.7/argparse.pyt   __ne__ì  s    c         C   s   | |  j  k S(   N(   R*   (   R"   R  (    (    s   /usr/lib/python2.7/argparse.pyt   __contains__ò  s    N(	   R   R,   R-   RM   R/   t   __hash__R  R  R   (    (    (    s   /usr/lib/python2.7/argparse.pyR   Å  s   			t   _ActionsContainerc           B   s∞   e  Z d  Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sg  t  t |  É j É  | |  _ | |  _ | |  _ | |  _ i  |  _ |  j d d  t
 É |  j d d t
 É |  j d d t É |  j d d t É |  j d d t É |  j d d t É |  j d d t É |  j d d t É |  j d d	 t É |  j d d
 t É |  j d d t É |  j É  g  |  _ i  |  _ g  |  _ g  |  _ i  |  _ t j d É |  _ g  |  _ d  S(   NRm   t   storet   store_constt
   store_truet   store_falseR   t   append_constt   countRh   R˜   t   parserss   ^-\d+$|^-\d*\.\d+$(   RÈ   R"  RM   t   descriptiont   argument_defaultt   prefix_charst   conflict_handlert   _registriest   registerR/   RË   RÍ   RÎ   RÏ   RÌ   R   RÒ   RÛ   Rˆ   R˘   t   _get_handlert   _actionst   _option_string_actionst   _action_groupst   _mutually_exclusive_groupst	   _defaultsRE   RF   t   _negative_number_matchert   _has_negative_number_optionals(   R"   R*  R,  R+  R-  (    (    s   /usr/lib/python2.7/argparse.pyRM   û  s2    					
					c         C   s#   |  j  j | i  É } | | | <d  S(   N(   R.  R  (   R"   t   registry_nameR'   RŸ   t   registry(    (    s   /usr/lib/python2.7/argparse.pyR/  “  s    c         C   s   |  j  | j | | É S(   N(   R.  Rû   (   R"   R8  R'   R¨   (    (    s   /usr/lib/python2.7/argparse.pyt   _registry_get÷  s    c         K   sJ   |  j  j | É x3 |  j D]( } | j | k r | | j | _ q q Wd  S(   N(   R5  t   updateR1  R°   R¨   (   R"   R  Rm   (    (    s   /usr/lib/python2.7/argparse.pyt   set_defaults‹  s    c         C   sL   x6 |  j  D]+ } | j | k r
 | j d  k	 r
 | j Sq
 W|  j j | d  É S(   N(   R1  R°   R¨   R/   R5  Rû   (   R"   R°   Rm   (    (    s   /usr/lib/python2.7/argparse.pyt   get_defaultÂ  s    c         O   s¨  |  j  } | s6 t | É d k rl | d d | k rl | rW d | k rW t d É Ç n  |  j | | é  } n |  j | | é  } d | k rŸ | d } | |  j k r∑ |  j | | d <qŸ |  j d k	 rŸ |  j | d <qŸ n  |  j | É } t	 | É s
t d | f É Ç n  | | ç  } |  j
 d | j | j É } t	 | É sSt d | f É Ç n  t |  d	 É rüy |  j É  j | d É Wqüt k
 rõt d
 É Ç qüXn  |  j | É S(   sÉ   
        add_argument(dest, ..., name=value, ...)
        add_argument(option_string, option_string, ..., name=value, ...)
        i   i    R°   s+   dest supplied twice for positional argumentR¨   s   unknown action "%s"R   s   %r is not callableR¯   s,   length of metavar tuple does not match nargsN(   R,  Rk   R8   t   _get_positional_kwargst   _get_optional_kwargsR5  R+  R/   t   _pop_action_classR   R:  R   R   R¯   R†   t	   TypeErrort   _add_action(   R"   RW   R  t   charsR°   t   action_classRm   t	   type_func(    (    s   /usr/lib/python2.7/argparse.pyRt   Ô  s2    		-
c         O   s&   t  |  | | é } |  j j | É | S(   N(   t   _ArgumentGroupR3  R   (   R"   RW   R  Rß   (    (    s   /usr/lib/python2.7/argparse.pyt   add_argument_group  s    c         K   s#   t  |  | ç } |  j j | É | S(   N(   t   _MutuallyExclusiveGroupR4  R   (   R"   R  Rß   (    (    s   /usr/lib/python2.7/argparse.pyt   add_mutually_exclusive_group#  s    c         C   sê   |  j  | É |  j j | É |  | _ x | j D] } | |  j | <q0 WxB | j D]7 } |  j j | É rQ |  j sà |  j j t	 É qà qQ qQ W| S(   N(
   t   _check_conflictR1  R   t	   containerRÑ   R2  R6  t   matchR7  R§   (   R"   Rm   R´   (    (    s   /usr/lib/python2.7/argparse.pyRB  (  s    		c         C   s   |  j  j | É d  S(   N(   R1  t   remove(   R"   Rm   (    (    s   /usr/lib/python2.7/argparse.pyt   _remove_action=  s    c         C   sO  i  } xO |  j  D]D } | j | k rG t d É } t | | j É Ç n  | | | j <q Wi  } xv | j  D]k } | j | k rÆ |  j d | j d | j d | j É | | j <n  x" | j D] } | | j | | <q∏ Wqh WxD | j D]9 } |  j	 d | j
 É } x | j D] } | | | <qWq· Wx* | j D] } | j | |  É j | É q(Wd  S(   Ns.   cannot merge actions - two groups are named %rt   titleR*  R-  Rõ   (   R3  RO  RÇ   R8   RG  R*  R-  Rô   R4  RI  Rõ   R1  Rû   RB  (   R"   RK  t   title_group_mapRß   R
  t	   group_mapRm   t   mutex_group(    (    s   /usr/lib/python2.7/argparse.pyt   _add_container_actions@  s,    				c         K   sì   d | k r' t  d É } t | É Ç n  | j d É t t g k rO t | d <n  | j d É t k r} d | k r} t | d <n  t | d | d g  ÉS(   NRõ   s1   'required' is an invalid argument for positionalsR¢   R¨   R°   RÑ   (   RÇ   RA  Rû   R   R   R§   RÉ   (   R"   R°   R  R
  (    (    s   /usr/lib/python2.7/argparse.pyR>  h  s    !c   
      O   sV  g  } g  } x™ | D]¢ } | d |  j  k rZ t d É } | |  j  f } t | | É Ç n  | j | É | d |  j  k r t | É d k rµ | d |  j  k r≤ | j | É q≤ qµ q q W| j d d  É } | d  k r@| rÍ | d }	 n
 | d }	 |	 j |  j  É } | s+t d É } t | | É Ç n  | j d d É } n  t	 | d | d | ÉS(	   Ni    s8   invalid option string %r: must start with a character %ri   R°   s%   dest= is required for options like %rR  RÇ   RÑ   (
   R,  RÇ   R8   R   Rk   Rü   R/   t   lstript   replaceRÉ   (
   R"   RW   R  RÑ   t   long_option_stringsR´   R
  Rπ   R°   t   dest_option_string(    (    s   /usr/lib/python2.7/argparse.pyR?  x  s.    
c         C   s%   | j  d | É } |  j d | | É S(   NRm   (   Rü   R:  (   R"   R  R¨   Rm   (    (    s   /usr/lib/python2.7/argparse.pyR@  õ  s    c         C   sU   d |  j  } y t |  | É SWn0 t k
 rP t d É } t | |  j  É Ç n Xd  S(   Ns   _handle_conflict_%ss%   invalid conflict_resolution value: %r(   R-  R.   R“   RÇ   R8   (   R"   t   handler_func_nameR
  (    (    s   /usr/lib/python2.7/argparse.pyR0  ü  s    c         C   sr   g  } xC | j  D]8 } | |  j k r |  j | } | j | | f É q q W| rn |  j É  } | | | É n  d  S(   N(   RÑ   R2  R   R0  (   R"   Rm   t   confl_optionalsR´   t   confl_optionalR-  (    (    s   /usr/lib/python2.7/argparse.pyRJ  ®  s    c         C   sK   t  d É } d j g  | D] \ } } | ^ q É } t | | | É Ç d  S(   Ns    conflicting option string(s): %ss   , (   RÇ   R!   R   (   R"   Rm   t   conflicting_actionsR‡   R´   t   conflict_string(    (    s   /usr/lib/python2.7/argparse.pyt   _handle_conflict_error∂  s    	c         C   sZ   xS | D]K \ } } | j  j | É |  j j | d  É | j  s | j j | É q q Wd  S(   N(   RÑ   RM  R2  Rü   R/   RK  RN  (   R"   Rm   R[  R´   (    (    s   /usr/lib/python2.7/argparse.pyt   _handle_conflict_resolveΩ  s
    	N(   R   R,   RM   R/  R/   R:  R<  R=  Rt   RG  RI  RB  RN  RS  R>  R?  R@  R0  RJ  R]  R^  (    (    (    s   /usr/lib/python2.7/argparse.pyR"  ú  s$   	4				
	/					(		#				RF  c           B   s)   e  Z d d d  Ñ Z d Ñ  Z d Ñ  Z RS(   c         K   sπ   | j  } | d | j É | d | j É | d | j É t t |  É j } | d | | ç | |  _ g  |  _ | j	 |  _	 | j
 |  _
 | j |  _ | j |  _ | j |  _ | j |  _ d  S(   NR-  R,  R+  R*  (   R  R-  R,  R+  RÈ   RF  RM   RO  Rô   R.  R1  R2  R5  R7  R4  (   R"   RK  RO  R*  R  R;  t
   super_init(    (    s   /usr/lib/python2.7/argparse.pyRM   Œ  s    			c         C   s,   t  t |  É j | É } |  j j | É | S(   N(   RÈ   RF  RB  Rô   R   (   R"   Rm   (    (    s   /usr/lib/python2.7/argparse.pyRB  ‰  s    c         C   s*   t  t |  É j | É |  j j | É d  S(   N(   RÈ   RF  RN  Rô   RM  (   R"   Rm   (    (    s   /usr/lib/python2.7/argparse.pyRN  È  s    N(   R   R,   R/   RM   RB  RN  (    (    (    s   /usr/lib/python2.7/argparse.pyRF  Ã  s   	RH  c           B   s&   e  Z e d  Ñ Z d Ñ  Z d Ñ  Z RS(   c         C   s,   t  t |  É j | É | |  _ | |  _ d  S(   N(   RÈ   RH  RM   Rõ   t
   _container(   R"   RK  Rõ   (    (    s   /usr/lib/python2.7/argparse.pyRM     s    	c         C   sJ   | j  r$ t d É } t | É Ç n  |  j j | É } |  j j | É | S(   Ns-   mutually exclusive arguments must be optional(   Rõ   RÇ   R8   R`  RB  Rô   R   (   R"   Rm   R
  (    (    s   /usr/lib/python2.7/argparse.pyRB  ı  s    	c         C   s$   |  j  j | É |  j j | É d  S(   N(   R`  RN  Rô   RM  (   R"   Rm   (    (    s   /usr/lib/python2.7/argparse.pyRN  ˝  s    (   R   R,   RÁ   RM   RB  RN  (    (    (    s   /usr/lib/python2.7/argparse.pyRH  Ó  s   	c           B   sU  e  Z d  Z d! d! d! d! d! g  e d d! d! d e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d! d! d	 Ñ Z d! d! d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d! d Ñ Z d! d Ñ Z d! d Ñ Z d! d Ñ Z  d d! d Ñ Z! d  Ñ  Z" RS("   sa  Object for parsing command line strings into Python objects.

    Keyword Arguments:
        - prog -- The name of the program (default: sys.argv[0])
        - usage -- A usage message (default: auto-generated from arguments)
        - description -- A description of what the program does
        - epilog -- Text following the argument descriptions
        - parents -- Parsers whose arguments should be copied into this one
        - formatter_class -- HelpFormatter class for printing help messages
        - prefix_chars -- Characters that prefix optional arguments
        - fromfile_prefix_chars -- Characters that prefix files containing
            additional arguments
        - argument_default -- The default value for all arguments
        - conflict_handler -- String indicating how to handle conflicts
        - add_help -- Add a -h/-help option
    R  t   errorc         C   s  | d  k	 r+ d d  l } | j d t É n  t t |  É j } | d | d | d |
 d | É | d  k rÑ t j j	 t
 j d É } n  | |  _ | |  _ | |  _ | |  _ | |  _ |	 |  _ | |  _ |  j } | t d É É |  _ | t d	 É É |  _ d  |  _ d
 Ñ  } |  j d d  | É d | k r-d n | d } |  j rw|  j | d | d d d d d t d t d É Én  |  j r¿|  j | d | d d d d d t d |  j d t d É Én  xL | D]D } |  j | É y | j } Wn t k
 r˙q«X|  j j | É q«Wd  S(   NiˇˇˇˇsÇ   The "version" argument to ArgumentParser is deprecated. Please use "add_argument(..., action='version', version="N", ...)" insteadR*  R,  R+  R-  i    s   positional argumentss   optional argumentsc         S   s   |  S(   N(    (   R  (    (    s   /usr/lib/python2.7/argparse.pyt   identityB  s    R   R  t   hi   Rh   Rm   R¨   s   show this help message and exitt   vR˜   s&   show program's version number and exit(   R/   t   warningst   warnt   DeprecationWarningRÈ   R    RM   R5   t   patht   basenameR  t   argvRI   Rc   t   epilogR˜   t   formatter_classt   fromfile_prefix_charst   add_helpRG  RÇ   t   _positionalst
   _optionalst   _subparsersR/  Rt   R   RS  R5  R“   R;  (   R"   RI   Rc   R*  Rk  R˜   t   parentsRl  R,  Rm  R+  R-  Rn  Re  t	   superinitt	   add_groupRb  t   default_prefixRR   t   defaults(    (    s   /usr/lib/python2.7/argparse.pyRM     sX    
													c         C   sA   d d d d d d d g } g  | D] } | t  |  | É f ^ q" S(   NRI   Rc   R*  R˜   Rl  R-  Rn  (   R.   (   R"   R„   R&   (    (    s   /usr/lib/python2.7/argparse.pyR    b  s    	c   	      K   sG  |  j  d  k	 r% |  j t d É É n  | j d t |  É É d | k sS d | k rõ t | j d d É É } t | j d d  É É } |  j | | É |  _  n |  j |  _  | j	 d É d  k r|  j
 É  } |  j É  } |  j } | j |  j | | d É | j É  j É  | d <n  |  j | d É } | d	 g  | ç } |  j  j | É | S(
   Ns(   cannot have multiple subparser argumentsR  RO  R*  t   subcommandsRI   RT   R)  RÑ   (   Rq  R/   Ra  RÇ   R  R   Rü   RG  Ro  Rû   R¯   t   _get_positional_actionsR4  Rg   Rc   RZ   Rw   R@  RB  (	   R"   R  RO  R*  RQ   Râ   Re   t   parsers_classRm   (    (    s   /usr/lib/python2.7/argparse.pyt   add_subparsersq  s$    	c         C   s0   | j  r |  j j | É n |  j j | É | S(   N(   RÑ   Rp  RB  Ro  (   R"   Rm   (    (    s   /usr/lib/python2.7/argparse.pyRB  ê  s    	c         C   s#   g  |  j  D] } | j r
 | ^ q
 S(   N(   R1  RÑ   (   R"   Rm   (    (    s   /usr/lib/python2.7/argparse.pyt   _get_optional_actionsó  s    c         C   s#   g  |  j  D] } | j s
 | ^ q
 S(   N(   R1  RÑ   (   R"   Rm   (    (    s   /usr/lib/python2.7/argparse.pyRx  ú  s    c         C   sK   |  j  | | É \ } } | rG t d É } |  j | d j | É É n  | S(   Ns   unrecognized arguments: %sRz   (   R  RÇ   Ra  R!   (   R"   RW   R1   Rj  R
  (    (    s   /usr/lib/python2.7/argparse.pyt
   parse_args§  s
    c         C   sv  | d  k r t j d } n t | É } | d  k r@ t É  } n  x` |  j D]U } | j t k	 rJ t | | j É sü | j	 t k	 rú t
 | | j | j	 É qú qü qJ qJ Wx: |  j D]/ } t | | É s≠ t
 | | |  j | É q≠ q≠ Wy[ |  j | | É \ } } t | t É r0| j t | t É É t | t É n  | | f SWn4 t k
 rqt j É  d } |  j t | É É n Xd  S(   Ni   (   R/   R  Rj  RÃ   R   R1  R°   R   R   R¨   R0   R5  t   _parse_known_argsR  Rá   R.   t   delattrR   t   exc_infoRa  R≈   (   R"   RW   R1   Rm   R°   t   err(    (    s   /usr/lib/python2.7/argparse.pyR  ´  s,    #c            sL  à	 j  d  k	 r! à	 j à É â n  i  â  xr à	 j D]g } | j } xU t | j É D]D \ } } à  j | g  É } | j | |  É | j | | d É qP Wq1 Wi  â g  } t à É }	 xï t |	 É D]á \ } }
 |
 d k r| j	 d É x_ |	 D] }
 | j	 d É qÌ Wq¡ à	 j
 |
 É } | d  k r+d } n | à | <d } | j	 | É q¡ Wd j | É â t É  â t É  â d  á  á á á á	 f d Ü â
 á á á á á	 á
 f d Ü  } à	 j É  â á á á á	 á
 f d	 Ü  } g  â d
 } à rÒt à É } n d } xØ | | k r®t g  à D] } | | k r| ^ qÉ } | | k rj| | É } | | k ra| } q˙qj| } n  | à k rôà | | !} à j | É | } n  | | É } q˙W| | É } à j à | É à r‚à	 j t d É É n  x¬ à	 j D]∑ } | à k rÏ| j r-t | É } à	 j t d É | É q£| j d  k	 r£t | j t É r£t à | j É r£| j t à | j É k r£t à | j à	 j | | j É É q£qÏqÏWxò à	 j D]ç } | j r±x{ | j D] } | à k r Pq q Wg  | j D]! } | j t k	 rÓt | É ^ qÓ} t d É } à	 j | d j | É É q±q±Wà à f S(   Ni   s   --R  t   At   ORT   c            sª   à j  |  É à j |  | É } | |  j k	 rï à j  |  É xW à  j |  g  É D]@ } | à k rN t d É } t | É } t |  | | É Ç qN qN Wn  | t k	 r∑ |  à à | | É n  d  S(   Ns   not allowed with argument %s(   Rö   t   _get_valuesR¨   Rû   RÇ   Rﬁ   R   R   (   Rm   t   argument_stringsR´   t   argument_valuest   conflict_actionR
  t   action_name(   t   action_conflictsR1   t   seen_actionst   seen_non_default_actionsR"   (    s   /usr/lib/python2.7/argparse.pyt   take_action˝  s    c            s  à |  } | \ } } } à j  } g  } x£t rÕ| d  k rV à j à  |  É |  d S| d  k	 ry| | d É } à j } | d k r| d | k r| j | g  | f É | d }	 |	 | d } | d p— d  }
 à j } | | k r¸ | | } |
 } qvt d É } t | | | É Ç q | d k rW|  d } | g } | j | | | f É Pq t d É } t | | | É Ç q+ |  d } à | } | | | É } | | } à  | | !} | j | | | f É Pq+ W| s⁄t Ç x' | D] \ } } } à | | | É q·W| S(   Ni   RÅ  i    s   ignored explicit argument %r(	   t   _match_argumentR§   R/   R   R,  R2  RÇ   R   RO   (   t   start_indext   option_tupleRm   R´   t   explicit_argt   match_argumentt   action_tuplest	   arg_countRC  t   chart   new_explicit_argt   optionals_mapR
  t   stopRW   R®   t   selected_patterns(   R$   t   arg_strings_patternt   extrast   option_string_indicesR"   Rã  (    s   /usr/lib/python2.7/argparse.pyt   consume_optional  sP    
			
	
	
	


c            s   à j  } à |  } | à | É } xE t à | É D]4 \ } } à  |  |  | !} |  | 7}  à | | É q2 Wà t | É à (|  S(   N(   t   _match_arguments_partialt   zipRk   (   Rç  t   match_partialt   selected_patternt
   arg_countsRm   Rí  RW   (   R$   Rò  Râ   R"   Rã  (    s   /usr/lib/python2.7/argparse.pyt   consume_positionals_  s    	

i    iˇˇˇˇs   too few argumentss   argument %s is requireds#   one of the arguments %s is requiredRz   (   Rm  R/   t   _read_args_from_filesR4  Rô   Rù   R  Rá   t   iterR   t   _parse_optionalR!   Ró   Rx  R=   R<   Ra  RÇ   R1  Rõ   Rﬁ   R¨   R¿   t
   basestringR   R°   R.   R0   t
   _get_valueRh   R   (   R"   R$   R1   RR  R•   R™   t   mutex_actiont	   conflictst   arg_string_pattern_partst   arg_strings_itert
   arg_stringRé  t   patternRõ  R°  Rç  t   max_option_string_indexRò   t   next_option_string_indext   positionals_end_indext   stringst
   stop_indexRm   R&   Rß   R„   R
  (    (   Rà  R$   Rò  Rô  R1   Rö  Râ   Râ  Rä  R"   Rã  s   /usr/lib/python2.7/argparse.pyR}  Œ  sö    		
		J
			 	!!c         C   s  g  } x˚ | D]Û } | s- | d |  j  k r= | j | É q yå t | d É } zj g  } xA | j É  j É  D]- } x$ |  j | É D] } | j | É qÇ Wql W|  j | É } | j | É Wd  | j É  XWq t	 k
 rˇ t
 j É  d } |  j t | É É q Xq W| S(   Ni    i   (   Rm  R   RØ   t   readR⁄   t   convert_arg_line_to_argsR¢  Rá   R∞   R  R  R  Ra  R≈   (   R"   R$   t   new_arg_stringsR´  t	   args_filet   arg_lineR%   RÄ  (    (    s   /usr/lib/python2.7/argparse.pyR¢  ƒ  s$    c         C   s   | g S(   N(    (   R"   R∂  (    (    s   /usr/lib/python2.7/argparse.pyR≥  ·  s    c         C   sß   |  j  | É } t j | | É } | d  k rî i t d É d  6t d É t 6t d É t 6} t d É | j } | j | j | É } t	 | | É Ç n  t
 | j d É É S(   Ns   expected one arguments   expected at most one arguments   expected at least one arguments   expected %s argument(s)i   (   t   _get_nargs_patternRE   RL  R/   RÇ   R   R
   R¢   Rû   R   Rk   Rß   (   R"   Rm   Rò  t   nargs_patternRL  t   nargs_errorsR¨   R
  (    (    s   /usr/lib/python2.7/argparse.pyRå  ‰  s    c   
      C   s∞   g  } x£ t  t | É d d É D]â } | |  } d j g  | D] } |  j | É ^ q< É } t j | | É } | d  k	 r | j g  | j É  D] }	 t |	 É ^ qã É Pq q W| S(   Ni    iˇˇˇˇRT   (	   Rú   Rk   R!   R∑  RE   RL  R/   Rá   Re   (
   R"   Rd   Rò  R√   R™   t   actions_sliceRm   R¨  RL  R  (    (    s   /usr/lib/python2.7/argparse.pyRú  ˜  s    
	",c   	      C   sÄ  | s
 d  S| d |  j k r! d  S| |  j k rJ |  j | } | | d  f St | É d k r` d  Sd | k r∞ | j d d É \ } } | |  j k r∞ |  j | } | | | f Sn  |  j | É } t | É d k r"d j g  | D] \ } } } | ^ qﬁ É } | | f } |  j t d É | É n t | É d k rA| \ } | S|  j	 j
 | É rc|  j scd  Sn  d | k rsd  Sd  | d  f S(   Ni    i   t   =s   , s#   ambiguous option: %s could match %sRz   (   R/   R,  R2  Rk   t   splitt   _get_option_tuplesR!   Ra  RÇ   R6  RL  R7  (	   R"   R´  Rm   R´   Rè  t   option_tuplest   optionsRπ   Ré  (    (    s   /usr/lib/python2.7/argparse.pyR§    s:    	"		c   
      C   sô  g  } |  j  } | d | k r¥ | d | k r¥ d | k rV | j d d É \ } } n | } d  } x0|  j D]A } | j | É rl |  j | } | | | f } | j | É ql ql Wn· | d | k r~| d | k r~| } d  } | d  } | d }	 xû |  j D]y } | | k r<|  j | } | | |	 f } | j | É q˛ | j | É r˛ |  j | } | | | f } | j | É q˛ q˛ Wn |  j t d É | É | S(   Ni    i   Rª  i   s   unexpected option string: %s(   R,  Rº  R/   R2  t
   startswithR   Ra  RÇ   (
   R"   R´   R√   RC  t   option_prefixRè  Rm   Rπ   t   short_option_prefixt   short_explicit_arg(    (    s   /usr/lib/python2.7/argparse.pyRΩ  @  s8    	  

c         C   s“   | j  } | d  k r d } nÄ | t k r3 d } nk | t k rH d } nV | t k r] d } nA | t k rr d } n, | t k rá d } n d d j d	 | É } | j rŒ | j	 d d
 É } | j	 d d
 É } n  | S(   Ns   (-*A-*)s   (-*A?-*)s	   (-*[A-]*)s
   (-*A[A-]*)s   ([-AO]*)s   (-*A[-AO]*)s   (-*%s-*)s   -*RÅ  RT   R  (
   R¢   R/   R   R   R
   R   R   R!   RÑ   RU  (   R"   Rm   R¢   R∏  (    (    s   /usr/lib/python2.7/argparse.pyR∑  l  s$    								c         C   s  | j  t t g k r= y | j d É Wq= t k
 r9 q= Xn  | r® | j  t k r® | j rh | j } n	 | j } t	 | t
 É r|  j | | É } |  j | | É qnq| r¸ | j  t k r¸ | j r¸ | j d  k	 r„ | j } n | } |  j | | É nt | É d k rQ| j  d  t g k rQ| \ } |  j | | É } |  j | | É n» | j  t k ràg  | D] } |  j | | É ^ qg} në | j  t k r”g  | D] } |  j | | É ^ qû} |  j | | d É nF g  | D] } |  j | | É ^ q⁄} x | D] } |  j | | É qˇW| S(   Ns   --i   i    (   R¢   R   R   RM  R8   R   RÑ   R‚   R¨   R¿   R•  R¶  t   _check_valueR   R/   Rk   (   R"   Rm   R$   R'   R´  Rd  (    (    s   /usr/lib/python2.7/argparse.pyRÉ  ò  s>    		
'	(%%c         C   s  |  j  d | j | j É } t | É sI t d É } t | | | É Ç n  y | | É } Wn≠ t k
 rØ t | j d t | j É É } t t	 j
 É  d É } t | | É Ç nZ t t f k
 rt | j d t | j É É } t d É } t | | | | f É Ç n X| S(   NR   s   %r is not callableR   i   s   invalid %s value: %r(   R:  R   R   RÇ   R   R   R.   R   R≈   R  R  RA  R8   (   R"   Rm   R´  RE  R
  R√   R&   (    (    s   /usr/lib/python2.7/argparse.pyR¶  Ã  s    c         C   se   | j  d  k	 ra | | j  k ra | d j t t | j  É É f } t d É | } t | | É Ç n  d  S(   Ns   , s#   invalid choice: %r (choose from %s)(   Rƒ   R/   R!   t   mapR   RÇ   R   (   R"   Rm   R'   Rπ   R
  (    (    s   /usr/lib/python2.7/argparse.pyRƒ  Â  s    !c         C   s2   |  j  É  } | j |  j |  j |  j É | j É  S(   N(   R¯   Rg   Rc   R1  R4  RZ   (   R"   RQ   (    (    s   /usr/lib/python2.7/argparse.pyt   format_usageÔ  s    
c         C   s†   |  j  É  } | j |  j |  j |  j É | j |  j É xK |  j D]@ } | j | j	 É | j | j É | j
 | j É | j É  qB W| j |  j É | j É  S(   N(   R¯   Rg   Rc   R1  R4  Ra   R*  R3  R]   RO  Ru   Rô   R^   Rk  RZ   (   R"   RQ   t   action_group(    (    s   /usr/lib/python2.7/argparse.pyRZ   ı  s    
c         C   sB   d d  l  } | j d t É |  j É  } | j |  j É | j É  S(   Niˇˇˇˇsk   The format_version method is deprecated -- the "version" argument to ArgumentParser is no longer supported.(   Re  Rf  Rg  R¯   Ra   R˜   RZ   (   R"   Re  RQ   (    (    s   /usr/lib/python2.7/argparse.pyt   format_version	  s    c         C   s   |  j  d |  j É S(   NRI   (   Rl  RI   (   R"   (    (    s   /usr/lib/python2.7/argparse.pyR¯   	  s    c         C   s2   | d  k r t j } n  |  j |  j É  | É d  S(   N(   R/   R  R  t   _print_messageR∆  (   R"   t   file(    (    s   /usr/lib/python2.7/argparse.pyt   print_usage	  s    c         C   s2   | d  k r t j } n  |  j |  j É  | É d  S(   N(   R/   R  R  R…  RZ   (   R"   R   (    (    s   /usr/lib/python2.7/argparse.pyRÙ   !	  s    c         C   s6   d d  l  } | j d t É |  j |  j É  | É d  S(   Niˇˇˇˇsj   The print_version method is deprecated -- the "version" argument to ArgumentParser is no longer supported.(   Re  Rf  Rg  R…  R»  (   R"   R   Re  (    (    s   /usr/lib/python2.7/argparse.pyt   print_version&	  s
    c         C   s2   | r. | d  k r t j } n  | j | É n  d  S(   N(   R/   R  t   stderrt   write(   R"   R‡   R   (    (    s   /usr/lib/python2.7/argparse.pyR…  .	  s    i    c         C   s-   | r |  j  | t j É n  t j | É d  S(   N(   R…  R  RÕ  Rı   (   R"   t   statusR‡   (    (    s   /usr/lib/python2.7/argparse.pyRı   7	  s    c         C   s7   |  j  t j É |  j d t d É |  j | f É d S(   s   error(message: string)

        Prints a usage message incorporating the message to stderr and
        exits.

        If you override this in a subclass, it should not return -- it
        should either exit or raise an exception.
        i   s   %s: error: %s
N(   RÀ  R  RÕ  Rı   RÇ   RI   (   R"   R‡   (    (    s   /usr/lib/python2.7/argparse.pyRa  <	  s    	N(#   R   R,   R-   R/   R   R§   RM   R    Rz  RB  R{  Rx  R|  R  R}  R¢  R≥  Rå  Rú  R§  RΩ  R∑  RÉ  R¶  Rƒ  R∆  RZ   R»  R¯   RÀ  RÙ   RÃ  R…  Rı   Ra  (    (    (    s   /usr/lib/python2.7/argparse.pyR      sR   B					#	ˆ					9	,	,	4		
			
		(5   R-   t   __version__t   __all__t   collectionsR˛   RÔ   RÓ   t   osR5   t   reRE   t   sysR  t   textwrapR‘   R   RÇ   R   R   R   R   R
   R   R   R  RŸ   R   R2   R   R   R   R   Rﬁ   t	   ExceptionR   R   R	   RË   RÍ   RÎ   RÏ   RÌ   R   RÒ   RÛ   Rˆ   R˘   R   R   R"  RF  RH  R    (    (    (    s   /usr/lib/python2.7/argparse.pyt   <module>>   sx   			
ˇ „		[#%T,ˇ 1"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # -*- Mode: Python -*-
#   Id: asyncore.py,v 2.51 2000/09/07 22:29:26 rushing Exp
#   Author: Sam Rushing <rushing@nightmare.com>

# ======================================================================
# Copyright 1996 by Sam Rushing
#
#                         All Rights Reserved
#
# Permission to use, copy, modify, and distribute this software and
# its documentation for any purpose and without fee is hereby
# granted, provided that the above copyright notice appear in all
# copies and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of Sam
# Rushing not be used in advertising or publicity pertaining to
# distribution of the software without specific, written prior
# permission.
#
# SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
# NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# ======================================================================

"""Basic infrastructure for asynchronous socket service clients and servers.

There are only two ways to have a program on a single processor do "more
than one thing at a time".  Multi-threaded programming is the simplest and
most popular way to do it, but there is another very different technique,
that lets you have nearly all the advantages of multi-threading, without
actually using multiple threads. it's really only practical if your program
is largely I/O bound. If your program is CPU bound, then pre-emptive
scheduled threads are probably what you really need. Network servers are
rarely CPU-bound, however.

If your operating system supports the select() system call in its I/O
library (and nearly all do), then you can use it to juggle multiple
communication channels at once; doing other work while your I/O is taking
place in the "background."  Although this strategy can seem strange and
complex, especially at first, it is in many ways easier to understand and
control than multi-threaded programming. The module documented here solves
many of the difficult problems for you, making the task of building
sophisticated high-performance network servers and clients a snap.
"""

import select
import socket
import sys
import time
import warnings

import os
from errno import EALREADY, EINPROGRESS, EWOULDBLOCK, ECONNRESET, EINVAL, \
     ENOTCONN, ESHUTDOWN, EINTR, EISCONN, EBADF, ECONNABORTED, EPIPE, EAGAIN, \
     errorcode

_DISCONNECTED = frozenset((ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE,
                           EBADF))

try:
    socket_map
except NameError:
    socket_map = {}

def _strerror(err):
    try:
        return os.strerror(err)
    except (ValueError, OverflowError, NameError):
        if err in errorcode:
            return errorcode[err]
        return "Unknown error %s" %err

class ExitNow(Exception):
    pass

_reraised_exceptions = (ExitNow, KeyboardInterrupt, SystemExit)

def read(obj):
    try:
        obj.handle_read_event()
    except _reraised_exceptions:
        raise
    except:
        obj.handle_error()

def write(obj):
    try:
        obj.handle_write_event()
    except _reraised_exceptions:
        raise
    except:
        obj.handle_error()

def _exception(obj):
    try:
        obj.handle_expt_event()
    except _reraised_exceptions:
        raise
    except:
        obj.handle_error()

def readwrite(obj, flags):
    try:
        if flags & select.POLLIN:
            obj.handle_read_event()
        if flags & select.POLLOUT:
            obj.handle_write_event()
        if flags & select.POLLPRI:
            obj.handle_expt_event()
        if flags & (select.POLLHUP | select.POLLERR | select.POLLNVAL):
            obj.handle_close()
    except socket.error, e:
        if e.args[0] not in _DISCONNECTED:
            obj.handle_error()
        else:
            obj.handle_close()
    except _reraised_exceptions:
        raise
    except:
        obj.handle_error()

def poll(timeout=0.0, map=None):
    if map is None:
        map = socket_map
    if map:
        r = []; w = []; e = []
        for fd, obj in map.items():
            is_r = obj.readable()
            is_w = obj.writable()
            if is_r:
                r.append(fd)
            # accepting sockets should not be writable
            if is_w and not obj.accepting:
                w.append(fd)
            if is_r or is_w:
                e.append(fd)
        if [] == r == w == e:
            time.sleep(timeout)
            return

        try:
            r, w, e = select.select(r, w, e, timeout)
        except select.error, err:
            if err.args[0] != EINTR:
                raise
            else:
                return

        for fd in r:
            obj = map.get(fd)
            if obj is None:
                continue
            read(obj)

        for fd in w:
            obj = map.get(fd)
            if obj is None:
                continue
            write(obj)

        for fd in e:
            obj = map.get(fd)
            if obj is None:
                continue
            _exception(obj)

def poll2(timeout=0.0, map=None):
    # Use the poll() support added to the select module in Python 2.0
    if map is None:
        map = socket_map
    if timeout is not None:
        # timeout is in milliseconds
        timeout = int(timeout*1000)
    pollster = select.poll()
    if map:
        for fd, obj in map.items():
            flags = 0
            if obj.readable():
                flags |= select.POLLIN | select.POLLPRI
            # accepting sockets should not be writable
            if obj.writable() and not obj.accepting:
                flags |= select.POLLOUT
            if flags:
                # Only check for exceptions if object was either readable
                # or writable.
                flags |= select.POLLERR | select.POLLHUP | select.POLLNVAL
                pollster.register(fd, flags)
        try:
            r = pollster.poll(timeout)
        except select.error, err:
            if err.args[0] != EINTR:
                raise
            r = []
        for fd, flags in r:
            obj = map.get(fd)
            if obj is None:
                continue
            readwrite(obj, flags)

poll3 = poll2                           # Alias for backward compatibility

def loop(timeout=30.0, use_poll=False, map=None, count=None):
    if map is None:
        map = socket_map

    if use_poll and hasattr(select, 'poll'):
        poll_fun = poll2
    else:
        poll_fun = poll

    if count is None:
        while map:
            poll_fun(timeout, map)

    else:
        while map and count > 0:
            poll_fun(timeout, map)
            count = count - 1

class dispatcher:

    debug = False
    connected = False
    accepting = False
    connecting = False
    closing = False
    addr = None
    ignore_log_types = frozenset(['warning'])

    def __init__(self, sock=None, map=None):
        if map is None:
            self._map = socket_map
        else:
            self._map = map

        self._fileno = None

        if sock:
            # Set to nonblocking just to make sure for cases where we
            # get a socket from a blocking source.
            sock.setblocking(0)
            self.set_socket(sock, map)
            self.connected = True
            # The constructor no longer requires that the socket
            # passed be connected.
            try:
                self.addr = sock.getpeername()
            except socket.error, err:
                if err.args[0] in (ENOTCONN, EINVAL):
                    # To handle the case where we got an unconnected
                    # socket.
                    self.connected = False
                else:
                    # The socket is broken in some unknown way, alert
                    # the user and remove it from the map (to prevent
                    # polling of broken sockets).
                    self.del_channel(map)
                    raise
        else:
            self.socket = None

    def __repr__(self):
        status = [self.__class__.__module__+"."+self.__class__.__name__]
        if self.accepting and self.addr:
            status.append('listening')
        elif self.connected:
            status.append('connected')
        if self.addr is not None:
            try:
                status.append('%s:%d' % self.addr)
            except TypeError:
                status.append(repr(self.addr))
        return '<%s at %#x>' % (' '.join(status), id(self))

    __str__ = __repr__

    def add_channel(self, map=None):
        #self.log_info('adding channel %s' % self)
        if map is None:
            map = self._map
        map[self._fileno] = self

    def del_channel(self, map=None):
        fd = self._fileno
        if map is None:
            map = self._map
        if fd in map:
            #self.log_info('closing channel %d:%s' % (fd, self))
            del map[fd]
        self._fileno = None

    def create_socket(self, family, type):
        self.family_and_type = family, type
        sock = socket.socket(family, type)
        sock.setblocking(0)
        self.set_socket(sock)

    def set_socket(self, sock, map=None):
        self.socket = sock
##        self.__dict__['socket'] = sock
        self._fileno = sock.fileno()
        self.add_channel(map)

    def set_reuse_addr(self):
        # try to re-use a server port if possible
        try:
            self.socket.setsockopt(
                socket.SOL_SOCKET, socket.SO_REUSEADDR,
                self.socket.getsockopt(socket.SOL_SOCKET,
                                       socket.SO_REUSEADDR) | 1
                )
        except socket.error:
            pass

    # ==================================================
    # predicates for select()
    # these are used as filters for the lists of sockets
    # to pass to select().
    # ==================================================

    def readable(self):
        return True

    def writable(self):
        return True

    # ==================================================
    # socket object methods.
    # ==================================================

    def listen(self, num):
        self.accepting = True
        if os.name == 'nt' and num > 5:
            num = 5
        return self.socket.listen(num)

    def bind(self, addr):
        self.addr = addr
        return self.socket.bind(addr)

    def connect(self, address):
        self.connected = False
        self.connecting = True
        err = self.socket.connect_ex(address)
        if err in (EINPROGRESS, EALREADY, EWOULDBLOCK) \
        or err == EINVAL and os.name in ('nt', 'ce'):
            self.addr = address
            return
        if err in (0, EISCONN):
            self.addr = address
            self.handle_connect_event()
        else:
            raise socket.error(err, errorcode[err])

    def accept(self):
        # XXX can return either an address pair or None
        try:
            conn, addr = self.socket.accept()
        except TypeError:
            return None
        except socket.error as why:
            if why.args[0] in (EWOULDBLOCK, ECONNABORTED, EAGAIN):
                return None
            else:
                raise
        else:
            return conn, addr

    def send(self, data):
        try:
            result = self.socket.send(data)
            return result
        except socket.error, why:
            if why.args[0] == EWOULDBLOCK:
                return 0
            elif why.args[0] in _DISCONNECTED:
                self.handle_close()
                return 0
            else:
                raise

    def recv(self, buffer_size):
        try:
            data = self.socket.recv(buffer_size)
            if not data:
                # a closed connection is indicated by signaling
                # a read condition, and having recv() return 0.
                self.handle_close()
                return ''
            else:
                return data
        except socket.error, why:
            # winsock sometimes raises ENOTCONN
            if why.args[0] in _DISCONNECTED:
                self.handle_close()
                return ''
            else:
                raise

    def close(self):
        self.connected = False
        self.accepting = False
        self.connecting = False
        self.del_channel()
        try:
            self.socket.close()
        except socket.error, why:
            if why.args[0] not in (ENOTCONN, EBADF):
                raise

    # cheap inheritance, used to pass all other attribute
    # references to the underlying socket object.
    def __getattr__(self, attr):
        try:
            retattr = getattr(self.socket, attr)
        except AttributeError:
            raise AttributeError("%s instance has no attribute '%s'"
                                 %(self.__class__.__name__, attr))
        else:
            msg = "%(me)s.%(attr)s is deprecated. Use %(me)s.socket.%(attr)s " \
                  "instead." % {'me': self.__class__.__name__, 'attr':attr}
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return retattr

    # log and log_info may be overridden to provide more sophisticated
    # logging and warning methods. In general, log is for 'hit' logging
    # and 'log_info' is for informational, warning and error logging.

    def log(self, message):
        sys.stderr.write('log: %s\n' % str(message))

    def log_info(self, message, type='info'):
        if type not in self.ignore_log_types:
            print '%s: %s' % (type, message)

    def handle_read_event(self):
        if self.accepting:
            # accepting sockets are never connected, they "spawn" new
            # sockets that are connected
            self.handle_accept()
        elif not self.connected:
            if self.connecting:
                self.handle_connect_event()
            self.handle_read()
        else:
            self.handle_read()

    def handle_connect_event(self):
        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
        if err != 0:
            raise socket.error(err, _strerror(err))
        self.handle_connect()
        self.connected = True
        self.connecting = False

    def handle_write_event(self):
        if self.accepting:
            # Accepting sockets shouldn't get a write event.
            # We will pretend it didn't happen.
            return

        if not self.connected:
            if self.connecting:
                self.handle_connect_event()
        self.handle_write()

    def handle_expt_event(self):
        # handle_expt_event() is called if there might be an error on the
        # socket, or if there is OOB data
        # check for the error condition first
        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
        if err != 0:
            # we can get here when select.select() says that there is an
            # exceptional condition on the socket
            # since there is an error, we'll go ahead and close the socket
            # like we would in a subclassed handle_read() that received no
            # data
            self.handle_close()
        else:
            self.handle_expt()

    def handle_error(self):
        nil, t, v, tbinfo = compact_traceback()

        # sometimes a user repr method will crash.
        try:
            self_repr = repr(self)
        except:
            self_repr = '<__repr__(self) failed for object at %0x>' % id(self)

        self.log_info(
            'uncaptured python exception, closing channel %s (%s:%s %s)' % (
                self_repr,
                t,
                v,
                tbinfo
                ),
            'error'
            )
        self.handle_close()

    def handle_expt(self):
        self.log_info('unhandled incoming priority event', 'warning')

    def handle_read(self):
        self.log_info('unhandled read event', 'warning')

    def handle_write(self):
        self.log_info('unhandled write event', 'warning')

    def handle_connect(self):
        self.log_info('unhandled connect event', 'warning')

    def handle_accept(self):
        self.log_info('unhandled accept event', 'warning')

    def handle_close(self):
        self.log_info('unhandled close event', 'warning')
        self.close()

# ---------------------------------------------------------------------------
# adds simple buffered output capability, useful for simple clients.
# [for more sophisticated usage use asynchat.async_chat]
# ---------------------------------------------------------------------------

class dispatcher_with_send(dispatcher):

    def __init__(self, sock=None, map=None):
        dispatcher.__init__(self, sock, map)
        self.out_buffer = ''

    def initiate_send(self):
        num_sent = 0
        num_sent = dispatcher.send(self, self.out_buffer[:512])
        self.out_buffer = self.out_buffer[num_sent:]

    def handle_write(self):
        self.initiate_send()

    def writable(self):
        return (not self.connected) or len(self.out_buffer)

    def send(self, data):
        if self.debug:
            self.log_info('sending %s' % repr(data))
        self.out_buffer = self.out_buffer + data
        self.initiate_send()

# ---------------------------------------------------------------------------
# used for debugging.
# ---------------------------------------------------------------------------

def compact_traceback():
    t, v, tb = sys.exc_info()
    tbinfo = []
    if not tb: # Must have a traceback
        raise AssertionError("traceback does not exist")
    while tb:
        tbinfo.append((
            tb.tb_frame.f_code.co_filename,
            tb.tb_frame.f_code.co_name,
            str(tb.tb_lineno)
            ))
        tb = tb.tb_next

    # just to be safe
    del tb

    file, function, line = tbinfo[-1]
    info = ' '.join(['[%s|%s|%s]' % x for x in tbinfo])
    return (file, function, line), t, v, info

def close_all(map=None, ignore_all=False):
    if map is None:
        map = socket_map
    for x in map.values():
        try:
            x.close()
        except OSError, x:
            if x.args[0] == EBADF:
                pass
            elif not ignore_all:
                raise
        except _reraised_exceptions:
            raise
        except:
            if not ignore_all:
                raise
    map.clear()

# Asynchronous File I/O:
#
# After a little research (reading man pages on various unixen, and
# digging through the linux kernel), I've determined that select()
# isn't meant for doing asynchronous file i/o.
# Heartening, though - reading linux/mm/filemap.c shows that linux
# supports asynchronous read-ahead.  So _MOST_ of the time, the data
# will be sitting in memory for us already when we go to read it.
#
# What other OS's (besides NT) support async file i/o?  [VMS?]
#
# Regardless, this is useful for pipes, and stdin/stdout...

if os.name == 'posix':
    import fcntl

    class file_wrapper:
        # Here we override just enough to make a file
        # look like a socket for the purposes of asyncore.
        # The passed fd is automatically os.dup()'d

        def __init__(self, fd):
            self.fd = os.dup(fd)

        def recv(self, *args):
            return os.read(self.fd, *args)

        def send(self, *args):
            return os.write(self.fd, *args)

        def getsockopt(self, level, optname, buflen=None):
            if (level == socket.SOL_SOCKET and
                optname == socket.SO_ERROR and
                not buflen):
                return 0
            raise NotImplementedError("Only asyncore specific behaviour "
                                      "implemented.")

        read = recv
        write = send

        def close(self):
            os.close(self.fd)

        def fileno(self):
            return self.fd

    class file_dispatcher(dispatcher):

        def __init__(self, fd, map=None):
            dispatcher.__init__(self, None, map)
            self.connected = True
            try:
                fd = fd.fileno()
            except AttributeError:
                pass
            self.set_file(fd)
            # set it to non-blocking mode
            flags = fcntl.fcntl(fd, fcntl.F_GETFL, 0)
            flags = flags | os.O_NONBLOCK
            fcntl.fcntl(fd, fcntl.F_SETFL, flags)

        def set_file(self, fd):
            self.socket = file_wrapper(fd)
            self._fileno = self.socket.fileno()
            self.add_channel()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Û
”´[c           @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z m	 Z	 m
 Z
 m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z e e e e e e e f É Z y e Wn e k
 rÎ i  Z n Xd Ñ  Z d e f d Ñ  É  YZ e e e f Z d Ñ  Z  d Ñ  Z! d	 Ñ  Z" d
 Ñ  Z# d e$ d Ñ Z% d e$ d Ñ Z& e& Z' d e( e$ e$ d Ñ Z) d f  d Ñ  É  YZ* d e* f d Ñ  É  YZ+ d Ñ  Z, e$ e( d Ñ Z- e j. d k rˇd d l/ Z/ d f  d Ñ  É  YZ0 d e* f d Ñ  É  YZ1 n  d S(   s†  Basic infrastructure for asynchronous socket service clients and servers.

There are only two ways to have a program on a single processor do "more
than one thing at a time".  Multi-threaded programming is the simplest and
most popular way to do it, but there is another very different technique,
that lets you have nearly all the advantages of multi-threading, without
actually using multiple threads. it's really only practical if your program
is largely I/O bound. If your program is CPU bound, then pre-emptive
scheduled threads are probably what you really need. Network servers are
rarely CPU-bound, however.

If your operating system supports the select() system call in its I/O
library (and nearly all do), then you can use it to juggle multiple
communication channels at once; doing other work while your I/O is taking
place in the "background."  Although this strategy can seem strange and
complex, especially at first, it is in many ways easier to understand and
control than multi-threaded programming. The module documented here solves
many of the difficult problems for you, making the task of building
sophisticated high-performance network servers and clients a snap.
iˇˇˇˇN(   t   EALREADYt   EINPROGRESSt   EWOULDBLOCKt
   ECONNRESETt   EINVALt   ENOTCONNt	   ESHUTDOWNt   EINTRt   EISCONNt   EBADFt   ECONNABORTEDt   EPIPEt   EAGAINt	   errorcodec         C   sK   y t  j |  É SWn3 t t t f k
 rF |  t k r> t |  Sd |  SXd  S(   Ns   Unknown error %s(   t   ost   strerrort
   ValueErrort   OverflowErrort	   NameErrorR   (   t   err(    (    s   /usr/lib/python2.7/asyncore.pyt	   _strerrorD   s    t   ExitNowc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/asyncore.pyR   L   s   c         C   s9   y |  j  É  Wn$ t k
 r$ Ç  n |  j É  n Xd  S(   N(   t   handle_read_eventt   _reraised_exceptionst   handle_error(   t   obj(    (    s   /usr/lib/python2.7/asyncore.pyt   readQ   s    c         C   s9   y |  j  É  Wn$ t k
 r$ Ç  n |  j É  n Xd  S(   N(   t   handle_write_eventR   R   (   R   (    (    s   /usr/lib/python2.7/asyncore.pyt   writeY   s    c         C   s9   y |  j  É  Wn$ t k
 r$ Ç  n |  j É  n Xd  S(   N(   t   handle_expt_eventR   R   (   R   (    (    s   /usr/lib/python2.7/asyncore.pyt
   _exceptiona   s    c         C   s‰   yz | t  j @r |  j É  n  | t  j @r7 |  j É  n  | t  j @rQ |  j É  n  | t  j t  j Bt  j	 B@ry |  j
 É  n  Wnc t j k
 rº } | j d t k rØ |  j É  q‡ |  j
 É  n$ t k
 rœ Ç  n |  j É  n Xd  S(   Ni    (   t   selectt   POLLINR   t   POLLOUTR   t   POLLPRIR   t   POLLHUPt   POLLERRt   POLLNVALt   handle_closet   sockett   errort   argst   _DISCONNECTEDR   R   (   R   t   flagst   e(    (    s   /usr/lib/python2.7/asyncore.pyt	   readwritei   s"    g        c   
      C   s  | d  k r t } n  | r˛g  } g  } g  } xÑ | j É  D]v \ } } | j É  } | j É  } | rt | j | É n  | rî | j rî | j | É n  | s† | r: | j | É q: q: Wg  | k o÷ | k o÷ | k n rÏ t j |  É d  Sy% t	 j	 | | | |  É \ } } } Wn3 t	 j
 k
 rF}	 |	 j d t k r?Ç  qGd  Sn Xx9 | D]1 } | j | É } | d  k ruqNn  t | É qNWx9 | D]1 } | j | É } | d  k r±qän  t | É qäWx< | D]1 } | j | É } | d  k rÌq∆n  t | É q∆Wn  d  S(   Ni    (   t   Nonet
   socket_mapt   itemst   readablet   writablet   appendt	   acceptingt   timet   sleepR!   R*   R+   R   t   getR   R   R    (
   t   timeoutt   mapt   rt   wR.   t   fdR   t   is_rt   is_wR   (    (    s   /usr/lib/python2.7/asyncore.pyt   poll}   sN    	  '%c         C   s}  | d  k r t } n  |  d  k	 r4 t |  d É }  n  t j É  } | ryxù | j É  D]è \ } } d } | j É  rà | t j t j BO} n  | j	 É  rÆ | j
 rÆ | t j O} n  | rS | t j t j Bt j BO} | j | | É qS qS Wy | j |  É } Wn5 t j k
 r0} | j d t k r'Ç  n  g  } n XxE | D]: \ } } | j | É } | d  k req8n  t | | É q8Wn  d  S(   NiË  i    (   R0   R1   t   intR!   RA   R2   R3   R"   R$   R4   R6   R#   R&   R%   R'   t   registerR*   R+   R   R9   R/   (   R:   R;   t   pollsterR>   R   R-   R<   R   (    (    s   /usr/lib/python2.7/asyncore.pyt   poll2™   s4    	
g      >@c         C   sñ   | d  k r t } n  | r3 t t d É r3 t } n t } | d  k rb xJ | r^ | |  | É qH Wn0 x- | rë | d k rë | |  | É | d } qe Wd  S(   NRA   i    i   (   R0   R1   t   hasattrR!   RE   RA   (   R:   t   use_pollR;   t   countt   poll_fun(    (    s   /usr/lib/python2.7/asyncore.pyt   loopÕ   s    			t
   dispatcherc           B   sa  e  Z e Z e Z e Z e Z e Z d  Z	 e
 d  g É Z d  d  d Ñ Z d Ñ  Z e Z d  d Ñ Z d  d Ñ Z d Ñ  Z d  d Ñ Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& d Ñ  Z' d Ñ  Z( d Ñ  Z) d Ñ  Z* RS(!   t   warningc         C   s«   | d  k r t |  _ n	 | |  _ d  |  _ | r∫ | j d É |  j | | É t |  _ y | j É  |  _	 Wq√ t
 j k
 r∂ } | j d t t f k r£ t |  _ q∑ |  j | É Ç  q√ Xn	 d  |  _
 d  S(   Ni    (   R0   R1   t   _mapt   _filenot   setblockingt
   set_sockett   Truet	   connectedt   getpeernamet   addrR)   R*   R+   R   R   t   Falset   del_channel(   t   selft   sockR;   R   (    (    s   /usr/lib/python2.7/asyncore.pyt   __init__È   s     			
c         C   s…   |  j  j d |  j  j g } |  j r? |  j r? | j d É n |  j rX | j d É n  |  j d  k	 r¨ y | j d |  j É Wq¨ t k
 r® | j t	 |  j É É q¨ Xn  d d j
 | É t |  É f S(   Nt   .t	   listeningRR   s   %s:%ds   <%s at %#x>t    (   t	   __class__R   R   R6   RT   R5   RR   R0   t	   TypeErrort   reprt   joint   id(   RW   t   status(    (    s   /usr/lib/python2.7/asyncore.pyt   __repr__	  s    	c         C   s)   | d  k r |  j } n  |  | |  j <d  S(   N(   R0   RM   RN   (   RW   R;   (    (    s   /usr/lib/python2.7/asyncore.pyt   add_channel  s    c         C   sD   |  j  } | d  k r! |  j } n  | | k r7 | | =n  d  |  _  d  S(   N(   RN   R0   RM   (   RW   R;   R>   (    (    s   /usr/lib/python2.7/asyncore.pyRV     s    	
c         C   s?   | | f |  _  t j | | É } | j d É |  j | É d  S(   Ni    (   t   family_and_typeR)   RO   RP   (   RW   t   familyt   typeRX   (    (    s   /usr/lib/python2.7/asyncore.pyt   create_socket'  s    c         C   s)   | |  _  | j É  |  _ |  j | É d  S(   N(   R)   t   filenoRN   Rd   (   RW   RX   R;   (    (    s   /usr/lib/python2.7/asyncore.pyRP   -  s    	c         C   sT   y9 |  j  j t  j t  j |  j  j t  j t  j É d BÉ Wn t  j k
 rO n Xd  S(   Ni   (   R)   t
   setsockoptt
   SOL_SOCKETt   SO_REUSEADDRt
   getsockoptR*   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyt   set_reuse_addr3  s    	c         C   s   t  S(   N(   RQ   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyR3   D  s    c         C   s   t  S(   N(   RQ   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyR4   G  s    c         C   s=   t  |  _ t j d k r- | d k r- d } n  |  j j | É S(   Nt   nti   (   RQ   R6   R   t   nameR)   t   listen(   RW   t   num(    (    s   /usr/lib/python2.7/asyncore.pyRq   N  s    		c         C   s   | |  _  |  j j | É S(   N(   RT   R)   t   bind(   RW   RT   (    (    s   /usr/lib/python2.7/asyncore.pyRs   T  s    	c         C   s£   t  |  _ t |  _ |  j j | É } | t t t f k sT | t	 k ra t
 j d k ra | |  _ d  S| d t f k râ | |  _ |  j É  n t j | t | É Ç d  S(   NRo   t   cei    (   Ro   Rt   (   RU   RR   RQ   t
   connectingR)   t
   connect_exR   R    R   R   R   Rp   RT   R   t   handle_connect_eventR*   R   (   RW   t   addressR   (    (    s   /usr/lib/python2.7/asyncore.pyt   connectX  s    				c         C   st   y |  j  j É  \ } } WnJ t k
 r- d  St  j k
 re } | j d t t t f k r_ d  SÇ  n X| | f Sd  S(   Ni    (	   R)   t   acceptR^   R0   R*   R+   R   R
   R   (   RW   t   connRT   t   why(    (    s   /usr/lib/python2.7/asyncore.pyRz   f  s    c         C   sr   y |  j  j | É } | SWnQ t  j k
 rm } | j d t k rF d S| j d t k rg |  j É  d SÇ  n Xd  S(   Ni    (   R)   t   sendR*   R+   R   R,   R(   (   RW   t   datat   resultR|   (    (    s   /usr/lib/python2.7/asyncore.pyR}   t  s    
c         C   so   y. |  j  j | É } | s) |  j É  d S| SWn: t  j k
 rj } | j d t k rd |  j É  d SÇ  n Xd  S(   Nt    i    (   R)   t   recvR(   R*   R+   R,   (   RW   t   buffer_sizeR~   R|   (    (    s   /usr/lib/python2.7/asyncore.pyRÅ   Å  s    

c         C   sr   t  |  _ t  |  _ t  |  _ |  j É  y |  j j É  Wn5 t j k
 rm } | j d t	 t
 f k rn Ç  qn n Xd  S(   Ni    (   RU   RR   R6   Ru   RV   R)   t   closeR*   R+   R   R	   (   RW   R|   (    (    s   /usr/lib/python2.7/asyncore.pyRÉ   ì  s    			
c         C   sÇ   y t  |  j | É } Wn- t k
 rE t d |  j j | f É Ç n9 Xd i |  j j d 6| d 6} t j | t d d É| Sd  S(   Ns!   %s instance has no attribute '%s'sB   %(me)s.%(attr)s is deprecated. Use %(me)s.socket.%(attr)s instead.t   met   attrt
   stackleveli   (   t   getattrR)   t   AttributeErrorR]   R   t   warningst   warnt   DeprecationWarning(   RW   RÖ   t   retattrt   msg(    (    s   /usr/lib/python2.7/asyncore.pyt   __getattr__†  s    c         C   s   t  j j d t | É É d  S(   Ns   log: %s
(   t   syst   stderrR   t   str(   RW   t   message(    (    s   /usr/lib/python2.7/asyncore.pyt   log∞  s    t   infoc         C   s%   | |  j  k r! d | | f GHn  d  S(   Ns   %s: %s(   t   ignore_log_types(   RW   Rí   Rg   (    (    s   /usr/lib/python2.7/asyncore.pyt   log_info≥  s    c         C   sP   |  j  r |  j É  n6 |  j sB |  j r5 |  j É  n  |  j É  n
 |  j É  d  S(   N(   R6   t   handle_acceptRR   Ru   Rw   t   handle_read(   RW   (    (    s   /usr/lib/python2.7/asyncore.pyR   ∑  s    			c         C   sb   |  j  j t  j t  j É } | d k rB t  j | t | É É Ç n  |  j É  t |  _ t	 |  _
 d  S(   Ni    (   R)   Rm   Rk   t   SO_ERRORR*   R   t   handle_connectRQ   RR   RU   Ru   (   RW   R   (    (    s   /usr/lib/python2.7/asyncore.pyRw   √  s    
	c         C   s=   |  j  r d  S|  j s/ |  j r/ |  j É  q/ n  |  j É  d  S(   N(   R6   RR   Ru   Rw   t   handle_write(   RW   (    (    s   /usr/lib/python2.7/asyncore.pyR   À  s    			c         C   sB   |  j  j t  j t  j É } | d k r4 |  j É  n
 |  j É  d  S(   Ni    (   R)   Rm   Rk   Rô   R(   t   handle_expt(   RW   R   (    (    s   /usr/lib/python2.7/asyncore.pyR   ÷  s    c         C   sm   t  É  \ } } } } y t |  É } Wn d t |  É } n X|  j d | | | | f d É |  j É  d  S(   Ns)   <__repr__(self) failed for object at %0x>s:   uncaptured python exception, closing channel %s (%s:%s %s)R*   (   t   compact_tracebackR_   Ra   Rñ   R(   (   RW   t   nilt   tt   vt   tbinfot	   self_repr(    (    s   /usr/lib/python2.7/asyncore.pyR   Â  s    c         C   s   |  j  d d É d  S(   Ns!   unhandled incoming priority eventRL   (   Rñ   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyRú   ˘  s    c         C   s   |  j  d d É d  S(   Ns   unhandled read eventRL   (   Rñ   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyRò   ¸  s    c         C   s   |  j  d d É d  S(   Ns   unhandled write eventRL   (   Rñ   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyRõ   ˇ  s    c         C   s   |  j  d d É d  S(   Ns   unhandled connect eventRL   (   Rñ   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyRö     s    c         C   s   |  j  d d É d  S(   Ns   unhandled accept eventRL   (   Rñ   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyRó     s    c         C   s   |  j  d d É |  j É  d  S(   Ns   unhandled close eventRL   (   Rñ   RÉ   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyR(     s    N(+   R   R   RU   t   debugRR   R6   Ru   t   closingR0   RT   t	   frozensetRï   RY   Rc   t   __str__Rd   RV   Rh   RP   Rn   R3   R4   Rq   Rs   Ry   Rz   R}   RÅ   RÉ   Ré   Rì   Rñ   R   Rw   R   R   R   Rú   Rò   Rõ   Rö   Ró   R(   (    (    (    s   /usr/lib/python2.7/asyncore.pyRK   ﬂ   sL    																									t   dispatcher_with_sendc           B   s;   e  Z d d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s    t  j |  | | É d |  _ d  S(   NRÄ   (   RK   RY   t
   out_buffer(   RW   RX   R;   (    (    s   /usr/lib/python2.7/asyncore.pyRY     s    c         C   s3   d } t  j |  |  j d  É } |  j | |  _ d  S(   Ni    i   (   RK   R}   R®   (   RW   t   num_sent(    (    s   /usr/lib/python2.7/asyncore.pyt   initiate_send  s    c         C   s   |  j  É  d  S(   N(   R™   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyRõ     s    c         C   s   |  j  p t |  j É S(   N(   RR   t   lenR®   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyR4     s    c         C   sA   |  j  r# |  j d t | É É n  |  j | |  _ |  j É  d  S(   Ns
   sending %s(   R£   Rñ   R_   R®   R™   (   RW   R~   (    (    s   /usr/lib/python2.7/asyncore.pyR}   "  s    	N(   R   R   R0   RY   R™   Rõ   R4   R}   (    (    (    s   /usr/lib/python2.7/asyncore.pyRß     s
   			c    	      C   sÃ   t  j É  \ }  } } g  } | s0 t d É Ç n  xD | rv | j | j j j | j j j t | j	 É f É | j
 } q3 W~ | d \ } } } d j g  | D] } d | ^ qö É } | | | f |  | | f S(   Ns   traceback does not existiˇˇˇˇR\   s
   [%s|%s|%s](   Rè   t   exc_infot   AssertionErrorR5   t   tb_framet   f_codet   co_filenamet   co_nameRë   t	   tb_linenot   tb_nextR`   (	   Rü   R†   t   tbR°   t   filet   functiont   linet   xRî   (    (    s   /usr/lib/python2.7/asyncore.pyRù   ,  s    	&c         C   s•   |  d  k r t }  n  x |  j É  D]q } y | j É  Wq" t k
 rm } | j d t k r^ qì | sì Ç  qì q" t k
 rÄ Ç  q" | sì Ç  qì q" Xq" W|  j É  d  S(   Ni    (	   R0   R1   t   valuesRÉ   t   OSErrorR+   R	   R   t   clear(   R;   t
   ignore_allR∏   (    (    s   /usr/lib/python2.7/asyncore.pyt	   close_all@  s     		t   posixt   file_wrapperc           B   sM   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z e Z e Z d Ñ  Z	 d Ñ  Z
 RS(   c         C   s   t  j | É |  _ d  S(   N(   R   t   dupR>   (   RW   R>   (    (    s   /usr/lib/python2.7/asyncore.pyRY   g  s    c         G   s   t  j |  j | å S(   N(   R   R   R>   (   RW   R+   (    (    s   /usr/lib/python2.7/asyncore.pyRÅ   j  s    c         G   s   t  j |  j | å S(   N(   R   R   R>   (   RW   R+   (    (    s   /usr/lib/python2.7/asyncore.pyR}   m  s    c         C   s9   | t  j k r) | t  j k r) | r) d St d É Ç d  S(   Ni    s-   Only asyncore specific behaviour implemented.(   R)   Rk   Rô   t   NotImplementedError(   RW   t   levelt   optnamet   buflen(    (    s   /usr/lib/python2.7/asyncore.pyRm   p  s
    c         C   s   t  j |  j É d  S(   N(   R   RÉ   R>   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyRÉ   {  s    c         C   s   |  j  S(   N(   R>   (   RW   (    (    s   /usr/lib/python2.7/asyncore.pyRi   ~  s    N(   R   R   RY   RÅ   R}   R0   Rm   R   R   RÉ   Ri   (    (    (    s   /usr/lib/python2.7/asyncore.pyRø   b  s   				t   file_dispatcherc           B   s   e  Z d d  Ñ Z d Ñ  Z RS(   c         C   så   t  j |  d  | É t |  _ y | j É  } Wn t k
 r? n X|  j | É t j | t j	 d É } | t
 j B} t j | t j | É d  S(   Ni    (   RK   RY   R0   RQ   RR   Ri   Rà   t   set_filet   fcntlt   F_GETFLR   t
   O_NONBLOCKt   F_SETFL(   RW   R>   R;   R-   (    (    s   /usr/lib/python2.7/asyncore.pyRY   É  s    	c         C   s/   t  | É |  _ |  j j É  |  _ |  j É  d  S(   N(   Rø   R)   Ri   RN   Rd   (   RW   R>   (    (    s   /usr/lib/python2.7/asyncore.pyR∆   ê  s    N(   R   R   R0   RY   R∆   (    (    (    s   /usr/lib/python2.7/asyncore.pyR≈   Å  s   (2   t   __doc__R!   R)   Rè   R7   Râ   R   t   errnoR    R   R   R   R   R   R   R   R   R	   R
   R   R   R   R•   R,   R1   R   R   t	   ExceptionR   t   KeyboardInterruptt
   SystemExitR   R   R   R    R/   R0   RA   RE   t   poll3RU   RJ   RK   Rß   Rù   RΩ   Rp   R«   Rø   R≈   (    (    (    s   /usr/lib/python2.7/asyncore.pyt   <module>/   sB   ^
					-!ˇ 3	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """
atexit.py - allow programmer to define multiple exit functions to be executed
upon normal program termination.

One public function, register, is defined.
"""

__all__ = ["register"]

import sys

_exithandlers = []
def _run_exitfuncs():
    """run any registered exit functions

    _exithandlers is traversed in reverse order so functions are executed
    last in, first out.
    """

    exc_info = None
    while _exithandlers:
        func, targs, kargs = _exithandlers.pop()
        try:
            func(*targs, **kargs)
        except SystemExit:
            exc_info = sys.exc_info()
        except:
            import traceback
            print >> sys.stderr, "Error in atexit._run_exitfuncs:"
            traceback.print_exc()
            exc_info = sys.exc_info()

    if exc_info is not None:
        raise exc_info[0], exc_info[1], exc_info[2]


def register(func, *targs, **kargs):
    """register a function to be executed upon normal program termination

    func - function to be called at exit
    targs - optional arguments to pass to func
    kargs - optional keyword arguments to pass to func

    func is returned to facilitate usage as a decorator.
    """
    _exithandlers.append((func, targs, kargs))
    return func

if hasattr(sys, "exitfunc"):
    # Assume it's another registered exit function - append it to our list
    register(sys.exitfunc)
sys.exitfunc = _run_exitfuncs

if __name__ == "__main__":
    def x1():
        print "running x1"
    def x2(n):
        print "running x2(%r)" % (n,)
    def x3(n, kwd=None):
        print "running x3(%r, kwd=%r)" % (n, kwd)

    register(x1)
    register(x2, 12)
    register(x3, 5, "bar")
    register(x3, "no kwd args")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """Classes for manipulating audio devices (currently only for Sun and SGI)"""
from warnings import warnpy3k
warnpy3k("the audiodev module has been removed in Python 3.0", stacklevel=2)
del warnpy3k

__all__ = ["error","AudioDev"]

class error(Exception):
    pass

class Play_Audio_sgi:
    # Private instance variables
##      if 0: access frameratelist, nchannelslist, sampwidthlist, oldparams, \
##                params, config, inited_outrate, inited_width, \
##                inited_nchannels, port, converter, classinited: private

    classinited = 0
    frameratelist = nchannelslist = sampwidthlist = None

    def initclass(self):
        import AL
        self.frameratelist = [
                  (48000, AL.RATE_48000),
                  (44100, AL.RATE_44100),
                  (32000, AL.RATE_32000),
                  (22050, AL.RATE_22050),
                  (16000, AL.RATE_16000),
                  (11025, AL.RATE_11025),
                  ( 8000,  AL.RATE_8000),
                  ]
        self.nchannelslist = [
                  (1, AL.MONO),
                  (2, AL.STEREO),
                  (4, AL.QUADRO),
                  ]
        self.sampwidthlist = [
                  (1, AL.SAMPLE_8),
                  (2, AL.SAMPLE_16),
                  (3, AL.SAMPLE_24),
                  ]
        self.classinited = 1

    def __init__(self):
        import al, AL
        if not self.classinited:
            self.initclass()
        self.oldparams = []
        self.params = [AL.OUTPUT_RATE, 0]
        self.config = al.newconfig()
        self.inited_outrate = 0
        self.inited_width = 0
        self.inited_nchannels = 0
        self.converter = None
        self.port = None
        return

    def __del__(self):
        if self.port:
            self.stop()
        if self.oldparams:
            import al, AL
            al.setparams(AL.DEFAULT_DEVICE, self.oldparams)
            self.oldparams = []

    def wait(self):
        if not self.port:
            return
        import time
        while self.port.getfilled() > 0:
            time.sleep(0.1)
        self.stop()

    def stop(self):
        if self.port:
            self.port.closeport()
            self.port = None
        if self.oldparams:
            import al, AL
            al.setparams(AL.DEFAULT_DEVICE, self.oldparams)
            self.oldparams = []

    def setoutrate(self, rate):
        for (raw, cooked) in self.frameratelist:
            if rate == raw:
                self.params[1] = cooked
                self.inited_outrate = 1
                break
        else:
            raise error, 'bad output rate'

    def setsampwidth(self, width):
        for (raw, cooked) in self.sampwidthlist:
            if width == raw:
                self.config.setwidth(cooked)
                self.inited_width = 1
                break
        else:
            if width == 0:
                import AL
                self.inited_width = 0
                self.config.setwidth(AL.SAMPLE_16)
                self.converter = self.ulaw2lin
            else:
                raise error, 'bad sample width'

    def setnchannels(self, nchannels):
        for (raw, cooked) in self.nchannelslist:
            if nchannels == raw:
                self.config.setchannels(cooked)
                self.inited_nchannels = 1
                break
        else:
            raise error, 'bad # of channels'

    def writeframes(self, data):
        if not (self.inited_outrate and self.inited_nchannels):
            raise error, 'params not specified'
        if not self.port:
            import al, AL
            self.port = al.openport('Python', 'w', self.config)
            self.oldparams = self.params[:]
            al.getparams(AL.DEFAULT_DEVICE, self.oldparams)
            al.setparams(AL.DEFAULT_DEVICE, self.params)
        if self.converter:
            data = self.converter(data)
        self.port.writesamps(data)

    def getfilled(self):
        if self.port:
            return self.port.getfilled()
        else:
            return 0

    def getfillable(self):
        if self.port:
            return self.port.getfillable()
        else:
            return self.config.getqueuesize()

    # private methods
##      if 0: access *: private

    def ulaw2lin(self, data):
        import audioop
        return audioop.ulaw2lin(data, 2)

class Play_Audio_sun:
##      if 0: access outrate, sampwidth, nchannels, inited_outrate, inited_width, \
##                inited_nchannels, converter: private

    def __init__(self):
        self.outrate = 0
        self.sampwidth = 0
        self.nchannels = 0
        self.inited_outrate = 0
        self.inited_width = 0
        self.inited_nchannels = 0
        self.converter = None
        self.port = None
        return

    def __del__(self):
        self.stop()

    def setoutrate(self, rate):
        self.outrate = rate
        self.inited_outrate = 1

    def setsampwidth(self, width):
        self.sampwidth = width
        self.inited_width = 1

    def setnchannels(self, nchannels):
        self.nchannels = nchannels
        self.inited_nchannels = 1

    def writeframes(self, data):
        if not (self.inited_outrate and self.inited_width and self.inited_nchannels):
            raise error, 'params not specified'
        if not self.port:
            import sunaudiodev, SUNAUDIODEV
            self.port = sunaudiodev.open('w')
            info = self.port.getinfo()
            info.o_sample_rate = self.outrate
            info.o_channels = self.nchannels
            if self.sampwidth == 0:
                info.o_precision = 8
                self.o_encoding = SUNAUDIODEV.ENCODING_ULAW
                # XXX Hack, hack -- leave defaults
            else:
                info.o_precision = 8 * self.sampwidth
                info.o_encoding = SUNAUDIODEV.ENCODING_LINEAR
                self.port.setinfo(info)
        if self.converter:
            data = self.converter(data)
        self.port.write(data)

    def wait(self):
        if not self.port:
            return
        self.port.drain()
        self.stop()

    def stop(self):
        if self.port:
            self.port.flush()
            self.port.close()
            self.port = None

    def getfilled(self):
        if self.port:
            return self.port.obufcount()
        else:
            return 0

##    # Nobody remembers what this method does, and it's broken. :-(
##    def getfillable(self):
##        return BUFFERSIZE - self.getfilled()

def AudioDev():
    # Dynamically try to import and use a platform specific module.
    try:
        import al
    except ImportError:
        try:
            import sunaudiodev
            return Play_Audio_sun()
        except ImportError:
            try:
                import Audio_mac
            except ImportError:
                raise error, 'no audio device'
            else:
                return Audio_mac.Play_Audio_mac()
    else:
        return Play_Audio_sgi()

def test(fn = None):
    import sys
    if sys.argv[1:]:
        fn = sys.argv[1]
    else:
        fn = 'f:just samples:just.aif'
    import aifc
    af = aifc.open(fn, 'r')
    print fn, af.getparams()
    p = AudioDev()
    p.setoutrate(af.getframerate())
    p.setsampwidth(af.getsampwidth())
    p.setnchannels(af.getnchannels())
    BUFSIZ = af.getframerate()/af.getsampwidth()/af.getnchannels()
    while 1:
        data = af.readframes(BUFSIZ)
        if not data: break
        print len(data)
        p.writeframes(data)
    p.wait()

if __name__ == '__main__':
    test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   s†   d  Z  d d l m Z e d d d É[ d d g Z d e f d Ñ  É  YZ d	 d d
 Ñ  É  YZ d d d Ñ  É  YZ d Ñ  Z d d Ñ Z
 e d k rú e
 É  n  d S(   sG   Classes for manipulating audio devices (currently only for Sun and SGI)iˇˇˇˇ(   t   warnpy3ks2   the audiodev module has been removed in Python 3.0t
   stackleveli   t   errort   AudioDevc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/audiodev.pyR      s   t   Play_Audio_sgic           B   sà   e  Z d  Z d Z Z Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z RS(   i    c         C   s–   d d  l  } d | j f d | j f d | j f d | j f d | j f d | j f d | j f g |  _ d	 | j	 f d
 | j
 f d | j f g |  _ d	 | j f d
 | j f d | j f g |  _ d	 |  _ d  S(   NiˇˇˇˇiÄª  iD¨  i }  i"V  iÄ>  i+  i@  i   i   i   i   (   t   ALt
   RATE_48000t
   RATE_44100t
   RATE_32000t
   RATE_22050t
   RATE_16000t
   RATE_11025t	   RATE_8000t   frameratelistt   MONOt   STEREOt   QUADROt   nchannelslistt   SAMPLE_8t	   SAMPLE_16t	   SAMPLE_24t   sampwidthlistt   classinited(   t   selfR   (    (    s   /usr/lib/python2.7/audiodev.pyt	   initclass   s    c         C   sâ   d d  l  } d d  l } |  j s. |  j É  n  g  |  _ | j d g |  _ | j É  |  _ d |  _	 d |  _
 d |  _ d  |  _ d  |  _ d  S(   Niˇˇˇˇi    (   t   alR   R   R   t	   oldparamst   OUTPUT_RATEt   paramst	   newconfigt   configt   inited_outratet   inited_widtht   inited_nchannelst   Nonet	   convertert   port(   R   R   R   (    (    s   /usr/lib/python2.7/audiodev.pyt   __init__+   s    							c         C   s]   |  j  r |  j É  n  |  j rY d d  l } d d  l } | j | j |  j É g  |  _ n  d  S(   Niˇˇˇˇ(   R&   t   stopR   R   R   t	   setparamst   DEFAULT_DEVICE(   R   R   R   (    (    s   /usr/lib/python2.7/audiodev.pyt   __del__9   s    		c         C   sP   |  j  s d  Sd d  l } x& |  j  j É  d k rA | j d É q W|  j É  d  S(   Niˇˇˇˇi    göôôôôôπ?(   R&   t   timet	   getfilledt   sleepR(   (   R   R,   (    (    s   /usr/lib/python2.7/audiodev.pyt   waitA   s    	c         C   si   |  j  r" |  j  j É  d  |  _  n  |  j re d d  l } d d  l } | j | j |  j É g  |  _ n  d  S(   Niˇˇˇˇ(   R&   t	   closeportR$   R   R   R   R)   R*   (   R   R   R   (    (    s   /usr/lib/python2.7/audiodev.pyR(   I   s    		c         C   sM   xF |  j  D]2 \ } } | | k r
 | |  j d <d |  _ Pq
 q
 Wt d Ç d  S(   Ni   s   bad output rate(   R   R   R!   R   (   R   t   ratet   rawt   cooked(    (    s   /usr/lib/python2.7/audiodev.pyt
   setoutrateR   s    	c         C   sì   xå |  j  D]5 \ } } | | k r
 |  j j | É d |  _ Pq
 q
 W| d k rÜ d d  l } d |  _ |  j j | j É |  j |  _ n	 t d Ç d  S(   Ni   i    iˇˇˇˇs   bad sample width(	   R   R    t   setwidthR"   R   R   t   ulaw2linR%   R   (   R   t   widthR2   R3   R   (    (    s   /usr/lib/python2.7/audiodev.pyt   setsampwidth[   s    		c         C   sP   xI |  j  D]5 \ } } | | k r
 |  j j | É d |  _ Pq
 q
 Wt d Ç d  S(   Ni   s   bad # of channels(   R   R    t   setchannelsR#   R   (   R   t	   nchannelsR2   R3   (    (    s   /usr/lib/python2.7/audiodev.pyt   setnchannelsj   s    	c         C   s≈   |  j  o |  j s t d Ç n  |  j sñ d d  l } d d  l } | j d d |  j É |  _ |  j |  _	 | j
 | j |  j	 É | j | j |  j É n  |  j r± |  j | É } n  |  j j | É d  S(   Ns   params not specifiediˇˇˇˇt   Pythont   w(   R!   R#   R   R&   R   R   t   openportR    R   R   t	   getparamsR*   R)   R%   t
   writesamps(   R   t   dataR   R   (    (    s   /usr/lib/python2.7/audiodev.pyt   writeframess   s    		c         C   s   |  j  r |  j  j É  Sd Sd  S(   Ni    (   R&   R-   (   R   (    (    s   /usr/lib/python2.7/audiodev.pyR-   Ä   s    	c         C   s'   |  j  r |  j  j É  S|  j j É  Sd  S(   N(   R&   t   getfillableR    t   getqueuesize(   R   (    (    s   /usr/lib/python2.7/audiodev.pyRC   Ü   s    	c         C   s   d d  l  } | j | d É S(   Niˇˇˇˇi   (   t   audioopR6   (   R   RA   RE   (    (    s   /usr/lib/python2.7/audiodev.pyR6   è   s    N(   R   R   R   R$   R   R   R   R   R'   R+   R/   R(   R4   R8   R;   RB   R-   RC   R6   (    (    (    s   /usr/lib/python2.7/audiodev.pyR      s   															t   Play_Audio_sunc           B   sY   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   c         C   sL   d |  _  d |  _ d |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  S(   Ni    (	   t   outratet	   sampwidthR:   R!   R"   R#   R$   R%   R&   (   R   (    (    s   /usr/lib/python2.7/audiodev.pyR'   ó   s    								c         C   s   |  j  É  d  S(   N(   R(   (   R   (    (    s   /usr/lib/python2.7/audiodev.pyR+   ¢   s    c         C   s   | |  _  d |  _ d  S(   Ni   (   RG   R!   (   R   R1   (    (    s   /usr/lib/python2.7/audiodev.pyR4   •   s    	c         C   s   | |  _  d |  _ d  S(   Ni   (   RH   R"   (   R   R7   (    (    s   /usr/lib/python2.7/audiodev.pyR8   ©   s    	c         C   s   | |  _  d |  _ d  S(   Ni   (   R:   R#   (   R   R:   (    (    s   /usr/lib/python2.7/audiodev.pyR;   ≠   s    	c         C   s  |  j  o |  j o |  j s' t d Ç n  |  j s◊ d d  l } d d  l } | j d É |  _ |  j j É  } |  j	 | _
 |  j | _ |  j d k r® d | _ | j |  _ q◊ d |  j | _ | j | _ |  j j | É n  |  j rÚ |  j | É } n  |  j j | É d  S(   Ns   params not specifiediˇˇˇˇR=   i    i   (   R!   R"   R#   R   R&   t   sunaudiodevt   SUNAUDIODEVt   opent   getinfoRG   t   o_sample_rateR:   t
   o_channelsRH   t   o_precisiont   ENCODING_ULAWt
   o_encodingt   ENCODING_LINEARt   setinfoR%   t   write(   R   RA   RI   RJ   t   info(    (    s   /usr/lib/python2.7/audiodev.pyRB   ±   s"    			c         C   s(   |  j  s d  S|  j  j É  |  j É  d  S(   N(   R&   t   drainR(   (   R   (    (    s   /usr/lib/python2.7/audiodev.pyR/   ∆   s    	c         C   s3   |  j  r/ |  j  j É  |  j  j É  d  |  _  n  d  S(   N(   R&   t   flusht   closeR$   (   R   (    (    s   /usr/lib/python2.7/audiodev.pyR(   Ã   s    	c         C   s   |  j  r |  j  j É  Sd Sd  S(   Ni    (   R&   t	   obufcount(   R   (    (    s   /usr/lib/python2.7/audiodev.pyR-   “   s    	(   R   R   R'   R+   R4   R8   R;   RB   R/   R(   R-   (    (    (    s   /usr/lib/python2.7/audiodev.pyRF   ì   s   								c          C   së   y d d  l  }  Wns t k
 rÖ y d d  l } t É  SWqç t k
 rÅ y d d  l } Wn t k
 rs t d Ç qÇ X| j É  Sqç Xn Xt É  Sd  S(   Niˇˇˇˇs   no audio device(   R   t   ImportErrorRI   RF   t	   Audio_macR   t   Play_Audio_macR   (   R   RI   R[   (    (    s   /usr/lib/python2.7/audiodev.pyR   ‹   s    c         C   s  d d  l  } | j d r) | j d }  n d }  d d  l } | j |  d É } |  G| j É  GHt É  } | j | j É  É | j | j	 É  É | j
 | j É  É | j É  | j	 É  | j É  } x5 | j | É } | s⁄ Pn  t | É GH| j | É q¡ W| j É  d  S(   Niˇˇˇˇi   s   f:just samples:just.aift   r(   t   syst   argvt   aifcRK   R?   R   R4   t   getframerateR8   t   getsampwidthR;   t   getnchannelst
   readframest   lenRB   R/   (   t   fnR^   R`   t   aft   pt   BUFSIZRA   (    (    s   /usr/lib/python2.7/audiodev.pyt   testÓ   s&    	 