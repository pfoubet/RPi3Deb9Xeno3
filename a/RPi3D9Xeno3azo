"""Class for printing reports on profiled python code."""

# Written by James Roskind
# Based on prior profile module by Sjoerd Mullender...
#   which was hacked somewhat by: Guido van Rossum

# Copyright Disney Enterprises, Inc.  All Rights Reserved.
# Licensed to PSF under a Contributor Agreement
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied.  See the License for the specific language
# governing permissions and limitations under the License.


import sys
import os
import time
import marshal
import re
from functools import cmp_to_key

__all__ = ["Stats"]

class Stats:
    """This class is used for creating reports from data generated by the
    Profile class.  It is a "friend" of that class, and imports data either
    by direct access to members of Profile class, or by reading in a dictionary
    that was emitted (via marshal) from the Profile class.

    The big change from the previous Profiler (in terms of raw functionality)
    is that an "add()" method has been provided to combine Stats from
    several distinct profile runs.  Both the constructor and the add()
    method now take arbitrarily many file names as arguments.

    All the print methods now take an argument that indicates how many lines
    to print.  If the arg is a floating point number between 0 and 1.0, then
    it is taken as a decimal percentage of the available lines to be printed
    (e.g., .1 means print 10% of all available lines).  If it is an integer,
    it is taken to mean the number of lines of data that you wish to have
    printed.

    The sort_stats() method now processes some additional options (i.e., in
    addition to the old -1, 0, 1, or 2).  It takes an arbitrary number of
    quoted strings to select the sort order.  For example sort_stats('time',
    'name') sorts on the major key of 'internal function time', and on the
    minor key of 'the name of the function'.  Look at the two tables in
    sort_stats() and get_sort_arg_defs(self) for more examples.

    All methods return self, so you can string together commands like:
        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
    """

    def __init__(self, *args, **kwds):
        # I can't figure out how to explicitly specify a stream keyword arg
        # with *args:
        #   def __init__(self, *args, stream=sys.stdout): ...
        # so I use **kwds and sqauwk if something unexpected is passed in.
        self.stream = sys.stdout
        if "stream" in kwds:
            self.stream = kwds["stream"]
            del kwds["stream"]
        if kwds:
            keys = kwds.keys()
            keys.sort()
            extras = ", ".join(["%s=%s" % (k, kwds[k]) for k in keys])
            raise ValueError, "unrecognized keyword args: %s" % extras
        if not len(args):
            arg = None
        else:
            arg = args[0]
            args = args[1:]
        self.init(arg)
        self.add(*args)

    def init(self, arg):
        self.all_callees = None  # calc only if needed
        self.files = []
        self.fcn_list = None
        self.total_tt = 0
        self.total_calls = 0
        self.prim_calls = 0
        self.max_name_len = 0
        self.top_level = {}
        self.stats = {}
        self.sort_arg_dict = {}
        self.load_stats(arg)
        trouble = 1
        try:
            self.get_top_level_stats()
            trouble = 0
        finally:
            if trouble:
                print >> self.stream, "Invalid timing data",
                if self.files: print >> self.stream, self.files[-1],
                print >> self.stream

    def load_stats(self, arg):
        if not arg:  self.stats = {}
        elif isinstance(arg, basestring):
            f = open(arg, 'rb')
            self.stats = marshal.load(f)
            f.close()
            try:
                file_stats = os.stat(arg)
                arg = time.ctime(file_stats.st_mtime) + "    " + arg
            except:  # in case this is not unix
                pass
            self.files = [ arg ]
        elif hasattr(arg, 'create_stats'):
            arg.create_stats()
            self.stats = arg.stats
            arg.stats = {}
        if not self.stats:
            raise TypeError("Cannot create or construct a %r object from %r"
                            % (self.__class__, arg))
        return

    def get_top_level_stats(self):
        for func, (cc, nc, tt, ct, callers) in self.stats.items():
            self.total_calls += nc
            self.prim_calls  += cc
            self.total_tt    += tt
            if ("jprofile", 0, "profiler") in callers:
                self.top_level[func] = None
            if len(func_std_string(func)) > self.max_name_len:
                self.max_name_len = len(func_std_string(func))

    def add(self, *arg_list):
        if not arg_list: return self
        if len(arg_list) > 1: self.add(*arg_list[1:])
        other = arg_list[0]
        if type(self) != type(other) or self.__class__ != other.__class__:
            other = Stats(other)
        self.files += other.files
        self.total_calls += other.total_calls
        self.prim_calls += other.prim_calls
        self.total_tt += other.total_tt
        for func in other.top_level:
            self.top_level[func] = None

        if self.max_name_len < other.max_name_len:
            self.max_name_len = other.max_name_len

        self.fcn_list = None

        for func, stat in other.stats.iteritems():
            if func in self.stats:
                old_func_stat = self.stats[func]
            else:
                old_func_stat = (0, 0, 0, 0, {},)
            self.stats[func] = add_func_stats(old_func_stat, stat)
        return self

    def dump_stats(self, filename):
        """Write the profile data to a file we know how to load back."""
        f = file(filename, 'wb')
        try:
            marshal.dump(self.stats, f)
        finally:
            f.close()

    # list the tuple indices and directions for sorting,
    # along with some printable description
    sort_arg_dict_default = {
              "calls"     : (((1,-1),              ), "call count"),
              "ncalls"    : (((1,-1),              ), "call count"),
              "cumtime"   : (((3,-1),              ), "cumulative time"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "file"      : (((4, 1),              ), "file name"),
              "filename"  : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "primitive call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),
              "tottime"   : (((2,-1),              ), "internal time"),
              }

    def get_sort_arg_defs(self):
        """Expand all abbreviations that are unique."""
        if not self.sort_arg_dict:
            self.sort_arg_dict = dict = {}
            bad_list = {}
            for word, tup in self.sort_arg_dict_default.iteritems():
                fragment = word
                while fragment:
                    if not fragment:
                        break
                    if fragment in dict:
                        bad_list[fragment] = 0
                        break
                    dict[fragment] = tup
                    fragment = fragment[:-1]
            for word in bad_list:
                del dict[word]
        return self.sort_arg_dict

    def sort_stats(self, *field):
        if not field:
            self.fcn_list = 0
            return self
        if len(field) == 1 and isinstance(field[0], (int, long)):
            # Be compatible with old profiler
            field = [ {-1: "stdname",
                       0:  "calls",
                       1:  "time",
                       2:  "cumulative"}[field[0]] ]

        sort_arg_defs = self.get_sort_arg_defs()
        sort_tuple = ()
        self.sort_type = ""
        connector = ""
        for word in field:
            sort_tuple = sort_tuple + sort_arg_defs[word][0]
            self.sort_type += connector + sort_arg_defs[word][1]
            connector = ", "

        stats_list = []
        for func, (cc, nc, tt, ct, callers) in self.stats.iteritems():
            stats_list.append((cc, nc, tt, ct) + func +
                              (func_std_string(func), func))

        stats_list.sort(key=cmp_to_key(TupleComp(sort_tuple).compare))

        self.fcn_list = fcn_list = []
        for tuple in stats_list:
            fcn_list.append(tuple[-1])
        return self

    def reverse_order(self):
        if self.fcn_list:
            self.fcn_list.reverse()
        return self

    def strip_dirs(self):
        oldstats = self.stats
        self.stats = newstats = {}
        max_name_len = 0
        for func, (cc, nc, tt, ct, callers) in oldstats.iteritems():
            newfunc = func_strip_path(func)
            if len(func_std_string(newfunc)) > max_name_len:
                max_name_len = len(func_std_string(newfunc))
            newcallers = {}
            for func2, caller in callers.iteritems():
                newcallers[func_strip_path(func2)] = caller

            if newfunc in newstats:
                newstats[newfunc] = add_func_stats(
                                        newstats[newfunc],
                                        (cc, nc, tt, ct, newcallers))
            else:
                newstats[newfunc] = (cc, nc, tt, ct, newcallers)
        old_top = self.top_level
        self.top_level = new_top = {}
        for func in old_top:
            new_top[func_strip_path(func)] = None

        self.max_name_len = max_name_len

        self.fcn_list = None
        self.all_callees = None
        return self

    def calc_callees(self):
        if self.all_callees: return
        self.all_callees = all_callees = {}
        for func, (cc, nc, tt, ct, callers) in self.stats.iteritems():
            if not func in all_callees:
                all_callees[func] = {}
            for func2, caller in callers.iteritems():
                if not func2 in all_callees:
                    all_callees[func2] = {}
                all_callees[func2][func]  = caller
        return

    #******************************************************************
    # The following functions support actual printing of reports
    #******************************************************************

    # Optional "amount" is either a line count, or a percentage of lines.

    def eval_print_amount(self, sel, list, msg):
        new_list = list
        if isinstance(sel, basestring):
            try:
                rex = re.compile(sel)
            except re.error:
                msg += "   <Invalid regular expression %r>\n" % sel
                return new_list, msg
            new_list = []
            for func in list:
                if rex.search(func_std_string(func)):
                    new_list.append(func)
        else:
            count = len(list)
            if isinstance(sel, float) and 0.0 <= sel < 1.0:
                count = int(count * sel + .5)
                new_list = list[:count]
            elif isinstance(sel, (int, long)) and 0 <= sel < count:
                count = sel
                new_list = list[:count]
        if len(list) != len(new_list):
            msg += "   List reduced from %r to %r due to restriction <%r>\n" % (
                len(list), len(new_list), sel)

        return new_list, msg

    def get_print_list(self, sel_list):
        width = self.max_name_len
        if self.fcn_list:
            stat_list = self.fcn_list[:]
            msg = "   Ordered by: " + self.sort_type + '\n'
        else:
            stat_list = self.stats.keys()
            msg = "   Random listing order was used\n"

        for selection in sel_list:
            stat_list, msg = self.eval_print_amount(selection, stat_list, msg)

        count = len(stat_list)

        if not stat_list:
            return 0, stat_list
        print >> self.stream, msg
        if count < len(self.stats):
            width = 0
            for func in stat_list:
                if  len(func_std_string(func)) > width:
                    width = len(func_std_string(func))
        return width+2, stat_list

    def print_stats(self, *amount):
        for filename in self.files:
            print >> self.stream, filename
        if self.files: print >> self.stream
        indent = ' ' * 8
        for func in self.top_level:
            print >> self.stream, indent, func_get_function_name(func)

        print >> self.stream, indent, self.total_calls, "function calls",
        if self.total_calls != self.prim_calls:
            print >> self.stream, "(%d primitive calls)" % self.prim_calls,
        print >> self.stream, "in %.3f seconds" % self.total_tt
        print >> self.stream
        width, list = self.get_print_list(amount)
        if list:
            self.print_title()
            for func in list:
                self.print_line(func)
            print >> self.stream
            print >> self.stream
        return self

    def print_callees(self, *amount):
        width, list = self.get_print_list(amount)
        if list:
            self.calc_callees()

            self.print_call_heading(width, "called...")
            for func in list:
                if func in self.all_callees:
                    self.print_call_line(width, func, self.all_callees[func])
                else:
                    self.print_call_line(width, func, {})
            print >> self.stream
            print >> self.stream
        return self

    def print_callers(self, *amount):
        width, list = self.get_print_list(amount)
        if list:
            self.print_call_heading(width, "was called by...")
            for func in list:
                cc, nc, tt, ct, callers = self.stats[func]
                self.print_call_line(width, func, callers, "<-")
            print >> self.stream
            print >> self.stream
        return self

    def print_call_heading(self, name_size, column_title):
        print >> self.stream, "Function ".ljust(name_size) + column_title
        # print sub-header only if we have new-style callers
        subheader = False
        for cc, nc, tt, ct, callers in self.stats.itervalues():
            if callers:
                value = callers.itervalues().next()
                subheader = isinstance(value, tuple)
                break
        if subheader:
            print >> self.stream, " "*name_size + "    ncalls  tottime  cumtime"

    def print_call_line(self, name_size, source, call_dict, arrow="->"):
        print >> self.stream, func_std_string(source).ljust(name_size) + arrow,
        if not call_dict:
            print >> self.stream
            return
        clist = call_dict.keys()
        clist.sort()
        indent = ""
        for func in clist:
            name = func_std_string(func)
            value = call_dict[func]
            if isinstance(value, tuple):
                nc, cc, tt, ct = value
                if nc != cc:
                    substats = '%d/%d' % (nc, cc)
                else:
                    substats = '%d' % (nc,)
                substats = '%s %s %s  %s' % (substats.rjust(7+2*len(indent)),
                                             f8(tt), f8(ct), name)
                left_width = name_size + 1
            else:
                substats = '%s(%r) %s' % (name, value, f8(self.stats[func][3]))
                left_width = name_size + 3
            print >> self.stream, indent*left_width + substats
            indent = " "

    def print_title(self):
        print >> self.stream, '   ncalls  tottime  percall  cumtime  percall',
        print >> self.stream, 'filename:lineno(function)'

    def print_line(self, func):  # hack : should print percentages
        cc, nc, tt, ct, callers = self.stats[func]
        c = str(nc)
        if nc != cc:
            c = c + '/' + str(cc)
        print >> self.stream, c.rjust(9),
        print >> self.stream, f8(tt),
        if nc == 0:
            print >> self.stream, ' '*8,
        else:
            print >> self.stream, f8(float(tt)/nc),
        print >> self.stream, f8(ct),
        if cc == 0:
            print >> self.stream, ' '*8,
        else:
            print >> self.stream, f8(float(ct)/cc),
        print >> self.stream, func_std_string(func)

class TupleComp:
    """This class provides a generic function for comparing any two tuples.
    Each instance records a list of tuple-indices (from most significant
    to least significant), and sort direction (ascending or decending) for
    each tuple-index.  The compare functions can then be used as the function
    argument to the system sort() function when a list of tuples need to be
    sorted in the instances order."""

    def __init__(self, comp_select_list):
        self.comp_select_list = comp_select_list

    def compare (self, left, right):
        for index, direction in self.comp_select_list:
            l = left[index]
            r = right[index]
            if l < r:
                return -direction
            if l > r:
                return direction
        return 0

#**************************************************************************
# func_name is a triple (file:string, line:int, name:string)

def func_strip_path(func_name):
    filename, line, name = func_name
    return os.path.basename(filename), line, name

def func_get_function_name(func):
    return func[2]

def func_std_string(func_name): # match what old profile produced
    if func_name[:2] == ('~', 0):
        # special case for built-in functions
        name = func_name[2]
        if name.startswith('<') and name.endswith('>'):
            return '{%s}' % name[1:-1]
        else:
            return name
    else:
        return "%s:%d(%s)" % func_name

#**************************************************************************
# The following functions combine statists for pairs functions.
# The bulk of the processing involves correctly handling "call" lists,
# such as callers and callees.
#**************************************************************************

def add_func_stats(target, source):
    """Add together all the stats for two profile entries."""
    cc, nc, tt, ct, callers = source
    t_cc, t_nc, t_tt, t_ct, t_callers = target
    return (cc+t_cc, nc+t_nc, tt+t_tt, ct+t_ct,
              add_callers(t_callers, callers))

def add_callers(target, source):
    """Combine two caller lists in a single list."""
    new_callers = {}
    for func, caller in target.iteritems():
        new_callers[func] = caller
    for func, caller in source.iteritems():
        if func in new_callers:
            if isinstance(caller, tuple):
                # format used by cProfile
                new_callers[func] = tuple([i[0] + i[1] for i in
                                           zip(caller, new_callers[func])])
            else:
                # format used by profile
                new_callers[func] += caller
        else:
            new_callers[func] = caller
    return new_callers

def count_calls(callers):
    """Sum the caller statistics to get total number of calls received."""
    nc = 0
    for calls in callers.itervalues():
        nc += calls
    return nc

#**************************************************************************
# The following functions support printing of reports
#**************************************************************************

def f8(x):
    return "%8.3f" % x

#**************************************************************************
# Statistics browser added by ESR, April 2001
#**************************************************************************

if __name__ == '__main__':
    import cmd
    try:
        import readline
    except ImportError:
        pass

    class ProfileBrowser(cmd.Cmd):
        def __init__(self, profile=None):
            cmd.Cmd.__init__(self)
            self.prompt = "% "
            self.stats = None
            self.stream = sys.stdout
            if profile is not None:
                self.do_read(profile)

        def generic(self, fn, line):
            args = line.split()
            processed = []
            for term in args:
                try:
                    processed.append(int(term))
                    continue
                except ValueError:
                    pass
                try:
                    frac = float(term)
                    if frac > 1 or frac < 0:
                        print >> self.stream, "Fraction argument must be in [0, 1]"
                        continue
                    processed.append(frac)
                    continue
                except ValueError:
                    pass
                processed.append(term)
            if self.stats:
                getattr(self.stats, fn)(*processed)
            else:
                print >> self.stream, "No statistics object is loaded."
            return 0
        def generic_help(self):
            print >> self.stream, "Arguments may be:"
            print >> self.stream, "* An integer maximum number of entries to print."
            print >> self.stream, "* A decimal fractional number between 0 and 1, controlling"
            print >> self.stream, "  what fraction of selected entries to print."
            print >> self.stream, "* A regular expression; only entries with function names"
            print >> self.stream, "  that match it are printed."

        def do_add(self, line):
            if self.stats:
                self.stats.add(line)
            else:
                print >> self.stream, "No statistics object is loaded."
            return 0
        def help_add(self):
            print >> self.stream, "Add profile info from given file to current statistics object."

        def do_callees(self, line):
            return self.generic('print_callees', line)
        def help_callees(self):
            print >> self.stream, "Print callees statistics from the current stat object."
            self.generic_help()

        def do_callers(self, line):
            return self.generic('print_callers', line)
        def help_callers(self):
            print >> self.stream, "Print callers statistics from the current stat object."
            self.generic_help()

        def do_EOF(self, line):
            print >> self.stream, ""
            return 1
        def help_EOF(self):
            print >> self.stream, "Leave the profile brower."

        def do_quit(self, line):
            return 1
        def help_quit(self):
            print >> self.stream, "Leave the profile brower."

        def do_read(self, line):
            if line:
                try:
                    self.stats = Stats(line)
                except IOError, args:
                    print >> self.stream, args[1]
                    return
                except Exception as err:
                    print >> self.stream, err.__class__.__name__ + ':', err
                    return
                self.prompt = line + "% "
            elif len(self.prompt) > 2:
                line = self.prompt[:-2]
                self.do_read(line)
            else:
                print >> self.stream, "No statistics object is current -- cannot reload."
            return 0
        def help_read(self):
            print >> self.stream, "Read in profile data from a specified file."
            print >> self.stream, "Without argument, reload the current file."

        def do_reverse(self, line):
            if self.stats:
                self.stats.reverse_order()
            else:
                print >> self.stream, "No statistics object is loaded."
            return 0
        def help_reverse(self):
            print >> self.stream, "Reverse the sort order of the profiling report."

        def do_sort(self, line):
            if not self.stats:
                print >> self.stream, "No statistics object is loaded."
                return
            abbrevs = self.stats.get_sort_arg_defs()
            if line and all((x in abbrevs) for x in line.split()):
                self.stats.sort_stats(*line.split())
            else:
                print >> self.stream, "Valid sort keys (unique prefixes are accepted):"
                for (key, value) in Stats.sort_arg_dict_default.iteritems():
                    print >> self.stream, "%s -- %s" % (key, value[1])
            return 0
        def help_sort(self):
            print >> self.stream, "Sort profile data according to specified keys."
            print >> self.stream, "(Typing `sort' without arguments lists valid keys.)"
        def complete_sort(self, text, *args):
            return [a for a in Stats.sort_arg_dict_default if a.startswith(text)]

        def do_stats(self, line):
            return self.generic('print_stats', line)
        def help_stats(self):
            print >> self.stream, "Print statistics from the current stat object."
            self.generic_help()

        def do_strip(self, line):
            if self.stats:
                self.stats.strip_dirs()
            else:
                print >> self.stream, "No statistics object is loaded."
        def help_strip(self):
            print >> self.stream, "Strip leading path information from filenames in the report."

        def help_help(self):
            print >> self.stream, "Show help for a given command."

        def postcmd(self, stop, line):
            if stop:
                return stop
            return None

    import sys
    if len(sys.argv) > 1:
        initprofile = sys.argv[1]
    else:
        initprofile = None
    try:
        browser = ProfileBrowser(initprofile)
        print >> browser.stream, "Welcome to the profile statistics browser."
        browser.cmdloop()
        print >> browser.stream, "Goodbye."
    except KeyboardInterrupt:
        pass

# That's all, folks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c           @   sõ  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z d g Z d f  d Ñ  É  YZ	 d f  d Ñ  É  YZ
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d k ród d l Z y d d l Z Wn e k
 r˚ n Xd e j f d Ñ  É  YZ d d l Z e e j É d k rFe j d Z n e Z y4 e e É Z e j d IJe j É  e j d IJWn e k
 rìn Xn  d S(   s3   Class for printing reports on profiled python code.iˇˇˇˇN(   t
   cmp_to_keyt   Statsc           B   s<  e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z i d8 d
 6d; d 6d> d 6dA d 6dD d 6dG d 6dJ d 6dM d 6dP d 6dQ dR dS f d f d 6dV d 6dY d" 6d\ d% 6d_ d& 6Z	 d' Ñ  Z
 d( Ñ  Z d) Ñ  Z d* Ñ  Z d+ Ñ  Z d, Ñ  Z d- Ñ  Z d. Ñ  Z d/ Ñ  Z d0 Ñ  Z d1 Ñ  Z d2 d3 Ñ Z d4 Ñ  Z d5 Ñ  Z RS(`   s<  This class is used for creating reports from data generated by the
    Profile class.  It is a "friend" of that class, and imports data either
    by direct access to members of Profile class, or by reading in a dictionary
    that was emitted (via marshal) from the Profile class.

    The big change from the previous Profiler (in terms of raw functionality)
    is that an "add()" method has been provided to combine Stats from
    several distinct profile runs.  Both the constructor and the add()
    method now take arbitrarily many file names as arguments.

    All the print methods now take an argument that indicates how many lines
    to print.  If the arg is a floating point number between 0 and 1.0, then
    it is taken as a decimal percentage of the available lines to be printed
    (e.g., .1 means print 10% of all available lines).  If it is an integer,
    it is taken to mean the number of lines of data that you wish to have
    printed.

    The sort_stats() method now processes some additional options (i.e., in
    addition to the old -1, 0, 1, or 2).  It takes an arbitrary number of
    quoted strings to select the sort order.  For example sort_stats('time',
    'name') sorts on the major key of 'internal function time', and on the
    minor key of 'the name of the function'.  Look at the two tables in
    sort_stats() and get_sort_arg_defs(self) for more examples.

    All methods return self, so you can string together commands like:
        Stats('foo', 'goo').strip_dirs().sort_stats('calls').                            print_stats(5).print_callers(5)
    c         O   s“   t  j |  _ d | k r/ | d |  _ | d =n  | rã | j É  } | j É  d j g  | D] } d | | | f ^ qX É } t d | Ç n  t | É s† d  } n | d } | d } |  j	 | É |  j
 | å  d  S(   Nt   streams   , s   %s=%ss   unrecognized keyword args: %si    i   (   t   syst   stdoutR   t   keyst   sortt   joint
   ValueErrort   lent   Nonet   initt   add(   t   selft   argst   kwdsR   t   kt   extrast   arg(    (    s   /usr/lib/python2.7/pstats.pyt   __init__>   s    

0	

c         C   s∆   d  |  _ g  |  _ d  |  _ d |  _ d |  _ d |  _ d |  _ i  |  _ i  |  _	 i  |  _
 |  j | É d } z |  j É  d } Wd  | r¡ |  j d I|  j r∑ |  j |  j d In  |  j Jn  Xd  S(   Ni    i   s   Invalid timing dataiˇˇˇˇ(   R
   t   all_calleest   filest   fcn_listt   total_ttt   total_callst
   prim_callst   max_name_lent	   top_levelt   statst   sort_arg_dictt
   load_statst   get_top_level_statsR   (   R   R   t   trouble(    (    s   /usr/lib/python2.7/pstats.pyR   T   s(    										

	 c         C   sÏ   | s i  |  _  n± t | t É rí t | d É } t j | É |  _  | j É  y- t j | É } t	 j
 | j É d | } Wn n X| g |  _ n1 t | d É r√ | j É  | j  |  _  i  | _  n  |  j  sË t d |  j | f É Ç n  d  S(   Nt   rbs       t   create_statss.   Cannot create or construct a %r object from %r(   R   t
   isinstancet
   basestringt   opent   marshalt   loadt   closet   ost   statt   timet   ctimet   st_mtimeR   t   hasattrR"   t	   TypeErrort	   __class__(   R   R   t   ft
   file_stats(    (    s   /usr/lib/python2.7/pstats.pyR   j   s(     

	c         C   sØ   x® |  j  j É  D]ó \ } \ } } } } } |  j | 7_ |  j | 7_ |  j | 7_ d | k rt d  |  j | <n  t t | É É |  j	 k r t t | É É |  _	 q q Wd  S(   Nt   jprofilei    t   profiler(   R3   i    R4   (
   R   t   itemsR   R   R   R
   R   R	   t   func_std_stringR   (   R   t   funct   cct   nct   ttt   ctt   callers(    (    s   /usr/lib/python2.7/pstats.pyR      s    +c         G   st  | s
 |  St  | É d k r0 |  j | d å  n  | d } t |  É t | É k sd |  j | j k rs t | É } n  |  j | j 7_ |  j | j 7_ |  j | j 7_ |  j | j 7_ x | j	 D] } d  |  j	 | <q≈ W|  j | j k  r˝ | j |  _ n  d  |  _ xg | j j É  D]V \ } } | |  j k rA|  j | } n d d d d i  f } t | | É |  j | <qW|  S(   Ni   i    (   R	   R   t   typeR0   R   R   R   R   R   R   R
   R   R   R   t	   iteritemst   add_func_stats(   R   t   arg_listt   otherR7   R*   t   old_func_stat(    (    s   /usr/lib/python2.7/pstats.pyR   â   s,      
*	c         C   s8   t  | d É } z t j |  j | É Wd | j É  Xd S(   s:   Write the profile data to a file we know how to load back.t   wbN(   t   fileR&   t   dumpR   R(   (   R   t   filenameR1   (    (    s   /usr/lib/python2.7/pstats.pyt
   dump_stats£   s    i   iˇˇˇˇs
   call countt   callst   ncallsi   s   cumulative timet   cumtimet
   cumulativei   s	   file nameRD   RF   i   s   line numbert   linet   modulei   s   function namet   names   name/file/linet   nfli    s   primitive call countt   pcallsi   s   standard namet   stdnamei   s   internal timeR+   t   tottimec         C   s©   |  j  s¢ i  |  _  } i  } xh |  j j É  D]W \ } } | } xB | rÇ | sQ Pn  | | k rk d | | <Pn  | | | <| d  } qA Wq, Wx | D] } | | =qé Wn  |  j  S(   s)   Expand all abbreviations that are unique.i    iˇˇˇˇ(   R   t   sort_arg_dict_defaultR>   (   R   t   dictt   bad_listt   wordt   tupt   fragment(    (    s   /usr/lib/python2.7/pstats.pyt   get_sort_arg_defsæ   s     		

c         G   sá  | s d |  _  |  St | É d k rn t | d t t f É rn i d d 6d d 6d d 6d d 6| d g } n  |  j É  } d } d	 |  _ d	 } xA | D]9 } | | | d } |  j | | | d 7_ d
 } qñ Wg  } xY |  j j É  D]H \ } \ } }	 }
 } } | j	 | |	 |
 | f | t
 | É | f É qÈ W| j d t t | É j É É g  |  _  } x | D] } | j	 | d É qhW|  S(   Ni    i   RQ   iˇˇˇˇRH   R+   RK   i   t    s   , t   key(    (   R   R	   R#   t   intt   longRY   t	   sort_typeR   R>   t   appendR6   R   R    t	   TupleCompt   compare(   R   t   fieldt   sort_arg_defst
   sort_tuplet	   connectorRV   t
   stats_listR7   R8   R9   R:   R;   R<   R   t   tuple(    (    s   /usr/lib/python2.7/pstats.pyt
   sort_stats—   s2    	+
	
+c         C   s   |  j  r |  j  j É  n  |  S(   N(   R   t   reverse(   R   (    (    s   /usr/lib/python2.7/pstats.pyt   reverse_orderÒ   s    	c         C   sX  |  j  } i  |  _  } d } x„ | j É  D]’ \ } \ } } } } }	 t | É }
 t t |
 É É | k r} t t |
 É É } n  i  } x* |	 j É  D] \ } } | | t | É <qê W|
 | k rÂ t | |
 | | | | | f É | |
 <q) | | | | | f | |
 <q) W|  j } i  |  _ } x | D] } d  | t | É <qW| |  _ d  |  _	 d  |  _
 |  S(   Ni    (   R   R>   t   func_strip_pathR	   R6   R?   R   R
   R   R   R   (   R   t   oldstatst   newstatsR   R7   R8   R9   R:   R;   R<   t   newfunct
   newcallerst   func2t   callert   old_topt   new_top(    (    s   /usr/lib/python2.7/pstats.pyt
   strip_dirsˆ   s.    	(				c   
      C   s™   |  j  r d  Si  |  _  } xâ |  j j É  D]x \ } \ } } } } } | | k r^ i  | | <n  xA | j É  D]3 \ } }	 | | k rê i  | | <n  |	 | | | <qk Wq* Wd  S(   N(   R   R   R>   (
   R   R   R7   R8   R9   R:   R;   R<   Rp   Rq   (    (    s   /usr/lib/python2.7/pstats.pyt   calc_callees  s    	 +c         C   sw  | } t  | t É rì y t j | É } Wn) t j k
 rS | d | 7} | | f SXg  } x“ | D]+ } | j t | É É ra | j | É qa qa Wnú t | É } t  | t	 É rÎ d | k o≈ d k  n rÎ t
 | | d É } | |  } nD t  | t
 t f É r/d | k o| k  n r/| } | |  } n  t | É t | É k rm| d t | É t | É | f 7} n  | | f S(   Ns#      <Invalid regular expression %r>
g        g      ?g      ‡?i    s6      List reduced from %r to %r due to restriction <%r>
(   R#   R$   t   ret   compilet   errort   searchR6   R_   R	   t   floatR\   R]   (   R   t   selt   listt   msgt   new_listt   rexR7   t   count(    (    s   /usr/lib/python2.7/pstats.pyt   eval_print_amount%  s,    +1 c         C   s  |  j  } |  j r0 |  j } d |  j d } n |  j j É  } d } x) | D]! } |  j | | | É \ } } qL Wt | É } | sç d | f S|  j | IJ| t |  j É k  rˆ d } x> | D]3 } t t | É É | k rº t t | É É } qº qº Wn  | d | f S(   Ns      Ordered by: s   
s!      Random listing order was used
i    i   (	   R   R   R^   R   R   RÅ   R	   R   R6   (   R   t   sel_listt   widtht	   stat_listR}   t	   selectionRÄ   R7   (    (    s   /usr/lib/python2.7/pstats.pyt   get_print_list?  s$    		

c         G   s  x |  j  D] } |  j | IJq
 W|  j  r4 |  j Jn  d } x* |  j D] } |  j | It | É IJqD W|  j | I|  j Id I|  j |  j k r¨ |  j d |  j In  |  j d |  j IJ|  j J|  j | É \ } } | r|  j É  x | D] } |  j	 | É qÛ W|  j J|  j Jn  |  S(   Nt    i   s   function callss   (%d primitive calls)s   in %.3f secondss           (
   R   R   R   t   func_get_function_nameR   R   R   RÜ   t   print_titlet
   print_line(   R   t   amountRF   t   indentR7   RÉ   R|   (    (    s   /usr/lib/python2.7/pstats.pyt   print_statsW  s(    	 


c         G   sö   |  j  | É \ } } | rñ |  j É  |  j | d É xM | D]E } | |  j k rn |  j | | |  j | É q< |  j | | i  É q< W|  j J|  j Jn  |  S(   Ns	   called...(   RÜ   Ru   t   print_call_headingR   t   print_call_lineR   (   R   Rã   RÉ   R|   R7   (    (    s   /usr/lib/python2.7/pstats.pyt   print_calleesm  s    

c   
      G   sÉ   |  j  | É \ } } | r |  j | d É x@ | D]8 } |  j | \ } } } } }	 |  j | | |	 d É q2 W|  j J|  j Jn  |  S(   Ns   was called by...s   <-(   RÜ   Ré   R   Rè   R   (
   R   Rã   RÉ   R|   R7   R8   R9   R:   R;   R<   (    (    s   /usr/lib/python2.7/pstats.pyt   print_callers|  s    
c   
      C   sñ   |  j  d j | É | IJt } xQ |  j j É  D]@ \ } } } } } | r0 | j É  j É  }	 t |	 t É } Pq0 q0 W| rí |  j  d | d IJn  d  S(   Ns	   Function Rá   s       ncalls  tottime  cumtime(   R   t   ljustt   FalseR   t
   itervaluest   nextR#   Rg   (
   R   t	   name_sizet   column_titlet	   subheaderR8   R9   R:   R;   R<   t   value(    (    s   /usr/lib/python2.7/pstats.pyRé   á  s    %s   ->c         C   sT  |  j  t | É j | É | I| s1 |  j  Jd  S| j É  } | j É  d } x | D]¯ } t | É } | | }	 t |	 t É r|	 \ }
 } } } |
 | k r∞ d |
 | f } n d |
 f } d | j d d t | É É t	 | É t	 | É | f } | d } n. d | |	 t	 |  j
 | d	 É f } | d	 } |  j  | | | IJd
 } qT Wd  S(   NRZ   s   %d/%ds   %ds   %s %s %s  %si   i   i   s	   %s(%r) %si   Rá   (   R   R6   Rí   R   R   R#   Rg   t   rjustR	   t   f8R   (   R   Rñ   t   sourcet	   call_dictt   arrowt   clistRå   R7   RN   Rô   R9   R8   R:   R;   t   substatst
   left_width(    (    s   /usr/lib/python2.7/pstats.pyRè   ì  s,     

$
c         C   s   |  j  d I|  j  d IJd  S(   Ns-      ncalls  tottime  percall  cumtime  percalls   filename:lineno(function)(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyRâ   ≠  s    c         C   s  |  j  | \ } } } } } t | É } | | k rK | d t | É } n  |  j | j d É I|  j t | É I| d k rê |  j d In |  j t t | É | É I|  j t | É I| d k r‹ |  j d In |  j t t | É | É I|  j t | É IJd  S(   Nt   /i	   i    Rá   i   s           s           (   R   t   strR   Rö   Rõ   Rz   R6   (   R   R7   R8   R9   R:   R;   R<   t   c(    (    s   /usr/lib/python2.7/pstats.pyRä   ±  s    (   i   iˇˇˇˇ(   (   i   iˇˇˇˇ(   (   (   i   iˇˇˇˇs
   call count(   i   iˇˇˇˇ(   (   i   iˇˇˇˇ(   (   (   i   iˇˇˇˇs
   call count(   i   iˇˇˇˇ(   (   i   iˇˇˇˇ(   (   (   i   iˇˇˇˇs   cumulative time(   i   iˇˇˇˇ(   (   i   iˇˇˇˇ(   (   (   i   iˇˇˇˇs   cumulative time(   i   i   (   (   i   i   (   (   (   i   i   s	   file name(   i   i   (   (   i   i   (   (   (   i   i   s	   file name(   i   i   (   (   i   i   (   (   (   i   i   s   line number(   i   i   (   (   i   i   (   (   (   i   i   s	   file name(   i   i   (   (   i   i   (   (   (   i   i   s   function name(   i   i   (   i   i   (   i   i   (   i    iˇˇˇˇ(   (   i    iˇˇˇˇ(   (   (   i    iˇˇˇˇs   primitive call count(   i   i   (   (   i   i   (   (   (   i   i   s   standard name(   i   iˇˇˇˇ(   (   i   iˇˇˇˇ(   (   (   i   iˇˇˇˇs   internal time(   i   iˇˇˇˇ(   (   i   iˇˇˇˇ(   (   (   i   iˇˇˇˇs   internal time(   t   __name__t
   __module__t   __doc__R   R   R   R   R   RG   RS   RY   Rh   Rj   Rt   Ru   RÅ   RÜ   Rç   Rê   Rë   Ré   Rè   Râ   Rä   (    (    (    s   /usr/lib/python2.7/pstats.pyR       sH   				
		

		 										R`   c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sï  This class provides a generic function for comparing any two tuples.
    Each instance records a list of tuple-indices (from most significant
    to least significant), and sort direction (ascending or decending) for
    each tuple-index.  The compare functions can then be used as the function
    argument to the system sort() function when a list of tuples need to be
    sorted in the instances order.c         C   s   | |  _  d  S(   N(   t   comp_select_list(   R   R®   (    (    s   /usr/lib/python2.7/pstats.pyR   À  s    c         C   sS   xL |  j  D]A \ } } | | } | | } | | k  r; | S| | k r
 | Sq
 Wd S(   Ni    (   R®   (   R   t   leftt   rightt   indext	   directiont   lt   r(    (    s   /usr/lib/python2.7/pstats.pyRa   Œ  s    

(   R•   R¶   Rß   R   Ra   (    (    (    s   /usr/lib/python2.7/pstats.pyR`   √  s   	c         C   s(   |  \ } } } t  j j | É | | f S(   N(   R)   t   patht   basename(   t	   func_nameRF   RL   RN   (    (    s   /usr/lib/python2.7/pstats.pyRk   €  s    c         C   s   |  d S(   Ni   (    (   R7   (    (    s   /usr/lib/python2.7/pstats.pyRà   ﬂ  s    c         C   sZ   |  d  d
 k rN |  d } | j  d É rG | j d É rG d | d d !S| Sn d	 |  Sd  S(   Ni   t   ~i    t   <t   >s   {%s}i   iˇˇˇˇs	   %s:%d(%s)(   R≤   i    (   t
   startswitht   endswith(   R±   RN   (    (    s   /usr/lib/python2.7/pstats.pyR6   ‚  s    
c         C   sV   | \ } } } } } |  \ } } }	 }
 } | | | | | |	 | |
 t  | | É f S(   s3   Add together all the stats for two profile entries.(   t   add_callers(   t   targetRú   R8   R9   R:   R;   R<   t   t_cct   t_nct   t_ttt   t_ctt	   t_callers(    (    s   /usr/lib/python2.7/pstats.pyR?   Û  s    c         C   s≈   i  } x$ |  j  É  D] \ } } | | | <q Wxë | j  É  D]É \ } } | | k r≥ t | t É r† t g  t | | | É D] } | d | d ^ qx É | | <qΩ | | c | 7<q: | | | <q: W| S(   s*   Combine two caller lists in a single list.i    i   (   R>   R#   Rg   t   zip(   R∏   Rú   t   new_callersR7   Rq   t   i(    (    s   /usr/lib/python2.7/pstats.pyR∑   ˙  s    9c         C   s+   d } x |  j  É  D] } | | 7} q W| S(   s@   Sum the caller statistics to get total number of calls received.i    (   Rî   (   R<   R9   RH   (    (    s   /usr/lib/python2.7/pstats.pyt   count_calls  s    c         C   s   d |  S(   Ns   %8.3f(    (   t   x(    (    s   /usr/lib/python2.7/pstats.pyRõ     s    t   __main__t   ProfileBrowserc           B   sı   e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sN   t  j j |  É d |  _ d  |  _ t j |  _ | d  k	 rJ |  j	 | É n  d  S(   Ns   % (
   t   cmdt   CmdR   t   promptR
   R   R   R   R   t   do_read(   R   t   profile(    (    s   /usr/lib/python2.7/pstats.pyR   &  s    		c         C   s   | j  É  } g  } x® | D]† } y | j t | É É w Wn t k
 rL n XyK t | É } | d k st | d k  rá |  j d IJw n  | j | É w Wn t k
 r´ n X| j | É q W|  j rﬂ t |  j | É | å  n |  j d IJd S(   Ni   i    s#   Fraction argument must be in [0, 1]s   No statistics object is loaded.(   t   splitR_   R\   R   Rz   R   R   t   getattr(   R   t   fnRL   R   t	   processedt   termt   frac(    (    s   /usr/lib/python2.7/pstats.pyt   generic.  s,    	c         C   sR   |  j  d IJ|  j  d IJ|  j  d IJ|  j  d IJ|  j  d IJ|  j  d IJd  S(   Ns   Arguments may be:s0   * An integer maximum number of entries to print.s:   * A decimal fractional number between 0 and 1, controllings-     what fraction of selected entries to print.s8   * A regular expression; only entries with function namess     that match it are printed.(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt   generic_helpF  s    c         C   s-   |  j  r |  j  j | É n |  j d IJd S(   Ns   No statistics object is loaded.i    (   R   R   R   (   R   RL   (    (    s   /usr/lib/python2.7/pstats.pyt   do_addN  s    	c         C   s   |  j  d IJd  S(   Ns>   Add profile info from given file to current statistics object.(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt   help_addT  s    c         C   s   |  j  d | É S(   NRê   (   R–   (   R   RL   (    (    s   /usr/lib/python2.7/pstats.pyt
   do_calleesW  s    c         C   s   |  j  d IJ|  j É  d  S(   Ns6   Print callees statistics from the current stat object.(   R   R—   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt   help_calleesY  s    c         C   s   |  j  d | É S(   NRë   (   R–   (   R   RL   (    (    s   /usr/lib/python2.7/pstats.pyt
   do_callers]  s    c         C   s   |  j  d IJ|  j É  d  S(   Ns6   Print callers statistics from the current stat object.(   R   R—   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt   help_callers_  s    c         C   s   |  j  d IJd S(   NRZ   i   (   R   (   R   RL   (    (    s   /usr/lib/python2.7/pstats.pyt   do_EOFc  s    c         C   s   |  j  d IJd  S(   Ns   Leave the profile brower.(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt   help_EOFf  s    c         C   s   d S(   Ni   (    (   R   RL   (    (    s   /usr/lib/python2.7/pstats.pyt   do_quiti  s    c         C   s   |  j  d IJd  S(   Ns   Leave the profile brower.(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt	   help_quitk  s    c         C   sƒ   | rÅ y t  | É |  _ WnU t k
 r@ } |  j | d IJd  St k
 rp } |  j | j j d I| IJd  SX| d |  _ n? t |  j É d k r≥ |  j d  } |  j	 | É n |  j d IJd S(   Ni   t   :s   % i   i˛ˇˇˇs1   No statistics object is current -- cannot reload.i    (
   R   R   t   IOErrorR   t	   ExceptionR0   R•   R«   R	   R»   (   R   RL   R   t   err(    (    s   /usr/lib/python2.7/pstats.pyR»   n  s    c         C   s   |  j  d IJ|  j  d IJd  S(   Ns+   Read in profile data from a specified file.s*   Without argument, reload the current file.(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt	   help_read  s    c         C   s*   |  j  r |  j  j É  n |  j d IJd S(   Ns   No statistics object is loaded.i    (   R   Rj   R   (   R   RL   (    (    s   /usr/lib/python2.7/pstats.pyt
   do_reverseÉ  s    	c         C   s   |  j  d IJd  S(   Ns/   Reverse the sort order of the profiling report.(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt   help_reverseâ  s    c            s∂   |  j  s |  j d IJd  S|  j  j É  â  | rj t á  f d Ü  | j É  DÉ É rj |  j  j | j É  å  nH |  j d IJx8 t j j É  D]' \ } } |  j d | | d f IJqá Wd S(   Ns   No statistics object is loaded.c         3   s   |  ] } | à  k Vq d  S(   N(    (   t   .0R¬   (   t   abbrevs(    s   /usr/lib/python2.7/pstats.pys	   <genexpr>ë  s    s/   Valid sort keys (unique prefixes are accepted):s   %s -- %si   i    (	   R   R   RY   t   allR    Rh   R   RS   R>   (   R   RL   R[   Rô   (    (   R‰   s   /usr/lib/python2.7/pstats.pyt   do_sortå  s    	(c         C   s   |  j  d IJ|  j  d IJd  S(   Ns.   Sort profile data according to specified keys.s3   (Typing `sort' without arguments lists valid keys.)(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt	   help_sortò  s    c         G   s)   g  t  j D] } | j | É r
 | ^ q
 S(   N(   R   RS   Rµ   (   R   t   textR   t   a(    (    s   /usr/lib/python2.7/pstats.pyt   complete_sortõ  s    c         C   s   |  j  d | É S(   NRç   (   R–   (   R   RL   (    (    s   /usr/lib/python2.7/pstats.pyt   do_statsû  s    c         C   s   |  j  d IJ|  j É  d  S(   Ns.   Print statistics from the current stat object.(   R   R—   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt
   help_stats†  s    c         C   s*   |  j  r |  j  j É  n |  j d IJd  S(   Ns   No statistics object is loaded.(   R   Rt   R   (   R   RL   (    (    s   /usr/lib/python2.7/pstats.pyt   do_strip§  s    	c         C   s   |  j  d IJd  S(   Ns<   Strip leading path information from filenames in the report.(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt
   help_strip©  s    c         C   s   |  j  d IJd  S(   Ns   Show help for a given command.(   R   (   R   (    (    s   /usr/lib/python2.7/pstats.pyt	   help_help¨  s    c         C   s   | r
 | Sd  S(   N(   R
   (   R   t   stopRL   (    (    s   /usr/lib/python2.7/pstats.pyt   postcmdØ  s    N(   R•   R¶   R
   R   R–   R—   R“   R”   R‘   R’   R÷   R◊   Rÿ   RŸ   R⁄   R€   R»   R‡   R·   R‚   RÊ   RÁ   RÍ   RÎ   RÏ   RÌ   RÓ   RÔ   RÒ   (    (    (    s   /usr/lib/python2.7/pstats.pyRƒ   %  s4   																								i   s*   Welcome to the profile statistics browser.s   Goodbye.(    Rß   R   R)   R+   R&   Rv   t	   functoolsR    t   __all__R   R`   Rk   Rà   R6   R?   R∑   R¡   Rõ   R•   R≈   t   readlinet   ImportErrorR∆   Rƒ   R	   t   argvt   initprofileR
   t   browserR   t   cmdloopt   KeyboardInterrupt(    (    (    s   /usr/lib/python2.7/pstats.pyt   <module>   sF   	ˇ §							è
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   """Pseudo terminal utilities."""

# Bugs: No signal handling.  Doesn't set slave termios and window size.
#       Only tested on Linux.
# See:  W. Richard Stevens. 1992.  Advanced Programming in the
#       UNIX Environment.  Chapter 19.
# Author: Steen Lumholt -- with additions by Guido.

from select import select
import os
import tty

__all__ = ["openpty","fork","spawn"]

STDIN_FILENO = 0
STDOUT_FILENO = 1
STDERR_FILENO = 2

CHILD = 0

def openpty():
    """openpty() -> (master_fd, slave_fd)
    Open a pty master/slave pair, using os.openpty() if possible."""

    try:
        return os.openpty()
    except (AttributeError, OSError):
        pass
    master_fd, slave_name = _open_terminal()
    slave_fd = slave_open(slave_name)
    return master_fd, slave_fd

def master_open():
    """master_open() -> (master_fd, slave_name)
    Open a pty master and return the fd, and the filename of the slave end.
    Deprecated, use openpty() instead."""

    try:
        master_fd, slave_fd = os.openpty()
    except (AttributeError, OSError):
        pass
    else:
        slave_name = os.ttyname(slave_fd)
        os.close(slave_fd)
        return master_fd, slave_name

    return _open_terminal()

def _open_terminal():
    """Open pty master and return (master_fd, tty_name).
    SGI and generic BSD version, for when openpty() fails."""
    try:
        import sgi
    except ImportError:
        pass
    else:
        try:
            tty_name, master_fd = sgi._getpty(os.O_RDWR, 0666, 0)
        except IOError, msg:
            raise os.error, msg
        return master_fd, tty_name
    for x in 'pqrstuvwxyzPQRST':
        for y in '0123456789abcdef':
            pty_name = '/dev/pty' + x + y
            try:
                fd = os.open(pty_name, os.O_RDWR)
            except os.error:
                continue
            return (fd, '/dev/tty' + x + y)
    raise os.error, 'out of pty devices'

def slave_open(tty_name):
    """slave_open(tty_name) -> slave_fd
    Open the pty slave and acquire the controlling terminal, returning
    opened filedescriptor.
    Deprecated, use openpty() instead."""

    result = os.open(tty_name, os.O_RDWR)
    try:
        from fcntl import ioctl, I_PUSH
    except ImportError:
        return result
    try:
        ioctl(result, I_PUSH, "ptem")
        ioctl(result, I_PUSH, "ldterm")
    except IOError:
        pass
    return result

def fork():
    """fork() -> (pid, master_fd)
    Fork and make the child a session leader with a controlling terminal."""

    try:
        pid, fd = os.forkpty()
    except (AttributeError, OSError):
        pass
    else:
        if pid == CHILD:
            try:
                os.setsid()
            except OSError:
                # os.forkpty() already set us session leader
                pass
        return pid, fd

    master_fd, slave_fd = openpty()
    pid = os.fork()
    if pid == CHILD:
        # Establish a new session.
        os.setsid()
        os.close(master_fd)

        # Slave becomes stdin/stdout/stderr of child.
        os.dup2(slave_fd, STDIN_FILENO)
        os.dup2(slave_fd, STDOUT_FILENO)
        os.dup2(slave_fd, STDERR_FILENO)
        if (slave_fd > STDERR_FILENO):
            os.close (slave_fd)

        # Explicitly open the tty to make it become a controlling tty.
        tmp_fd = os.open(os.ttyname(STDOUT_FILENO), os.O_RDWR)
        os.close(tmp_fd)
    else:
        os.close(slave_fd)

    # Parent and child process.
    return pid, master_fd

def _writen(fd, data):
    """Write all the data to a descriptor."""
    while data != '':
        n = os.write(fd, data)
        data = data[n:]

def _read(fd):
    """Default read function."""
    return os.read(fd, 1024)

def _copy(master_fd, master_read=_read, stdin_read=_read):
    """Parent copy loop.
    Copies
            pty master -> standard output   (master_read)
            standard input -> pty master    (stdin_read)"""
    fds = [master_fd, STDIN_FILENO]
    while True:
        rfds, wfds, xfds = select(fds, [], [])
        if master_fd in rfds:
            data = master_read(master_fd)
            if not data:  # Reached EOF.
                fds.remove(master_fd)
            else:
                os.write(STDOUT_FILENO, data)
        if STDIN_FILENO in rfds:
            data = stdin_read(STDIN_FILENO)
            if not data:
                fds.remove(STDIN_FILENO)
            else:
                _writen(master_fd, data)

def spawn(argv, master_read=_read, stdin_read=_read):
    """Create a spawned process."""
    if type(argv) == type(''):
        argv = (argv,)
    pid, master_fd = fork()
    if pid == CHILD:
        os.execlp(argv[0], *argv)
    try:
        mode = tty.tcgetattr(STDIN_FILENO)
        tty.setraw(STDIN_FILENO)
        restore = 1
    except tty.error:    # This is the same as termios.error
        restore = 0
    try:
        _copy(master_fd, master_read, stdin_read)
    except (IOError, OSError):
        if restore:
            tty.tcsetattr(STDIN_FILENO, tty.TCSAFLUSH, mode)

    os.close(master_fd)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   s∂   d  Z  d d l m Z d d l Z d d l Z d d d g Z d Z d Z d	 Z d Z d
 Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e e d Ñ Z e e d Ñ Z d S(   s   Pseudo terminal utilities.iˇˇˇˇ(   t   selectNt   openptyt   forkt   spawni    i   i   c          C   sM   y t  j É  SWn t t f k
 r' n Xt É  \ }  } t | É } |  | f S(   sd   openpty() -> (master_fd, slave_fd)
    Open a pty master/slave pair, using os.openpty() if possible.(   t   osR   t   AttributeErrort   OSErrort   _open_terminalt
   slave_open(   t	   master_fdt
   slave_namet   slave_fd(    (    s   /usr/lib/python2.7/pty.pyR      s    c          C   s]   y t  j É  \ }  } Wn t t f k
 r/ n' Xt  j | É } t  j | É |  | f St É  S(   sõ   master_open() -> (master_fd, slave_name)
    Open a pty master and return the fd, and the filename of the slave end.
    Deprecated, use openpty() instead.(   R   R   R   R   t   ttynamet   closeR   (   R	   R   R
   (    (    s   /usr/lib/python2.7/pty.pyt   master_open!   s    
c          C   sÙ   y d d l  }  Wn t k
 r# nO Xy" |  j t j d d É \ } } Wn t k
 rg } t j | Ç n X| | f Sxo d D]g } x^ d D]V } d | | } y t j | t j É } Wn t j k
 rÃ qÜ n X| d | | f SWqy Wt j d	 Ç d S(
   sl   Open pty master and return (master_fd, tty_name).
    SGI and generic BSD version, for when openpty() fails.iˇˇˇˇNi∂  i    t   pqrstuvwxyzPQRSTt   0123456789abcdefs   /dev/ptys   /dev/ttys   out of pty devices(   t   sgit   ImportErrort   _getptyR   t   O_RDWRt   IOErrort   errort   open(   R   t   tty_nameR	   t   msgt   xt   yt   pty_namet   fd(    (    s   /usr/lib/python2.7/pty.pyR   1   s$    "
c         C   sÄ   t  j |  t  j É } y d d l m } m } Wn t k
 rC | SXy$ | | | d É | | | d É Wn t k
 r{ n X| S(   s©   slave_open(tty_name) -> slave_fd
    Open the pty slave and acquire the controlling terminal, returning
    opened filedescriptor.
    Deprecated, use openpty() instead.iˇˇˇˇ(   t   ioctlt   I_PUSHt   ptemt   ldterm(   R   R   R   t   fcntlR   R   R   R   (   R   t   resultR   R   (    (    s   /usr/lib/python2.7/pty.pyR   H   s    c          C   s:  y t  j É  \ }  } Wn t t f k
 r/ n< X|  t k ra y t  j É  Wqa t k
 r] qa Xn  |  | f St É  \ } } t  j É  }  |  t k r#t  j É  t  j | É t  j	 | t
 É t  j	 | t É t  j	 | t É | t k rı t  j | É n  t  j t  j t É t  j É } t  j | É n t  j | É |  | f S(   sd   fork() -> (pid, master_fd)
    Fork and make the child a session leader with a controlling terminal.(   R   t   forkptyR   R   t   CHILDt   setsidR   R   R   t   dup2t   STDIN_FILENOt   STDOUT_FILENOt   STDERR_FILENOR   R   R   (   t   pidR   R	   R   t   tmp_fd(    (    s   /usr/lib/python2.7/pty.pyR   Z   s0    

c         C   s3   x, | d k r. t  j |  | É } | | } q Wd S(   s#   Write all the data to a descriptor.t    N(   R   t   write(   R   t   datat   n(    (    s   /usr/lib/python2.7/pty.pyt   _writenÇ   s    c         C   s   t  j |  d É S(   s   Default read function.i   (   R   t   read(   R   (    (    s   /usr/lib/python2.7/pty.pyt   _readà   s    c         C   s∑   |  t  g } x§ t r≤ t | g  g  É \ } } } |  | k rq | |  É } | s^ | j |  É qq t j t | É n  t  | k r | t  É } | sü | j t  É qØ t |  | É q q Wd S(   sè   Parent copy loop.
    Copies
            pty master -> standard output   (master_read)
            standard input -> pty master    (stdin_read)N(   R(   t   TrueR    t   removeR   R.   R)   R1   (   R	   t   master_readt
   stdin_readt   fdst   rfdst   wfdst   xfdsR/   (    (    s   /usr/lib/python2.7/pty.pyt   _copyå   s    	c         C   s˜   t  |  É t  d É k r$ |  f }  n  t É  \ } } | t k rV t j |  d |  å n  y& t j t É } t j t É d } Wn t j	 k
 rò d } n Xy t
 | | | É Wn6 t t f k
 rÂ | rÊ t j t t j | É qÊ n Xt j | É d S(   s   Create a spawned process.R-   i    i   N(   t   typeR   R%   R   t   execlpt   ttyt	   tcgetattrR(   t   setrawR   R<   R   R   t	   tcsetattrt	   TCSAFLUSHR   (   t   argvR6   R7   R+   R	   t   modet   restore(    (    s   /usr/lib/python2.7/pty.pyR   °   s"    

(   t   __doc__R    R   R?   t   __all__R(   R)   R*   R%   R   R   R   R   R   R1   R3   R<   R   (    (    (    s   /usr/lib/python2.7/pty.pyt   <module>   s"   					(		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              """Routine to "compile" a .py file to a .pyc (or .pyo) file.

This module has intimate knowledge of the format of .pyc files.
"""

import __builtin__
import imp
import marshal
import os
import sys
import traceback

MAGIC = imp.get_magic()

__all__ = ["compile", "main", "PyCompileError"]


class PyCompileError(Exception):
    """Exception raised when an error occurs while attempting to
    compile the file.

    To raise this exception, use

        raise PyCompileError(exc_type,exc_value,file[,msg])

    where

        exc_type:   exception type to be used in error message
                    type name can be accesses as class variable
                    'exc_type_name'

        exc_value:  exception value to be used in error message
                    can be accesses as class variable 'exc_value'

        file:       name of file being compiled to be used in error message
                    can be accesses as class variable 'file'

        msg:        string message to be written as error message
                    If no value is given, a default exception message will be given,
                    consistent with 'standard' py_compile output.
                    message (or default) can be accesses as class variable 'msg'

    """

    def __init__(self, exc_type, exc_value, file, msg=''):
        exc_type_name = exc_type.__name__
        if exc_type is SyntaxError:
            tbtext = ''.join(traceback.format_exception_only(exc_type, exc_value))
            errmsg = tbtext.replace('File "<string>"', 'File "%s"' % file)
        else:
            errmsg = "Sorry: %s: %s" % (exc_type_name,exc_value)

        Exception.__init__(self,msg or errmsg,exc_type_name,exc_value,file)

        self.exc_type_name = exc_type_name
        self.exc_value = exc_value
        self.file = file
        self.msg = msg or errmsg

    def __str__(self):
        return self.msg


def wr_long(f, x):
    """Internal; write a 32-bit int to a file in little-endian order."""
    f.write(chr( x        & 0xff))
    f.write(chr((x >> 8)  & 0xff))
    f.write(chr((x >> 16) & 0xff))
    f.write(chr((x >> 24) & 0xff))

def compile(file, cfile=None, dfile=None, doraise=False):
    """Byte-compile one Python source file to Python bytecode.

    Arguments:

    file:    source filename
    cfile:   target filename; defaults to source with 'c' or 'o' appended
             ('c' normally, 'o' in optimizing mode, giving .pyc or .pyo)
    dfile:   purported filename; defaults to source (this is the filename
             that will show up in error messages)
    doraise: flag indicating whether or not an exception should be
             raised when a compile error is found. If an exception
             occurs and this flag is set to False, a string
             indicating the nature of the exception will be printed,
             and the function will return to the caller. If an
             exception occurs and this flag is set to True, a
             PyCompileError exception will be raised.

    Note that it isn't necessary to byte-compile Python modules for
    execution efficiency -- Python itself byte-compiles a module when
    it is loaded, and if it can, writes out the bytecode to the
    corresponding .pyc (or .pyo) file.

    However, if a Python installation is shared between users, it is a
    good idea to byte-compile all modules upon installation, since
    other users may not be able to write in the source directories,
    and thus they won't be able to write the .pyc/.pyo file, and then
    they would be byte-compiling every module each time it is loaded.
    This can slow down program start-up considerably.

    See compileall.py for a script/module that uses this module to
    byte-compile all installed files (or all files in selected
    directories).

    """
    with open(file, 'U') as f:
        try:
            timestamp = long(os.fstat(f.fileno()).st_mtime)
        except AttributeError:
            timestamp = long(os.stat(file).st_mtime)
        codestring = f.read()
    try:
        codeobject = __builtin__.compile(codestring, dfile or file,'exec')
    except Exception,err:
        py_exc = PyCompileError(err.__class__, err, dfile or file)
        if doraise:
            raise py_exc
        else:
            sys.stderr.write(py_exc.msg + '\n')
            return
    if cfile is None:
        cfile = file + (__debug__ and 'c' or 'o')
    # Atomically write the pyc/pyo file.  Issue #13146.
    # id() is used to generate a pseudo-random filename.
    path_tmp = '{}.{}'.format(cfile, id(cfile))
    try:
        with open(path_tmp, 'wb') as fc:
            fc.write('\0\0\0\0')
            wr_long(fc, timestamp)
            marshal.dump(codeobject, fc)
            fc.flush()
            fc.seek(0, 0)
            fc.write(MAGIC)
        os.rename(path_tmp, cfile)
    except OSError:
        try:
            os.unlink(path_tmp)
        except OSError:
            pass
        raise

def main(args=None):
    """Compile several source files.

    The files named in 'args' (or on the command line, if 'args' is
    not specified) are compiled and the resulting bytecode is cached
    in the normal manner.  This function does not search a directory
    structure to locate source files; it only compiles files named
    explicitly.  If '-' is the only parameter in args, the list of
    files is taken from standard input.

    """
    if args is None:
        args = sys.argv[1:]
    rv = 0
    if args == ['-']:
        while True:
            filename = sys.stdin.readline()
            if not filename:
                break
            filename = filename.rstrip('\n')
            try:
                compile(filename, doraise=True)
            except PyCompileError as error:
                rv = 1
                sys.stderr.write("%s\n" % error.msg)
            except IOError as error:
                rv = 1
                sys.stderr.write("%s\n" % error)
    else:
        for filename in args:
            try:
                compile(filename, doraise=True)
            except PyCompileError as error:
                # return value to indicate at least one failure
                rv = 1
                sys.stderr.write("%s\n" % error.msg)
    return rv

if __name__ == "__main__":
    sys.exit(main())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   s…   d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z e j É  Z d d d g Z	 d e
 f d Ñ  É  YZ d Ñ  Z d d e d Ñ Z d d	 Ñ Z e d
 k r≈ e j e É  É n  d S(   s{   Routine to "compile" a .py file to a .pyc (or .pyo) file.

This module has intimate knowledge of the format of .pyc files.
iˇˇˇˇNt   compilet   maint   PyCompileErrorc           B   s#   e  Z d  Z d d Ñ Z d Ñ  Z RS(   sõ  Exception raised when an error occurs while attempting to
    compile the file.

    To raise this exception, use

        raise PyCompileError(exc_type,exc_value,file[,msg])

    where

        exc_type:   exception type to be used in error message
                    type name can be accesses as class variable
                    'exc_type_name'

        exc_value:  exception value to be used in error message
                    can be accesses as class variable 'exc_value'

        file:       name of file being compiled to be used in error message
                    can be accesses as class variable 'file'

        msg:        string message to be written as error message
                    If no value is given, a default exception message will be given,
                    consistent with 'standard' py_compile output.
                    message (or default) can be accesses as class variable 'msg'

    t    c         C   s¶   | j  } | t k rI d j t j | | É É } | j d d | É } n d | | f } t j |  | pk | | | | É | |  _ | |  _	 | |  _
 | pú | |  _ d  S(   NR   s   File "<string>"s	   File "%s"s   Sorry: %s: %s(   t   __name__t   SyntaxErrort   joint	   tracebackt   format_exception_onlyt   replacet	   Exceptiont   __init__t   exc_type_namet	   exc_valuet   filet   msg(   t   selft   exc_typeR   R   R   R   t   tbtextt   errmsg(    (    s    /usr/lib/python2.7/py_compile.pyR   -   s    				c         C   s   |  j  S(   N(   R   (   R   (    (    s    /usr/lib/python2.7/py_compile.pyt   __str__<   s    (   R   t
   __module__t   __doc__R   R   (    (    (    s    /usr/lib/python2.7/py_compile.pyR      s   c         C   sl   |  j  t | d @É É |  j  t | d ?d @É É |  j  t | d ?d @É É |  j  t | d ?d @É É d S(   s>   Internal; write a 32-bit int to a file in little-endian order.iˇ   i   i   i   N(   t   writet   chr(   t   ft   x(    (    s    /usr/lib/python2.7/py_compile.pyt   wr_long@   s    c      	   C   sÊ  t  |  d É èa } y" t t j | j É  É j É } Wn) t k
 r_ t t j |  É j É } n X| j É  } Wd QXy t	 j
 | | pá |  d É } WnX t k
 rÎ } t | j | | p∏ |  É }	 | rÕ |	 Ç qÏ t j j |	 j d É d Sn X| d k r|  t rd p
d } n  d j | t | É É }
 y} t  |
 d É èX } | j d	 É t | | É t j | | É | j É  | j d
 d
 É | j t É Wd QXt j |
 | É Wn9 t k
 r·y t j |
 É Wn t k
 r⁄n XÇ  n Xd S(   sL  Byte-compile one Python source file to Python bytecode.

    Arguments:

    file:    source filename
    cfile:   target filename; defaults to source with 'c' or 'o' appended
             ('c' normally, 'o' in optimizing mode, giving .pyc or .pyo)
    dfile:   purported filename; defaults to source (this is the filename
             that will show up in error messages)
    doraise: flag indicating whether or not an exception should be
             raised when a compile error is found. If an exception
             occurs and this flag is set to False, a string
             indicating the nature of the exception will be printed,
             and the function will return to the caller. If an
             exception occurs and this flag is set to True, a
             PyCompileError exception will be raised.

    Note that it isn't necessary to byte-compile Python modules for
    execution efficiency -- Python itself byte-compiles a module when
    it is loaded, and if it can, writes out the bytecode to the
    corresponding .pyc (or .pyo) file.

    However, if a Python installation is shared between users, it is a
    good idea to byte-compile all modules upon installation, since
    other users may not be able to write in the source directories,
    and thus they won't be able to write the .pyc/.pyo file, and then
    they would be byte-compiling every module each time it is loaded.
    This can slow down program start-up considerably.

    See compileall.py for a script/module that uses this module to
    byte-compile all installed files (or all files in selected
    directories).

    t   UNt   execs   
t   ct   os   {}.{}t   wbs       i    (   t   opent   longt   ost   fstatt   filenot   st_mtimet   AttributeErrort   statt   readt   __builtin__R    R
   R   t	   __class__t   syst   stderrR   R   t   Nonet	   __debug__t   formatt   idR   t   marshalt   dumpt   flusht   seekt   MAGICt   renamet   OSErrort   unlink(   R   t   cfilet   dfilet   doraiseR   t	   timestampt
   codestringt
   codeobjectt   errt   py_exct   path_tmpt   fc(    (    s    /usr/lib/python2.7/py_compile.pyR    G   s@    #"	
c         C   s8  |  d k r t j d }  n  d } |  d g k r‹ x t rÿ t j j É  } | sS Pn  | j d É } y t | d t ÉWq4 t k
 r® } d } t j	 j
 d | j É q4 t k
 r‘ } d } t j	 j
 d | É q4 Xq4 WnX xU |  D]M } y t | d t ÉWq„ t k
 r/} d } t j	 j
 d | j É q„ Xq„ W| S(   s†  Compile several source files.

    The files named in 'args' (or on the command line, if 'args' is
    not specified) are compiled and the resulting bytecode is cached
    in the normal manner.  This function does not search a directory
    structure to locate source files; it only compiles files named
    explicitly.  If '-' is the only parameter in args, the list of
    files is taken from standard input.

    i   i    t   -s   
R<   s   %s
N(   R.   R,   t   argvt   Truet   stdint   readlinet   rstripR    R   R-   R   R   t   IOError(   t   argst   rvt   filenamet   error(    (    s    /usr/lib/python2.7/py_compile.pyR   é   s0    	t   __main__(   R   R*   t   impR2   R#   R,   R   t	   get_magicR6   t   __all__R
   R   R   R.   t   FalseR    R   R   t   exit(    (    (    s    /usr/lib/python2.7/py_compile.pyt   <module>   s   .	G&                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #! /usr/bin/python2.7

"""Conversions to/from quoted-printable transport encoding as per RFC 1521."""

# (Dec 1991 version).

__all__ = ["encode", "decode", "encodestring", "decodestring"]

ESCAPE = '='
MAXLINESIZE = 76
HEX = '0123456789ABCDEF'
EMPTYSTRING = ''

try:
    from binascii import a2b_qp, b2a_qp
except ImportError:
    a2b_qp = None
    b2a_qp = None


def needsquoting(c, quotetabs, header):
    """Decide whether a particular character needs to be quoted.

    The 'quotetabs' flag indicates whether embedded tabs and spaces should be
    quoted.  Note that line-ending tabs and spaces are always encoded, as per
    RFC 1521.
    """
    if c in ' \t':
        return quotetabs
    # if header, we have to escape _ because _ is used to escape space
    if c == '_':
        return header
    return c == ESCAPE or not (' ' <= c <= '~')

def quote(c):
    """Quote a single character."""
    i = ord(c)
    return ESCAPE + HEX[i//16] + HEX[i%16]



def encode(input, output, quotetabs, header = 0):
    """Read 'input', apply quoted-printable encoding, and write to 'output'.

    'input' and 'output' are files with readline() and write() methods.
    The 'quotetabs' flag indicates whether embedded tabs and spaces should be
    quoted.  Note that line-ending tabs and spaces are always encoded, as per
    RFC 1521.
    The 'header' flag indicates whether we are encoding spaces as _ as per
    RFC 1522.
    """

    if b2a_qp is not None:
        data = input.read()
        odata = b2a_qp(data, quotetabs = quotetabs, header = header)
        output.write(odata)
        return

    def write(s, output=output, lineEnd='\n'):
        # RFC 1521 requires that the line ending in a space or tab must have
        # that trailing character encoded.
        if s and s[-1:] in ' \t':
            output.write(s[:-1] + quote(s[-1]) + lineEnd)
        elif s == '.':
            output.write(quote(s) + lineEnd)
        else:
            output.write(s + lineEnd)

    prevline = None
    while 1:
        line = input.readline()
        if not line:
            break
        outline = []
        # Strip off any readline induced trailing newline
        stripped = ''
        if line[-1:] == '\n':
            line = line[:-1]
            stripped = '\n'
        # Calculate the un-length-limited encoded line
        for c in line:
            if needsquoting(c, quotetabs, header):
                c = quote(c)
            if header and c == ' ':
                outline.append('_')
            else:
                outline.append(c)
        # First, write out the previous line
        if prevline is not None:
            write(prevline)
        # Now see if we need any soft line breaks because of RFC-imposed
        # length limitations.  Then do the thisline->prevline dance.
        thisline = EMPTYSTRING.join(outline)
        while len(thisline) > MAXLINESIZE:
            # Don't forget to include the soft line break `=' sign in the
            # length calculation!
            write(thisline[:MAXLINESIZE-1], lineEnd='=\n')
            thisline = thisline[MAXLINESIZE-1:]
        # Write out the current line
        prevline = thisline
    # Write out the last line, without a trailing newline
    if prevline is not None:
        write(prevline, lineEnd=stripped)

def encodestring(s, quotetabs = 0, header = 0):
    if b2a_qp is not None:
        return b2a_qp(s, quotetabs = quotetabs, header = header)
    from cStringIO import StringIO
    infp = StringIO(s)
    outfp = StringIO()
    encode(infp, outfp, quotetabs, header)
    return outfp.getvalue()



def decode(input, output, header = 0):
    """Read 'input', apply quoted-printable decoding, and write to 'output'.
    'input' and 'output' are files with readline() and write() methods.
    If 'header' is true, decode underscore as space (per RFC 1522)."""

    if a2b_qp is not None:
        data = input.read()
        odata = a2b_qp(data, header = header)
        output.write(odata)
        return

    new = ''
    while 1:
        line = input.readline()
        if not line: break
        i, n = 0, len(line)
        if n > 0 and line[n-1] == '\n':
            partial = 0; n = n-1
            # Strip trailing whitespace
            while n > 0 and line[n-1] in " \t\r":
                n = n-1
        else:
            partial = 1
        while i < n:
            c = line[i]
            if c == '_' and header:
                new = new + ' '; i = i+1
            elif c != ESCAPE:
                new = new + c; i = i+1
            elif i+1 == n and not partial:
                partial = 1; break
            elif i+1 < n and line[i+1] == ESCAPE:
                new = new + ESCAPE; i = i+2
            elif i+2 < n and ishex(line[i+1]) and ishex(line[i+2]):
                new = new + chr(unhex(line[i+1:i+3])); i = i+3
            else: # Bad escape sequence -- leave it in
                new = new + c; i = i+1
        if not partial:
            output.write(new + '\n')
            new = ''
    if new:
        output.write(new)

def decodestring(s, header = 0):
    if a2b_qp is not None:
        return a2b_qp(s, header = header)
    from cStringIO import StringIO
    infp = StringIO(s)
    outfp = StringIO()
    decode(infp, outfp, header = header)
    return outfp.getvalue()



# Other helper functions
def ishex(c):
    """Return true if the character 'c' is a hexadecimal digit."""
    return '0' <= c <= '9' or 'a' <= c <= 'f' or 'A' <= c <= 'F'

def unhex(s):
    """Get the integer value of a hexadecimal number."""
    bits = 0
    for c in s:
        if '0' <= c <= '9':
            i = ord('0')
        elif 'a' <= c <= 'f':
            i = ord('a')-10
        elif 'A' <= c <= 'F':
            i = ord('A')-10
        else:
            break
        bits = bits*16 + (ord(c) - i)
    return bits



def main():
    import sys
    import getopt
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'td')
    except getopt.error, msg:
        sys.stdout = sys.stderr
        print msg
        print "usage: quopri [-t | -d] [file] ..."
        print "-t: quote tabs"
        print "-d: decode; default encode"
        sys.exit(2)
    deco = 0
    tabs = 0
    for o, a in opts:
        if o == '-t': tabs = 1
        if o == '-d': deco = 1
    if tabs and deco:
        sys.stdout = sys.stderr
        print "-t and -d are mutually exclusive"
        sys.exit(2)
    if not args: args = ['-']
    sts = 0
    for file in args:
        if file == '-':
            fp = sys.stdin
        else:
            try:
                fp = open(file)
            except IOError, msg:
                sys.stderr.write("%s: can't open (%s)\n" % (file, msg))
                sts = 1
                continue
        if deco:
            decode(fp, sys.stdout)
        else:
            encode(fp, sys.stdout, tabs)
        if fp is not sys.stdin:
            fp.close()
    if sts:
        sys.exit(sts)



if __name__ == '__main__':
    main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """Parse a Python module and describe its classes and methods.

Parse enough of a Python file to recognize imports and class and
method definitions, and to find out the superclasses of a class.

The interface consists of a single function:
        readmodule_ex(module [, path])
where module is the name of a Python module, and path is an optional
list of directories where the module is to be searched.  If present,
path is prepended to the system search path sys.path.  The return
value is a dictionary.  The keys of the dictionary are the names of
the classes defined in the module (including classes that are defined
via the from XXX import YYY construct).  The values are class
instances of the class Class defined here.  One special key/value pair
is present for packages: the key '__path__' has a list as its value
which contains the package search path.

A class is described by the class Class in this module.  Instances
of this class have the following instance variables:
        module -- the module name
        name -- the name of the class
        super -- a list of super classes (Class instances)
        methods -- a dictionary of methods
        file -- the file in which the class was defined
        lineno -- the line in the file on which the class statement occurred
The dictionary of methods uses the method names as keys and the line
numbers on which the method was defined as values.
If the name of a super class is not recognized, the corresponding
entry in the list of super classes is not a class instance but a
string giving the name of the super class.  Since import statements
are recognized and imported modules are scanned as well, this
shouldn't happen often.

A function is described by the class Function in this module.
Instances of this class have the following instance variables:
        module -- the module name
        name -- the name of the class
        file -- the file in which the class was defined
        lineno -- the line in the file on which the class statement occurred
"""

import sys
import imp
import tokenize
from token import NAME, DEDENT, OP
from operator import itemgetter

__all__ = ["readmodule", "readmodule_ex", "Class", "Function"]

_modules = {}                           # cache of modules we've seen

# each Python class is represented by an instance of this class
class Class:
    '''Class to represent a Python class.'''
    def __init__(self, module, name, super, file, lineno):
        self.module = module
        self.name = name
        if super is None:
            super = []
        self.super = super
        self.methods = {}
        self.file = file
        self.lineno = lineno

    def _addmethod(self, name, lineno):
        self.methods[name] = lineno

class Function:
    '''Class to represent a top-level Python function'''
    def __init__(self, module, name, file, lineno):
        self.module = module
        self.name = name
        self.file = file
        self.lineno = lineno

def readmodule(module, path=None):
    '''Backwards compatible interface.

    Call readmodule_ex() and then only keep Class objects from the
    resulting dictionary.'''

    res = {}
    for key, value in _readmodule(module, path or []).items():
        if isinstance(value, Class):
            res[key] = value
    return res

def readmodule_ex(module, path=None):
    '''Read a module file and return a dictionary of classes.

    Search for MODULE in PATH and sys.path, read and parse the
    module and return a dictionary with one entry for each class
    found in the module.
    '''
    return _readmodule(module, path or [])

def _readmodule(module, path, inpackage=None):
    '''Do the hard work for readmodule[_ex].

    If INPACKAGE is given, it must be the dotted name of the package in
    which we are searching for a submodule, and then PATH must be the
    package search path; otherwise, we are searching for a top-level
    module, and PATH is combined with sys.path.
    '''
    # Compute the full module name (prepending inpackage if set)
    if inpackage is not None:
        fullmodule = "%s.%s" % (inpackage, module)
    else:
        fullmodule = module

    # Check in the cache
    if fullmodule in _modules:
        return _modules[fullmodule]

    # Initialize the dict for this module's contents
    dict = {}

    # Check if it is a built-in module; we don't do much for these
    if module in sys.builtin_module_names and inpackage is None:
        _modules[module] = dict
        return dict

    # Check for a dotted module name
    i = module.rfind('.')
    if i >= 0:
        package = module[:i]
        submodule = module[i+1:]
        parent = _readmodule(package, path, inpackage)
        if inpackage is not None:
            package = "%s.%s" % (inpackage, package)
        if not '__path__' in parent:
            raise ImportError('No package named {}'.format(package))
        return _readmodule(submodule, parent['__path__'], package)

    # Search the path for the module
    f = None
    if inpackage is not None:
        f, fname, (_s, _m, ty) = imp.find_module(module, path)
    else:
        f, fname, (_s, _m, ty) = imp.find_module(module, path + sys.path)
    if ty == imp.PKG_DIRECTORY:
        dict['__path__'] = [fname]
        path = [fname] + path
        f, fname, (_s, _m, ty) = imp.find_module('__init__', [fname])
    _modules[fullmodule] = dict
    if ty != imp.PY_SOURCE:
        # not Python source, can't do anything with this module
        f.close()
        return dict

    stack = [] # stack of (class, indent) pairs

    g = tokenize.generate_tokens(f.readline)
    try:
        for tokentype, token, start, _end, _line in g:
            if tokentype == DEDENT:
                lineno, thisindent = start
                # close nested classes and defs
                while stack and stack[-1][1] >= thisindent:
                    del stack[-1]
            elif token == 'def':
                lineno, thisindent = start
                # close previous nested classes and defs
                while stack and stack[-1][1] >= thisindent:
                    del stack[-1]
                tokentype, meth_name, start = g.next()[0:3]
                if tokentype != NAME:
                    continue # Syntax error
                if stack:
                    cur_class = stack[-1][0]
                    if isinstance(cur_class, Class):
                        # it's a method
                        cur_class._addmethod(meth_name, lineno)
                    # else it's a nested def
                else:
                    # it's a function
                    dict[meth_name] = Function(fullmodule, meth_name,
                                               fname, lineno)
                stack.append((None, thisindent)) # Marker for nested fns
            elif token == 'class':
                lineno, thisindent = start
                # close previous nested classes and defs
                while stack and stack[-1][1] >= thisindent:
                    del stack[-1]
                tokentype, class_name, start = g.next()[0:3]
                if tokentype != NAME:
                    continue # Syntax error
                # parse what follows the class name
                tokentype, token, start = g.next()[0:3]
                inherit = None
                if token == '(':
                    names = [] # List of superclasses
                    # there's a list of superclasses
                    level = 1
                    super = [] # Tokens making up current superclass
                    while True:
                        tokentype, token, start = g.next()[0:3]
                        if token in (')', ',') and level == 1:
                            n = "".join(super)
                            if n in dict:
                                # we know this super class
                                n = dict[n]
                            else:
                                c = n.split('.')
                                if len(c) > 1:
                                    # super class is of the form
                                    # module.class: look in module for
                                    # class
                                    m = c[-2]
                                    c = c[-1]
                                    if m in _modules:
                                        d = _modules[m]
                                        if c in d:
                                            n = d[c]
                            names.append(n)
                            super = []
                        if token == '(':
                            level += 1
                        elif token == ')':
                            level -= 1
                            if level == 0:
                                break
                        elif token == ',' and level == 1:
                            pass
                        # only use NAME and OP (== dot) tokens for type name
                        elif tokentype in (NAME, OP) and level == 1:
                            super.append(token)
                        # expressions in the base list are not supported
                    inherit = names
                cur_class = Class(fullmodule, class_name, inherit,
                                  fname, lineno)
                if not stack:
                    dict[class_name] = cur_class
                stack.append((cur_class, thisindent))
            elif token == 'import' and start[1] == 0:
                modules = _getnamelist(g)
                for mod, _mod2 in modules:
                    try:
                        # Recursively read the imported module
                        if inpackage is None:
                            _readmodule(mod, path)
                        else:
                            try:
                                _readmodule(mod, path, inpackage)
                            except ImportError:
                                _readmodule(mod, [])
                    except:
                        # If we can't find or parse the imported module,
                        # too bad -- don't die here.
                        pass
            elif token == 'from' and start[1] == 0:
                mod, token = _getname(g)
                if not mod or token != "import":
                    continue
                names = _getnamelist(g)
                try:
                    # Recursively read the imported module
                    d = _readmodule(mod, path, inpackage)
                except:
                    # If we can't find or parse the imported module,
                    # too bad -- don't die here.
                    continue
                # add any classes that were defined in the imported module
                # to our name space if they were mentioned in the list
                for n, n2 in names:
                    if n in d:
                        dict[n2 or n] = d[n]
                    elif n == '*':
                        # don't add names that start with _
                        for n in d:
                            if n[0] != '_':
                                dict[n] = d[n]
    except StopIteration:
        pass

    f.close()
    return dict

def _getnamelist(g):
    # Helper to get a comma-separated list of dotted names plus 'as'
    # clauses.  Return a list of pairs (name, name2) where name2 is
    # the 'as' name, or None if there is no 'as' clause.
    names = []
    while True:
        name, token = _getname(g)
        if not name:
            break
        if token == 'as':
            name2, token = _getname(g)
        else:
            name2 = None
        names.append((name, name2))
        while token != "," and "\n" not in token:
            token = g.next()[1]
        if token != ",":
            break
    return names

def _getname(g):
    # Helper to get a dotted name, return a pair (name, token) where
    # name is the dotted name, or None if there was no dotted name,
    # and token is the next input token.
    parts = []
    tokentype, token = g.next()[0:2]
    if tokentype != NAME and token != '*':
        return (None, token)
    parts.append(token)
    while True:
        tokentype, token = g.next()[0:2]
        if token != '.':
            break
        tokentype, token = g.next()[0:2]
        if tokentype != NAME:
            break
        parts.append(token)
    return (".".join(parts), token)

def _main():
    # Main program for testing.
    import os
    mod = sys.argv[1]
    if os.path.exists(mod):
        path = [os.path.dirname(mod)]
        mod = os.path.basename(mod)
        if mod.lower().endswith(".py"):
            mod = mod[:-3]
    else:
        path = []
    dict = readmodule_ex(mod, path)
    objs = dict.values()
    objs.sort(lambda a, b: cmp(getattr(a, 'lineno', 0),
                               getattr(b, 'lineno', 0)))
    for obj in objs:
        if isinstance(obj, Class):
            print "class", obj.name, obj.super, obj.lineno
            methods = sorted(obj.methods.iteritems(), key=itemgetter(1))
            for name, lineno in methods:
                if name != "__path__":
                    print "  def", name, lineno
        elif isinstance(obj, Function):
            print "def", obj.name, obj.lineno

if __name__ == "__main__":
    _main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sÌ   d  Z  d d l Z d d l Z d d l Z d d l m Z m Z m Z d d l m	 Z	 d d d d g Z
 i  Z d d d	 Ñ  É  YZ d d d
 Ñ  É  YZ d d Ñ Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z e d k rÈ e É  n  d S(   sÁ  Parse a Python module and describe its classes and methods.

Parse enough of a Python file to recognize imports and class and
method definitions, and to find out the superclasses of a class.

The interface consists of a single function:
        readmodule_ex(module [, path])
where module is the name of a Python module, and path is an optional
list of directories where the module is to be searched.  If present,
path is prepended to the system search path sys.path.  The return
value is a dictionary.  The keys of the dictionary are the names of
the classes defined in the module (including classes that are defined
via the from XXX import YYY construct).  The values are class
instances of the class Class defined here.  One special key/value pair
is present for packages: the key '__path__' has a list as its value
which contains the package search path.

A class is described by the class Class in this module.  Instances
of this class have the following instance variables:
        module -- the module name
        name -- the name of the class
        super -- a list of super classes (Class instances)
        methods -- a dictionary of methods
        file -- the file in which the class was defined
        lineno -- the line in the file on which the class statement occurred
The dictionary of methods uses the method names as keys and the line
numbers on which the method was defined as values.
If the name of a super class is not recognized, the corresponding
entry in the list of super classes is not a class instance but a
string giving the name of the super class.  Since import statements
are recognized and imported modules are scanned as well, this
shouldn't happen often.

A function is described by the class Function in this module.
Instances of this class have the following instance variables:
        module -- the module name
        name -- the name of the class
        file -- the file in which the class was defined
        lineno -- the line in the file on which the class statement occurred
iˇˇˇˇN(   t   NAMEt   DEDENTt   OP(   t
   itemgettert
   readmodulet   readmodule_ext   Classt   Functionc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s"   Class to represent a Python class.c         C   sO   | |  _  | |  _ | d  k r' g  } n  | |  _ i  |  _ | |  _ | |  _ d  S(   N(   t   modulet   namet   Nonet   supert   methodst   filet   lineno(   t   selfR   R	   R   R   R   (    (    s   /usr/lib/python2.7/pyclbr.pyt   __init__7   s    						c         C   s   | |  j  | <d  S(   N(   R   (   R   R	   R   (    (    s   /usr/lib/python2.7/pyclbr.pyt
   _addmethodA   s    (   t   __name__t
   __module__t   __doc__R   R   (    (    (    s   /usr/lib/python2.7/pyclbr.pyR   5   s   	
c           B   s   e  Z d  Z d Ñ  Z RS(   s.   Class to represent a top-level Python functionc         C   s(   | |  _  | |  _ | |  _ | |  _ d  S(   N(   R   R	   R   R   (   R   R   R	   R   R   (    (    s   /usr/lib/python2.7/pyclbr.pyR   F   s    			(   R   R   R   R   (    (    (    s   /usr/lib/python2.7/pyclbr.pyR   D   s   c         C   sR   i  } xE t  |  | p g  É j É  D]( \ } } t | t É r" | | | <q" q" W| S(   s}   Backwards compatible interface.

    Call readmodule_ex() and then only keep Class objects from the
    resulting dictionary.(   t   _readmodulet   itemst
   isinstanceR   (   R   t   patht   rest   keyt   value(    (    s   /usr/lib/python2.7/pyclbr.pyR   L   s
    (c         C   s   t  |  | p g  É S(   s’   Read a module file and return a dictionary of classes.

    Search for MODULE in PATH and sys.path, read and parse the
    module and return a dictionary with one entry for each class
    found in the module.
    (   R   (   R   R   (    (    s   /usr/lib/python2.7/pyclbr.pyR   X   s    c   &      C   sZ  | d k	 r d | |  f } n |  } | t k r9 t | Si  } |  t j k rh | d k rh | t |  <| S|  j d É } | d k r|  |  } |  | d } t | | | É } | d k	 rÃ d | | f } n  d | k r t d j | É É Ç n  t | | d | É Sd }	 | d k	 r=t j	 |  | É \ }	 }
 \ } } } n+ t j	 |  | t j
 É \ }	 }
 \ } } } | t j k rª|
 g | d <|
 g | } t j	 d |
 g É \ }	 }
 \ } } } n  | t | <| t j k r‚|	 j É  | Sg  } t j |	 j É } y>x7| D]/\ } } } } } | t k r\| \ } } xˇ| rX| d d | k rX| d =q4Wq| d	 k r2| \ } } x% | rõ| d d | k rõ| d =qwW| j É  d d
 !\ } } } | t k r qn  | r| d d } t | t É r| j | | É qn t | | |
 | É | | <| j d | f É q| d k rû| \ } } x% | rq| d d | k rq| d =qMW| j É  d d
 !\ } } } | t k r†qn  | j É  d d
 !\ } } } d } | d k r]g  } d } g  } xqt rS| j É  d d
 !\ } } } | d k r≈| d k r≈d j | É } | | k rE| | } nj | j d É } t | É d k rØ| d }  | d } |  t k rØt |  }! | |! k r¨|! | } q¨qØn  | j | É g  } n  | d k rﬁ| d 7} q„| d k r| d 8} | d k rPPqPq„| d k r"| d k r"q„| t t f k r„| d k r„| j | É q„q„W| } n  t | | | |
 | É } | sà| | | <n  | j | | f É q| d k r?| d d k r?t | É }" xj|" D]k \ }# }$ yU | d k r¯t |# | É n5 y t |# | | É Wn t k
 r,t |# g  É n XWqÕqÕXqÕWq| d k r| d d k rt | É \ }# } |# s| d k rÜqn  t | É } y t |# | | É }! Wn
 qn Xx{ | D]p \ } }% | |! k rÎ|! | | |% pÁ| <qº| d k rºx2 |! D]' } | d d k r˛|! | | | <q˛q˛WqºqºWqqWWn t  k
 rKn X|	 j É  | S(   s.  Do the hard work for readmodule[_ex].

    If INPACKAGE is given, it must be the dotted name of the package in
    which we are searching for a submodule, and then PATH must be the
    package search path; otherwise, we are searching for a top-level
    module, and PATH is combined with sys.path.
    s   %s.%st   .i    i   t   __path__s   No package named {}R   iˇˇˇˇt   defi   t   classt   (t   )t   ,t    i˛ˇˇˇt   importt   fromt   *t   _N(   R!   R"   (!   R
   t   _modulest   syst   builtin_module_namest   rfindR   t   ImportErrort   formatt   impt   find_moduleR   t   PKG_DIRECTORYt	   PY_SOURCEt   closet   tokenizet   generate_tokenst   readlineR   t   nextR    R   R   R   R   t   appendt   Truet   joint   splitt   lenR   t   _getnamelistt   _getnamet   StopIteration(&   R   R   t	   inpackaget
   fullmodulet   dictt   it   packaget	   submodulet   parentt   ft   fnamet   _st   _mt   tyt   stackt   gt	   tokentypet   tokent   startt   _endt   _lineR   t
   thisindentt	   meth_namet	   cur_classt
   class_namet   inheritt   namest   levelR   t   nt   ct   mt   dt   modulest   modt   _mod2t   n2(    (    s   /usr/lib/python2.7/pyclbr.pyR   a   s   	

'+*

		


	
	'
c         C   s¨   g  } xü t  rß t |  É \ } } | s+ Pn  | d k rL t |  É \ } } n d  } | j | | f É x, | d k rì d | k rì |  j É  d } qh W| d k r	 Pq	 q	 W| S(   Nt   asR"   s   
i   (   R8   R=   R
   R7   R6   (   RL   RW   R	   RN   t   name2(    (    s   /usr/lib/python2.7/pyclbr.pyR<     s    	c         C   sÕ   g  } |  j  É  d d !\ } } | t k rA | d k rA d  | f S| j | É xi t rπ |  j  É  d d !\ } } | d k rÄ Pn  |  j  É  d d !\ } } | t k r© Pn  | j | É qQ Wd j | É | f S(   Ni    i   R&   R   (   R6   R    R
   R7   R8   R9   (   RL   t   partsRM   RN   (    (    s   /usr/lib/python2.7/pyclbr.pyR=   +  s    
	c    	      C   sb  d d  l  }  t j d } |  j j | É rw |  j j | É g } |  j j | É } | j É  j d É r} | d  } q} n g  } t	 | | É } | j
 É  } | j d Ñ  É x≥ | D]´ } t | t É r5d G| j G| j G| j GHt | j j É  d t d É É} xX | D]( \ } } | d k rd	 G| G| GHqqWqØ t | t É rØ d
 G| j G| j GHqØ qØ Wd  S(   Niˇˇˇˇi   s   .pyi˝ˇˇˇc         S   s%   t  t |  d d É t | d d É É S(   NR   i    (   t   cmpt   getattr(   t   at   b(    (    s   /usr/lib/python2.7/pyclbr.pyt   <lambda>K  s   R   R   R   s     defR   (   t   osR)   t   argvR   t   existst   dirnamet   basenamet   lowert   endswithR   t   valuest   sortR   R   R	   R   R   t   sortedR   t	   iteritemsR   R   (	   Ri   R^   R   RA   t   objst   objR   R	   R   (    (    s   /usr/lib/python2.7/pyclbr.pyt   _main>  s(    !t   __main__(    (    (   R   R)   R.   R3   RN   R    R   R   t   operatorR   t   __all__R(   R   R   R
   R   R   R   R<   R=   Rv   R   (    (    (    s   /usr/lib/python2.7/pyclbr.pyt   <module>(   s"   	∂			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #! /usr/bin/python2.7
# -*- coding: latin-1 -*-
"""Generate Python documentation in HTML or text for interactive use.

In the Python interpreter, do "from pydoc import help" to provide online
help.  Calling help(thing) on a Python object documents the object.

Or, at the shell command line outside of Python:

Run "pydoc <name>" to show documentation on something.  <name> may be
the name of a function, module, package, or a dotted reference to a
class or function within a module or module in a package.  If the
argument contains a path segment delimiter (e.g. slash on Unix,
backslash on Windows) it is treated as the path to a Python source file.

Run "pydoc -k <keyword>" to search for a keyword in the synopsis lines
of all available modules.

Run "pydoc -p <port>" to start an HTTP server on a given port on the
local machine to generate documentation web pages.  Port number 0 can be
used to get an arbitrary unused port.

For platforms without a command line, "pydoc -g" starts the HTTP server
and also pops up a little window for controlling it.

Run "pydoc -w <name>" to write out the HTML documentation for a module
to a file named "<name>.html".

Module docs for core modules are assumed to be in

    https://docs.python.org/library/

This can be overridden by setting the PYTHONDOCS environment variable
to a different URL or to a local directory containing the Library
Reference Manual pages.
"""

__author__ = "Ka-Ping Yee <ping@lfw.org>"
__date__ = "26 February 2001"

__version__ = "$Revision: 88564 $"
__credits__ = """Guido van Rossum, for an excellent programming language.
Tommy Burnette, the original creator of manpy.
Paul Prescod, for all his work on onlinehelp.
Richard Chamberlain, for the first implementation of textdoc.
"""

# Known bugs that can't be fixed here:
#   - imp.load_module() cannot be prevented from clobbering existing
#     loaded modules, so calling synopsis() on a binary module file
#     changes the contents of any existing module with the same name.
#   - If the __file__ attribute on a module is a relative path and
#     the current directory is changed with os.chdir(), an incorrect
#     path will be displayed.

import sys, imp, os, re, types, inspect, __builtin__, pkgutil, warnings
from repr import Repr
from string import expandtabs, find, join, lower, split, strip, rfind, rstrip
from traceback import extract_tb
try:
    from collections import deque
except ImportError:
    # Python 2.3 compatibility
    class deque(list):
        def popleft(self):
            return self.pop(0)

# --------------------------------------------------------- common routines

def pathdirs():
    """Convert sys.path into a list of absolute, existing, unique paths."""
    dirs = []
    normdirs = []
    for dir in sys.path:
        dir = os.path.abspath(dir or '.')
        normdir = os.path.normcase(dir)
        if normdir not in normdirs and os.path.isdir(dir):
            dirs.append(dir)
            normdirs.append(normdir)
    return dirs

def getdoc(object):
    """Get the doc string or comments for an object."""
    result = inspect.getdoc(object) or inspect.getcomments(object)
    result = _encode(result)
    return result and re.sub('^ *\n', '', rstrip(result)) or ''

def splitdoc(doc):
    """Split a doc string into a synopsis line (if any) and the rest."""
    lines = split(strip(doc), '\n')
    if len(lines) == 1:
        return lines[0], ''
    elif len(lines) >= 2 and not rstrip(lines[1]):
        return lines[0], join(lines[2:], '\n')
    return '', join(lines, '\n')

def classname(object, modname):
    """Get a class name and qualify it with a module name if necessary."""
    name = object.__name__
    if object.__module__ != modname:
        name = object.__module__ + '.' + name
    return name

def isdata(object):
    """Check if an object is of a type that probably means it's data."""
    return not (inspect.ismodule(object) or inspect.isclass(object) or
                inspect.isroutine(object) or inspect.isframe(object) or
                inspect.istraceback(object) or inspect.iscode(object))

def replace(text, *pairs):
    """Do a series of global replacements on a string."""
    while pairs:
        text = join(split(text, pairs[0]), pairs[1])
        pairs = pairs[2:]
    return text

def cram(text, maxlen):
    """Omit part of a string if needed to make it fit in a maximum length."""
    if len(text) > maxlen:
        pre = max(0, (maxlen-3)//2)
        post = max(0, maxlen-3-pre)
        return text[:pre] + '...' + text[len(text)-post:]
    return text

_re_stripid = re.compile(r' at 0x[0-9a-f]{6,16}(>+)$', re.IGNORECASE)
def stripid(text):
    """Remove the hexadecimal id from a Python object representation."""
    # The behaviour of %p is implementation-dependent in terms of case.
    return _re_stripid.sub(r'\1', text)

def _is_some_method(obj):
    return inspect.ismethod(obj) or inspect.ismethoddescriptor(obj)

def allmethods(cl):
    methods = {}
    for key, value in inspect.getmembers(cl, _is_some_method):
        methods[key] = 1
    for base in cl.__bases__:
        methods.update(allmethods(base)) # all your base are belong to us
    for key in methods.keys():
        methods[key] = getattr(cl, key)
    return methods

def _split_list(s, predicate):
    """Split sequence s via predicate, and return pair ([true], [false]).

    The return value is a 2-tuple of lists,
        ([x for x in s if predicate(x)],
         [x for x in s if not predicate(x)])
    """

    yes = []
    no = []
    for x in s:
        if predicate(x):
            yes.append(x)
        else:
            no.append(x)
    return yes, no

def visiblename(name, all=None, obj=None):
    """Decide whether to show documentation on a variable."""
    # Certain special names are redundant.
    _hidden_names = ('__builtins__', '__doc__', '__file__', '__path__',
                     '__module__', '__name__', '__slots__', '__package__')
    if name in _hidden_names: return 0
    # Private names are hidden, but special names are displayed.
    if name.startswith('__') and name.endswith('__'): return 1
    # Namedtuples have public fields and methods with a single leading underscore
    if name.startswith('_') and hasattr(obj, '_fields'):
        return 1
    if all is not None:
        # only document that which the programmer exported in __all__
        return name in all
    else:
        return not name.startswith('_')

def classify_class_attrs(object):
    """Wrap inspect.classify_class_attrs, with fixup for data descriptors."""
    def fixup(data):
        name, kind, cls, value = data
        if inspect.isdatadescriptor(value):
            kind = 'data descriptor'
        return name, kind, cls, value
    return map(fixup, inspect.classify_class_attrs(object))

# ----------------------------------------------------- Unicode support helpers

try:
    _unicode = unicode
except NameError:
    # If Python is built without Unicode support, the unicode type
    # will not exist. Fake one that nothing will match, and make
    # the _encode function that do nothing.
    class _unicode(object):
        pass
    _encoding = 'ascii'
    def _encode(text, encoding='ascii'):
        return text
else:
    import locale
    _encoding = locale.getpreferredencoding()

    def _encode(text, encoding=None):
        if isinstance(text, unicode):
            return text.encode(encoding or _encoding, 'xmlcharrefreplace')
        else:
            return text

def _binstr(obj):
    # Ensure that we have an encoded (binary) string representation of obj,
    # even if it is a unicode string.
    if isinstance(obj, _unicode):
        return obj.encode(_encoding, 'xmlcharrefreplace')
    return str(obj)

# ----------------------------------------------------- module manipulation

def ispackage(path):
    """Guess whether a path refers to a package directory."""
    if os.path.isdir(path):
        for ext in ('.py', '.pyc', '.pyo'):
            if os.path.isfile(os.path.join(path, '__init__' + ext)):
                return True
    return False

def source_synopsis(file):
    line = file.readline()
    while line[:1] == '#' or not strip(line):
        line = file.readline()
        if not line: break
    line = strip(line)
    if line[:4] == 'r"""': line = line[1:]
    if line[:3] == '"""':
        line = line[3:]
        if line[-1:] == '\\': line = line[:-1]
        while not strip(line):
            line = file.readline()
            if not line: break
        result = strip(split(line, '"""')[0])
    else: result = None
    return result

def synopsis(filename, cache={}):
    """Get the one-line summary out of a module file."""
    mtime = os.stat(filename).st_mtime
    lastupdate, result = cache.get(filename, (None, None))
    if lastupdate is None or lastupdate < mtime:
        info = inspect.getmoduleinfo(filename)
        try:
            file = open(filename)
        except IOError:
            # module can't be opened, so skip it
            return None
        if info and 'b' in info[2]: # binary modules have to be imported
            try: module = imp.load_module('__temp__', file, filename, info[1:])
            except: return None
            result = module.__doc__.splitlines()[0] if module.__doc__ else None
            del sys.modules['__temp__']
        else: # text modules can be directly examined
            result = source_synopsis(file)
            file.close()
        cache[filename] = (mtime, result)
    return result

class ErrorDuringImport(Exception):
    """Errors that occurred while trying to import something to document it."""
    def __init__(self, filename, exc_info):
        exc, value, tb = exc_info
        self.filename = filename
        self.exc = exc
        self.value = value
        self.tb = tb

    def __str__(self):
        exc = self.exc
        if type(exc) is types.ClassType:
            exc = exc.__name__
        return 'problem in %s - %s: %s' % (self.filename, exc, self.value)

def importfile(path):
    """Import a Python source file or compiled file given its path."""
    magic = imp.get_magic()
    file = open(path, 'r')
    if file.read(len(magic)) == magic:
        kind = imp.PY_COMPILED
    else:
        kind = imp.PY_SOURCE
    file.close()
    filename = os.path.basename(path)
    name, ext = os.path.splitext(filename)
    file = open(path, 'r')
    try:
        module = imp.load_module(name, file, path, (ext, 'r', kind))
    except:
        raise ErrorDuringImport(path, sys.exc_info())
    file.close()
    return module

def safeimport(path, forceload=0, cache={}):
    """Import a module; handle errors; return None if the module isn't found.

    If the module *is* found but an exception occurs, it's wrapped in an
    ErrorDuringImport exception and reraised.  Unlike __import__, if a
    package path is specified, the module at the end of the path is returned,
    not the package at the beginning.  If the optional 'forceload' argument
    is 1, we reload the module from disk (unless it's a dynamic extension)."""
    try:
        # If forceload is 1 and the module has been previously loaded from
        # disk, we always have to reload the module.  Checking the file's
        # mtime isn't good enough (e.g. the module could contain a class
        # that inherits from another module that has changed).
        if forceload and path in sys.modules:
            if path not in sys.builtin_module_names:
                # Avoid simply calling reload() because it leaves names in
                # the currently loaded module lying around if they're not
                # defined in the new source file.  Instead, remove the
                # module from sys.modules and re-import.  Also remove any
                # submodules because they won't appear in the newly loaded
                # module's namespace if they're already in sys.modules.
                subs = [m for m in sys.modules if m.startswith(path + '.')]
                for key in [path] + subs:
                    # Prevent garbage collection.
                    cache[key] = sys.modules[key]
                    del sys.modules[key]
        module = __import__(path)
    except:
        # Did the error occur before or after the module was found?
        (exc, value, tb) = info = sys.exc_info()
        if path in sys.modules:
            # An error occurred while executing the imported module.
            raise ErrorDuringImport(sys.modules[path].__file__, info)
        elif exc is SyntaxError:
            # A SyntaxError occurred before we could execute the module.
            raise ErrorDuringImport(value.filename, info)
        elif exc is ImportError and extract_tb(tb)[-1][2]=='safeimport':
            # The import error occurred directly in this function,
            # which means there is no such module in the path.
            return None
        else:
            # Some other error occurred during the importing process.
            raise ErrorDuringImport(path, sys.exc_info())
    for part in split(path, '.')[1:]:
        try: module = getattr(module, part)
        except AttributeError: return None
    return module

# ---------------------------------------------------- formatter base class

class Doc:
    def document(self, object, name=None, *args):
        """Generate documentation for an object."""
        args = (object, name) + args
        # 'try' clause is to attempt to handle the possibility that inspect
        # identifies something in a way that pydoc itself has issues handling;
        # think 'super' and how it is a descriptor (which raises the exception
        # by lacking a __name__ attribute) and an instance.
        if inspect.isgetsetdescriptor(object): return self.docdata(*args)
        if inspect.ismemberdescriptor(object): return self.docdata(*args)
        try:
            if inspect.ismodule(object): return self.docmodule(*args)
            if inspect.isclass(object): return self.docclass(*args)
            if inspect.isroutine(object): return self.docroutine(*args)
        except AttributeError:
            pass
        if isinstance(object, property): return self.docproperty(*args)
        return self.docother(*args)

    def fail(self, object, name=None, *args):
        """Raise an exception for unimplemented types."""
        message = "don't know how to document object%s of type %s" % (
            name and ' ' + repr(name), type(object).__name__)
        raise TypeError, message

    docmodule = docclass = docroutine = docother = docproperty = docdata = fail

    def getdocloc(self, object,
                  basedir=os.path.join(sys.exec_prefix, "lib",
                                       "python"+sys.version[0:3])):
        """Return the location of module docs or None"""

        try:
            file = inspect.getabsfile(object)
        except TypeError:
            file = '(built-in)'

        docloc = os.environ.get("PYTHONDOCS",
                                "https://docs.python.org/library")
        basedir = os.path.normcase(basedir)
        if (isinstance(object, type(os)) and
            (object.__name__ in ('errno', 'exceptions', 'gc', 'imp',
                                 'marshal', 'posix', 'signal', 'sys',
                                 'thread', 'zipimport') or
             (file.startswith(basedir) and
              not file.startswith(os.path.join(basedir, 'dist-packages')) and
              not file.startswith(os.path.join(basedir, 'site-packages')))) and
            object.__name__ not in ('xml.etree', 'test.pydoc_mod')):
            if docloc.startswith(("http://", "https://")):
                docloc = "%s/%s" % (docloc.rstrip("/"), object.__name__.lower())
            else:
                docloc = os.path.join(docloc, object.__name__.lower() + ".html")
        else:
            docloc = None
        return docloc

# -------------------------------------------- HTML documentation generator

class HTMLRepr(Repr):
    """Class for safely making an HTML representation of a Python object."""
    def __init__(self):
        Repr.__init__(self)
        self.maxlist = self.maxtuple = 20
        self.maxdict = 10
        self.maxstring = self.maxother = 100

    def escape(self, text):
        return replace(text, '&', '&amp;', '<', '&lt;', '>', '&gt;')

    def repr(self, object):
        return Repr.repr(self, object)

    def repr1(self, x, level):
        if hasattr(type(x), '__name__'):
            methodname = 'repr_' + join(split(type(x).__name__), '_')
            if hasattr(self, methodname):
                return getattr(self, methodname)(x, level)
        return self.escape(cram(stripid(repr(x)), self.maxother))

    def repr_string(self, x, level):
        test = cram(x, self.maxstring)
        testrepr = repr(test)
        if '\\' in test and '\\' not in replace(testrepr, r'\\', ''):
            # Backslashes are only literal in the string and are never
            # needed to make any special characters, so show a raw string.
            return 'r' + testrepr[0] + self.escape(test) + testrepr[0]
        return re.sub(r'((\\[\\abfnrtv\'"]|\\[0-9]..|\\x..|\\u....)+)',
                      r'<font color="#c040c0">\1</font>',
                      self.escape(testrepr))

    repr_str = repr_string

    def repr_instance(self, x, level):
        try:
            return self.escape(cram(stripid(repr(x)), self.maxstring))
        except:
            return self.escape('<%s instance>' % x.__class__.__name__)

    repr_unicode = repr_string

class HTMLDoc(Doc):
    """Formatter class for HTML documentation."""

    # ------------------------------------------- HTML formatting utilities

    _repr_instance = HTMLRepr()
    repr = _repr_instance.repr
    escape = _repr_instance.escape

    def page(self, title, contents):
        """Format an HTML page."""
        return _encode('''
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: %s</title>
<meta charset="utf-8">
</head><body bgcolor="#f0f0f8">
%s
</body></html>''' % (title, contents), 'ascii')

    def heading(self, title, fgcol, bgcol, extras=''):
        """Format a page heading."""
        return '''
<table width="100%%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="%s">
<td valign=bottom>&nbsp;<br>
<font color="%s" face="helvetica, arial">&nbsp;<br>%s</font></td
><td align=right valign=bottom
><font color="%s" face="helvetica, arial">%s</font></td></tr></table>
    ''' % (bgcol, fgcol, title, fgcol, extras or '&nbsp;')

    def section(self, title, fgcol, bgcol, contents, width=6,
                prelude='', marginalia=None, gap='&nbsp;'):
        """Format a section with a heading."""
        if marginalia is None:
            marginalia = '<tt>' + '&nbsp;' * width + '</tt>'
        result = '''<p>
<table width="100%%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="%s">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="%s" face="helvetica, arial">%s</font></td></tr>
    ''' % (bgcol, fgcol, title)
        if prelude:
            result = result + '''
<tr bgcolor="%s"><td rowspan=2>%s</td>
<td colspan=2>%s</td></tr>
<tr><td>%s</td>''' % (bgcol, marginalia, prelude, gap)
        else:
            result = result + '''
<tr><td bgcolor="%s">%s</td><td>%s</td>''' % (bgcol, marginalia, gap)

        return result + '\n<td width="100%%">%s</td></tr></table>' % contents

    def bigsection(self, title, *args):
        """Format a section with a big heading."""
        title = '<big><strong>%s</strong></big>' % title
        return self.section(title, *args)

    def preformat(self, text):
        """Format literal preformatted text."""
        text = self.escape(expandtabs(text))
        return replace(text, '\n\n', '\n \n', '\n\n', '\n \n',
                             ' ', '&nbsp;', '\n', '<br>\n')

    def multicolumn(self, list, format, cols=4):
        """Format a list of items into a multi-column list."""
        result = ''
        rows = (len(list)+cols-1)//cols
        for col in range(cols):
            result = result + '<td width="%d%%" valign=top>' % (100//cols)
            for i in range(rows*col, rows*col+rows):
                if i < len(list):
                    result = result + format(list[i]) + '<br>\n'
            result = result + '</td>'
        return '<table width="100%%" summary="list"><tr>%s</tr></table>' % result

    def grey(self, text): return '<font color="#909090">%s</font>' % text

    def namelink(self, name, *dicts):
        """Make a link for an identifier, given name-to-URL mappings."""
        for dict in dicts:
            if name in dict:
                return '<a href="%s">%s</a>' % (dict[name], name)
        return name

    def classlink(self, object, modname):
        """Make a link for a class."""
        name, module = object.__name__, sys.modules.get(object.__module__)
        if hasattr(module, name) and getattr(module, name) is object:
            return '<a href="%s.html#%s">%s</a>' % (
                module.__name__, name, classname(object, modname))
        return classname(object, modname)

    def modulelink(self, object):
        """Make a link for a module."""
        return '<a href="%s.html">%s</a>' % (object.__name__, object.__name__)

    def modpkglink(self, data):
        """Make a link for a module or package to display in an index."""
        name, path, ispackage, shadowed = data
        if shadowed:
            return self.grey(name)
        if path:
            url = '%s.%s.html' % (path, name)
        else:
            url = '%s.html' % name
        if ispackage:
            text = '<strong>%s</strong>&nbsp;(package)' % name
        else:
            text = name
        return '<a href="%s">%s</a>' % (url, text)

    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):
        """Mark up some plain text, given a context of symbols to look for.
        Each context dictionary maps object names to anchor names."""
        escape = escape or self.escape
        results = []
        here = 0
        pattern = re.compile(r'\b((http|ftp)://\S+[\w/]|'
                                r'RFC[- ]?(\d+)|'
                                r'PEP[- ]?(\d+)|'
                                r'(self\.)?(\w+))')
        while True:
            match = pattern.search(text, here)
            if not match: break
            start, end = match.span()
            results.append(escape(text[here:start]))

            all, scheme, rfc, pep, selfdot, name = match.groups()
            if scheme:
                url = escape(all).replace('"', '&quot;')
                results.append('<a href="%s">%s</a>' % (url, url))
            elif rfc:
                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)
                results.append('<a href="%s">%s</a>' % (url, escape(all)))
            elif pep:
                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)
                results.append('<a href="%s">%s</a>' % (url, escape(all)))
            elif selfdot:
                # Create a link for methods like 'self.method(...)'
                # and use <strong> for attributes like 'self.attr'
                if text[end:end+1] == '(':
                    results.append('self.' + self.namelink(name, methods))
                else:
                    results.append('self.<strong>%s</strong>' % name)
            elif text[end:end+1] == '(':
                results.append(self.namelink(name, methods, funcs, classes))
            else:
                results.append(self.namelink(name, classes))
            here = end
        results.append(escape(text[here:]))
        return join(results, '')

    # ---------------------------------------------- type-specific routines

    def formattree(self, tree, modname, parent=None):
        """Produce HTML for a class tree as given by inspect.getclasstree()."""
        result = ''
        for entry in tree:
            if type(entry) is type(()):
                c, bases = entry
                result = result + '<dt><font face="helvetica, arial">'
                result = result + self.classlink(c, modname)
                if bases and bases != (parent,):
                    parents = []
                    for base in bases:
                        parents.append(self.classlink(base, modname))
                    result = result + '(' + join(parents, ', ') + ')'
                result = result + '\n</font></dt>'
            elif type(entry) is type([]):
                result = result + '<dd>\n%s</dd>\n' % self.formattree(
                    entry, modname, c)
        return '<dl>\n%s</dl>\n' % result

    def docmodule(self, object, name=None, mod=None, *ignored):
        """Produce HTML documentation for a module object."""
        name = object.__name__ # ignore the passed-in name
        try:
            all = object.__all__
        except AttributeError:
            all = None
        parts = split(name, '.')
        links = []
        for i in range(len(parts)-1):
            links.append(
                '<a href="%s.html"><font color="#ffffff">%s</font></a>' %
                (join(parts[:i+1], '.'), parts[i]))
        linkedname = join(links + parts[-1:], '.')
        head = '<big><big><strong>%s</strong></big></big>' % linkedname
        try:
            path = inspect.getabsfile(object)
            url = path
            if sys.platform == 'win32':
                import nturl2path
                url = nturl2path.pathname2url(path)
            filelink = '<a href="file:%s">%s</a>' % (url, path)
        except TypeError:
            filelink = '(built-in)'
        info = []
        if hasattr(object, '__version__'):
            version = _binstr(object.__version__)
            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':
                version = strip(version[11:-1])
            info.append('version %s' % self.escape(version))
        if hasattr(object, '__date__'):
            info.append(self.escape(_binstr(object.__date__)))
        if info:
            head = head + ' (%s)' % join(info, ', ')
        docloc = self.getdocloc(object)
        if docloc is not None:
            docloc = '<br><a href="%(docloc)s">Module Docs</a>' % locals()
        else:
            docloc = ''
        result = self.heading(
            head, '#ffffff', '#7799ee',
            '<a href=".">index</a><br>' + filelink + docloc)

        modules = inspect.getmembers(object, inspect.ismodule)

        classes, cdict = [], {}
        for key, value in inspect.getmembers(object, inspect.isclass):
            # if __all__ exists, believe it.  Otherwise use old heuristic.
            if (all is not None or
                (inspect.getmodule(value) or object) is object):
                if visiblename(key, all, object):
                    classes.append((key, value))
                    cdict[key] = cdict[value] = '#' + key
        for key, value in classes:
            for base in value.__bases__:
                key, modname = base.__name__, base.__module__
                module = sys.modules.get(modname)
                if modname != name and module and hasattr(module, key):
                    if getattr(module, key) is base:
                        if not key in cdict:
                            cdict[key] = cdict[base] = modname + '.html#' + key
        funcs, fdict = [], {}
        for key, value in inspect.getmembers(object, inspect.isroutine):
            # if __all__ exists, believe it.  Otherwise use old heuristic.
            if (all is not None or
                inspect.isbuiltin(value) or inspect.getmodule(value) is object):
                if visiblename(key, all, object):
                    funcs.append((key, value))
                    fdict[key] = '#-' + key
                    if inspect.isfunction(value): fdict[value] = fdict[key]
        data = []
        for key, value in inspect.getmembers(object, isdata):
            if visiblename(key, all, object):
                data.append((key, value))

        doc = self.markup(getdoc(object), self.preformat, fdict, cdict)
        doc = doc and '<tt>%s</tt>' % doc
        result = result + '<p>%s</p>\n' % doc

        if hasattr(object, '__path__'):
            modpkgs = []
            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):
                modpkgs.append((modname, name, ispkg, 0))
            modpkgs.sort()
            contents = self.multicolumn(modpkgs, self.modpkglink)
            result = result + self.bigsection(
                'Package Contents', '#ffffff', '#aa55cc', contents)
        elif modules:
            contents = self.multicolumn(
                modules, lambda key_value, s=self: s.modulelink(key_value[1]))
            result = result + self.bigsection(
                'Modules', '#ffffff', '#aa55cc', contents)

        if classes:
            classlist = map(lambda key_value: key_value[1], classes)
            contents = [
                self.formattree(inspect.getclasstree(classlist, 1), name)]
            for key, value in classes:
                contents.append(self.document(value, key, name, fdict, cdict))
            result = result + self.bigsection(
                'Classes', '#ffffff', '#ee77aa', join(contents))
        if funcs:
            contents = []
            for key, value in funcs:
                contents.append(self.document(value, key, name, fdict, cdict))
            result = result + self.bigsection(
                'Functions', '#ffffff', '#eeaa77', join(contents))
        if data:
            contents = []
            for key, value in data:
                contents.append(self.document(value, key))
            result = result + self.bigsection(
                'Data', '#ffffff', '#55aa55', join(contents, '<br>\n'))
        if hasattr(object, '__author__'):
            contents = self.markup(_binstr(object.__author__), self.preformat)
            result = result + self.bigsection(
                'Author', '#ffffff', '#7799ee', contents)
        if hasattr(object, '__credits__'):
            contents = self.markup(_binstr(object.__credits__), self.preformat)
            result = result + self.bigsection(
                'Credits', '#ffffff', '#7799ee', contents)

        return result

    def docclass(self, object, name=None, mod=None, funcs={}, classes={},
                 *ignored):
        """Produce HTML documentation for a class object."""
        realname = object.__name__
        name = name or realname
        bases = object.__bases__

        contents = []
        push = contents.append

        # Cute little class to pump out a horizontal rule between sections.
        class HorizontalRule:
            def __init__(self):
                self.needone = 0
            def maybe(self):
                if self.needone:
                    push('<hr>\n')
                self.needone = 1
        hr = HorizontalRule()

        # List the mro, if non-trivial.
        mro = deque(inspect.getmro(object))
        if len(mro) > 2:
            hr.maybe()
            push('<dl><dt>Method resolution order:</dt>\n')
            for base in mro:
                push('<dd>%s</dd>\n' % self.classlink(base,
                                                      object.__module__))
            push('</dl>\n')

        def spill(msg, attrs, predicate):
            ok, attrs = _split_list(attrs, predicate)
            if ok:
                hr.maybe()
                push(msg)
                for name, kind, homecls, value in ok:
                    try:
                        value = getattr(object, name)
                    except Exception:
                        # Some descriptors may meet a failure in their __get__.
                        # (bug #1785)
                        push(self._docdescriptor(name, value, mod))
                    else:
                        push(self.document(value, name, mod,
                                        funcs, classes, mdict, object))
                    push('\n')
            return attrs

        def spilldescriptors(msg, attrs, predicate):
            ok, attrs = _split_list(attrs, predicate)
            if ok:
                hr.maybe()
                push(msg)
                for name, kind, homecls, value in ok:
                    push(self._docdescriptor(name, value, mod))
            return attrs

        def spilldata(msg, attrs, predicate):
            ok, attrs = _split_list(attrs, predicate)
            if ok:
                hr.maybe()
                push(msg)
                for name, kind, homecls, value in ok:
                    base = self.docother(getattr(object, name), name, mod)
                    if (hasattr(value, '__call__') or
                            inspect.isdatadescriptor(value)):
                        doc = getattr(value, "__doc__", None)
                    else:
                        doc = None
                    if doc is None:
                        push('<dl><dt>%s</dl>\n' % base)
                    else:
                        doc = self.markup(getdoc(value), self.preformat,
                                          funcs, classes, mdict)
                        doc = '<dd><tt>%s</tt>' % doc
                        push('<dl><dt>%s%s</dl>\n' % (base, doc))
                    push('\n')
            return attrs

        attrs = filter(lambda data: visiblename(data[0], obj=object),
                       classify_class_attrs(object))
        mdict = {}
        for key, kind, homecls, value in attrs:
            mdict[key] = anchor = '#' + name + '-' + key
            try:
                value = getattr(object, name)
            except Exception:
                # Some descriptors may meet a failure in their __get__.
                # (bug #1785)
                pass
            try:
                # The value may not be hashable (e.g., a data attr with
                # a dict or list value).
                mdict[value] = anchor
            except TypeError:
                pass

        while attrs:
            if mro:
                thisclass = mro.popleft()
            else:
                thisclass = attrs[0][2]
            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)

            if thisclass is __builtin__.object:
                attrs = inherited
                continue
            elif thisclass is object:
                tag = 'defined here'
            else:
                tag = 'inherited from %s' % self.classlink(thisclass,
                                                           object.__module__)
            tag += ':<br>\n'

            # Sort attrs by name.
            try:
                attrs.sort(key=lambda t: t[0])
            except TypeError:
                attrs.sort(lambda t1, t2: cmp(t1[0], t2[0]))    # 2.3 compat

            # Pump out the attrs, segregated by kind.
            attrs = spill('Methods %s' % tag, attrs,
                          lambda t: t[1] == 'method')
            attrs = spill('Class methods %s' % tag, attrs,
                          lambda t: t[1] == 'class method')
            attrs = spill('Static methods %s' % tag, attrs,
                          lambda t: t[1] == 'static method')
            attrs = spilldescriptors('Data descriptors %s' % tag, attrs,
                                     lambda t: t[1] == 'data descriptor')
            attrs = spilldata('Data and other attributes %s' % tag, attrs,
                              lambda t: t[1] == 'data')
            assert attrs == []
            attrs = inherited

        contents = ''.join(contents)

        if name == realname:
            title = '<a name="%s">class <strong>%s</strong></a>' % (
                name, realname)
        else:
            title = '<strong>%s</strong> = <a name="%s">class %s</a>' % (
                name, name, realname)
        if bases:
            parents = []
            for base in bases:
                parents.append(self.classlink(base, object.__module__))
            title = title + '(%s)' % join(parents, ', ')
        doc = self.markup(getdoc(object), self.preformat, funcs, classes, mdict)
        doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc

        return self.section(title, '#000000', '#ffc8d8', contents, 3, doc)

    def formatvalue(self, object):
        """Format an argument default value as text."""
        return self.grey('=' + self.repr(object))

    def docroutine(self, object, name=None, mod=None,
                   funcs={}, classes={}, methods={}, cl=None):
        """Produce HTML documentation for a function or method object."""
        realname = object.__name__
        name = name or realname
        anchor = (cl and cl.__name__ or '') + '-' + name
        note = ''
        skipdocs = 0
        if inspect.ismethod(object):
            imclass = object.im_class
            if cl:
                if imclass is not cl:
                    note = ' from ' + self.classlink(imclass, mod)
            else:
                if object.im_self is not None:
                    note = ' method of %s instance' % self.classlink(
                        object.im_self.__class__, mod)
                else:
                    note = ' unbound %s method' % self.classlink(imclass,mod)
            object = object.im_func

        if name == realname:
            title = '<a name="%s"><strong>%s</strong></a>' % (anchor, realname)
        else:
            if (cl and realname in cl.__dict__ and
                cl.__dict__[realname] is object):
                reallink = '<a href="#%s">%s</a>' % (
                    cl.__name__ + '-' + realname, realname)
                skipdocs = 1
            else:
                reallink = realname
            title = '<a name="%s"><strong>%s</strong></a> = %s' % (
                anchor, name, reallink)
        if inspect.isfunction(object):
            args, varargs, varkw, defaults = inspect.getargspec(object)
            argspec = inspect.formatargspec(
                args, varargs, varkw, defaults, formatvalue=self.formatvalue)
            if realname == '<lambda>':
                title = '<strong>%s</strong> <em>lambda</em> ' % name
                argspec = argspec[1:-1] # remove parentheses
        else:
            argspec = '(...)'

        decl = title + argspec + (note and self.grey(
               '<font face="helvetica, arial">%s</font>' % note))

        if skipdocs:
            return '<dl><dt>%s</dt></dl>\n' % decl
        else:
            doc = self.markup(
                getdoc(object), self.preformat, funcs, classes, methods)
            doc = doc and '<dd><tt>%s</tt></dd>' % doc
            return '<dl><dt>%s</dt>%s</dl>\n' % (decl, doc)

    def _docdescriptor(self, name, value, mod):
        results = []
        push = results.append

        if name:
            push('<dl><dt><strong>%s</strong></dt>\n' % name)
        if value.__doc__ is not None:
            doc = self.markup(getdoc(value), self.preformat)
            push('<dd><tt>%s</tt></dd>\n' % doc)
        push('</dl>\n')

        return ''.join(results)

    def docproperty(self, object, name=None, mod=None, cl=None):
        """Produce html documentation for a property."""
        return self._docdescriptor(name, object, mod)

    def docother(self, object, name=None, mod=None, *ignored):
        """Produce HTML documentation for a data object."""
        lhs = name and '<strong>%s</strong> = ' % name or ''
        return lhs + self.repr(object)

    def docdata(self, object, name=None, mod=None, cl=None):
        """Produce html documentation for a data descriptor."""
        return self._docdescriptor(name, object, mod)

    def index(self, dir, shadowed=None):
        """Generate an HTML index for a directory of modules."""
        modpkgs = []
        if shadowed is None: shadowed = {}
        for importer, name, ispkg in pkgutil.iter_modules([dir]):
            modpkgs.append((name, '', ispkg, name in shadowed))
            shadowed[name] = 1

        modpkgs.sort()
        contents = self.multicolumn(modpkgs, self.modpkglink)
        return self.bigsection(dir, '#ffffff', '#ee77aa', contents)

# -------------------------------------------- text documentation generator

class TextRepr(Repr):
    """Class for safely making a text representation of a Python object."""
    def __init__(self):
        Repr.__init__(self)
        self.maxlist = self.maxtuple = 20
        self.maxdict = 10
        self.maxstring = self.maxother = 100

    def repr1(self, x, level):
        if hasattr(type(x), '__name__'):
            methodname = 'repr_' + join(split(type(x).__name__), '_')
            if hasattr(self, methodname):
                return getattr(self, methodname)(x, level)
        return cram(stripid(repr(x)), self.maxother)

    def repr_string(self, x, level):
        test = cram(x, self.maxstring)
        testrepr = repr(test)
        if '\\' in test and '\\' not in replace(testrepr, r'\\', ''):
            # Backslashes are only literal in the string and are never
            # needed to make any special characters, so show a raw string.
            return 'r' + testrepr[0] + test + testrepr[0]
        return testrepr

    repr_str = repr_string

    def repr_instance(self, x, level):
        try:
            return cram(stripid(repr(x)), self.maxstring)
        except:
            return '<%s instance>' % x.__class__.__name__

class TextDoc(Doc):
    """Formatter class for text documentation."""

    # ------------------------------------------- text formatting utilities

    _repr_instance = TextRepr()
    repr = _repr_instance.repr

    def bold(self, text):
        """Format a string in bold by overstriking."""
        return join(map(lambda ch: ch + '\b' + ch, text), '')

    def indent(self, text, prefix='    '):
        """Indent text by prepending a given prefix to each line."""
        if not text: return ''
        lines = split(text, '\n')
        lines = map(lambda line, prefix=prefix: prefix + line, lines)
        if lines: lines[-1] = rstrip(lines[-1])
        return join(lines, '\n')

    def section(self, title, contents):
        """Format a section with a given heading."""
        return self.bold(title) + '\n' + rstrip(self.indent(contents)) + '\n\n'

    # ---------------------------------------------- type-specific routines

    def formattree(self, tree, modname, parent=None, prefix=''):
        """Render in text a class tree as returned by inspect.getclasstree()."""
        result = ''
        for entry in tree:
            if type(entry) is type(()):
                c, bases = entry
                result = result + prefix + classname(c, modname)
                if bases and bases != (parent,):
                    parents = map(lambda c, m=modname: classname(c, m), bases)
                    result = result + '(%s)' % join(parents, ', ')
                result = result + '\n'
            elif type(entry) is type([]):
                result = result + self.formattree(
                    entry, modname, c, prefix + '    ')
        return result

    def docmodule(self, object, name=None, mod=None):
        """Produce text documentation for a given module object."""
        name = object.__name__ # ignore the passed-in name
        synop, desc = splitdoc(getdoc(object))
        result = self.section('NAME', name + (synop and ' - ' + synop))

        try:
            all = object.__all__
        except AttributeError:
            all = None

        try:
            file = inspect.getabsfile(object)
        except TypeError:
            file = '(built-in)'
        result = result + self.section('FILE', file)

        docloc = self.getdocloc(object)
        if docloc is not None:
            result = result + self.section('MODULE DOCS', docloc)

        if desc:
            result = result + self.section('DESCRIPTION', desc)

        classes = []
        for key, value in inspect.getmembers(object, inspect.isclass):
            # if __all__ exists, believe it.  Otherwise use old heuristic.
            if (all is not None
                or (inspect.getmodule(value) or object) is object):
                if visiblename(key, all, object):
                    classes.append((key, value))
        funcs = []
        for key, value in inspect.getmembers(object, inspect.isroutine):
            # if __all__ exists, believe it.  Otherwise use old heuristic.
            if (all is not None or
                inspect.isbuiltin(value) or inspect.getmodule(value) is object):
                if visiblename(key, all, object):
                    funcs.append((key, value))
        data = []
        for key, value in inspect.getmembers(object, isdata):
            if visiblename(key, all, object):
                data.append((key, value))

        modpkgs = []
        modpkgs_names = set()
        if hasattr(object, '__path__'):
            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):
                modpkgs_names.add(modname)
                if ispkg:
                    modpkgs.append(modname + ' (package)')
                else:
                    modpkgs.append(modname)

            modpkgs.sort()
            result = result + self.section(
                'PACKAGE CONTENTS', join(modpkgs, '\n'))

        # Detect submodules as sometimes created by C extensions
        submodules = []
        for key, value in inspect.getmembers(object, inspect.ismodule):
            if value.__name__.startswith(name + '.') and key not in modpkgs_names:
                submodules.append(key)
        if submodules:
            submodules.sort()
            result = result + self.section(
                'SUBMODULES', join(submodules, '\n'))

        if classes:
            classlist = map(lambda key_value: key_value[1], classes)
            contents = [self.formattree(
                inspect.getclasstree(classlist, 1), name)]
            for key, value in classes:
                contents.append(self.document(value, key, name))
            result = result + self.section('CLASSES', join(contents, '\n'))

        if funcs:
            contents = []
            for key, value in funcs:
                contents.append(self.document(value, key, name))
            result = result + self.section('FUNCTIONS', join(contents, '\n'))

        if data:
            contents = []
            for key, value in data:
                contents.append(self.docother(value, key, name, maxlen=70))
            result = result + self.section('DATA', join(contents, '\n'))

        if hasattr(object, '__version__'):
            version = _binstr(object.__version__)
            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':
                version = strip(version[11:-1])
            result = result + self.section('VERSION', version)
        if hasattr(object, '__date__'):
            result = result + self.section('DATE', _binstr(object.__date__))
        if hasattr(object, '__author__'):
            result = result + self.section('AUTHOR', _binstr(object.__author__))
        if hasattr(object, '__credits__'):
            result = result + self.section('CREDITS', _binstr(object.__credits__))
        return result

    def docclass(self, object, name=None, mod=None, *ignored):
        """Produce text documentation for a given class object."""
        realname = object.__name__
        name = name or realname
        bases = object.__bases__

        def makename(c, m=object.__module__):
            return classname(c, m)

        if name == realname:
            title = 'class ' + self.bold(realname)
        else:
            title = self.bold(name) + ' = class ' + realname
        if bases:
            parents = map(makename, bases)
            title = title + '(%s)' % join(parents, ', ')

        doc = getdoc(object)
        contents = doc and [doc + '\n'] or []
        push = contents.append

        # List the mro, if non-trivial.
        mro = deque(inspect.getmro(object))
        if len(mro) > 2:
            push("Method resolution order:")
            for base in mro:
                push('    ' + makename(base))
            push('')

        # Cute little class to pump out a horizontal rule between sections.
        class HorizontalRule:
            def __init__(self):
                self.needone = 0
            def maybe(self):
                if self.needone:
                    push('-' * 70)
                self.needone = 1
        hr = HorizontalRule()

        def spill(msg, attrs, predicate):
            ok, attrs = _split_list(attrs, predicate)
            if ok:
                hr.maybe()
                push(msg)
                for name, kind, homecls, value in ok:
                    try:
                        value = getattr(object, name)
                    except Exception:
                        # Some descriptors may meet a failure in their __get__.
                        # (bug #1785)
                        push(self._docdescriptor(name, value, mod))
                    else:
                        push(self.document(value,
                                        name, mod, object))
            return attrs

        def spilldescriptors(msg, attrs, predicate):
            ok, attrs = _split_list(attrs, predicate)
            if ok:
                hr.maybe()
                push(msg)
                for name, kind, homecls, value in ok:
                    push(self._docdescriptor(name, value, mod))
            return attrs

        def spilldata(msg, attrs, predicate):
            ok, attrs = _split_list(attrs, predicate)
            if ok:
                hr.maybe()
                push(msg)
                for name, kind, homecls, value in ok:
                    if (hasattr(value, '__call__') or
                            inspect.isdatadescriptor(value)):
                        doc = getdoc(value)
                    else:
                        doc = None
                    push(self.docother(getattr(object, name),
                                       name, mod, maxlen=70, doc=doc) + '\n')
            return attrs

        attrs = filter(lambda data: visiblename(data[0], obj=object),
                       classify_class_attrs(object))
        while attrs:
            if mro:
                thisclass = mro.popleft()
            else:
                thisclass = attrs[0][2]
            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)

            if thisclass is __builtin__.object:
                attrs = inherited
                continue
            elif thisclass is object:
                tag = "defined here"
            else:
                tag = "inherited from %s" % classname(thisclass,
                                                      object.__module__)

            # Sort attrs by name.
            attrs.sort()

            # Pump out the attrs, segregated by kind.
            attrs = spill("Methods %s:\n" % tag, attrs,
                          lambda t: t[1] == 'method')
            attrs = spill("Class methods %s:\n" % tag, attrs,
                          lambda t: t[1] == 'class method')
            attrs = spill("Static methods %s:\n" % tag, attrs,
                          lambda t: t[1] == 'static method')
            attrs = spilldescriptors("Data descriptors %s:\n" % tag, attrs,
                                     lambda t: t[1] == 'data descriptor')
            attrs = spilldata("Data and other attributes %s:\n" % tag, attrs,
                              lambda t: t[1] == 'data')
            assert attrs == []
            attrs = inherited

        contents = '\n'.join(contents)
        if not contents:
            return title + '\n'
        return title + '\n' + self.indent(rstrip(contents), ' |  ') + '\n'

    def formatvalue(self, object):
        """Format an argument default value as text."""
        return '=' + self.repr(object)

    def docroutine(self, object, name=None, mod=None, cl=None):
        """Produce text documentation for a function or method object."""
        realname = object.__name__
        name = name or realname
        note = ''
        skipdocs = 0
        if inspect.ismethod(object):
            imclass = object.im_class
            if cl:
                if imclass is not cl:
                    note = ' from ' + classname(imclass, mod)
            else:
                if object.im_self is not None:
                    note = ' method of %s instance' % classname(
                        object.im_self.__class__, mod)
                else:
                    note = ' unbound %s method' % classname(imclass,mod)
            object = object.im_func

        if name == realname:
            title = self.bold(realname)
        else:
            if (cl and realname in cl.__dict__ and
                cl.__dict__[realname] is object):
                skipdocs = 1
            title = self.bold(name) + ' = ' + realname
        if inspect.isfunction(object):
            args, varargs, varkw, defaults = inspect.getargspec(object)
            argspec = inspect.formatargspec(
                args, varargs, varkw, defaults, formatvalue=self.formatvalue)
            if realname == '<lambda>':
                title = self.bold(name) + ' lambda '
                argspec = argspec[1:-1] # remove parentheses
        else:
            argspec = '(...)'
        decl = title + argspec + note

        if skipdocs:
            return decl + '\n'
        else:
            doc = getdoc(object) or ''
            return decl + '\n' + (doc and rstrip(self.indent(doc)) + '\n')

    def _docdescriptor(self, name, value, mod):
        results = []
        push = results.append

        if name:
            push(self.bold(name))
            push('\n')
        doc = getdoc(value) or ''
        if doc:
            push(self.indent(doc))
            push('\n')
        return ''.join(results)

    def docproperty(self, object, name=None, mod=None, cl=None):
        """Produce text documentation for a property."""
        return self._docdescriptor(name, object, mod)

    def docdata(self, object, name=None, mod=None, cl=None):
        """Produce text documentation for a data descriptor."""
        return self._docdescriptor(name, object, mod)

    def docother(self, object, name=None, mod=None, parent=None, maxlen=None, doc=None):
        """Produce text documentation for a data object."""
        repr = self.repr(object)
        if maxlen:
            line = (name and name + ' = ' or '') + repr
            chop = maxlen - len(line)
            if chop < 0: repr = repr[:chop] + '...'
        line = (name and self.bold(name) + ' = ' or '') + repr
        if doc is not None:
            line += '\n' + self.indent(str(doc))
        return line

# --------------------------------------------------------- user interfaces

def pager(text):
    """The first time this is called, determine what kind of pager to use."""
    global pager
    pager = getpager()
    pager(text)

def getpager():
    """Decide what method to use for paging through text."""
    if type(sys.stdout) is not types.FileType:
        return plainpager
    if not hasattr(sys.stdin, "isatty"):
        return plainpager
    if not sys.stdin.isatty() or not sys.stdout.isatty():
        return plainpager
    if 'PAGER' in os.environ:
        if sys.platform == 'win32': # pipes completely broken in Windows
            return lambda text: tempfilepager(plain(text), os.environ['PAGER'])
        elif os.environ.get('TERM') in ('dumb', 'emacs'):
            return lambda text: pipepager(plain(text), os.environ['PAGER'])
        else:
            return lambda text: pipepager(text, os.environ['PAGER'])
    if os.environ.get('TERM') in ('dumb', 'emacs'):
        return plainpager
    if sys.platform == 'win32' or sys.platform.startswith('os2'):
        return lambda text: tempfilepager(plain(text), 'more <')
    if hasattr(os, 'system') and os.system('(pager) 2>/dev/null') == 0:
        return lambda text: pipepager(text, 'pager')
    if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:
        return lambda text: pipepager(text, 'less')

    import tempfile
    (fd, filename) = tempfile.mkstemp()
    os.close(fd)
    try:
        if hasattr(os, 'system') and os.system('more "%s"' % filename) == 0:
            return lambda text: pipepager(text, 'more')
        else:
            return ttypager
    finally:
        os.unlink(filename)

def plain(text):
    """Remove boldface formatting from text."""
    return re.sub('.\b', '', text)

def pipepager(text, cmd):
    """Page through text by feeding it to another program."""
    pipe = os.popen(cmd, 'w')
    try:
        pipe.write(_encode(text))
        pipe.close()
    except IOError:
        pass # Ignore broken pipes caused by quitting the pager program.

def tempfilepager(text, cmd):
    """Page through text by invoking a program on a temporary file."""
    import tempfile
    filename = tempfile.mktemp()
    file = open(filename, 'w')
    file.write(_encode(text))
    file.close()
    try:
        os.system(cmd + ' "' + filename + '"')
    finally:
        os.unlink(filename)

def ttypager(text):
    """Page through text on a text terminal."""
    lines = plain(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding))).split('\n')
    try:
        import tty
        fd = sys.stdin.fileno()
        old = tty.tcgetattr(fd)
        tty.setcbreak(fd)
        getchar = lambda: sys.stdin.read(1)
    except (ImportError, AttributeError):
        tty = None
        getchar = lambda: sys.stdin.readline()[:-1][:1]

    try:
        try:
            h = int(os.environ.get('LINES', 0))
        except ValueError:
            h = 0
        if h <= 1:
            h = 25
        r = inc = h - 1
        sys.stdout.write(join(lines[:inc], '\n') + '\n')
        while lines[r:]:
            sys.stdout.write('-- more --')
            sys.stdout.flush()
            c = getchar()

            if c in ('q', 'Q'):
                sys.stdout.write('\r          \r')
                break
            elif c in ('\r', '\n'):
                sys.stdout.write('\r          \r' + lines[r] + '\n')
                r = r + 1
                continue
            if c in ('b', 'B', '\x1b'):
                r = r - inc - inc
                if r < 0: r = 0
            sys.stdout.write('\n' + join(lines[r:r+inc], '\n') + '\n')
            r = r + inc

    finally:
        if tty:
            tty.tcsetattr(fd, tty.TCSAFLUSH, old)

def plainpager(text):
    """Simply print unformatted text.  This is the ultimate fallback."""
    sys.stdout.write(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding)))

def describe(thing):
    """Produce a short description of the given thing."""
    if inspect.ismodule(thing):
        if thing.__name__ in sys.builtin_module_names:
            return 'built-in module ' + thing.__name__
        if hasattr(thing, '__path__'):
            return 'package ' + thing.__name__
        else:
            return 'module ' + thing.__name__
    if inspect.isbuiltin(thing):
        return 'built-in function ' + thing.__name__
    if inspect.isgetsetdescriptor(thing):
        return 'getset descriptor %s.%s.%s' % (
            thing.__objclass__.__module__, thing.__objclass__.__name__,
            thing.__name__)
    if inspect.ismemberdescriptor(thing):
        return 'member descriptor %s.%s.%s' % (
            thing.__objclass__.__module__, thing.__objclass__.__name__,
            thing.__name__)
    if inspect.isclass(thing):
        return 'class ' + thing.__name__
    if inspect.isfunction(thing):
        return 'function ' + thing.__name__
    if inspect.ismethod(thing):
        return 'method ' + thing.__name__
    if type(thing) is types.InstanceType:
        return 'instance of ' + thing.__class__.__name__
    return type(thing).__name__

def locate(path, forceload=0):
    """Locate an object by name or dotted path, importing as necessary."""
    parts = [part for part in split(path, '.') if part]
    module, n = None, 0
    while n < len(parts):
        nextmodule = safeimport(join(parts[:n+1], '.'), forceload)
        if nextmodule: module, n = nextmodule, n + 1
        else: break
    if module:
        object = module
    else:
        object = __builtin__
    for part in parts[n:]:
        try:
            object = getattr(object, part)
        except AttributeError:
            return None
    return object

# --------------------------------------- interactive interpreter interface

text = TextDoc()
html = HTMLDoc()

class _OldStyleClass: pass
_OLD_INSTANCE_TYPE = type(_OldStyleClass())

def resolve(thing, forceload=0):
    """Given an object or a path to an object, get the object and its name."""
    if isinstance(thing, str):
        object = locate(thing, forceload)
        if object is None:
            raise ImportError, 'no Python documentation found for %r' % thing
        return object, thing
    else:
        name = getattr(thing, '__name__', None)
        return thing, name if isinstance(name, str) else None

def render_doc(thing, title='Python Library Documentation: %s', forceload=0):
    """Render text documentation, given an object or a path to an object."""
    object, name = resolve(thing, forceload)
    desc = describe(object)
    module = inspect.getmodule(object)
    if name and '.' in name:
        desc += ' in ' + name[:name.rfind('.')]
    elif module and module is not object:
        desc += ' in module ' + module.__name__
    if type(object) is _OLD_INSTANCE_TYPE:
        # If the passed object is an instance of an old-style class,
        # document its available methods instead of its value.
        object = object.__class__
    elif not (inspect.ismodule(object) or
              inspect.isclass(object) or
              inspect.isroutine(object) or
              inspect.isgetsetdescriptor(object) or
              inspect.ismemberdescriptor(object) or
              isinstance(object, property)):
        # If the passed object is a piece of data or an instance,
        # document its available methods instead of its value.
        object = type(object)
        desc += ' object'
    return title % desc + '\n\n' + text.document(object, name)

def doc(thing, title='Python Library Documentation: %s', forceload=0):
    """Display text documentation, given an object or a path to an object."""
    try:
        pager(render_doc(thing, title, forceload))
    except (ImportError, ErrorDuringImport), value:
        print value

def writedoc(thing, forceload=0):
    """Write HTML documentation to a file in the current directory."""
    try:
        object, name = resolve(thing, forceload)
        page = html.page(describe(object), html.document(object, name))
        file = open(name + '.html', 'w')
        file.write(page)
        file.close()
        print 'wrote', name + '.html'
    except (ImportError, ErrorDuringImport), value:
        print value

def writedocs(dir, pkgpath='', done=None):
    """Write out HTML documentation for all modules in a directory tree."""
    if done is None: done = {}
    for importer, modname, ispkg in pkgutil.walk_packages([dir], pkgpath):
        writedoc(modname)
    return

class Helper:

    # These dictionaries map a topic name to either an alias, or a tuple
    # (label, seealso-items).  The "label" is the label of the corresponding
    # section in the .rst file under Doc/ and an index into the dictionary
    # in pydoc_data/topics.py.
    #
    # CAUTION: if you change one of these dictionaries, be sure to adapt the
    #          list of needed labels in Doc/tools/pyspecific.py and
    #          regenerate the pydoc_data/topics.py file by running
    #              make pydoc-topics
    #          in Doc/ and copying the output file into the Lib/ directory.

    keywords = {
        'and': 'BOOLEAN',
        'as': 'with',
        'assert': ('assert', ''),
        'break': ('break', 'while for'),
        'class': ('class', 'CLASSES SPECIALMETHODS'),
        'continue': ('continue', 'while for'),
        'def': ('function', ''),
        'del': ('del', 'BASICMETHODS'),
        'elif': 'if',
        'else': ('else', 'while for'),
        'except': 'try',
        'exec': ('exec', ''),
        'finally': 'try',
        'for': ('for', 'break continue while'),
        'from': 'import',
        'global': ('global', 'NAMESPACES'),
        'if': ('if', 'TRUTHVALUE'),
        'import': ('import', 'MODULES'),
        'in': ('in', 'SEQUENCEMETHODS2'),
        'is': 'COMPARISON',
        'lambda': ('lambda', 'FUNCTIONS'),
        'not': 'BOOLEAN',
        'or': 'BOOLEAN',
        'pass': ('pass', ''),
        'print': ('print', ''),
        'raise': ('raise', 'EXCEPTIONS'),
        'return': ('return', 'FUNCTIONS'),
        'try': ('try', 'EXCEPTIONS'),
        'while': ('while', 'break continue if TRUTHVALUE'),
        'with': ('with', 'CONTEXTMANAGERS EXCEPTIONS yield'),
        'yield': ('yield', ''),
    }
    # Either add symbols to this dictionary or to the symbols dictionary
    # directly: Whichever is easier. They are merged later.
    _symbols_inverse = {
        'STRINGS' : ("'", "'''", "r'", "u'", '"""', '"', 'r"', 'u"'),
        'OPERATORS' : ('+', '-', '*', '**', '/', '//', '%', '<<', '>>', '&',
                       '|', '^', '~', '<', '>', '<=', '>=', '==', '!=', '<>'),
        'COMPARISON' : ('<', '>', '<=', '>=', '==', '!=', '<>'),
        'UNARY' : ('-', '~'),
        'AUGMENTEDASSIGNMENT' : ('+=', '-=', '*=', '/=', '%=', '&=', '|=',
                                '^=', '<<=', '>>=', '**=', '//='),
        'BITWISE' : ('<<', '>>', '&', '|', '^', '~'),
        'COMPLEX' : ('j', 'J')
    }
    symbols = {
        '%': 'OPERATORS FORMATTING',
        '**': 'POWER',
        ',': 'TUPLES LISTS FUNCTIONS',
        '.': 'ATTRIBUTES FLOAT MODULES OBJECTS',
        '...': 'ELLIPSIS',
        ':': 'SLICINGS DICTIONARYLITERALS',
        '@': 'def class',
        '\\': 'STRINGS',
        '_': 'PRIVATENAMES',
        '__': 'PRIVATENAMES SPECIALMETHODS',
        '`': 'BACKQUOTES',
        '(': 'TUPLES FUNCTIONS CALLS',
        ')': 'TUPLES FUNCTIONS CALLS',
        '[': 'LISTS SUBSCRIPTS SLICINGS',
        ']': 'LISTS SUBSCRIPTS SLICINGS'
    }
    for topic, symbols_ in _symbols_inverse.iteritems():
        for symbol in symbols_:
            topics = symbols.get(symbol, topic)
            if topic not in topics:
                topics = topics + ' ' + topic
            symbols[symbol] = topics

    topics = {
        'TYPES': ('types', 'STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS '
                  'FUNCTIONS CLASSES MODULES FILES inspect'),
        'STRINGS': ('strings', 'str UNICODE SEQUENCES STRINGMETHODS FORMATTING '
                    'TYPES'),
        'STRINGMETHODS': ('string-methods', 'STRINGS FORMATTING'),
        'FORMATTING': ('formatstrings', 'OPERATORS'),
        'UNICODE': ('strings', 'encodings unicode SEQUENCES STRINGMETHODS '
                    'FORMATTING TYPES'),
        'NUMBERS': ('numbers', 'INTEGER FLOAT COMPLEX TYPES'),
        'INTEGER': ('integers', 'int range'),
        'FLOAT': ('floating', 'float math'),
        'COMPLEX': ('imaginary', 'complex cmath'),
        'SEQUENCES': ('typesseq', 'STRINGMETHODS FORMATTING xrange LISTS'),
        'MAPPINGS': 'DICTIONARIES',
        'FUNCTIONS': ('typesfunctions', 'def TYPES'),
        'METHODS': ('typesmethods', 'class def CLASSES TYPES'),
        'CODEOBJECTS': ('bltin-code-objects', 'compile FUNCTIONS TYPES'),
        'TYPEOBJECTS': ('bltin-type-objects', 'types TYPES'),
        'FRAMEOBJECTS': 'TYPES',
        'TRACEBACKS': 'TYPES',
        'NONE': ('bltin-null-object', ''),
        'ELLIPSIS': ('bltin-ellipsis-object', 'SLICINGS'),
        'FILES': ('bltin-file-objects', ''),
        'SPECIALATTRIBUTES': ('specialattrs', ''),
        'CLASSES': ('types', 'class SPECIALMETHODS PRIVATENAMES'),
        'MODULES': ('typesmodules', 'import'),
        'PACKAGES': 'import',
        'EXPRESSIONS': ('operator-summary', 'lambda or and not in is BOOLEAN '
                        'COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER '
                        'UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES '
                        'LISTS DICTIONARIES BACKQUOTES'),
        'OPERATORS': 'EXPRESSIONS',
        'PRECEDENCE': 'EXPRESSIONS',
        'OBJECTS': ('objects', 'TYPES'),
        'SPECIALMETHODS': ('specialnames', 'BASICMETHODS ATTRIBUTEMETHODS '
                           'CALLABLEMETHODS SEQUENCEMETHODS1 MAPPINGMETHODS '
                           'SEQUENCEMETHODS2 NUMBERMETHODS CLASSES'),
        'BASICMETHODS': ('customization', 'cmp hash repr str SPECIALMETHODS'),
        'ATTRIBUTEMETHODS': ('attribute-access', 'ATTRIBUTES SPECIALMETHODS'),
        'CALLABLEMETHODS': ('callable-types', 'CALLS SPECIALMETHODS'),
        'SEQUENCEMETHODS1': ('sequence-types', 'SEQUENCES SEQUENCEMETHODS2 '
                             'SPECIALMETHODS'),
        'SEQUENCEMETHODS2': ('sequence-methods', 'SEQUENCES SEQUENCEMETHODS1 '
                             'SPECIALMETHODS'),
        'MAPPINGMETHODS': ('sequence-types', 'MAPPINGS SPECIALMETHODS'),
        'NUMBERMETHODS': ('numeric-types', 'NUMBERS AUGMENTEDASSIGNMENT '
                          'SPECIALMETHODS'),
        'EXECUTION': ('execmodel', 'NAMESPACES DYNAMICFEATURES EXCEPTIONS'),
        'NAMESPACES': ('naming', 'global ASSIGNMENT DELETION DYNAMICFEATURES'),
        'DYNAMICFEATURES': ('dynamic-features', ''),
        'SCOPING': 'NAMESPACES',
        'FRAMES': 'NAMESPACES',
        'EXCEPTIONS': ('exceptions', 'try except finally raise'),
        'COERCIONS': ('coercion-rules','CONVERSIONS'),
        'CONVERSIONS': ('conversions', 'COERCIONS'),
        'IDENTIFIERS': ('identifiers', 'keywords SPECIALIDENTIFIERS'),
        'SPECIALIDENTIFIERS': ('id-classes', ''),
        'PRIVATENAMES': ('atom-identifiers', ''),
        'LITERALS': ('atom-literals', 'STRINGS BACKQUOTES NUMBERS '
                     'TUPLELITERALS LISTLITERALS DICTIONARYLITERALS'),
        'TUPLES': 'SEQUENCES',
        'TUPLELITERALS': ('exprlists', 'TUPLES LITERALS'),
        'LISTS': ('typesseq-mutable', 'LISTLITERALS'),
        'LISTLITERALS': ('lists', 'LISTS LITERALS'),
        'DICTIONARIES': ('typesmapping', 'DICTIONARYLITERALS'),
        'DICTIONARYLITERALS': ('dict', 'DICTIONARIES LITERALS'),
        'BACKQUOTES': ('string-conversions', 'repr str STRINGS LITERALS'),
        'ATTRIBUTES': ('attribute-references', 'getattr hasattr setattr '
                       'ATTRIBUTEMETHODS'),
        'SUBSCRIPTS': ('subscriptions', 'SEQUENCEMETHODS1'),
        'SLICINGS': ('slicings', 'SEQUENCEMETHODS2'),
        'CALLS': ('calls', 'EXPRESSIONS'),
        'POWER': ('power', 'EXPRESSIONS'),
        'UNARY': ('unary', 'EXPRESSIONS'),
        'BINARY': ('binary', 'EXPRESSIONS'),
        'SHIFTING': ('shifting', 'EXPRESSIONS'),
        'BITWISE': ('bitwise', 'EXPRESSIONS'),
        'COMPARISON': ('comparisons', 'EXPRESSIONS BASICMETHODS'),
        'BOOLEAN': ('booleans', 'EXPRESSIONS TRUTHVALUE'),
        'ASSERTION': 'assert',
        'ASSIGNMENT': ('assignment', 'AUGMENTEDASSIGNMENT'),
        'AUGMENTEDASSIGNMENT': ('augassign', 'NUMBERMETHODS'),
        'DELETION': 'del',
        'PRINTING': 'print',
        'RETURNING': 'return',
        'IMPORTING': 'import',
        'CONDITIONAL': 'if',
        'LOOPING': ('compound', 'for while break continue'),
        'TRUTHVALUE': ('truth', 'if while and or not BASICMETHODS'),
        'DEBUGGING': ('debugger', 'pdb'),
        'CONTEXTMANAGERS': ('context-managers', 'with'),
    }

    def __init__(self, input=None, output=None):
        self._input = input
        self._output = output

    input  = property(lambda self: self._input or sys.stdin)
    output = property(lambda self: self._output or sys.stdout)

    def __repr__(self):
        if inspect.stack()[1][3] == '?':
            self()
            return ''
        return '<pydoc.Helper instance>'

    _GoInteractive = object()
    def __call__(self, request=_GoInteractive):
        if request is not self._GoInteractive:
            self.help(request)
        else:
            self.intro()
            self.interact()
            self.output.write('''
You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type "help(object)".  Executing "help('string')"
has the same effect as typing a particular string at the help> prompt.
''')

    def interact(self):
        self.output.write('\n')
        while True:
            try:
                request = self.getline('help> ')
                if not request: break
            except (KeyboardInterrupt, EOFError):
                break
            request = strip(replace(request, '"', '', "'", ''))
            if lower(request) in ('q', 'quit'): break
            self.help(request)

    def getline(self, prompt):
        """Read one line, using raw_input when available."""
        if self.input is sys.stdin:
            return raw_input(prompt)
        else:
            self.output.write(prompt)
            self.output.flush()
            return self.input.readline()

    def help(self, request):
        if type(request) is type(''):
            request = request.strip()
            if request == 'help': self.intro()
            elif request == 'keywords': self.listkeywords()
            elif request == 'symbols': self.listsymbols()
            elif request == 'topics': self.listtopics()
            elif request == 'modules': self.listmodules()
            elif request[:8] == 'modules ':
                self.listmodules(split(request)[1])
            elif request in self.symbols: self.showsymbol(request)
            elif request in self.keywords: self.showtopic(request)
            elif request in self.topics: self.showtopic(request)
            elif request: doc(request, 'Help on %s:')
        elif isinstance(request, Helper): self()
        else: doc(request, 'Help on %s:')
        self.output.write('\n')

    def intro(self):
        self.output.write('''
Welcome to Python %s!  This is the online help utility.

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at http://docs.python.org/%s/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, or topics, type "modules",
"keywords", or "topics".  Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as "spam", type "modules spam".
''' % tuple([sys.version[:3]]*2))

    def list(self, items, columns=4, width=80):
        items = items[:]
        items.sort()
        colw = width / columns
        rows = (len(items) + columns - 1) / columns
        for row in range(rows):
            for col in range(columns):
                i = col * rows + row
                if i < len(items):
                    self.output.write(items[i])
                    if col < columns - 1:
                        self.output.write(' ' + ' ' * (colw-1 - len(items[i])))
            self.output.write('\n')

    def listkeywords(self):
        self.output.write('''
Here is a list of the Python keywords.  Enter any keyword to get more help.

''')
        self.list(self.keywords.keys())

    def listsymbols(self):
        self.output.write('''
Here is a list of the punctuation symbols which Python assigns special meaning
to. Enter any symbol to get more help.

''')
        self.list(self.symbols.keys())

    def listtopics(self):
        self.output.write('''
Here is a list of available topics.  Enter any topic name to get more help.

''')
        self.list(self.topics.keys())

    def showtopic(self, topic, more_xrefs=''):
        try:
            import pydoc_data.topics
        except ImportError:
            self.output.write('''
Sorry, topic and keyword documentation is not available because the
module "pydoc_data.topics" could not be found.
''')
            return
        target = self.topics.get(topic, self.keywords.get(topic))
        if not target:
            self.output.write('no documentation found for %s\n' % repr(topic))
            return
        if type(target) is type(''):
            return self.showtopic(target, more_xrefs)

        label, xrefs = target
        try:
            doc = pydoc_data.topics.topics[label]
        except KeyError:
            self.output.write('no documentation found for %s\n' % repr(topic))
            return
        pager(strip(doc) + '\n')
        if more_xrefs:
            xrefs = (xrefs or '') + ' ' + more_xrefs
        if xrefs:
            import StringIO, formatter
            buffer = StringIO.StringIO()
            formatter.DumbWriter(buffer).send_flowing_data(
                'Related help topics: ' + join(split(xrefs), ', ') + '\n')
            self.output.write('\n%s\n' % buffer.getvalue())

    def showsymbol(self, symbol):
        target = self.symbols[symbol]
        topic, _, xrefs = target.partition(' ')
        self.showtopic(topic, xrefs)

    def listmodules(self, key=''):
        if key:
            self.output.write('''
Here is a list of matching modules.  Enter any module name to get more help.

''')
            apropos(key)
        else:
            self.output.write('''
Please wait a moment while I gather a list of all available modules...

''')
            modules = {}
            def callback(path, modname, desc, modules=modules):
                if modname and modname[-9:] == '.__init__':
                    modname = modname[:-9] + ' (package)'
                if find(modname, '.') < 0:
                    modules[modname] = 1
            def onerror(modname):
                callback(None, modname, None)
            ModuleScanner().run(callback, onerror=onerror)
            self.list(modules.keys())
            self.output.write('''
Enter any module name to get more help.  Or, type "modules spam" to search
for modules whose descriptions contain the word "spam".
''')

help = Helper()

class Scanner:
    """A generic tree iterator."""
    def __init__(self, roots, children, descendp):
        self.roots = roots[:]
        self.state = []
        self.children = children
        self.descendp = descendp

    def next(self):
        if not self.state:
            if not self.roots:
                return None
            root = self.roots.pop(0)
            self.state = [(root, self.children(root))]
        node, children = self.state[-1]
        if not children:
            self.state.pop()
            return self.next()
        child = children.pop(0)
        if self.descendp(child):
            self.state.append((child, self.children(child)))
        return child


class ModuleScanner:
    """An interruptible scanner that searches module synopses."""

    def run(self, callback, key=None, completer=None, onerror=None):
        if key: key = lower(key)
        self.quit = False
        seen = {}

        for modname in sys.builtin_module_names:
            if modname != '__main__':
                seen[modname] = 1
                if key is None:
                    callback(None, modname, '')
                else:
                    desc = split(__import__(modname).__doc__ or '', '\n')[0]
                    if find(lower(modname + ' - ' + desc), key) >= 0:
                        callback(None, modname, desc)

        for importer, modname, ispkg in pkgutil.walk_packages(onerror=onerror):
            if self.quit:
                break
            if key is None:
                callback(None, modname, '')
            else:
                loader = importer.find_module(modname)
                if hasattr(loader,'get_source'):
                    import StringIO
                    desc = source_synopsis(
                        StringIO.StringIO(loader.get_source(modname))
                    ) or ''
                    if hasattr(loader,'get_filename'):
                        path = loader.get_filename(modname)
                    else:
                        path = None
                else:
                    module = loader.load_module(modname)
                    desc = module.__doc__.splitlines()[0] if module.__doc__ else ''
                    path = getattr(module,'__file__',None)
                if find(lower(modname + ' - ' + desc), key) >= 0:
                    callback(path, modname, desc)

        if completer:
            completer()

def apropos(key):
    """Print all the one-line module summaries that contain a substring."""
    def callback(path, modname, desc):
        if modname[-9:] == '.__init__':
            modname = modname[:-9] + ' (package)'
        print modname, desc and '- ' + desc
    def onerror(modname):
        pass
    with warnings.catch_warnings():
        warnings.filterwarnings('ignore') # ignore problems during import
        ModuleScanner().run(callback, key, onerror=onerror)

# --------------------------------------------------- web browser interface

def serve(port, callback=None, completer=None):
    import BaseHTTPServer, mimetools, select

    # Patch up mimetools.Message so it doesn't break if rfc822 is reloaded.
    class Message(mimetools.Message):
        def __init__(self, fp, seekable=1):
            Message = self.__class__
            Message.__bases__[0].__bases__[0].__init__(self, fp, seekable)
            self.encodingheader = self.getheader('content-transfer-encoding')
            self.typeheader = self.getheader('content-type')
            self.parsetype()
            self.parseplist()

    class DocHandler(BaseHTTPServer.BaseHTTPRequestHandler):
        def send_document(self, title, contents):
            try:
                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.end_headers()
                self.wfile.write(html.page(title, contents))
            except IOError: pass

        def do_GET(self):
            path = self.path
            if path[-5:] == '.html': path = path[:-5]
            if path[:1] == '/': path = path[1:]
            if path and path != '.':
                try:
                    obj = locate(path, forceload=1)
                except ErrorDuringImport, value:
                    self.send_document(path, html.escape(str(value)))
                    return
                if obj:
                    self.send_document(describe(obj), html.document(obj, path))
                else:
                    self.send_document(path,
'no Python documentation found for %s' % repr(path))
            else:
                heading = html.heading(
'<big><big><strong>Python: Index of Modules</strong></big></big>',
'#ffffff', '#7799ee')
                def bltinlink(name):
                    return '<a href="%s.html">%s</a>' % (name, name)
                names = filter(lambda x: x != '__main__',
                               sys.builtin_module_names)
                contents = html.multicolumn(names, bltinlink)
                indices = ['<p>' + html.bigsection(
                    'Built-in Modules', '#ffffff', '#ee77aa', contents)]

                seen = {}
                for dir in sys.path:
                    indices.append(html.index(dir, seen))
                contents = heading + join(indices) + '''<p align=right>
<font color="#909090" face="helvetica, arial"><strong>
pydoc</strong> by Ka-Ping Yee &lt;ping@lfw.org&gt;</font>'''
                self.send_document('Index of Modules', contents)

        def log_message(self, *args): pass

    class DocServer(BaseHTTPServer.HTTPServer):
        def __init__(self, port, callback):
            host = 'localhost'
            self.address = (host, port)
            self.callback = callback
            self.base.__init__(self, self.address, self.handler)

        def serve_until_quit(self):
            import select
            self.quit = False
            while not self.quit:
                rd, wr, ex = select.select([self.socket.fileno()], [], [], 1)
                if rd: self.handle_request()

        def server_activate(self):
            self.base.server_activate(self)
            self.url = 'http://%s:%d/' % (self.address[0], self.server_port)
            if self.callback: self.callback(self)

    DocServer.base = BaseHTTPServer.HTTPServer
    DocServer.handler = DocHandler
    DocHandler.MessageClass = Message
    try:
        try:
            DocServer(port, callback).serve_until_quit()
        except (KeyboardInterrupt, select.error):
            pass
    finally:
        if completer: completer()

# ----------------------------------------------------- graphical interface

def gui():
    """Graphical interface (starts web server and pops up a control window)."""
    class GUI:
        def __init__(self, window, port=7464):
            self.window = window
            self.server = None
            self.scanner = None

            import Tkinter
            self.server_frm = Tkinter.Frame(window)
            self.title_lbl = Tkinter.Label(self.server_frm,
                text='Starting server...\n ')
            self.open_btn = Tkinter.Button(self.server_frm,
                text='open browser', command=self.open, state='disabled')
            self.quit_btn = Tkinter.Button(self.server_frm,
                text='quit serving', command=self.quit, state='disabled')

            self.search_frm = Tkinter.Frame(window)
            self.search_lbl = Tkinter.Label(self.search_frm, text='Search for')
            self.search_ent = Tkinter.Entry(self.search_frm)
            self.search_ent.bind('<Return>', self.search)
            self.stop_btn = Tkinter.Button(self.search_frm,
                text='stop', pady=0, command=self.stop, state='disabled')
            if sys.platform == 'win32':
                # Trying to hide and show this button crashes under Windows.
                self.stop_btn.pack(side='right')

            self.window.title('pydoc')
            self.window.protocol('WM_DELETE_WINDOW', self.quit)
            self.title_lbl.pack(side='top', fill='x')
            self.open_btn.pack(side='left', fill='x', expand=1)
            self.quit_btn.pack(side='right', fill='x', expand=1)
            self.server_frm.pack(side='top', fill='x')

            self.search_lbl.pack(side='left')
            self.search_ent.pack(side='right', fill='x', expand=1)
            self.search_frm.pack(side='top', fill='x')
            self.search_ent.focus_set()

            font = ('helvetica', sys.platform == 'win32' and 8 or 10)
            self.result_lst = Tkinter.Listbox(window, font=font, height=6)
            self.result_lst.bind('<Button-1>', self.select)
            self.result_lst.bind('<Double-Button-1>', self.goto)
            self.result_scr = Tkinter.Scrollbar(window,
                orient='vertical', command=self.result_lst.yview)
            self.result_lst.config(yscrollcommand=self.result_scr.set)

            self.result_frm = Tkinter.Frame(window)
            self.goto_btn = Tkinter.Button(self.result_frm,
                text='go to selected', command=self.goto)
            self.hide_btn = Tkinter.Button(self.result_frm,
                text='hide results', command=self.hide)
            self.goto_btn.pack(side='left', fill='x', expand=1)
            self.hide_btn.pack(side='right', fill='x', expand=1)

            self.window.update()
            self.minwidth = self.window.winfo_width()
            self.minheight = self.window.winfo_height()
            self.bigminheight = (self.server_frm.winfo_reqheight() +
                                 self.search_frm.winfo_reqheight() +
                                 self.result_lst.winfo_reqheight() +
                                 self.result_frm.winfo_reqheight())
            self.bigwidth, self.bigheight = self.minwidth, self.bigminheight
            self.expanded = 0
            self.window.wm_geometry('%dx%d' % (self.minwidth, self.minheight))
            self.window.wm_minsize(self.minwidth, self.minheight)
            self.window.tk.willdispatch()

            import threading
            threading.Thread(
                target=serve, args=(port, self.ready, self.quit)).start()

        def ready(self, server):
            self.server = server
            self.title_lbl.config(
                text='Python documentation server at\n' + server.url)
            self.open_btn.config(state='normal')
            self.quit_btn.config(state='normal')

        def open(self, event=None, url=None):
            url = url or self.server.url
            try:
                import webbrowser
                webbrowser.open(url)
            except ImportError: # pre-webbrowser.py compatibility
                if sys.platform == 'win32':
                    os.system('start "%s"' % url)
                else:
                    rc = os.system('netscape -remote "openURL(%s)" &' % url)
                    if rc: os.system('netscape "%s" &' % url)

        def quit(self, event=None):
            if self.server:
                self.server.quit = 1
            self.window.quit()

        def search(self, event=None):
            key = self.search_ent.get()
            self.stop_btn.pack(side='right')
            self.stop_btn.config(state='normal')
            self.search_lbl.config(text='Searching for "%s"...' % key)
            self.search_ent.forget()
            self.search_lbl.pack(side='left')
            self.result_lst.delete(0, 'end')
            self.goto_btn.config(state='disabled')
            self.expand()

            import threading
            if self.scanner:
                self.scanner.quit = 1
            self.scanner = ModuleScanner()
            def onerror(modname):
                pass
            threading.Thread(target=self.scanner.run,
                             args=(self.update, key, self.done),
                             kwargs=dict(onerror=onerror)).start()

        def update(self, path, modname, desc):
            if modname[-9:] == '.__init__':
                modname = modname[:-9] + ' (package)'
            self.result_lst.insert('end',
                modname + ' - ' + (desc or '(no description)'))

        def stop(self, event=None):
            if self.scanner:
                self.scanner.quit = 1
                self.scanner = None

        def done(self):
            self.scanner = None
            self.search_lbl.config(text='Search for')
            self.search_lbl.pack(side='left')
            self.search_ent.pack(side='right', fill='x', expand=1)
            if sys.platform != 'win32': self.stop_btn.forget()
            self.stop_btn.config(state='disabled')

        def select(self, event=None):
            self.goto_btn.config(state='normal')

        def goto(self, event=None):
            selection = self.result_lst.curselection()
            if selection:
                modname = split(self.result_lst.get(selection[0]))[0]
                self.open(url=self.server.url + modname + '.html')

        def collapse(self):
            if not self.expanded: return
            self.result_frm.forget()
            self.result_scr.forget()
            self.result_lst.forget()
            self.bigwidth = self.window.winfo_width()
            self.bigheight = self.window.winfo_height()
            self.window.wm_geometry('%dx%d' % (self.minwidth, self.minheight))
            self.window.wm_minsize(self.minwidth, self.minheight)
            self.expanded = 0

        def expand(self):
            if self.expanded: return
            self.result_frm.pack(side='bottom', fill='x')
            self.result_scr.pack(side='right', fill='y')
            self.result_lst.pack(side='top', fill='both', expand=1)
            self.window.wm_geometry('%dx%d' % (self.bigwidth, self.bigheight))
            self.window.wm_minsize(self.minwidth, self.bigminheight)
            self.expanded = 1

        def hide(self, event=None):
            self.stop()
            self.collapse()

    import Tkinter
    try:
        root = Tkinter.Tk()
        # Tk will crash if pythonw.exe has an XP .manifest
        # file and the root has is not destroyed explicitly.
        # If the problem is ever fixed in Tk, the explicit
        # destroy can go.
        try:
            gui = GUI(root)
            root.mainloop()
        finally:
            root.destroy()
    except KeyboardInterrupt:
        pass

# -------------------------------------------------- command-line interface

def ispath(x):
    return isinstance(x, str) and find(x, os.sep) >= 0

def cli():
    """Command-line interface (looks at sys.argv to decide what to do)."""
    import getopt
    class BadUsage: pass

    # Scripts don't get the current directory in their path by default
    # unless they are run with the '-m' switch
    if '' not in sys.path:
        scriptdir = os.path.dirname(sys.argv[0])
        if scriptdir in sys.path:
            sys.path.remove(scriptdir)
        sys.path.insert(0, '.')

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'gk:p:w')
        writing = 0

        for opt, val in opts:
            if opt == '-g':
                gui()
                return
            if opt == '-k':
                apropos(val)
                return
            if opt == '-p':
                try:
                    port = int(val)
                except ValueError:
                    raise BadUsage
                def ready(server):
                    print 'pydoc server ready at %s' % server.url
                def stopped():
                    print 'pydoc server stopped'
                serve(port, ready, stopped)
                return
            if opt == '-w':
                writing = 1

        if not args: raise BadUsage
        for arg in args:
            if ispath(arg) and not os.path.exists(arg):
                print 'file %r does not exist' % arg
                break
            try:
                if ispath(arg) and os.path.isfile(arg):
                    arg = importfile(arg)
                if writing:
                    if ispath(arg) and os.path.isdir(arg):
                        writedocs(arg)
                    else:
                        writedoc(arg)
                else:
                    help.help(arg)
            except ErrorDuringImport, value:
                print value

    except (getopt.error, BadUsage):
        cmd = os.path.basename(sys.argv[0])
        print """pydoc - the Python documentation tool

%s <name> ...
    Show text documentation on something.  <name> may be the name of a
    Python keyword, topic, function, module, or package, or a dotted
    reference to a class or function within a module or module in a
    package.  If <name> contains a '%s', it is used as the path to a
    Python source file to document. If name is 'keywords', 'topics',
    or 'modules', a listing of these things is displayed.

%s -k <keyword>
    Search for a keyword in the synopsis lines of all available modules.

%s -p <port>
    Start an HTTP server on the given port on the local machine.  Port
    number 0 can be used to get an arbitrary unused port.

%s -g
    Pop up a graphical interface for finding and serving documentation.

%s -w <name> ...
    Write out the HTML documentation for a module to a file in the current
    directory.  If <name> contains a '%s', it is treated as a filename; if
    it names a directory, documentation is written for all the contents.
""" % (cmd, os.sep, cmd, cmd, cmd, cmd, os.sep)

if __name__ == '__main__': cli()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   s8  d  Z  d Z d Z d Z d Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l m Z d d l m Z m Z m Z m Z m Z m Z m Z m Z d d	 l m Z y d d
 l m Z Wn' e k
 r!d e f d Ñ  É  YZ n Xd Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% e j& d e j' É Z( d Ñ  Z) d Ñ  Z* d Ñ  Z+ d Ñ  Z, e- e- d Ñ Z. d Ñ  Z/ y
 e0 Z1 Wn9 e2 k
 r˜d e3 f d Ñ  É  YZ1 d Z4 d d Ñ Z5 n% Xd d l6 Z6 e6 j7 É  Z4 e- d Ñ Z5 d  Ñ  Z8 d! Ñ  Z9 d" Ñ  Z: i  d# Ñ Z; d$ e< f d% Ñ  É  YZ= d& Ñ  Z> d' i  d( Ñ Z? d) f  d* Ñ  É  YZ@ d+ e f d, Ñ  É  YZA d- e@ f d. Ñ  É  YZB d/ e f d0 Ñ  É  YZC d1 e@ f d2 Ñ  É  YZD d3 Ñ  aE d4 Ñ  ZF d5 Ñ  ZG d6 Ñ  ZH d7 Ñ  ZI d8 Ñ  ZJ d9 Ñ  ZK d: Ñ  ZL d' d; Ñ ZM eD É  ZN eB É  ZO d< f  d= Ñ  É  YZP eQ eP É  É ZR d' d> Ñ ZS d? d' d@ Ñ ZT d? d' dA Ñ ZU d' dB Ñ ZV dC e- dD Ñ ZW dE f  dF Ñ  É  YZX eX É  ZY dG f  dH Ñ  É  YZZ dI f  dJ Ñ  É  YZ[ dK Ñ  Z\ e- e- dL Ñ Z] dM Ñ  Z^ dN Ñ  Z_ dO Ñ  Z` ea dP k r4e` É  n  d S(Q   sO  Generate Python documentation in HTML or text for interactive use.

In the Python interpreter, do "from pydoc import help" to provide online
help.  Calling help(thing) on a Python object documents the object.

Or, at the shell command line outside of Python:

Run "pydoc <name>" to show documentation on something.  <name> may be
the name of a function, module, package, or a dotted reference to a
class or function within a module or module in a package.  If the
argument contains a path segment delimiter (e.g. slash on Unix,
backslash on Windows) it is treated as the path to a Python source file.

Run "pydoc -k <keyword>" to search for a keyword in the synopsis lines
of all available modules.

Run "pydoc -p <port>" to start an HTTP server on a given port on the
local machine to generate documentation web pages.  Port number 0 can be
used to get an arbitrary unused port.

For platforms without a command line, "pydoc -g" starts the HTTP server
and also pops up a little window for controlling it.

Run "pydoc -w <name>" to write out the HTML documentation for a module
to a file named "<name>.html".

Module docs for core modules are assumed to be in

    https://docs.python.org/library/

This can be overridden by setting the PYTHONDOCS environment variable
to a different URL or to a local directory containing the Library
Reference Manual pages.
s   Ka-Ping Yee <ping@lfw.org>s   26 February 2001s   $Revision: 88564 $s‘   Guido van Rossum, for an excellent programming language.
Tommy Burnette, the original creator of manpy.
Paul Prescod, for all his work on onlinehelp.
Richard Chamberlain, for the first implementation of textdoc.
iˇˇˇˇN(   t   Repr(   t
   expandtabst   findt   joint   lowert   splitt   stript   rfindt   rstrip(   t
   extract_tb(   t   dequeR
   c           B   s   e  Z d  Ñ  Z RS(   c         C   s   |  j  d É S(   Ni    (   t   pop(   t   self(    (    s   /usr/lib/python2.7/pydoc.pyt   popleftA   s    (   t   __name__t
   __module__R   (    (    (    s   /usr/lib/python2.7/pydoc.pyR
   @   s   c          C   sâ   g  }  g  } xv t  j D]k } t j j | p. d É } t j j | É } | | k r t j j | É r |  j | É | j | É q q W|  S(   sA   Convert sys.path into a list of absolute, existing, unique paths.t   .(   t   syst   patht   ost   abspatht   normcaset   isdirt   append(   t   dirst   normdirst   dirt   normdir(    (    s   /usr/lib/python2.7/pydoc.pyt   pathdirsF   s    c         C   sO   t  j |  É p t  j |  É } t | É } | rK t j d d t | É É pN d S(   s-   Get the doc string or comments for an object.s   ^ *
t    (   t   inspectt   getdoct   getcommentst   _encodet   ret   subR   (   t   objectt   result(    (    s   /usr/lib/python2.7/pydoc.pyR   R   s    c         C   sÜ   t  t |  É d É } t | É d k r5 | d d f St | É d k rs t | d É rs | d t | d d É f Sd t | d É f S(   s>   Split a doc string into a synopsis line (if any) and the rest.s   
i   i    R   i   (   R   R   t   lenR   R   (   t   doct   lines(    (    s   /usr/lib/python2.7/pydoc.pyt   splitdocX   s    #c         C   s0   |  j  } |  j | k r, |  j d | } n  | S(   s@   Get a class name and qualify it with a module name if necessary.R   (   R   R   (   R$   t   modnamet   name(    (    s   /usr/lib/python2.7/pydoc.pyt	   classnamea   s    	c         C   sY   t  j |  É pW t  j |  É pW t  j |  É pW t  j |  É pW t  j |  É pW t  j |  É S(   s>   Check if an object is of a type that probably means it's data.(   R   t   ismodulet   isclasst	   isroutinet   isframet   istracebackt   iscode(   R$   (    (    s   /usr/lib/python2.7/pydoc.pyt   isdatah   s    c         G   s;   x4 | r6 t  t |  | d É | d É }  | d } q W|  S(   s/   Do a series of global replacements on a string.i    i   i   (   R   R   (   t   textt   pairs(    (    s   /usr/lib/python2.7/pydoc.pyt   replacen   s    	 c         C   sb   t  |  É | k r^ t d | d d É } t d | d | É } |  |  d |  t  |  É | S|  S(   sC   Omit part of a string if needed to make it fit in a maximum length.i    i   i   s   ...(   R&   t   max(   R4   t   maxlent   pret   post(    (    s   /usr/lib/python2.7/pydoc.pyt   cramu   s
    s    at 0x[0-9a-f]{6,16}(>+)$c         C   s   t  j d |  É S(   s>   Remove the hexadecimal id from a Python object representation.s   \1(   t   _re_stripidR#   (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyt   stripid~   s    c         C   s   t  j |  É p t  j |  É S(   N(   R   t   ismethodt   ismethoddescriptor(   t   obj(    (    s   /usr/lib/python2.7/pydoc.pyt   _is_some_methodÉ   s    c         C   sà   i  } x* t  j |  t É D] \ } } d | | <q Wx$ |  j D] } | j t | É É q= Wx' | j É  D] } t |  | É | | <qg W| S(   Ni   (   R   t
   getmembersRA   t	   __bases__t   updatet
   allmethodst   keyst   getattr(   t   clt   methodst   keyt   valuet   base(    (    s   /usr/lib/python2.7/pydoc.pyRE   Ü   s    c         C   sP   g  } g  } x7 |  D]/ } | | É r5 | j  | É q | j  | É q W| | f S(   s    Split sequence s via predicate, and return pair ([true], [false]).

    The return value is a 2-tuple of lists,
        ([x for x in s if predicate(x)],
         [x for x in s if not predicate(x)])
    (   R   (   t   st	   predicatet   yest   not   x(    (    s   /usr/lib/python2.7/pydoc.pyt   _split_listê   s    c         C   sÇ   d } |  | k r d	 S|  j  d
 É r8 |  j d
 É r8 d S|  j  d É rZ t | d É rZ d S| d k	 rp |  | k S|  j  d É Sd S(   s3   Decide whether to show documentation on a variable.t   __builtins__t   __doc__t   __file__t   __path__R   R   t	   __slots__t   __package__i    t   __i   t   _t   _fieldsN(   RS   RT   RU   RV   R   R   RW   RX   (   t
   startswitht   endswitht   hasattrt   None(   R+   t   allR@   t   _hidden_names(    (    s   /usr/lib/python2.7/pydoc.pyt   visiblename°   s       
c         C   s   d Ñ  } t  | t j |  É É S(   sC   Wrap inspect.classify_class_attrs, with fixup for data descriptors.c         S   s:   |  \ } } } } t  j | É r* d } n  | | | | f S(   Ns   data descriptor(   R   t   isdatadescriptor(   t   dataR+   t   kindt   clsRK   (    (    s   /usr/lib/python2.7/pydoc.pyt   fixup¥   s    	(   t   mapR   t   classify_class_attrs(   R$   Rg   (    (    s   /usr/lib/python2.7/pydoc.pyRi   ≤   s    	t   _unicodec           B   s   e  Z RS(    (   R   R   (    (    (    s   /usr/lib/python2.7/pydoc.pyRj   √   s   t   asciic         C   s   |  S(   N(    (   R4   t   encoding(    (    s   /usr/lib/python2.7/pydoc.pyR!   ∆   s    c         C   s-   t  |  t É r% |  j | p t d É S|  Sd  S(   Nt   xmlcharrefreplace(   t
   isinstancet   unicodet   encodet	   _encoding(   R4   Rl   (    (    s   /usr/lib/python2.7/pydoc.pyR!   Ã   s    c         C   s)   t  |  t É r |  j t d É St |  É S(   NRm   (   Rn   Rj   Rp   Rq   t   str(   R@   (    (    s   /usr/lib/python2.7/pydoc.pyt   _binstr“   s    c         C   sS   t  j j |  É rO x: d D]/ } t  j j t  j j |  d | É É r t Sq Wn  t S(   s3   Guess whether a path refers to a package directory.s   .pys   .pycs   .pyot   __init__(   s   .pys   .pycs   .pyo(   R   R   R   t   isfileR   t   Truet   False(   R   t   ext(    (    s   /usr/lib/python2.7/pydoc.pyt	   ispackage€   s
    %c         C   sı   |  j  É  } x7 | d  d k s, t | É rE |  j  É  } | s Pq q Wt | É } | d  d k ro | d } n  | d  d k rÎ | d } | d d k r¶ | d  } n  x& t | É sŒ |  j  É  } | s© Pq© q© Wt t | d É d	 É } n d  } | S(
   Ni   t   #i   s   r"""i   s   """iˇˇˇˇs   \i    (   t   readlineR   R   R_   (   t   filet   lineR%   (    (    s   /usr/lib/python2.7/pydoc.pyt   source_synopsis„   s&       
  c         C   s  t  j |  É j } | j |  d É \ } } | d k sB | | k  rt j |  É } y t |  É } Wn t k
 ru d SX| rÊ d | d k rÊ y  t	 j
 d | |  | d É } Wn d SX| j r” | j j É  d n d } t j d =n t | É } | j É  | | f | |  <n  | S(   s.   Get the one-line summary out of a module file.t   bi   t   __temp__i   i    N(   NN(   R   t   statt   st_mtimet   getR_   R   t   getmoduleinfot   opent   IOErrort   impt   load_moduleRT   t
   splitlinesR   t   modulesR~   t   close(   t   filenamet   cachet   mtimet
   lastupdateR%   t   infoR|   t   module(    (    s   /usr/lib/python2.7/pydoc.pyt   synopsisÙ   s&       "
t   ErrorDuringImportc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sE   Errors that occurred while trying to import something to document it.c         C   s7   | \ } } } | |  _  | |  _ | |  _ | |  _ d  S(   N(   Rå   t   excRK   t   tb(   R   Rå   t   exc_infoRî   RK   Rï   (    (    s   /usr/lib/python2.7/pydoc.pyRt     s
    			c         C   sA   |  j  } t | É t j k r* | j } n  d |  j | |  j f S(   Ns   problem in %s - %s: %s(   Rî   t   typet   typest	   ClassTypeR   Rå   RK   (   R   Rî   (    (    s   /usr/lib/python2.7/pydoc.pyt   __str__  s    	(   R   R   RT   Rt   Rö   (    (    (    s   /usr/lib/python2.7/pydoc.pyRì   
  s   	c         C   s‡   t  j É  } t |  d É } | j t | É É | k rB t  j } n	 t  j } | j É  t j	 j
 |  É } t j	 j | É \ } } t |  d É } y% t  j | | |  | d | f É } Wn t |  t j É  É Ç n X| j É  | S(   s<   Import a Python source file or compiled file given its path.t   r(   Rá   t	   get_magicRÖ   t   readR&   t   PY_COMPILEDt	   PY_SOURCERã   R   R   t   basenamet   splitextRà   Rì   R   Rñ   (   R   t   magicR|   Re   Rå   R+   Rx   Rë   (    (    s   /usr/lib/python2.7/pydoc.pyt
   importfile  s    	
%
i    c         C   sî  yú | rè |  t  j k rè |  t  j k rè g  t  j D] } | j |  d É r1 | ^ q1 } x3 |  g | D]! } t  j | | | <t  j | =qd Wqè n  t |  É } Wn´ t  j É  \ } } }	 }
 |  t  j k rÊ t t  j |  j |
 É Ç qJ| t k rt | j	 |
 É Ç qJ| t
 k r1t |	 É d d d k r1d St |  t  j É  É Ç n XxC t |  d É d D]. } y t | | É } Wq^t k
 rãd SXq^W| S(   sΩ  Import a module; handle errors; return None if the module isn't found.

    If the module *is* found but an exception occurs, it's wrapped in an
    ErrorDuringImport exception and reraised.  Unlike __import__, if a
    package path is specified, the module at the end of the path is returned,
    not the package at the beginning.  If the optional 'forceload' argument
    is 1, we reload the module from disk (unless it's a dynamic extension).R   iˇˇˇˇi   t
   safeimporti   N(   R   Rä   t   builtin_module_namesR\   t
   __import__Rñ   Rì   RU   t   SyntaxErrorRå   t   ImportErrorR	   R_   R   RG   t   AttributeError(   R   t	   forceloadRç   t   mt   subsRJ   Rë   Rî   RK   Rï   Rê   t   part(    (    s   /usr/lib/python2.7/pydoc.pyR§   ,  s.    /&  	t   Docc           B   si   e  Z d d  Ñ Z d d Ñ Z e Z Z Z Z Z	 Z
 e j j e j d d e j d d !É d Ñ Z RS(   c         G   s›   | | f | } t  j | É r, |  j | å  St  j | É rH |  j | å  SyX t  j | É rg |  j | å  St  j | É rÉ |  j | å  St  j | É rü |  j	 | å  SWn t
 k
 r≥ n Xt | t É r– |  j | å  S|  j | å  S(   s%   Generate documentation for an object.(   R   t   isgetsetdescriptort   docdatat   ismemberdescriptorR-   t	   docmoduleR.   t   docclassR/   t
   docroutineR©   Rn   t   propertyt   docpropertyt   docother(   R   R$   R+   t   args(    (    s   /usr/lib/python2.7/pydoc.pyt   document_  s"          c         G   s6   d | o d t  | É t | É j f } t | Ç d S(   s+   Raise an exception for unimplemented types.s.   don't know how to document object%s of type %st    N(   t   reprRó   R   t	   TypeError(   R   R$   R+   R∏   t   message(    (    s   /usr/lib/python2.7/pydoc.pyt   failq  s    &t   libt   pythoni    i   c         C   s7  y t  j | É } Wn t k
 r, d } n Xt j j d d É } t j j | É } t | t	 t É É r-| j
 d k s≈ | j | É r-| j t j j | d É É r-| j t j j | d É É r-| j
 d k r-| j d É rd | j d É | j
 j É  f } q3t j j | | j
 j É  d É } n d } | S(   s*   Return the location of module docs or Nones
   (built-in)t
   PYTHONDOCSs   https://docs.python.org/libraryt   errnot
   exceptionst   gcRá   t   marshalt   posixt   signalR   t   threadt	   zipimports   dist-packagess   site-packagess	   xml.etrees   test.pydoc_mods   http://s   https://s   %s/%st   /s   .html(
   R¬   R√   Rƒ   Rá   R≈   R∆   R«   R   R»   R…   (   s	   xml.etrees   test.pydoc_mod(   s   http://s   https://N(   R   t
   getabsfileRº   R   t   environRÉ   R   R   Rn   Ró   R   R\   R   R   R   R_   (   R   R$   t   basedirR|   t   docloc(    (    s   /usr/lib/python2.7/pydoc.pyt	   getdoclocy  s(    
	 	%%N(   R   R   R_   Rπ   Ræ   R≤   R≥   R¥   R∑   R∂   R∞   R   R   R   R   t   exec_prefixt   versionRœ   (    (    (    s   /usr/lib/python2.7/pydoc.pyRÆ   ^  s
   t   HTMLReprc           B   sP   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z	 e Z
 RS(   sB   Class for safely making an HTML representation of a Python object.c         C   s:   t  j |  É d |  _ |  _ d |  _ d |  _ |  _ d  S(   Ni   i
   id   (   R    Rt   t   maxlistt   maxtuplet   maxdictt	   maxstringt   maxother(   R   (    (    s   /usr/lib/python2.7/pydoc.pyRt   ö  s    	c         C   s   t  | d d d d d d É S(   Nt   &s   &amp;t   <s   &lt;t   >s   &gt;(   R6   (   R   R4   (    (    s   /usr/lib/python2.7/pydoc.pyt   escape†  s    c         C   s   t  j |  | É S(   N(   R    Rª   (   R   R$   (    (    s   /usr/lib/python2.7/pydoc.pyRª   £  s    c         C   sÑ   t  t | É d É r_ d t t t | É j É d É } t  |  | É r_ t |  | É | | É Sn  |  j t t t	 | É É |  j
 É É S(   NR   t   repr_RZ   (   R^   Ró   R   R   R   RG   R€   R;   R=   Rª   R◊   (   R   RQ   t   levelt
   methodname(    (    s   /usr/lib/python2.7/pydoc.pyt   repr1¶  s
    "c         C   s   t  | |  j É } t | É } d | k rc d t | d d É k rc d | d |  j | É | d St j d d |  j | É É S(   Ns   \s   \\R   Rõ   i    s-   ((\\[\\abfnrtv\'"]|\\[0-9]..|\\x..|\\u....)+)s   <font color="#c040c0">\1</font>(   R;   R÷   Rª   R6   R€   R"   R#   (   R   RQ   R›   t   testt   testrepr(    (    s   /usr/lib/python2.7/pydoc.pyt   repr_string≠  s    $!	c         C   sK   y) |  j  t t t | É É |  j É É SWn |  j  d | j j É SXd  S(   Ns   <%s instance>(   R€   R;   R=   Rª   R÷   t	   __class__R   (   R   RQ   R›   (    (    s   /usr/lib/python2.7/pydoc.pyt   repr_instance∫  s    )(   R   R   RT   Rt   R€   Rª   Rﬂ   R‚   t   repr_strR‰   t   repr_unicode(    (    (    s   /usr/lib/python2.7/pydoc.pyR“   ò  s   						t   HTMLDocc           B   sO  e  Z d  Z e É  Z e j Z e j Z d Ñ  Z d d Ñ Z d d d d d Ñ Z
 d Ñ  Z d Ñ  Z d	 d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d i  i  i  d Ñ Z d d Ñ Z d d d Ñ Z d d i  i  d Ñ Z d Ñ  Z d d i  i  i  d d Ñ Z d Ñ  Z d d d d Ñ Z d d d Ñ Z d d d d Ñ Z d d Ñ Z RS(   s'   Formatter class for HTML documentation.c         C   s   t  d | | f d É S(   s   Format an HTML page.sÆ   
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: %s</title>
<meta charset="utf-8">
</head><body bgcolor="#f0f0f8">
%s
</body></html>Rk   (   R!   (   R   t   titlet   contents(    (    s   /usr/lib/python2.7/pydoc.pyt   pageÀ  s    R   c         C   s   d | | | | | p d f S(   s   Format a page heading.s'  
<table width="100%%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="%s">
<td valign=bottom>&nbsp;<br>
<font color="%s" face="helvetica, arial">&nbsp;<br>%s</font></td
><td align=right valign=bottom
><font color="%s" face="helvetica, arial">%s</font></td></tr></table>
    s   &nbsp;(    (   R   RË   t   fgcolt   bgcolt   extras(    (    s   /usr/lib/python2.7/pydoc.pyt   heading’  s    	i   s   &nbsp;c	   
      C   sz   | d k r! d d | d } n  d | | | f }	 | rW |	 d | | | | f }	 n |	 d | | | f }	 |	 d | S(	   s    Format a section with a heading.s   <tt>s   &nbsp;s   </tt>sÀ   <p>
<table width="100%%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="%s">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="%s" face="helvetica, arial">%s</font></td></tr>
    sR   
<tr bgcolor="%s"><td rowspan=2>%s</td>
<td colspan=2>%s</td></tr>
<tr><td>%s</td>s(   
<tr><td bgcolor="%s">%s</td><td>%s</td>s'   
<td width="100%%">%s</td></tr></table>N(   R_   (
   R   RË   RÎ   RÏ   RÈ   t   widtht   preludet
   marginaliat   gapR%   (    (    s   /usr/lib/python2.7/pydoc.pyt   section‡  s    c         G   s   d | } |  j  | | å S(   s$   Format a section with a big heading.s   <big><strong>%s</strong></big>(   RÛ   (   R   RË   R∏   (    (    s   /usr/lib/python2.7/pydoc.pyt
   bigsectionˆ  s    
c      
   C   s7   |  j  t | É É } t | d d d d d d d d É	 S(   s!   Format literal preformatted text.s   

s   
 
R∫   s   &nbsp;s   
s   <br>
(   R€   R   R6   (   R   R4   (    (    s   /usr/lib/python2.7/pydoc.pyt	   preformat˚  s    i   c         C   s¨   d } t  | É | d | } xÉ t | É D]u } | d d | } xP t | | | | | É D]3 } | t  | É k  r_ | | | | É d } q_ q_ W| d } q+ Wd | S(   s0   Format a list of items into a multi-column list.R   i   s   <td width="%d%%" valign=top>id   s   <br>
s   </td>s7   <table width="100%%" summary="list"><tr>%s</tr></table>(   R&   t   range(   R   t   listt   formatt   colsR%   t   rowst   colt   i(    (    s   /usr/lib/python2.7/pydoc.pyt   multicolumn  s    "c         C   s   d | S(   Ns   <font color="#909090">%s</font>(    (   R   R4   (    (    s   /usr/lib/python2.7/pydoc.pyt   grey  s    c         G   s3   x, | D]$ } | | k r d | | | f Sq W| S(   s:   Make a link for an identifier, given name-to-URL mappings.s   <a href="%s">%s</a>(    (   R   R+   t   dictst   dict(    (    s   /usr/lib/python2.7/pydoc.pyt   namelink  s    c         C   sm   | j  t j j | j É } } t | | É r` t | | É | k r` d | j  | t | | É f St | | É S(   s   Make a link for a class.s   <a href="%s.html#%s">%s</a>(   R   R   Rä   RÉ   R   R^   RG   R,   (   R   R$   R*   R+   Rë   (    (    s   /usr/lib/python2.7/pydoc.pyt	   classlink  s
    $c         C   s   d | j  | j  f S(   s   Make a link for a module.s   <a href="%s.html">%s</a>(   R   (   R   R$   (    (    s   /usr/lib/python2.7/pydoc.pyt
   modulelink  s    c         C   so   | \ } } } } | r% |  j  | É S| r> d | | f } n
 d | } | r[ d | } n | } d | | f S(   s;   Make a link for a module or package to display in an index.s
   %s.%s.htmls   %s.htmls"   <strong>%s</strong>&nbsp;(package)s   <a href="%s">%s</a>(   R˛   (   R   Rd   R+   R   Ry   t   shadowedt   urlR4   (    (    s   /usr/lib/python2.7/pydoc.pyt
   modpkglink"  s    
c         C   s  | p |  j  } g  } d } t j d É } xΩt rÈ| j | | É }	 |	 sO Pn  |	 j É  \ }
 } | j | | | |
 !É É |	 j É  \ } } } } } } | r— | | É j d d É } | j d | | f É n| rd t	 | É } | j d | | | É f É nŸ | r=d t	 | É } | j d | | | É f É n£ | ré| | | d !d	 k rz| j d
 |  j
 | | É É q‡| j d | É nR | | | d !d	 k r«| j |  j
 | | | | É É n | j |  j
 | | É É | } q- W| j | | | É É t | d É S(   sÉ   Mark up some plain text, given a context of symbols to look for.
        Each context dictionary maps object names to anchor names.i    sD   \b((http|ftp)://\S+[\w/]|RFC[- ]?(\d+)|PEP[- ]?(\d+)|(self\.)?(\w+))t   "s   &quot;s   <a href="%s">%s</a>s'   http://www.rfc-editor.org/rfc/rfc%d.txts(   http://www.python.org/dev/peps/pep-%04d/i   t   (s   self.s   self.<strong>%s</strong>R   (   R€   R"   t   compileRv   t   searcht   spanR   t   groupsR6   t   intR  R   (   R   R4   R€   t   funcst   classesRI   t   resultst   heret   patternt   matcht   startt   endR`   t   schemet   rfct   pept   selfdotR+   R  (    (    s   /usr/lib/python2.7/pydoc.pyt   markup1  s<    	    "
c   
      C   s  d } x˙ | D]Ú } t  | É t  d	 É k r« | \ } } | d } | |  j | | É } | r∫ | | f k r∫ g  } x' | D] }	 | j |  j |	 | É É qy W| d t | d É d } n  | d } q t  | É t  g  É k r | d |  j | | | É } q q Wd | S(
   sA   Produce HTML for a class tree as given by inspect.getclasstree().R   s"   <dt><font face="helvetica, arial">R  s   , t   )s   
</font></dt>s   <dd>
%s</dd>
s   <dl>
%s</dl>
(    (   Ró   R  R   R   t
   formattree(
   R   t   treeR*   t   parentR%   t   entryt   ct   basest   parentsRL   (    (    s   /usr/lib/python2.7/pydoc.pyR  \  s     
c   $      G   sΩ  | j  } y | j } Wn t k
 r/ d } n Xt | d É } g  } xJ t t | É d É D]2 } | j d t | | d  d É | | f É q\ Wt | | d d É }	 d |	 }
 yV t	 j
 | É } | } t j d k r¯ d d l } | j | É } n  d | | f } Wn t k
 r"d	 } n Xg  } t | d
 É röt | j É } | d  d. k r}| d d k r}t | d d !É } n  | j d |  j | É É n  t | d É rÀ| j |  j t | j É É É n  | rÎ|
 d t | d É }
 n  |  j | É } | d k	 rd t É  } n d } |  j |
 d d d | | É } t	 j | t	 j É } g  i  } } xã t	 j | t	 j É D]t \ } } | d k	 sßt	 j | É pû| | k rtt | | | É rË| j | | f É d | | | <| | <qËqtqtWx≤ | D]™ \ } } xõ | j D]ê } | j  | j } } t j  j! | É } | | k r	| r	t | | É r	t" | | É | k rô| | k rñ| d | | | <| | <qñqôq	q	WqÛWg  i  } } x¨ t	 j | t	 j# É D]ï \ } } | d k	 s t	 j$ | É s t	 j | É | k rƒt | | | É rY| j | | f É d | | | <t	 j% | É rV| | | | <qVqYqƒqƒWg  } xH t	 j | t& É D]4 \ } } t | | | É rv| j | | f É qvqvW|  j' t( | É |  j) | | É } | o‹d | } | d | } t | d É rg  } x< t* j+ | j, É D]( \ }  } }! | j | | |! d f É qW| j- É  |  j. | |  j/ É }" | |  j0 d d d |" É } n= | rº|  j. | |  d  Ñ É }" | |  j0 d! d d |" É } n  | rSt1 d" Ñ  | É }# |  j2 t	 j3 |# d É | É g }" x6 | D]. \ } } |" j |  j4 | | | | | É É q¸W| |  j0 d# d d$ t |" É É } n  | rΩg  }" x6 | D]. \ } } |" j |  j4 | | | | | É É qfW| |  j0 d% d d& t |" É É } n  | r!g  }" x- | D]% \ } } |" j |  j4 | | É É q–W| |  j0 d' d d( t |" d) É É } n  t | d* É rm|  j' t | j5 É |  j) É }" | |  j0 d+ d d |" É } n  t | d, É rπ|  j' t | j6 É |  j) É }" | |  j0 d- d d |" É } n  | S(/   s/   Produce HTML documentation for a module object.R   i   s5   <a href="%s.html"><font color="#ffffff">%s</font></a>iˇˇˇˇs)   <big><big><strong>%s</strong></big></big>t   win32Ns   <a href="file:%s">%s</a>s
   (built-in)t   __version__i   t   $s
   Revision: s
   version %st   __date__s    (%s)s   , s(   <br><a href="%(docloc)s">Module Docs</a>R   s   #ffffffs   #7799ees   <a href=".">index</a><br>Rz   s   .html#s   #-s   <tt>%s</tt>s
   <p>%s</p>
RV   i    s   Package Contentss   #aa55ccc         S   s   | j  |  d É S(   Ni   (   R  (   t	   key_valueRM   (    (    s   /usr/lib/python2.7/pydoc.pyt   <lambda>»  s    t   Modulesc         S   s   |  d S(   Ni   (    (   R'  (    (    s   /usr/lib/python2.7/pydoc.pyR(  Õ  s    t   Classess   #ee77aat	   Functionss   #eeaa77t   Datas   #55aa55s   <br>
t
   __author__t   Authort   __credits__t   Creditss   $Revision: (7   R   t   __all__R©   R_   R   Rˆ   R&   R   R   R   RÀ   R   t   platformt
   nturl2patht   pathname2urlRº   R^   Rs   R$  R   R€   R&  Rœ   t   localsRÓ   RB   R-   R.   t	   getmoduleRb   RC   R   Rä   RÉ   RG   R/   t	   isbuiltint
   isfunctionR3   R  R   Rı   t   pkgutilt   iter_modulesRV   t   sortR˝   R  RÙ   Rh   R  t   getclasstreeRπ   R-  R/  ($   R   R$   R+   t   modt   ignoredR`   t   partst   linksR¸   t
   linkednamet   headR   R  R3  t   filelinkRê   R—   RŒ   R%   Rä   R  t   cdictRJ   RK   RL   R*   Rë   R  t   fdictRd   R'   t   modpkgst   importert   ispkgRÈ   t	   classlist(    (    s   /usr/lib/python2.7/pydoc.pyR≤   o  s‡    	
'

 "	" !+"$ !"
		!&	&				c            s  à j  } | p | } à j } g  }	 |	 j â d d( á f d Ü  É  Y}
 |
 É  â t t j à É É } t | É d k r≈ à j É  à d É x+ | D]# } à d à j | à j	 É É që Wà d É n  á  á á á á á á á f d Ü  } á á á á f d Ü  } á  á á á á á á á f d	 Ü  } t
 á f d
 Ü  t à É É } i  â x} | D]u \ } } } } d | d | à | <} y t à | É } Wn t k
 r¢n Xy | à | <WqPt k
 rƒqPXqPWxn| r9| rÁ| j É  â n | d d â t | á f d Ü  É \ } } à t j k r.| } qÃn. à à k rCd } n d à j à à j	 É } | d 7} y | j d d Ñ  É Wn! t k
 r†| j d Ñ  É n X| d | | d Ñ  É } | d | | d Ñ  É } | d | | d Ñ  É } | d | | d Ñ  É } | d | | d Ñ  É } | g  k s0t Ç | } qÃWd j |	 É }	 | | k rhd  | | f } n d! | | | f } | rŒg  } x* | D]" } | j à j | à j	 É É qéW| d" t | d# É } n  à j t à É à j à à  à É } | oˇd$ | } à j | d% d& |	 d' | É S()   s.   Produce HTML documentation for a class object.t   HorizontalRulec              s    e  Z d  Ñ  Z á  f d Ü  Z RS(   c         S   s   d |  _  d  S(   Ni    (   t   needone(   R   (    (    s   /usr/lib/python2.7/pydoc.pyRt   ˜  s    c            s#   |  j  r à  d É n  d |  _  d  S(   Ns   <hr>
i   (   RK  (   R   (   t   push(    s   /usr/lib/python2.7/pydoc.pyt   maybe˘  s    	(   R   R   Rt   RM  (    (   RL  (    s   /usr/lib/python2.7/pydoc.pyRJ  ˆ  s   	i   s&   <dl><dt>Method resolution order:</dt>
s   <dd>%s</dd>
s   </dl>
c      
      s¬   t  | | É \ } } | ræ à j É  à |  É xå | D]Å \ } } } } y t à | É } Wn* t k
 rá à à j | | à É É n& Xà à j | | à à à  à à É É à d É q6 Wn  | S(   Ns   
(   RR   RM  RG   t	   Exceptiont   _docdescriptorRπ   (   t   msgt   attrsRN   t   okR+   Re   t   homeclsRK   (   R  R  t   hrt   mdictR=  R$   RL  R   (    s   /usr/lib/python2.7/pydoc.pyt   spill	  s    

c            sl   t  | | É \ } } | rh à  j É  à |  É x6 | D]+ \ } } } } à à j | | à É É q6 Wn  | S(   N(   RR   RM  RO  (   RP  RQ  RN   RR  R+   Re   RS  RK   (   RT  R=  RL  R   (    s   /usr/lib/python2.7/pydoc.pyt   spilldescriptors  s    

 c   
         s  t  | | É \ } } | rà j É  à |  É x› | D]“ \ } } } } à j t à | É | à É } t | d É sÑ t j | É rô t | d d  É }	 n d  }	 |	 d  k rº à d | É nB à j t	 | É à j
 à à  à É }	 d |	 }	 à d | |	 f É à d É q6 Wn  | S(   Nt   __call__RT   s   <dl><dt>%s</dl>
s   <dd><tt>%s</tt>s   <dl><dt>%s%s</dl>
s   
(   RR   RM  R∑   RG   R^   R   Rc   R_   R  R   Rı   (
   RP  RQ  RN   RR  R+   Re   RS  RK   RL   R'   (   R  R  RT  RU  R=  R$   RL  R   (    s   /usr/lib/python2.7/pydoc.pyt	   spilldata$  s$    


c            s   t  |  d d à  ÉS(   Ni    R@   (   Rb   (   Rd   (   R$   (    s   /usr/lib/python2.7/pydoc.pyR(  :  s    Rz   t   -i    c            s   |  d à  k S(   Ni   (    (   t   t(   t	   thisclass(    s   /usr/lib/python2.7/pydoc.pyR(  Q  s    s   defined heres   inherited from %ss   :<br>
RJ   c         S   s   |  d S(   Ni    (    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  _  s    c         S   s   t  |  d | d É S(   Ni    (   t   cmp(   t   t1t   t2(    (    s   /usr/lib/python2.7/pydoc.pyR(  a  s    s
   Methods %sc         S   s   |  d d k S(   Ni   t   method(    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  e  s    s   Class methods %sc         S   s   |  d d k S(   Ni   s   class method(    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  g  s    s   Static methods %sc         S   s   |  d d k S(   Ni   s   static method(    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  i  s    s   Data descriptors %sc         S   s   |  d d k S(   Ni   s   data descriptor(    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  k  s    s   Data and other attributes %sc         S   s   |  d d k S(   Ni   Rd   (    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  m  s    R   s*   <a name="%s">class <strong>%s</strong></a>s/   <strong>%s</strong> = <a name="%s">class %s</a>s   (%s)s   , s   <tt>%s<br>&nbsp;</tt>s   #000000s   #ffc8d8i   (    (   R   RC   R   R
   R   t   getmroR&   RM  R  R   t   filterRi   RG   RN  Rº   R   RR   t   __builtin__R$   R;  t   AssertionErrorR   R  R   Rı   RÛ   (   R   R$   R+   R=  R  R  R>  t   realnameR!  RÈ   RJ  t   mroRL   RV  RW  RY  RQ  RJ   Re   RS  RK   t   anchort	   inheritedt   tagRË   R"  R'   (    (	   R  R  RT  RU  R=  R$   RL  R   R\  s   /usr/lib/python2.7/pydoc.pyR≥   Î  sî    				

$	$		

 $c         C   s   |  j  d |  j | É É S(   s)   Format an argument default value as text.t   =(   R˛   Rª   (   R   R$   (    (    s   /usr/lib/python2.7/pydoc.pyt   formatvalueÉ  s    c         C   sG  | j  } | p | } | r$ | j  p' d d | }	 d }
 d } t j | É r‘ | j } | rÑ | | k	 r» d |  j | | É }
 q» nD | j d k	 r≤ d |  j | j j | É }
 n d |  j | | É }
 | j } n  | | k rÛ d |	 | f } ne | r?| | j	 k r?| j	 | | k r?d | j  d | | f } d	 } n | } d
 |	 | | f } t j
 | É rÃt j | É \ } } } } t j | | | | d |  j É} | d k r“d | } | d	 d !} q“n d } | | |
 oÔ|  j d |
 É } | rd | S|  j t | É |  j | | | É } | o2d | } d | | f Sd S(   s;   Produce HTML documentation for a function or method object.R   RZ  i    s    from s    method of %s instances    unbound %s methods$   <a name="%s"><strong>%s</strong></a>s   <a href="#%s">%s</a>i   s)   <a name="%s"><strong>%s</strong></a> = %sRk  s   <lambda>s$   <strong>%s</strong> <em>lambda</em> iˇˇˇˇs   (...)s'   <font face="helvetica, arial">%s</font>s   <dl><dt>%s</dt></dl>
s   <dd><tt>%s</tt></dd>s   <dl><dt>%s</dt>%s</dl>
N(   R   R   R>   t   im_classR  t   im_selfR_   R„   t   im_funct   __dict__R8  t
   getargspect   formatargspecRk  R˛   R  R   Rı   (   R   R$   R+   R=  R  R  RI   RH   Re  Rg  t   notet   skipdocst   imclassRË   t   reallinkR∏   t   varargst   varkwt   defaultst   argspect   declR'   (    (    s   /usr/lib/python2.7/pydoc.pyR¥   á  sR    				
c         C   sx   g  } | j  } | r& | d | É n  | j d  k	 ra |  j t | É |  j É } | d | É n  | d É d j | É S(   Ns!   <dl><dt><strong>%s</strong></dt>
s   <dd><tt>%s</tt></dd>
s   </dl>
R   (   R   RT   R_   R  R   Rı   R   (   R   R+   RK   R=  R  RL  R'   (    (    s   /usr/lib/python2.7/pydoc.pyRO  Ω  s    	
c         C   s   |  j  | | | É S(   s*   Produce html documentation for a property.(   RO  (   R   R$   R+   R=  RH   (    (    s   /usr/lib/python2.7/pydoc.pyR∂      s    c         G   s'   | r d | p d } | |  j  | É S(   s-   Produce HTML documentation for a data object.s   <strong>%s</strong> = R   (   Rª   (   R   R$   R+   R=  R>  t   lhs(    (    s   /usr/lib/python2.7/pydoc.pyR∑   Œ  s    c         C   s   |  j  | | | É S(   s1   Produce html documentation for a data descriptor.(   RO  (   R   R$   R+   R=  RH   (    (    s   /usr/lib/python2.7/pydoc.pyR∞   ”  s    c         C   sü   g  } | d k r i  } n  xL t j | g É D]8 \ } } } | j | d | | | k f É d | | <q. W| j É  |  j | |  j É } |  j | d d | É S(   s2   Generate an HTML index for a directory of modules.R   i   s   #ffffffs   #ee77aaN(   R_   R9  R:  R   R;  R˝   R  RÙ   (   R   R   R  RF  RG  R+   RH  RÈ   (    (    s   /usr/lib/python2.7/pydoc.pyt   index◊  s     	"
N(   R   R   RT   R“   t   _repr_instanceRª   R€   RÍ   RÓ   R_   RÛ   RÙ   Rı   R˝   R˛   R  R  R  R  R  R  R≤   R≥   Rk  R¥   RO  R∂   R∑   R∞   R|  (    (    (    s   /usr/lib/python2.7/pydoc.pyRÁ   ¬  s8   				
							+|ò	5	t   TextReprc           B   s8   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z RS(   sA   Class for safely making a text representation of a Python object.c         C   s:   t  j |  É d |  _ |  _ d |  _ d |  _ |  _ d  S(   Ni   i
   id   (   R    Rt   R”   R‘   R’   R÷   R◊   (   R   (    (    s   /usr/lib/python2.7/pydoc.pyRt   Á  s    	c         C   s{   t  t | É d É r_ d t t t | É j É d É } t  |  | É r_ t |  | É | | É Sn  t t t | É É |  j	 É S(   NR   R‹   RZ   (
   R^   Ró   R   R   R   RG   R;   R=   Rª   R◊   (   R   RQ   R›   Rﬁ   (    (    s   /usr/lib/python2.7/pydoc.pyRﬂ   Ì  s
    "c         C   s^   t  | |  j É } t | É } d | k rZ d t | d d É k rZ d | d | | d S| S(   Ns   \s   \\R   Rõ   i    (   R;   R÷   Rª   R6   (   R   RQ   R›   R‡   R·   (    (    s   /usr/lib/python2.7/pydoc.pyR‚   Ù  s
    $c         C   s9   y  t  t t | É É |  j É SWn d | j j SXd  S(   Ns   <%s instance>(   R;   R=   Rª   R÷   R„   R   (   R   RQ   R›   (    (    s   /usr/lib/python2.7/pydoc.pyR‰   ˇ  s     (   R   R   RT   Rt   Rﬂ   R‚   RÂ   R‰   (    (    (    s   /usr/lib/python2.7/pydoc.pyR~  Â  s   				t   TextDocc           B   sÀ   e  Z d  Z e É  Z e j Z d Ñ  Z d d Ñ Z d Ñ  Z d d d Ñ Z
 d d d Ñ Z d d d Ñ Z d	 Ñ  Z d d d d
 Ñ Z d Ñ  Z d d d d Ñ Z d d d d Ñ Z d d d d d d Ñ Z RS(   s'   Formatter class for text documentation.c         C   s   t  t d Ñ  | É d É S(   s(   Format a string in bold by overstriking.c         S   s   |  d |  S(   Ns   (    (   t   ch(    (    s   /usr/lib/python2.7/pydoc.pyR(    s    R   (   R   Rh   (   R   R4   (    (    s   /usr/lib/python2.7/pydoc.pyt   bold  s    s       c         C   sX   | s
 d St  | d É } t | d Ñ | É } | rK t | d É | d <n  t | d É S(   s6   Indent text by prepending a given prefix to each line.R   s   
c         S   s   | |  S(   N(    (   R}   t   prefix(    (    s   /usr/lib/python2.7/pydoc.pyR(    s    iˇˇˇˇ(   R   Rh   R   R   (   R   R4   RÇ  R(   (    (    s   /usr/lib/python2.7/pydoc.pyt   indent  s      c         C   s(   |  j  | É d t |  j | É É d S(   s&   Format a section with a given heading.s   
s   

(   RÅ  R   RÉ  (   R   RË   RÈ   (    (    s   /usr/lib/python2.7/pydoc.pyRÛ     s    R   c   
      C   s‚   d } x’ | D]Õ } t  | É t  d É k rü | \ } } | | t | | É } | rí | | f k rí t | d Ñ | É }	 | d t |	 d É } n  | d } q t  | É t  g  É k r | |  j | | | | d É } q q W| S(   sB   Render in text a class tree as returned by inspect.getclasstree().R   c         S   s   t  |  | É S(   N(   R,   (   R   R´   (    (    s   /usr/lib/python2.7/pydoc.pyR(  '  s    s   (%s)s   , s   
s       (    (   Ró   R,   Rh   R   R  (
   R   R  R*   R  RÇ  R%   R  R   R!  R"  (    (    s   /usr/lib/python2.7/pydoc.pyR    s    	c         C   s‚  | j  } t t | É É \ } } |  j d | | o: d | É } y | j } Wn t k
 rg d  } n Xy t j | É } Wn t	 k
 rî d } n X| |  j d | É } |  j
 | É }	 |	 d  k	 rﬂ | |  j d |	 É } n  | r˛ | |  j d | É } n  g  }
 xu t j | t j É D]^ \ } } | d  k	 sMt j | É pD| | k rt | | | É rx|
 j | | f É qxqqWg  } x~ t j | t j É D]g \ } } | d  k	 s‘t j | É s‘t j | É | k ròt | | | É rˇ| j | | f É qˇqòqòWg  } xH t j | t É D]4 \ } } t | | | É r| j | | f É qqWg  } t É  } t | d É r¯xW t j | j É D]C \ } } } | j | É | rª| j | d É qÖ| j | É qÖW| j É  | |  j d	 t | d
 É É } n  g  } xU t j | t j É D]> \ } } | j  j | d É r| | k r| j | É qqW| rà| j É  | |  j d t | d
 É É } n  |
 rt d Ñ  |
 É } |  j t j | d É | É g } x0 |
 D]( \ } } | j |  j  | | | É É q»W| |  j d t | d
 É É } n  | rwg  } x0 | D]( \ } } | j |  j  | | | É É q)W| |  j d t | d
 É É } n  | rﬁg  } x6 | D]. \ } } | j |  j! | | | d d ÉÉ qäW| |  j d t | d
 É É } n  t | d É rKt" | j# É } | d  d! k r2| d d k r2t$ | d d !É } n  | |  j d | É } n  t | d É r|| |  j d t" | j% É É } n  t | d É r≠| |  j d t" | j& É É } n  t | d É rﬁ| |  j d t" | j' É É } n  | S("   s5   Produce text documentation for a given module object.t   NAMEs    - s
   (built-in)t   FILEs   MODULE DOCSt   DESCRIPTIONRV   s
    (package)s   PACKAGE CONTENTSs   
R   t
   SUBMODULESc         S   s   |  d S(   Ni   (    (   R'  (    (    s   /usr/lib/python2.7/pydoc.pyR(  s  s    i   t   CLASSESt	   FUNCTIONSR8   iF   t   DATAR$  i   R%  s
   Revision: iˇˇˇˇt   VERSIONR&  t   DATER-  t   AUTHORR/  t   CREDITSNs   $Revision: ((   R   R)   R   RÛ   R1  R©   R_   R   RÀ   Rº   Rœ   RB   R.   R6  Rb   R   R/   R7  R3   t   setR^   R9  R:  RV   t   addR;  R   R-   R\   Rh   R  R<  Rπ   R∑   Rs   R$  R   R&  R-  R/  (   R   R$   R+   R=  t   synopt   descR%   R`   R|   RŒ   R  RJ   RK   R  Rd   RF  t   modpkgs_namesRG  R*   RH  t
   submodulesRI  RÈ   R—   (    (    s   /usr/lib/python2.7/pydoc.pyR≤   /  s¢    	 

""$	"
	""
	 " "&" """c            s&  à j  } | p | } à j } à j d Ñ } | | k rO d à j | É } n à j | É d | } | rï t | | É }	 | d t |	 d É } n  t à É }
 |
 r¥ |
 d g p∑ g  } | j â t t	 j
 à É É } t | É d k r&à d É x" | D] } à d	 | | É É q˚ Wà d
 É n  d d  á f d Ü  É  Y} | É  â  á  á á á á f d Ü  } á  á á á f d Ü  } á  á á á á f d Ü  } t á f d Ü  t à É É } x0| rÊ| r“| j É  â n | d d â t | á f d Ü  É \ } } à t j k r| } q∑n+ à à k r.d } n d t à à j É } | j É  | d | | d Ñ  É } | d | | d Ñ  É } | d | | d Ñ  É } | d | | d Ñ  É } | d | | d Ñ  É } | g  k s›t Ç | } q∑Wd j | É } | s| d S| d à j t | É d É d S(!   s4   Produce text documentation for a given class object.c         S   s   t  |  | É S(   N(   R,   (   R   R´   (    (    s   /usr/lib/python2.7/pydoc.pyt   makenameô  s    s   class s	    = class s   (%s)s   , s   
i   s   Method resolution order:s       R   RJ  c              s    e  Z d  Ñ  Z á  f d Ü  Z RS(   c         S   s   d |  _  d  S(   Ni    (   RK  (   R   (    (    s   /usr/lib/python2.7/pydoc.pyRt   ≤  s    c            s'   |  j  r à  d d É n  d |  _  d  S(   NRZ  iF   i   (   RK  (   R   (   RL  (    s   /usr/lib/python2.7/pydoc.pyRM  ¥  s    	(   R   R   Rt   RM  (    (   RL  (    s   /usr/lib/python2.7/pydoc.pyRJ  ±  s   	c            sØ   t  | | É \ } } | r´ à  j É  à |  É xy | D]n \ } } } } y t à | É } Wn* t k
 rá à à j | | à É É q6 Xà à j | | à à É É q6 Wn  | S(   N(   RR   RM  RG   RN  RO  Rπ   (   RP  RQ  RN   RR  R+   Re   RS  RK   (   RT  R=  R$   RL  R   (    s   /usr/lib/python2.7/pydoc.pyRV  ∫  s    

c            sl   t  | | É \ } } | rh à  j É  à |  É x6 | D]+ \ } } } } à à j | | à É É q6 Wn  | S(   N(   RR   RM  RO  (   RP  RQ  RN   RR  R+   Re   RS  RK   (   RT  R=  RL  R   (    s   /usr/lib/python2.7/pydoc.pyRW  À  s    

 c   	   
      s∏   t  | | É \ } } | r¥ à  j É  à |  É xÇ | D]w \ } } } } t | d É sf t j | É ru t | É } n d  } à à j t à | É | à d d d | Éd É q6 Wn  | S(   NRX  R8   iF   R'   s   
(	   RR   RM  R^   R   Rc   R   R_   R∑   RG   (	   RP  RQ  RN   RR  R+   Re   RS  RK   R'   (   RT  R=  R$   RL  R   (    s   /usr/lib/python2.7/pydoc.pyRY  ‘  s    

$c            s   t  |  d d à  ÉS(   Ni    R@   (   Rb   (   Rd   (   R$   (    s   /usr/lib/python2.7/pydoc.pyR(  „  s    i    c            s   |  d à  k S(   Ni   (    (   R[  (   R\  (    s   /usr/lib/python2.7/pydoc.pyR(  Í  s    s   defined heres   inherited from %ss   Methods %s:
c         S   s   |  d d k S(   Ni   R`  (    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  ˙  s    s   Class methods %s:
c         S   s   |  d d k S(   Ni   s   class method(    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  ¸  s    s   Static methods %s:
c         S   s   |  d d k S(   Ni   s   static method(    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(  ˛  s    s   Data descriptors %s:
c         S   s   |  d d k S(   Ni   s   data descriptor(    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(     s    s   Data and other attributes %s:
c         S   s   |  d d k S(   Ni   Rd   (    (   R[  (    (    s   /usr/lib/python2.7/pydoc.pyR(    s    s    |  (    (   R   RC   R   RÅ  Rh   R   R   R   R
   R   Ra  R&   Rb  Ri   R   RR   Rc  R$   R,   R;  Rd  RÉ  R   (   R   R$   R+   R=  R>  Re  R!  Rï  RË   R"  R'   RÈ   Rf  RL   RJ  RV  RW  RY  RQ  Rh  Ri  (    (   RT  R=  R$   RL  R   R\  s   /usr/lib/python2.7/pydoc.pyR≥   ì  sn    			
					

c         C   s   d |  j  | É S(   s)   Format an argument default value as text.Rj  (   Rª   (   R   R$   (    (    s   /usr/lib/python2.7/pydoc.pyRk    s    c         C   sÓ  | j  } | p | } d } d } t j | É rÆ | j } | rd | | k	 r¢ d t | | É } q¢ n> | j d k	 rè d t | j j | É } n d t | | É } | j } n  | | k rÃ |  j	 | É }	 nH | r˝ | | j
 k r˝ | j
 | | k r˝ d } n  |  j	 | É d | }	 t j | É rët j | É \ }
 } } } t j |
 | | | d |  j É} | d	 k ró|  j	 | É d
 }	 | d d !} qón d } |	 | | } | r≥| d St | É p¬d } | d | oËt |  j | É É d Sd S(   s;   Produce text documentation for a function or method object.R   i    s    from s    method of %s instances    unbound %s methodi   s    = Rk  s   <lambda>s    lambda iˇˇˇˇs   (...)s   
N(   R   R   R>   Rl  R,   Rm  R_   R„   Rn  RÅ  Ro  R8  Rp  Rq  Rk  R   R   RÉ  (   R   R$   R+   R=  RH   Re  Rr  Rs  Rt  RË   R∏   Rv  Rw  Rx  Ry  Rz  R'   (    (    s   /usr/lib/python2.7/pydoc.pyR¥     sB    			c         C   sz   g  } | j  } | r5 | |  j | É É | d É n  t | É pD d } | rm | |  j | É É | d É n  d j | É S(   Ns   
R   (   R   RÅ  R   RÉ  R   (   R   R+   RK   R=  R  RL  R'   (    (    s   /usr/lib/python2.7/pydoc.pyRO  :  s    	c         C   s   |  j  | | | É S(   s*   Produce text documentation for a property.(   RO  (   R   R$   R+   R=  RH   (    (    s   /usr/lib/python2.7/pydoc.pyR∂   G  s    c         C   s   |  j  | | | É S(   s1   Produce text documentation for a data descriptor.(   RO  (   R   R$   R+   R=  RH   (    (    s   /usr/lib/python2.7/pydoc.pyR∞   K  s    c   
      C   s≤   |  j  | É } | r_ | r% | d p( d | } | t | É }	 |	 d k  r_ | |	  d } q_ n  | rx |  j | É d p{ d | } | d k	 rÆ | d |  j t | É É 7} n  | S(   s-   Produce text documentation for a data object.s    = R   i    s   ...s   
N(   Rª   R&   RÅ  R_   RÉ  Rr   (
   R   R$   R+   R=  R  R8   R'   Rª   R}   t   chop(    (    s   /usr/lib/python2.7/pydoc.pyR∑   O  s     # N(   R   R   RT   R~  R}  Rª   RÅ  RÉ  RÛ   R_   R  R≤   R≥   Rk  R¥   RO  R∂   R∞   R∑   (    (    (    s   /usr/lib/python2.7/pydoc.pyR    s   				dx	+	c         C   s   t  É  a t |  É d S(   sC   The first time this is called, determine what kind of pager to use.N(   t   getpagert   pager(   R4   (    (    s   /usr/lib/python2.7/pydoc.pyRò  ]  s    	c          C   sµ  t  t j É t j k	 r t St t j d É s2 t St j j É  sR t j j É  rV t Sd t	 j
 k r§ t j d k r{ d Ñ  St	 j
 j d É d k rö d Ñ  Sd	 Ñ  Sn  t	 j
 j d É d k r¿ t St j d k s· t j j d
 É rË d Ñ  St t	 d É rt	 j d É d k rd Ñ  St t	 d É r>t	 j d É d k r>d Ñ  Sd d l }  |  j É  \ } } t	 j | É z7 t t	 d É rõt	 j d | É d k rõd Ñ  St SWd t	 j | É Xd S(   s2   Decide what method to use for paging through text.t   isattyt   PAGERR#  c         S   s   t  t |  É t j d É S(   NRö  (   t   tempfilepagert   plainR   RÃ   (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyR(  m  s    t   TERMt   dumbt   emacsc         S   s   t  t |  É t j d É S(   NRö  (   t	   pipepagerRú  R   RÃ   (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyR(  o  s    c         S   s   t  |  t j d É S(   NRö  (   R†  R   RÃ   (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyR(  q  s    t   os2c         S   s   t  t |  É d É S(   Ns   more <(   Rõ  Rú  (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyR(  u  s    t   systems   (pager) 2>/dev/nulli    c         S   s   t  |  d É S(   NRò  (   R†  (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyR(  w  s    s   (less) 2>/dev/nullc         S   s   t  |  d É S(   Nt   less(   R†  (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyR(  y  s    iˇˇˇˇNs	   more "%s"c         S   s   t  |  d É S(   Nt   more(   R†  (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyR(  Ä  s    (   Rû  Rü  (   Rû  Rü  (   Ró   R   t   stdoutRò   t   FileTypet
   plainpagerR^   t   stdinRô  R   RÃ   R2  RÉ   R\   R¢  t   tempfilet   mkstempRã   t   ttypagert   unlink(   R©  t   fdRå   (    (    s   /usr/lib/python2.7/pydoc.pyRó  c  s8     
!$$(c         C   s   t  j d d |  É S(   s%   Remove boldface formatting from text.s   .R   (   R"   R#   (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyRú  Ü  s    c         C   sK   t  j | d É } y! | j t |  É É | j É  Wn t k
 rF n Xd S(   s3   Page through text by feeding it to another program.t   wN(   R   t   popent   writeR!   Rã   RÜ   (   R4   t   cmdt   pipe(    (    s   /usr/lib/python2.7/pydoc.pyR†  ä  s    c         C   sv   d d l  } | j É  } t | d É } | j t |  É É | j É  z t j | d | d É Wd t j | É Xd S(   s<   Page through text by invoking a program on a temporary file.iˇˇˇˇNRÆ  s    "R  (	   R©  t   mktempRÖ   R∞  R!   Rã   R   R¢  R¨  (   R4   R±  R©  Rå   R|   (    (    s   /usr/lib/python2.7/pydoc.pyRõ  ì  s    
c   
      C   s?  t  t t  |  É t t j d t É É É j d É } yD d d l } t j j	 É  } | j
 | É } | j | É d Ñ  } Wn& t t f k
 rü d } d Ñ  } n Xzxy t t j j d d É É } Wn t k
 r€ d } n X| d	 k rÒ d
 } n  | d	 } } t j j t | |  d É d É xÙ | | rt j j d É t j j É  | É  }	 |	 d k rst j j d É Pn8 |	 d k r´t j j d | | d É | d	 } q#n  |	 d k r›| | | } | d k  r›d } q›n  t j j d t | | | | !d É d É | | } q#WWd | r:| j | | j | É n  Xd S(   s%   Page through text on a text terminal.Rl   s   
iˇˇˇˇNc           S   s   t  j j d É S(   Ni   (   R   R®  Rù   (    (    (    s   /usr/lib/python2.7/pydoc.pyR(  ß  s    c           S   s   t  j j É  d  d  S(   Niˇˇˇˇi   (   R   R®  R{   (    (    (    s   /usr/lib/python2.7/pydoc.pyR(  ™  s    t   LINESi    i   i   s
   -- more --t   qt   Qs             s   R   t   Bs   (   Rµ  R∂  (   s   s   
(   R   R∑  s   (   Rú  R!   RG   R   R•  Rq   R   t   ttyR®  t   filenot	   tcgetattrt	   setcbreakR®   R©   R_   R  R   RÃ   RÉ   t
   ValueErrorR∞  R   t   flusht	   tcsetattrt	   TCSAFLUSH(
   R4   R(   R∏  R≠  t   oldt   getchart   hRõ   t   incR   (    (    s   /usr/lib/python2.7/pydoc.pyR´  ü  sL    3
	!	
 ,c         C   s2   t  j j t t |  É t t  j d t É É É d S(   s>   Simply print unformatted text.  This is the ultimate fallback.Rl   N(   R   R•  R∞  R!   Rú  RG   Rq   (   R4   (    (    s   /usr/lib/python2.7/pydoc.pyRß  À  s    c         C   sJ  t  j |  É rT |  j t j k r, d |  j St |  d É rF d |  j Sd |  j Sn  t  j |  É rn d |  j St  j |  É rù d |  j j	 |  j j |  j f St  j
 |  É rÃ d |  j j	 |  j j |  j f St  j |  É rÊ d |  j St  j |  É r d	 |  j St  j |  É rd
 |  j St |  É t j k r=d |  j j St |  É j S(   s/   Produce a short description of the given thing.s   built-in module RV   s   package s   module s   built-in function s   getset descriptor %s.%s.%ss   member descriptor %s.%s.%ss   class s	   function s   method s   instance of (   R   R-   R   R   R•   R^   R7  RØ   t   __objclass__R   R±   R.   R8  R>   Ró   Rò   t   InstanceTypeR„   (   t   thing(    (    s   /usr/lib/python2.7/pydoc.pyt   describeœ  s2    c         C   sﬁ   g  t  |  d É D] } | r | ^ q } d \ } } xQ | t | É k  rá t t | | d  d É | É } | rÉ | | d } } q7 Pq7 W| ró | } n t } x: | | D]. } y t | | É } Wq® t k
 r’ d SXq® W| S(   s@   Locate an object by name or dotted path, importing as necessary.R   i    i   N(   Ni    (   R   R_   R&   R§   R   Rc  RG   R©   (   R   R™   R≠   R?  Rë   t   nt
   nextmoduleR$   (    (    s   /usr/lib/python2.7/pydoc.pyt   locateÏ  s     (  		t   _OldStyleClassc           B   s   e  Z RS(    (   R   R   (    (    (    s   /usr/lib/python2.7/pydoc.pyRÀ    s    c         C   sy   t  |  t É rD t |  | É } | d k r: t d |  Ç n  | |  f St |  d d É } |  t  | t É rn | n d f Sd S(   sD   Given an object or a path to an object, get the object and its name.s$   no Python documentation found for %rR   N(   Rn   Rr   R   R_   R®   RG   (   R∆  R™   R$   R+   (    (    s   /usr/lib/python2.7/pydoc.pyt   resolve  s    
s    Python Library Documentation: %sc         C   s3  t  |  | É \ } } t | É } t j | É } | r` d | k r` | d | | j d É  7} n& | rÜ | | k	 rÜ | d | j 7} n  t | É t k r§ | j } ns t j	 | É p˚ t j
 | É p˚ t j | É p˚ t j | É p˚ t j | É p˚ t | t É st | É } | d 7} n  | | d t j | | É S(   sB   Render text documentation, given an object or a path to an object.R   s    in s    in module s    objects   

(   RÃ  R«  R   R6  R   R   Ró   t   _OLD_INSTANCE_TYPER„   R-   R.   R/   RØ   R±   Rn   Rµ   R4   Rπ   (   R∆  RË   R™   R$   R+   Rí  Rë   (    (    s   /usr/lib/python2.7/pydoc.pyt
   render_doc  s$    c         C   s?   y t  t |  | | É É Wn t t f k
 r: } | GHn Xd S(   sC   Display text documentation, given an object or a path to an object.N(   Rò  RŒ  R®   Rì   (   R∆  RË   R™   RK   (    (    s   /usr/lib/python2.7/pydoc.pyR'   +  s    c         C   sô   yt t  |  | É \ } } t j t | É t j | | É É } t | d d É } | j | É | j É  d G| d GHWn t t	 f k
 rî } | GHn Xd S(   s<   Write HTML documentation to a file in the current directory.s   .htmlRÆ  t   wroteN(
   RÃ  t   htmlRÍ   R«  Rπ   RÖ   R∞  Rã   R®   Rì   (   R∆  R™   R$   R+   RÍ   R|   RK   (    (    s   /usr/lib/python2.7/pydoc.pyt   writedoc2  s    $
R   c         C   sL   | d k r i  } n  x0 t j |  g | É D] \ } } } t | É q+ Wd S(   sA   Write out HTML documentation for all modules in a directory tree.N(   R_   R9  t   walk_packagesR—  (   R   t   pkgpatht   doneRG  R*   RH  (    (    s   /usr/lib/python2.7/pydoc.pyt	   writedocs>  s
     	%t   Helperc           B   s÷  e  Z i d  d 6d d 6d(d 6d)d 6d*d 6d+d
 6d,d 6d-d 6d d 6d.d 6d d 6d/d 6d d 6d0d 6d d 6d1d 6d2d 6d3d 6d4d 6d  d! 6d5d" 6d  d$ 6d  d% 6d6d& 6d7d' 6d8d( 6d9d* 6d:d 6d;d+ 6d<d 6d=d. 6Z i d>d7 6d?dL 6d@d  6dAdM 6dBdZ 6dCd[ 6dDd^ 6Z i d_ d> 6d` d; 6da db 6dc dd 6de df 6dg dh 6di dj 6d7 dk 6dl dm 6dn do 6dp dq 6dr ds 6dr dt 6du dv 6du dw 6Z xd e j É  D]V \ Z Z xG e D]? Z e j	 e e É Z
 e e
 k r‡e
 dx e Z
 n  e
 e e <q´WqòWiN dEd{ 6dFd7 6dGdÄ 6dHdÇ 6dIdÑ 6dJdá 6dKdä 6dLdç 6dMd^ 6dNdí 6dì dî 6dOd# 6dPdô 6dQdú 6dRdü 6d{ d† 6d{ d° 6dSd£ 6dTde 6dUdß 6dVd© 6dWd´ 6dXd 6d d≠ 6dYd∞ 6d∞ dL 6d∞ d± 6dZd≥ 6d[d∂ 6d\d 6d]dª 6d^dæ 6d_d¡ 6d`d 6dad≈ 6dbd» 6dcdÀ 6ddd 6dedœ 6d d– 6d d— 6dfd) 6dgd÷ 6dhd’ 6did⁄ 6djd‹ 6dkdl 6dld‡ 6dí d· 6dmd‰ 6dndÁ 6dodÊ 6dpdì 6dqdÎ 6drdp 6dsdÚ 6dtdÙ 6dud• 6dvd˜ 6dwd` 6dxdM 6dyd˚ 6dzd˝ 6d{d[ 6d|d  6d}d  6d d6d~d6ddZ 6d d6d' d6d* d	6d d
6d d6dÄd6dÅd 6dÇd6dÉd6Z
 dÑdÑdÑ Z e dÑ  É Z e dÑ  É Z dÑ  Z e É  Z e dÑ Z dÑ  Z dÑ  Z dÑ  Z dÑ  Z dd d!Ñ Z d"Ñ  Z d#Ñ  Z d$Ñ  Z d d%Ñ Z d&Ñ  Z d d'Ñ Z RS(Ö  t   BOOLEANt   andt   witht   ast   assertR   t   breaks	   while fort   classs   CLASSES SPECIALMETHODSt   continuet   functiont   deft   delt   BASICMETHODSt   ift   elift   elset   tryt   exceptt   exect   finallyt   fors   break continue whilet   importt   fromt   globalt
   NAMESPACESt
   TRUTHVALUEt   MODULESt   int   SEQUENCEMETHODS2t
   COMPARISONt   ist   lambdaRâ  t   nott   ort   passt   printt   raiset
   EXCEPTIONSt   returnt   whiles   break continue if TRUTHVALUEs    CONTEXTMANAGERS EXCEPTIONS yieldt   yieldt   's   '''s   r's   u's   """R  s   r"s   u"t   STRINGSt   +RZ  t   *s   **R    s   //t   %s   <<s   >>Rÿ   t   |t   ^t   ~RŸ   R⁄   s   <=s   >=s   ==s   !=s   <>t	   OPERATORSt   UNARYs   +=s   -=s   *=s   /=s   %=s   &=s   |=s   ^=s   <<=s   >>=s   **=s   //=t   AUGMENTEDASSIGNMENTt   BITWISEt   jt   Jt   COMPLEXs   OPERATORS FORMATTINGt   POWERs   TUPLES LISTS FUNCTIONSt   ,s    ATTRIBUTES FLOAT MODULES OBJECTSR   t   ELLIPSISs   ...s   SLICINGS DICTIONARYLITERALSt   :s	   def classt   @s   \t   PRIVATENAMESRZ   s   PRIVATENAMES SPECIALMETHODSRY   t
   BACKQUOTESt   `s   TUPLES FUNCTIONS CALLSR  R  s   LISTS SUBSCRIPTS SLICINGSt   [t   ]R∫   Rò   sR   STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS FUNCTIONS CLASSES MODULES FILES inspectt   TYPESt   stringss4   str UNICODE SEQUENCES STRINGMETHODS FORMATTING TYPESs   string-methodss   STRINGS FORMATTINGt   STRINGMETHODSt   formatstringst
   FORMATTINGs:   encodings unicode SEQUENCES STRINGMETHODS FORMATTING TYPESt   UNICODEt   numberss   INTEGER FLOAT COMPLEX TYPESt   NUMBERSt   integerss	   int ranget   INTEGERt   floatings
   float matht   FLOATt	   imaginarys   complex cmatht   typesseqs%   STRINGMETHODS FORMATTING xrange LISTSt	   SEQUENCESt   DICTIONARIESt   MAPPINGSt   typesfunctionss	   def TYPESt   typesmethodss   class def CLASSES TYPESt   METHODSs   bltin-code-objectss   compile FUNCTIONS TYPESt   CODEOBJECTSs   bltin-type-objectss   types TYPESt   TYPEOBJECTSt   FRAMEOBJECTSt
   TRACEBACKSs   bltin-null-objectt   NONEs   bltin-ellipsis-objectt   SLICINGSs   bltin-file-objectst   FILESt   specialattrst   SPECIALATTRIBUTESs!   class SPECIALMETHODS PRIVATENAMESRà  t   typesmodulest   PACKAGESs   operator-summarys£   lambda or and not in is BOOLEAN COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES LISTS DICTIONARIES BACKQUOTESt   EXPRESSIONSt
   PRECEDENCEt   objectst   OBJECTSt   specialnamesst   BASICMETHODS ATTRIBUTEMETHODS CALLABLEMETHODS SEQUENCEMETHODS1 MAPPINGMETHODS SEQUENCEMETHODS2 NUMBERMETHODS CLASSESt   SPECIALMETHODSt   customizations    cmp hash repr str SPECIALMETHODSs   attribute-accesss   ATTRIBUTES SPECIALMETHODSt   ATTRIBUTEMETHODSs   callable-typess   CALLS SPECIALMETHODSt   CALLABLEMETHODSs   sequence-typess)   SEQUENCES SEQUENCEMETHODS2 SPECIALMETHODSt   SEQUENCEMETHODS1s   sequence-methodss)   SEQUENCES SEQUENCEMETHODS1 SPECIALMETHODSs   MAPPINGS SPECIALMETHODSt   MAPPINGMETHODSs   numeric-typess*   NUMBERS AUGMENTEDASSIGNMENT SPECIALMETHODSt   NUMBERMETHODSt	   execmodels%   NAMESPACES DYNAMICFEATURES EXCEPTIONSt	   EXECUTIONt   namings*   global ASSIGNMENT DELETION DYNAMICFEATURESs   dynamic-featurest   DYNAMICFEATURESt   SCOPINGt   FRAMESR√   s   try except finally raises   coercion-rulest   CONVERSIONSt	   COERCIONSt   conversionst   identifierss   keywords SPECIALIDENTIFIERSt   IDENTIFIERSs
   id-classest   SPECIALIDENTIFIERSs   atom-identifierss   atom-literalssH   STRINGS BACKQUOTES NUMBERS TUPLELITERALS LISTLITERALS DICTIONARYLITERALSt   LITERALSt   TUPLESt	   exprlistss   TUPLES LITERALSt   TUPLELITERALSs   typesseq-mutablet   LISTLITERALSt   LISTSt   listss   LISTS LITERALSt   typesmappingt   DICTIONARYLITERALSR   s   DICTIONARIES LITERALSs   string-conversionss   repr str STRINGS LITERALSs   attribute-referencess(   getattr hasattr setattr ATTRIBUTEMETHODSt
   ATTRIBUTESt   subscriptionst
   SUBSCRIPTSt   slicingst   callst   CALLSt   powert   unaryt   binaryt   BINARYt   shiftingt   SHIFTINGt   bitwiset   comparisonss   EXPRESSIONS BASICMETHODSt   booleanss   EXPRESSIONS TRUTHVALUEt	   ASSERTIONt
   assignmentt
   ASSIGNMENTt	   augassignt   DELETIONt   PRINTINGt	   RETURNINGt	   IMPORTINGt   CONDITIONALt   compounds   for while break continuet   LOOPINGt   truths    if while and or not BASICMETHODSt   debuggert   pdbt	   DEBUGGINGs   context-managerst   CONTEXTMANAGERSc         C   s   | |  _  | |  _ d  S(   N(   t   _inputt   _output(   R   t   inputt   output(    (    s   /usr/lib/python2.7/pydoc.pyRt   ˆ  s    	c         C   s   |  j  p t j S(   N(   Rw  R   R®  (   R   (    (    s   /usr/lib/python2.7/pydoc.pyR(  ˙  s    c         C   s   |  j  p t j S(   N(   Rx  R   R•  (   R   (    (    s   /usr/lib/python2.7/pydoc.pyR(  ˚  s    c         C   s)   t  j É  d d d k r% |  É  d Sd S(   Ni   i   t   ?R   s   <pydoc.Helper instance>(   R   t   stack(   R   (    (    s   /usr/lib/python2.7/pydoc.pyt   __repr__˝  s    c         C   sG   | |  j  k	 r |  j | É n$ |  j É  |  j É  |  j j d É d  S(   Ns  
You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type "help(object)".  Executing "help('string')"
has the same effect as typing a particular string at the help> prompt.
(   t   _GoInteractivet   helpt   introt   interactRz  R∞  (   R   t   request(    (    s   /usr/lib/python2.7/pydoc.pyRX    s    

	c         C   sö   |  j  j d É xÉ t rï y |  j d É } | s5 Pn  Wn t t f k
 rP Pn Xt t | d d d d É É } t | É d k rÖ Pn  |  j	 | É q Wd  S(	   Ns   
s   help> R  R   Rˇ  Rµ  t   quit(   Rµ  RÉ  (
   Rz  R∞  Rv   t   getlinet   KeyboardInterruptt   EOFErrorR   R6   R   R  (   R   RÇ  (    (    s   /usr/lib/python2.7/pydoc.pyRÅ    s    	  c         C   sJ   |  j  t j k r t | É S|  j j | É |  j j É  |  j  j É  Sd S(   s.   Read one line, using raw_input when available.N(   Ry  R   R®  t	   raw_inputRz  R∞  RΩ  R{   (   R   t   prompt(    (    s   /usr/lib/python2.7/pydoc.pyRÑ    s
    
c         C   s{  t  | É t  d É k rA| j É  } | d k r= |  j É  qg| d k rV |  j É  qg| d k ro |  j É  qg| d k rà |  j É  qg| d k r° |  j É  qg| d  d k rÀ |  j t | É d	 É qg| |  j k rÍ |  j	 | É qg| |  j
 k r	|  j | É qg| |  j k r(|  j | É qg| rgt | d
 É qgn& t | t É rZ|  É  n t | d
 É |  j j d É d  S(   NR   R  t   keywordst   symbolst   topicsRä   i   s   modules i   s   Help on %s:s   
(   Ró   R   RÄ  t   listkeywordst   listsymbolst
   listtopicst   listmodulesR   Rä  t
   showsymbolRâ  t	   showtopicRã  R'   Rn   R÷  Rz  R∞  (   R   RÇ  (    (    s   /usr/lib/python2.7/pydoc.pyR  &  s4              
c         C   s,   |  j  j d t t j d  g d É É d  S(   Nsà  
Welcome to Python %s!  This is the online help utility.

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at http://docs.python.org/%s/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, or topics, type "modules",
"keywords", or "topics".  Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as "spam", type "modules spam".
i   i   (   Rz  R∞  t   tupleR   R—   (   R   (    (    s   /usr/lib/python2.7/pydoc.pyRÄ  8  s    	i   iP   c   	   	   C   sÈ   | } | j  É  | | } t | É | d | } xØ t | É D]° } xà t | É D]z } | | | } | t | É k  rS |  j j | | É | | d k  rÕ |  j j d d | d t | | É É qÕ qS qS W|  j j d É q@ Wd  S(   Ni   R∫   s   
(   R;  R&   Rˆ   Rz  R∞  (	   R   t   itemst   columnsRÔ   t   colwR˙   t   rowR˚   R¸   (    (    s   /usr/lib/python2.7/pydoc.pyR˜   I  s    

4c         C   s*   |  j  j d É |  j |  j j É  É d  S(   NsN   
Here is a list of the Python keywords.  Enter any keyword to get more help.

(   Rz  R∞  R˜   Râ  RF   (   R   (    (    s   /usr/lib/python2.7/pydoc.pyRå  W  s    	c         C   s*   |  j  j d É |  j |  j j É  É d  S(   Nsx   
Here is a list of the punctuation symbols which Python assigns special meaning
to. Enter any symbol to get more help.

(   Rz  R∞  R˜   Rä  RF   (   R   (    (    s   /usr/lib/python2.7/pydoc.pyRç  ^  s    	c         C   s*   |  j  j d É |  j |  j j É  É d  S(   NsN   
Here is a list of available topics.  Enter any topic name to get more help.

(   Rz  R∞  R˜   Rã  RF   (   R   (    (    s   /usr/lib/python2.7/pydoc.pyRé  f  s    	c         C   sö  y d d  l  } Wn" t k
 r4 |  j j d É d  SX|  j j | |  j j | É É } | sz |  j j d t | É É d  St | É t d É k r¢ |  j	 | | É S| \ } } y | j j | } Wn, t
 k
 r |  j j d t | É É d  SXt t | É d É | r"| pd d | } n  | rñd d  l } d d  l }	 | j É  }
 |	 j |
 É j d t t | É d É d É |  j j d	 |
 j É  É n  d  S(
   Niˇˇˇˇst   
Sorry, topic and keyword documentation is not available because the
module "pydoc_data.topics" could not be found.
s   no documentation found for %s
R   s   
R∫   s   Related help topics: s   , s   
%s
(   t   pydoc_data.topicsR®   Rz  R∞  Rã  RÉ   Râ  Rª   Ró   Rë  t   KeyErrorRò  R   t   StringIOt	   formattert
   DumbWritert   send_flowing_dataR   R   t   getvalue(   R   t   topict
   more_xrefst
   pydoc_datat   targett   labelt   xrefsR'   Rô  Rö  t   buffer(    (    s   /usr/lib/python2.7/pydoc.pyRë  m  s6    	!c         C   s9   |  j  | } | j d É \ } } } |  j | | É d  S(   NR∫   (   Rä  t	   partitionRë  (   R   t   symbolR°  Rû  RZ   R£  (    (    s   /usr/lib/python2.7/pydoc.pyRê  ç  s    c            së   | r# |  j  j d É t | É nj |  j  j d É i  } | d Ñ â  á  f d Ü  } t É  j à  d | É|  j | j É  É |  j  j d É d  S(   NsO   
Here is a list of matching modules.  Enter any module name to get more help.

sI   
Please wait a moment while I gather a list of all available modules...

c         S   sM   | r' | d d k r' | d  d } n  t  | d É d k  rI d | | <n  d  S(   Ni˜ˇˇˇs	   .__init__s
    (package)R   i    i   (   R   (   R   R*   Rí  Rä   (    (    s   /usr/lib/python2.7/pydoc.pyt   callbackü  s    c            s   à  d  |  d  É d  S(   N(   R_   (   R*   (   Rß  (    s   /usr/lib/python2.7/pydoc.pyt   onerror§  s    R®  sÑ   
Enter any module name to get more help.  Or, type "modules spam" to search
for modules whose descriptions contain the word "spam".
(   Rz  R∞  t   apropost   ModuleScannert   runR˜   RF   (   R   RJ   Rä   R®  (    (   Rß  s   /usr/lib/python2.7/pydoc.pyRè  í  s    			(   R€  R   (   R‹  s	   while for(   R›  s   CLASSES SPECIALMETHODS(   Rﬁ  s	   while for(   Rﬂ  R   (   R·  R‚  (   RÂ  s	   while for(   RË  R   (   RÍ  s   break continue while(   RÌ  RÓ  (   R„  RÔ  (   RÎ  R  (   RÒ  RÚ  (   Rı  Râ  (   R¯  R   (   R˘  R   (   R˙  R˚  (   R¸  Râ  (   RÊ  R˚  (   R˝  s   break continue if TRUTHVALUE(   RŸ  s    CONTEXTMANAGERS EXCEPTIONS yield(   R˛  R   (   Rˇ  s   '''s   r's   u's   """R  s   r"s   u"(   R  RZ  R  s   **R    s   //R  s   <<s   >>Rÿ   R  R  R  RŸ   R⁄   s   <=s   >=s   ==s   !=s   <>(   RŸ   R⁄   s   <=s   >=s   ==s   !=s   <>(   RZ  R  (   s   +=s   -=s   *=s   /=s   %=s   &=s   |=s   ^=s   <<=s   >>=s   **=s   //=(   s   <<s   >>Rÿ   R  R  R  (   R  R  (   Rò   sR   STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS FUNCTIONS CLASSES MODULES FILES inspect(   R  s4   str UNICODE SEQUENCES STRINGMETHODS FORMATTING TYPES(   s   string-methodss   STRINGS FORMATTING(   R  R  (   R  s:   encodings unicode SEQUENCES STRINGMETHODS FORMATTING TYPES(   R  s   INTEGER FLOAT COMPLEX TYPES(   R   s	   int range(   R"  s
   float math(   R$  s   complex cmath(   R%  s%   STRINGMETHODS FORMATTING xrange LISTS(   R)  s	   def TYPES(   R*  s   class def CLASSES TYPES(   s   bltin-code-objectss   compile FUNCTIONS TYPES(   s   bltin-type-objectss   types TYPES(   s   bltin-null-objectR   (   s   bltin-ellipsis-objectR1  (   s   bltin-file-objectsR   (   R3  R   (   Rò   s!   class SPECIALMETHODS PRIVATENAMES(   R5  RÎ  (   s   operator-summarys£   lambda or and not in is BOOLEAN COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES LISTS DICTIONARIES BACKQUOTES(   R9  R  (   R;  st   BASICMETHODS ATTRIBUTEMETHODS CALLABLEMETHODS SEQUENCEMETHODS1 MAPPINGMETHODS SEQUENCEMETHODS2 NUMBERMETHODS CLASSES(   R=  s    cmp hash repr str SPECIALMETHODS(   s   attribute-accesss   ATTRIBUTES SPECIALMETHODS(   s   callable-typess   CALLS SPECIALMETHODS(   s   sequence-typess)   SEQUENCES SEQUENCEMETHODS2 SPECIALMETHODS(   s   sequence-methodss)   SEQUENCES SEQUENCEMETHODS1 SPECIALMETHODS(   s   sequence-typess   MAPPINGS SPECIALMETHODS(   s   numeric-typess*   NUMBERS AUGMENTEDASSIGNMENT SPECIALMETHODS(   RC  s%   NAMESPACES DYNAMICFEATURES EXCEPTIONS(   RE  s*   global ASSIGNMENT DELETION DYNAMICFEATURES(   s   dynamic-featuresR   (   R√   s   try except finally raise(   s   coercion-rulesRI  (   RK  RJ  (   RL  s   keywords SPECIALIDENTIFIERS(   s
   id-classesR   (   s   atom-identifiersR   (   s   atom-literalssH   STRINGS BACKQUOTES NUMBERS TUPLELITERALS LISTLITERALS DICTIONARYLITERALS(   RQ  s   TUPLES LITERALS(   s   typesseq-mutableRS  (   RU  s   LISTS LITERALS(   RV  RW  (   R   s   DICTIONARIES LITERALS(   s   string-conversionss   repr str STRINGS LITERALS(   s   attribute-referencess(   getattr hasattr setattr ATTRIBUTEMETHODS(   RY  R@  (   R[  RÚ  (   R\  R7  (   R^  R7  (   R_  R7  (   R`  R7  (   Rb  R7  (   Rd  R7  (   Re  s   EXPRESSIONS BASICMETHODS(   Rf  s   EXPRESSIONS TRUTHVALUE(   Rh  R	  (   Rj  RB  (   Rp  s   for while break continue(   Rr  s    if while and or not BASICMETHODS(   Rs  Rt  (   s   context-managersRŸ  N(   R   R   Râ  t   _symbols_inverseRä  t	   iteritemsRû  t   symbols_R¶  RÉ   Rã  R_   Rt   Rµ   Ry  Rz  R}  R$   R~  RX  RÅ  RÑ  R  RÄ  R˜   Rå  Rç  Ré  Rë  Rê  Rè  (    (    (    s   /usr/lib/python2.7/pydoc.pyR÷  E  s@  
  


										 	t   Scannerc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s   A generic tree iterator.c         C   s)   | |  _  g  |  _ | |  _ | |  _ d  S(   N(   t   rootst   statet   childrent   descendp(   R   R∞  R≤  R≥  (    (    s   /usr/lib/python2.7/pydoc.pyRt   ±  s    
		c         C   s∫   |  j  sF |  j s d  S|  j j d É } | |  j | É f g |  _  n  |  j  d \ } } | sv |  j  j É  |  j É  S| j d É } |  j | É r∂ |  j  j | |  j | É f É n  | S(   Ni    iˇˇˇˇ(   R±  R∞  R_   R   R≤  t   nextR≥  R   (   R   t   roott   nodeR≤  t   child(    (    s   /usr/lib/python2.7/pydoc.pyR¥  ∑  s    		
"(   R   R   RT   Rt   R¥  (    (    (    s   /usr/lib/python2.7/pydoc.pyRØ  Ø  s   	R™  c           B   s    e  Z d  Z d d d d Ñ Z RS(   s7   An interruptible scanner that searches module synopses.c         C   s  | r t  | É } n  t |  _ i  } x° t j D]ñ } | d k r. d | | <| d  k ri | d  | d É qƒ t t | É j p~ d d É d } t	 t  | d | É | É d k rƒ | d  | | É qƒ q. q. Wx@t
 j d | É D],\ } } }	 |  j r˜ Pn  | d  k r| d  | d É q€ | j | É }
 t |
 d É réd	 d  l } t | j |
 j | É É É pad } t |
 d
 É rÖ|
 j | É } q—d  } nC |
 j | É } | j rπ| j j É  d n d } t | d d  É } t	 t  | d | É | É d k r€ | | | | É q€ q€ W| r| É  n  d  S(   Nt   __main__i   R   s   
i    s    - R®  t
   get_sourceiˇˇˇˇt   get_filenameRU   (   R   Rw   RÉ  R   R•   R_   R   R¶   RT   R   R9  R“  t   find_moduleR^   Rô  R~   Rπ  R∫  Rà   Râ   RG   (   R   Rß  RJ   t	   completerR®  t   seenR*   Rí  RG  RH  t   loaderRô  R   Rë   (    (    s   /usr/lib/python2.7/pydoc.pyR´     sB     	
"#"		"#N(   R   R   RT   R_   R´  (    (    (    s   /usr/lib/python2.7/pydoc.pyR™  «  s   c      	   C   sO   d Ñ  } d Ñ  } t  j É  è+ t  j d É t É  j | |  d | ÉWd QXd S(   sA   Print all the one-line module summaries that contain a substring.c         S   s8   | d d k r! | d  d } n  | G| o2 d | GHd  S(   Ni˜ˇˇˇs	   .__init__s
    (package)s   - (    (   R   R*   Rí  (    (    s   /usr/lib/python2.7/pydoc.pyRß  ı  s    c         S   s   d  S(   N(    (   R*   (    (    s   /usr/lib/python2.7/pydoc.pyR®  ˘  s    t   ignoreR®  N(   t   warningst   catch_warningst   filterwarningsR™  R´  (   RJ   Rß  R®  (    (    s   /usr/lib/python2.7/pydoc.pyR©  Û  s
    		c   	      C   s›   d d  l  } d d  l } d d  l } d | j f d Ñ  É  Y} d | j f d Ñ  É  Y} d | j f d Ñ  É  Y} | j | _ | | _ | | _ z8 y | |  | É j	 É  Wn t
 | j f k
 r√ n XWd  | rÿ | É  n  Xd  S(   Niˇˇˇˇt   Messagec           B   s   e  Z d  d Ñ Z RS(   i   c         S   sf   |  j  } | j d j d j |  | | É |  j d É |  _ |  j d É |  _ |  j É  |  j É  d  S(   Ni    s   content-transfer-encodings   content-type(   R„   RC   Rt   t	   getheadert   encodingheadert
   typeheadert	   parsetypet
   parseplist(   R   t   fpt   seekableR√  (    (    s   /usr/lib/python2.7/pydoc.pyRt     s    	!
(   R   R   Rt   (    (    (    s   /usr/lib/python2.7/pydoc.pyR√    s   t
   DocHandlerc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         S   s_   yG |  j  d É |  j d d É |  j É  |  j j t j | | É É Wn t k
 rZ n Xd  S(   Ni»   s   Content-Types	   text/html(   t   send_responset   send_headert   end_headerst   wfileR∞  R–  RÍ   RÜ   (   R   RË   RÈ   (    (    s   /usr/lib/python2.7/pydoc.pyt   send_document  s    
  c         S   s®  |  j  } | d d k r& | d  } n  | d  d k rC | d } n  | rÈ | d k rÈ y t | d d É} Wn3 t k
 r† } |  j | t j t | É É É d  SX| rÃ |  j t | É t j | | É É q§|  j | d t	 | É É nª t j
 d d	 d
 É } d Ñ  } t d Ñ  t j É } t j | | É } d t j d d	 d | É g } i  }	 x* t j  D] }
 | j t j |
 |	 É É q]W| t | É d } |  j d | É d  S(   Ni˚ˇˇˇs   .htmli   R    R   R™   s$   no Python documentation found for %ss?   <big><big><strong>Python: Index of Modules</strong></big></big>s   #ffffffs   #7799eec         S   s   d |  |  f S(   Ns   <a href="%s.html">%s</a>(    (   R+   (    (    s   /usr/lib/python2.7/pydoc.pyt	   bltinlink*  s    c         S   s
   |  d k S(   NR∏  (    (   RQ   (    (    s   /usr/lib/python2.7/pydoc.pyR(  ,  s    s   <p>s   Built-in Moduless   #ee77aasÄ   <p align=right>
<font color="#909090" face="helvetica, arial"><strong>
pydoc</strong> by Ka-Ping Yee &lt;ping@lfw.org&gt;</font>s   Index of Modules(   R   R   Rì   R–  R–  R€   Rr   R«  Rπ   Rª   RÓ   Rb  R   R•   R˝   RÙ   R   R|  R   (   R   R   R@   RK   RÓ   R—  t   namesRÈ   t   indicesRΩ  R   (    (    s   /usr/lib/python2.7/pydoc.pyt   do_GET  s<    	  %				c         W   s   d  S(   N(    (   R   R∏   (    (    s   /usr/lib/python2.7/pydoc.pyt   log_message:  s    (   R   R   R–  R‘  R’  (    (    (    s   /usr/lib/python2.7/pydoc.pyRÀ    s   		#t	   DocServerc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         S   s>   d } | | f |  _  | |  _ |  j j |  |  j  |  j É d  S(   Nt	   localhost(   t   addressRß  RL   Rt   t   handler(   R   t   portRß  t   host(    (    s   /usr/lib/python2.7/pydoc.pyRt   =  s    	c         S   si   d d  l  } t |  _ xM |  j sd | j  |  j j É  g g  g  d É \ } } } | r |  j É  q q Wd  S(   Niˇˇˇˇi   (   t   selectRw   RÉ  t   socketRπ  t   handle_request(   R   R‹  t   rdt   wrt   ex(    (    s   /usr/lib/python2.7/pydoc.pyt   serve_until_quitC  s    	- c         S   sJ   |  j  j |  É d |  j d |  j f |  _ |  j rF |  j |  É n  d  S(   Ns   http://%s:%d/i    (   RL   t   server_activateRÿ  t   server_portR  Rß  (   R   (    (    s   /usr/lib/python2.7/pydoc.pyR„  J  s    	 (   R   R   Rt   R‚  R„  (    (    (    s   /usr/lib/python2.7/pydoc.pyR÷  <  s   		(   t   BaseHTTPServert	   mimetoolsR‹  R√  t   BaseHTTPRequestHandlert
   HTTPServerRL   RŸ  t   MessageClassR‚  RÖ  t   error(	   R⁄  Rß  Rº  RÂ  RÊ  R‹  R√  RÀ  R÷  (    (    s   /usr/lib/python2.7/pydoc.pyt   serve  s    $	.		 c          C   so   d d d Ñ  É  Y}  d d l  } y8 | j É  } z |  | É } | j É  Wd | j É  XWn t k
 rj n Xd S(   sE   Graphical interface (starts web server and pops up a control window).t   GUIc           B   sò   e  Z d  d Ñ Z d Ñ  Z d d d Ñ Z d d Ñ Z d d Ñ Z d Ñ  Z d d Ñ Z	 d Ñ  Z
 d d	 Ñ Z d d
 Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z RS(   i(  c      
   S   sì  | |  _  d  |  _ d  |  _ d d  l } | j | É |  _ | j |  j d d É|  _ | j	 |  j d d d |  j
 d d É|  _ | j	 |  j d d d |  j d d É|  _ | j | É |  _ | j |  j d d	 É|  _ | j |  j É |  _ |  j j d
 |  j É | j	 |  j d d d d d |  j d d É|  _ t j d k rU|  j j d d É n  |  j  j d É |  j  j d |  j É |  j j d d d d É |  j j d d d d d d É |  j j d d d d d d É |  j j d d d d É |  j j d d É |  j j d d d d d d É |  j j d d d d É |  j j É  d t j d k r[d p^d f } | j | d | d d É|  _ |  j j d |  j É |  j j d  |  j É | j  | d! d" d |  j j! É|  _" |  j j# d# |  j" j$ É | j | É |  _% | j	 |  j% d d$ d |  j É|  _& | j	 |  j% d d% d |  j' É|  _( |  j& j d d d d d d É |  j( j d d d d d d É |  j  j) É  |  j  j* É  |  _+ |  j  j, É  |  _- |  j j. É  |  j j. É  |  j j. É  |  j% j. É  |  _/ |  j+ |  j/ |  _0 |  _1 d |  _2 |  j  j3 d& |  j+ |  j- f É |  j  j4 |  j+ |  j- É |  j  j5 j6 É  d d  l7 } | j8 d' t9 d( | |  j: |  j f É j; É  d  S()   NiˇˇˇˇR4   s   Starting server...
 s   open browsert   commandR±  t   disableds   quit servings
   Search fors   <Return>t   stopt   padyi    R#  t   sidet   rightt   pydoct   WM_DELETE_WINDOWt   topt   fillRQ   t   leftt   expandi   t	   helveticai   i
   t   fontt   heighti   s
   <Button-1>s   <Double-Button-1>t   orientt   verticalt   yscrollcommands   go to selecteds   hide resultss   %dx%dR°  R∏   (<   t   windowR_   t   servert   scannert   Tkintert   Framet
   server_frmt   Labelt	   title_lblt   ButtonRÖ   t   open_btnRÉ  t   quit_btnt
   search_frmt
   search_lblt   Entryt
   search_entt   bindR
  RÔ  t   stop_btnR   R2  t   packRË   t   protocolt	   focus_sett   Listboxt
   result_lstR‹  t   gotot	   Scrollbart   yviewt
   result_scrt   configRè  t
   result_frmt   goto_btnt   hidet   hide_btnRD   t   winfo_widtht   minwidtht   winfo_heightt	   minheightt   winfo_reqheightt   bigminheightt   bigwidtht	   bigheightt   expandedt   wm_geometryt
   wm_minsizet   tkt   willdispatcht	   threadingt   ThreadRÎ  t   readyR  (   R   Rˇ  R⁄  R  R˙  R+  (    (    s   /usr/lib/python2.7/pydoc.pyRt   _  sp    			!!&	 	c         S   sM   | |  _  |  j j d d | j É |  j j d d É |  j j d d É d  S(   NR4   s   Python documentation server at
R±  t   normal(   R   R  R  R  R  R	  (   R   R   (    (    s   /usr/lib/python2.7/pydoc.pyR-  §  s
    	c         S   só   | p |  j  j } y d d  l } | j | É Wna t k
 rí t j d k rb t j d | É qì t j d | É } | rì t j d | É qì n Xd  S(   NiˇˇˇˇR#  s
   start "%s"s    netscape -remote "openURL(%s)" &s   netscape "%s" &(	   R   R  t
   webbrowserRÖ   R®   R   R2  R   R¢  (   R   t   eventR  R/  t   rc(    (    s   /usr/lib/python2.7/pydoc.pyRÖ   ´  s     c         S   s)   |  j  r d |  j  _ n  |  j j É  d  S(   Ni   (   R   RÉ  Rˇ  (   R   R0  (    (    s   /usr/lib/python2.7/pydoc.pyRÉ  ∑  s    	c      	   S   s  |  j  j É  } |  j j d d É |  j j d d É |  j j d d | É |  j  j É  |  j j d d É |  j j d d	 É |  j	 j d d
 É |  j
 É  d d  l } |  j r¿ d |  j _ n  t É  |  _ d Ñ  } | j d |  j j d |  j | |  j f d t d | É É j É  d  S(   NRÒ  RÚ  R±  R.  R4   s   Searching for "%s"...R˜  i    R  RÓ  iˇˇˇˇi   c         S   s   d  S(   N(    (   R*   (    (    s   /usr/lib/python2.7/pydoc.pyR®  À  s    R°  R∏   t   kwargsR®  (   R  RÉ   R  R  R  R  t   forgetR  t   deleteR  R¯  R+  R  RÉ  R™  R,  R´  RD   R‘  R   R  (   R   R0  RJ   R+  R®  (    (    s   /usr/lib/python2.7/pydoc.pyR
  º  s"    
		c         S   sF   | d d k r! | d  d } n  |  j  j d | d | p= d É d  S(   Ni˜ˇˇˇs	   .__init__s
    (package)R  s    - s   (no description)(   R  t   insert(   R   R   R*   Rí  (    (    s   /usr/lib/python2.7/pydoc.pyRD   —  s    c         S   s%   |  j  r! d |  j  _ d  |  _  n  d  S(   Ni   (   R  RÉ  R_   (   R   R0  (    (    s   /usr/lib/python2.7/pydoc.pyRÔ  ◊  s    	c         S   sÑ   d  |  _ |  j j d d É |  j j d d É |  j j d d d d d d	 É t j d
 k rm |  j j	 É  n  |  j j d d É d  S(   NR4   s
   Search forRÒ  R˜  RÚ  Rˆ  RQ   R¯  i   R#  R±  RÓ  (
   R_   R  R  R  R  R  R   R2  R  R3  (   R   (    (    s   /usr/lib/python2.7/pydoc.pyR‘  ‹  s    	 c         S   s   |  j  j d d É d  S(   NR±  R.  (   R  R  (   R   R0  (    (    s   /usr/lib/python2.7/pydoc.pyR‹  ‰  s    c         S   sZ   |  j  j É  } | rV t |  j  j | d É É d } |  j d |  j j | d É n  d  S(   Ni    R  s   .html(   R  t   curselectionR   RÉ   RÖ   R   R  (   R   R0  t	   selectionR*   (    (    s   /usr/lib/python2.7/pydoc.pyR  Á  s     c         S   sû   |  j  s d  S|  j j É  |  j j É  |  j j É  |  j j É  |  _ |  j j É  |  _	 |  j j
 d |  j |  j f É |  j j |  j |  j É d |  _  d  S(   Ns   %dx%di    (   R&  R  R3  R  R  Rˇ  R  R$  R   R%  R'  R  R!  R(  (   R   (    (    s   /usr/lib/python2.7/pydoc.pyt   collapseÌ  s    	  c         S   s§   |  j  r d  S|  j j d d d d É |  j j d d d d É |  j j d d d d d	 d
 É |  j j d |  j |  j f É |  j j	 |  j
 |  j É d
 |  _  d  S(   NRÒ  t   bottomRˆ  RQ   RÚ  t   yRı  t   bothR¯  i   s   %dx%d(   R&  R  R  R  R  Rˇ  R'  R$  R%  R(  R  R#  (   R   (    (    s   /usr/lib/python2.7/pydoc.pyR¯  ¯  s    	  c         S   s   |  j  É  |  j É  d  S(   N(   RÔ  R8  (   R   R0  (    (    s   /usr/lib/python2.7/pydoc.pyR  	  s    
N(   R   R   Rt   R-  R_   RÖ   RÉ  R
  RD   RÔ  R‘  R‹  R  R8  R¯  R  (    (    (    s   /usr/lib/python2.7/pydoc.pyRÏ  ^  s   E						iˇˇˇˇN(    (   R  t   Tkt   mainloopt   destroyRÖ  (   RÏ  R  Rµ  t   gui(    (    s   /usr/lib/python2.7/pydoc.pyR?  \  s    ßc         C   s%   t  |  t É o$ t |  t j É d k S(   Ni    (   Rn   Rr   R   R   t   sep(   RQ   (    (    s   /usr/lib/python2.7/pydoc.pyt   ispath	  s    c          C   s¢  d d l  }  d d d Ñ  É  Y} d t j k r t j j t j d É } | t j k ri t j j | É n  t j j d d É n  y≈|  j  t j d d	 É \ } } d } x∂ | D]Æ \ } } | d
 k r— t É  d S| d k rÎ t	 | É d S| d k rGy t
 | É } Wn t k
 r | Ç n Xd Ñ  }	 d Ñ  }
 t | |	 |
 É d S| d k rÆ d } qÆ qÆ W| so| Ç n  x— | D]… } t | É r®t j j | É r®d | GHPn  y| t | É rÿt j j | É rÿt | É } n  | rt | É r	t j j | É r	t | É q#t | É n t j | É Wqvt k
 r>} | GHqvXqvWWnW |  j | f k
 rùt j j t j d É } d | t j | | | | t j f GHn Xd S(   s@   Command-line interface (looks at sys.argv to decide what to do).iˇˇˇˇNt   BadUsagec           B   s   e  Z RS(    (   R   R   (    (    (    s   /usr/lib/python2.7/pydoc.pyRB  	  s    R   i    R   i   s   gk:p:ws   -gs   -ks   -pc         S   s   d |  j  GHd  S(   Ns   pydoc server ready at %s(   R  (   R   (    (    s   /usr/lib/python2.7/pydoc.pyR-  6	  s    c           S   s	   d GHd  S(   Ns   pydoc server stopped(    (    (    (    s   /usr/lib/python2.7/pydoc.pyt   stopped8	  s    s   -ws   file %r does not existsÚ  pydoc - the Python documentation tool

%s <name> ...
    Show text documentation on something.  <name> may be the name of a
    Python keyword, topic, function, module, or package, or a dotted
    reference to a class or function within a module or module in a
    package.  If <name> contains a '%s', it is used as the path to a
    Python source file to document. If name is 'keywords', 'topics',
    or 'modules', a listing of these things is displayed.

%s -k <keyword>
    Search for a keyword in the synopsis lines of all available modules.

%s -p <port>
    Start an HTTP server on the given port on the local machine.  Port
    number 0 can be used to get an arbitrary unused port.

%s -g
    Pop up a graphical interface for finding and serving documentation.

%s -w <name> ...
    Write out the HTML documentation for a module to a file in the current
    directory.  If <name> contains a '%s', it is treated as a filename; if
    it names a directory, documentation is written for all the contents.
(    (   t   getoptR   R   R   t   dirnamet   argvt   removeR5  R?  R©  R  Rº  RÎ  RA  t   existsRu   R£   R   R’  R—  R  Rì   RÍ  R†   R@  (   RD  RB  t	   scriptdirt   optsR∏   t   writingt   optt   valR⁄  R-  RC  t   argRK   R±  (    (    s   /usr/lib/python2.7/pydoc.pyt   cli	  s^    

		 		R∏  (b   RT   R-  R&  R$  R/  R   Rá   R   R"   Rò   R   Rc  R9  R¿  Rª   R    t   stringR   R   R   R   R   R   R   R   t	   tracebackR	   t   collectionsR
   R®   R˜   R   R   R)   R,   R3   R6   R;   R	  t
   IGNORECASER<   R=   RA   RE   RR   R_   Rb   Ri   Ro   Rj   t	   NameErrorR$   Rq   R!   t   localet   getpreferredencodingRs   Ry   R~   Rí   RN  Rì   R£   R§   RÆ   R“   RÁ   R~  R  Rò  Ró  Rú  R†  Rõ  R´  Rß  R«  R   R4   R–  RÀ  Ró   RÕ  RÃ  RŒ  R'   R—  R’  R÷  R  RØ  R™  R©  RÎ  R?  RA  RO  R   (    (    (    s   /usr/lib/python2.7/pydoc.pyt   <module>$   s†   
l:											
		
					2:*ˇ ˇ % ˇ Y		#					,				ˇ i	,	[	∫		T                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Û
”´[c           @   s‰   d  Z  d d d d g Z d Z d Z d Z d Z y d	 d
 l m Z m Z Wn e	 k
 ri d Z d Z n Xd Ñ  Z d Ñ  Z d d Ñ Z d d d Ñ Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z e d k r‡ e É  n  d S(   sH   Conversions to/from quoted-printable transport encoding as per RFC 1521.t   encodet   decodet   encodestringt   decodestringt   =iL   t   0123456789ABCDEFt    iˇˇˇˇ(   t   a2b_qpt   b2a_qpc         C   sG   |  d k r | S|  d k r  | S|  t  k pF d |  k oC d k n S(   sÈ   Decide whether a particular character needs to be quoted.

    The 'quotetabs' flag indicates whether embedded tabs and spaces should be
    quoted.  Note that line-ending tabs and spaces are always encoded, as per
    RFC 1521.
    s    	t   _t    t   ~(   t   ESCAPE(   t   ct	   quotetabst   header(    (    s   /usr/lib/python2.7/quopri.pyt   needsquoting   s
    c         C   s(   t  |  É } t t | d t | d S(   s   Quote a single character.i   (   t   ordR   t   HEX(   R   t   i(    (    s   /usr/lib/python2.7/quopri.pyt   quote#   s    i    c         C   sì  t  d k	 rA |  j É  } t  | d | d | É} | j | É d S| d d Ñ } d } x|  j É  } | so Pn  g  }	 d }
 | d d k rû | d  } d }
 n  x^ | D]V } t | | | É rÃ t | É } n  | rÓ | d k rÓ |	 j d	 É q• |	 j | É q• W| d k	 r| | É n  t j	 |	 É } x< t
 | É t k re| | t d
  d d É| t d
 } q*W| } qY W| d k	 rè| | d |
 Én  d S(   sñ  Read 'input', apply quoted-printable encoding, and write to 'output'.

    'input' and 'output' are files with readline() and write() methods.
    The 'quotetabs' flag indicates whether embedded tabs and spaces should be
    quoted.  Note that line-ending tabs and spaces are always encoded, as per
    RFC 1521.
    The 'header' flag indicates whether we are encoding spaces as _ as per
    RFC 1522.
    R   R   Ns   
c         S   sw   |  r< |  d d k r< | j  |  d  t |  d É | É n7 |  d k rb | j  t |  É | É n | j  |  | É d  S(   Niˇˇˇˇs    	t   .(   t   writeR   (   t   st   outputt   lineEnd(    (    s   /usr/lib/python2.7/quopri.pyR   ;   s
    &R   iˇˇˇˇR
   R	   i   R   s   =
(   R   t   Nonet   readR   t   readlineR   R   t   appendt   EMPTYSTRINGt   joint   lent   MAXLINESIZE(   t   inputR   R   R   t   datat   odataR   t   prevlinet   linet   outlinet   strippedR   t   thisline(    (    s   /usr/lib/python2.7/quopri.pyR    *   s>    

	
c         C   sd   t  d  k	 r" t  |  d | d | ÉSd d l m } | |  É } | É  } t | | | | É | j É  S(   NR   R   iˇˇˇˇ(   t   StringIO(   R   R   t	   cStringIOR*   R    t   getvalue(   R   R   R   R*   t   infpt   outfp(    (    s   /usr/lib/python2.7/quopri.pyR   i   s    	c         C   sX  t  d k	 r; |  j É  } t  | d | É} | j | É d Sd } x˙|  j É  } | sZ Pn  d t | É } } | d k r— | | d d k r— d }	 | d } x7 | d k rÕ | | d d k rÕ | d } q† Wn d }	 x@| | k  r| | }
 |
 d k r| r| d	 } | d } q⁄ |
 t k r<| |
 } | d } q⁄ | d | k r]|	 r]d }	 Pq⁄ | d | k  rò| | d t k rò| t } | d
 } q⁄ | d
 | k  rt | | d É rt | | d
 É r| t t	 | | d | d !É É } | d } q⁄ | |
 } | d } q⁄ W|	 sD | j | d É d } qD qD W| rT| j | É n  d S(   s—   Read 'input', apply quoted-printable decoding, and write to 'output'.
    'input' and 'output' are files with readline() and write() methods.
    If 'header' is true, decode underscore as space (per RFC 1522).R   NR   i    i   s   
s    	R	   R
   i   i   (
   R   R   R   R   R   R    R   t   ishext   chrt   unhex(   R"   R   R   R#   R$   t   newR&   R   t   nt   partialR   (    (    s   /usr/lib/python2.7/quopri.pyR   t   sR       
#

 
  $
 8% 
 c         C   s^   t  d  k	 r t  |  d | ÉSd d l m } | |  É } | É  } t | | d | É| j É  S(   NR   iˇˇˇˇ(   R*   (   R   R   R+   R*   R   R,   (   R   R   R*   R-   R.   (    (    s   /usr/lib/python2.7/quopri.pyR   ü   s    	c         C   sP   d |  k o d k n pO d |  k o3 d k n pO d |  k oM d k SS(   s8   Return true if the character 'c' is a hexadecimal digit.t   0t   9t   at   ft   At   F(    (   R   (    (    s   /usr/lib/python2.7/quopri.pyR/   ´   s    c         C   sΩ   d } x∞ |  D]® } d | k o* d k n r> t  d É } n_ d | k oU d k n rm t  d É d } n0 d | k oÑ d k n rú t  d É d } n P| d	 t  | É | } q W| S(
   s.   Get the integer value of a hexadecimal number.i    R5   R6   R7   R8   i
   R9   R:   i   (   R   (   R   t   bitsR   R   (    (    s   /usr/lib/python2.7/quopri.pyR1   Ø   s    c          C   sÁ  d d  l  }  d d  l } y# | j |  j d d É \ } } WnC | j k
 rÄ } |  j |  _ | GHd GHd GHd GH|  j d É n Xd } d } x> | D]6 \ } } | d	 k rµ d } n  | d
 k rî d } qî qî W| r˚ | r˚ |  j |  _ d GH|  j d É n  | sd g } n  d }	 x∑ | D]Ø }
 |
 d k r8|  j } nI y t |
 É } Wn6 t	 k
 rÄ} |  j j
 d |
 | f É d }	 qn X| röt | |  j É n t | |  j | É | |  j k	 r| j É  qqW|	 r„|  j |	 É n  d  S(   Niˇˇˇˇi   t   tds"   usage: quopri [-t | -d] [file] ...s   -t: quote tabss   -d: decode; default encodei   i    s   -ts   -ds    -t and -d are mutually exclusivet   -s   %s: can't open (%s)
(   t   syst   getoptt   argvt   errort   stderrt   stdoutt   exitt   stdint   opent   IOErrorR   R   R    t   close(   R>   R?   t   optst   argst   msgt   decot   tabst   oR7   t   stst   filet   fp(    (    s   /usr/lib/python2.7/quopri.pyt   main¿   sR    # 	  t   __main__N(   t   __doc__t   __all__R   R!   R   R   t   binasciiR   R   t   ImportErrorR   R   R   R    R   R   R   R/   R1   RR   t   __name__(    (    (    s   /usr/lib/python2.7/quopri.pyt   <module>   s*   
		?+			,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """Random variable generators.

    integers
    --------
           uniform within range

    sequences
    ---------
           pick random element
           pick random sample
           generate random permutation

    distributions on the real line:
    ------------------------------
           uniform
           triangular
           normal (Gaussian)
           lognormal
           negative exponential
           gamma
           beta
           pareto
           Weibull

    distributions on the circle (angles 0 to 2pi)
    ---------------------------------------------
           circular uniform
           von Mises

General notes on the underlying Mersenne Twister core generator:

* The period is 2**19937-1.
* It is one of the most extensively tested generators in existence.
* Without a direct way to compute N steps forward, the semantics of
  jumpahead(n) are weakened to simply jump to another distant state and rely
  on the large period to avoid overlapping sequences.
* The random() method is implemented in C, executes in a single Python step,
  and is, therefore, threadsafe.

"""

from __future__ import division
from warnings import warn as _warn
from types import MethodType as _MethodType, BuiltinMethodType as _BuiltinMethodType
from math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil
from math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin
from os import urandom as _urandom
from binascii import hexlify as _hexlify
import hashlib as _hashlib

__all__ = ["Random","seed","random","uniform","randint","choice","sample",
           "randrange","shuffle","normalvariate","lognormvariate",
           "expovariate","vonmisesvariate","gammavariate","triangular",
           "gauss","betavariate","paretovariate","weibullvariate",
           "getstate","setstate","jumpahead", "WichmannHill", "getrandbits",
           "SystemRandom"]

NV_MAGICCONST = 4 * _exp(-0.5)/_sqrt(2.0)
TWOPI = 2.0*_pi
LOG4 = _log(4.0)
SG_MAGICCONST = 1.0 + _log(4.5)
BPF = 53        # Number of bits in a float
RECIP_BPF = 2**-BPF


# Translated by Guido van Rossum from C source provided by
# Adrian Baddeley.  Adapted by Raymond Hettinger for use with
# the Mersenne Twister  and os.urandom() core generators.

import _random

class Random(_random.Random):
    """Random number generator base class used by bound module functions.

    Used to instantiate instances of Random to get generators that don't
    share state.  Especially useful for multi-threaded programs, creating
    a different instance of Random for each thread, and using the jumpahead()
    method to ensure that the generated sequences seen by each thread don't
    overlap.

    Class Random can also be subclassed if you want to use a different basic
    generator of your own devising: in that case, override the following
    methods: random(), seed(), getstate(), setstate() and jumpahead().
    Optionally, implement a getrandbits() method so that randrange() can cover
    arbitrarily large ranges.

    """

    VERSION = 3     # used by getstate/setstate

    def __init__(self, x=None):
        """Initialize an instance.

        Optional argument x controls seeding, as for Random.seed().
        """

        self.seed(x)
        self.gauss_next = None

    def seed(self, a=None):
        """Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.
        """

        if a is None:
            try:
                # Seed with enough bytes to span the 19937 bit
                # state space for the Mersenne Twister
                a = long(_hexlify(_urandom(2500)), 16)
            except NotImplementedError:
                import time
                a = long(time.time() * 256) # use fractional seconds

        super(Random, self).seed(a)
        self.gauss_next = None

    def getstate(self):
        """Return internal state; can be passed to setstate() later."""
        return self.VERSION, super(Random, self).getstate(), self.gauss_next

    def setstate(self, state):
        """Restore internal state from object returned by getstate()."""
        version = state[0]
        if version == 3:
            version, internalstate, self.gauss_next = state
            super(Random, self).setstate(internalstate)
        elif version == 2:
            version, internalstate, self.gauss_next = state
            # In version 2, the state was saved as signed ints, which causes
            #   inconsistencies between 32/64-bit systems. The state is
            #   really unsigned 32-bit ints, so we convert negative ints from
            #   version 2 to positive longs for version 3.
            try:
                internalstate = tuple( long(x) % (2**32) for x in internalstate )
            except ValueError, e:
                raise TypeError, e
            super(Random, self).setstate(internalstate)
        else:
            raise ValueError("state with version %s passed to "
                             "Random.setstate() of version %s" %
                             (version, self.VERSION))

    def jumpahead(self, n):
        """Change the internal state to one that is likely far away
        from the current state.  This method will not be in Py3.x,
        so it is better to simply reseed.
        """
        # The super.jumpahead() method uses shuffling to change state,
        # so it needs a large and "interesting" n to work with.  Here,
        # we use hashing to create a large n for the shuffle.
        s = repr(n) + repr(self.getstate())
        n = int(_hashlib.new('sha512', s).hexdigest(), 16)
        super(Random, self).jumpahead(n)

## ---- Methods below this point do not need to be overridden when
## ---- subclassing for the purpose of using a different core generator.

## -------------------- pickle support  -------------------

    def __getstate__(self): # for pickle
        return self.getstate()

    def __setstate__(self, state):  # for pickle
        self.setstate(state)

    def __reduce__(self):
        return self.__class__, (), self.getstate()

## -------------------- integer methods  -------------------

    def randrange(self, start, stop=None, step=1, _int=int, _maxwidth=1L<<BPF):
        """Choose a random item from range(start, stop[, step]).

        This fixes the problem with randint() which includes the
        endpoint; in Python this is usually not what you want.

        """

        # This code is a bit messy to make it fast for the
        # common case while still doing adequate error checking.
        istart = _int(start)
        if istart != start:
            raise ValueError, "non-integer arg 1 for randrange()"
        if stop is None:
            if istart > 0:
                if istart >= _maxwidth:
                    return self._randbelow(istart)
                return _int(self.random() * istart)
            raise ValueError, "empty range for randrange()"

        # stop argument supplied.
        istop = _int(stop)
        if istop != stop:
            raise ValueError, "non-integer stop for randrange()"
        width = istop - istart
        if step == 1 and width > 0:
            # Note that
            #     int(istart + self.random()*width)
            # instead would be incorrect.  For example, consider istart
            # = -2 and istop = 0.  Then the guts would be in
            # -2.0 to 0.0 exclusive on both ends (ignoring that random()
            # might return 0.0), and because int() truncates toward 0, the
            # final result would be -1 or 0 (instead of -2 or -1).
            #     istart + int(self.random()*width)
            # would also be incorrect, for a subtler reason:  the RHS
            # can return a long, and then randrange() would also return
            # a long, but we're supposed to return an int (for backward
            # compatibility).

            if width >= _maxwidth:
                return _int(istart + self._randbelow(width))
            return _int(istart + _int(self.random()*width))
        if step == 1:
            raise ValueError, "empty range for randrange() (%d,%d, %d)" % (istart, istop, width)

        # Non-unit step argument supplied.
        istep = _int(step)
        if istep != step:
            raise ValueError, "non-integer step for randrange()"
        if istep > 0:
            n = (width + istep - 1) // istep
        elif istep < 0:
            n = (width + istep + 1) // istep
        else:
            raise ValueError, "zero step for randrange()"

        if n <= 0:
            raise ValueError, "empty range for randrange()"

        if n >= _maxwidth:
            return istart + istep*self._randbelow(n)
        return istart + istep*_int(self.random() * n)

    def randint(self, a, b):
        """Return random integer in range [a, b], including both end points.
        """

        return self.randrange(a, b+1)

    def _randbelow(self, n, _log=_log, _int=int, _maxwidth=1L<<BPF,
                   _Method=_MethodType, _BuiltinMethod=_BuiltinMethodType):
        """Return a random int in the range [0,n)

        Handles the case where n has more bits than returned
        by a single call to the underlying generator.
        """

        try:
            getrandbits = self.getrandbits
        except AttributeError:
            pass
        else:
            # Only call self.getrandbits if the original random() builtin method
            # has not been overridden or if a new getrandbits() was supplied.
            # This assures that the two methods correspond.
            if type(self.random) is _BuiltinMethod or type(getrandbits) is _Method:
                k = _int(1.00001 + _log(n-1, 2.0))   # 2**k > n-1 > 2**(k-2)
                r = getrandbits(k)
                while r >= n:
                    r = getrandbits(k)
                return r
        if n >= _maxwidth:
            _warn("Underlying random() generator does not supply \n"
                "enough bits to choose from a population range this large")
        return _int(self.random() * n)

## -------------------- sequence methods  -------------------

    def choice(self, seq):
        """Choose a random element from a non-empty sequence."""
        return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty

    def shuffle(self, x, random=None):
        """x, random=random.random -> shuffle list x in place; return None.

        Optional arg random is a 0-argument function returning a random
        float in [0.0, 1.0); by default, the standard random.random.

        """

        if random is None:
            random = self.random
        _int = int
        for i in reversed(xrange(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = _int(random() * (i+1))
            x[i], x[j] = x[j], x[i]

    def sample(self, population, k):
        """Chooses k unique random elements from a population sequence.

        Returns a new list containing elements from the population while
        leaving the original population unchanged.  The resulting list is
        in selection order so that all sub-slices will also be valid random
        samples.  This allows raffle winners (the sample) to be partitioned
        into grand prize and second place winners (the subslices).

        Members of the population need not be hashable or unique.  If the
        population contains repeats, then each occurrence is a possible
        selection in the sample.

        To choose a sample in a range of integers, use xrange as an argument.
        This is especially fast and space efficient for sampling from a
        large population:   sample(xrange(10000000), 60)
        """

        # Sampling without replacement entails tracking either potential
        # selections (the pool) in a list or previous selections in a set.

        # When the number of selections is small compared to the
        # population, then tracking selections is efficient, requiring
        # only a small set and an occasional reselection.  For
        # a larger number of selections, the pool tracking method is
        # preferred since the list takes less space than the
        # set and it doesn't suffer from frequent reselections.

        n = len(population)
        if not 0 <= k <= n:
            raise ValueError("sample larger than population")
        random = self.random
        _int = int
        result = [None] * k
        setsize = 21        # size of a small set minus size of an empty list
        if k > 5:
            setsize += 4 ** _ceil(_log(k * 3, 4)) # table size for big sets
        if n <= setsize or hasattr(population, "keys"):
            # An n-length list is smaller than a k-length set, or this is a
            # mapping type so the other algorithm wouldn't work.
            pool = list(population)
            for i in xrange(k):         # invariant:  non-selected at [0,n-i)
                j = _int(random() * (n-i))
                result[i] = pool[j]
                pool[j] = pool[n-i-1]   # move non-selected item into vacancy
        else:
            try:
                selected = set()
                selected_add = selected.add
                for i in xrange(k):
                    j = _int(random() * n)
                    while j in selected:
                        j = _int(random() * n)
                    selected_add(j)
                    result[i] = population[j]
            except (TypeError, KeyError):   # handle (at least) sets
                if isinstance(population, list):
                    raise
                return self.sample(tuple(population), k)
        return result

## -------------------- real-valued distributions  -------------------

## -------------------- uniform distribution -------------------

    def uniform(self, a, b):
        "Get a random number in the range [a, b) or [a, b] depending on rounding."
        return a + (b-a) * self.random()

## -------------------- triangular --------------------

    def triangular(self, low=0.0, high=1.0, mode=None):
        """Triangular distribution.

        Continuous distribution bounded by given lower and upper limits,
        and having a given mode value in-between.

        http://en.wikipedia.org/wiki/Triangular_distribution

        """
        u = self.random()
        try:
            c = 0.5 if mode is None else (mode - low) / (high - low)
        except ZeroDivisionError:
            return low
        if u > c:
            u = 1.0 - u
            c = 1.0 - c
            low, high = high, low
        return low + (high - low) * (u * c) ** 0.5

## -------------------- normal distribution --------------------

    def normalvariate(self, mu, sigma):
        """Normal distribution.

        mu is the mean, and sigma is the standard deviation.

        """
        # mu = mean, sigma = standard deviation

        # Uses Kinderman and Monahan method. Reference: Kinderman,
        # A.J. and Monahan, J.F., "Computer generation of random
        # variables using the ratio of uniform deviates", ACM Trans
        # Math Software, 3, (1977), pp257-260.

        random = self.random
        while 1:
            u1 = random()
            u2 = 1.0 - random()
            z = NV_MAGICCONST*(u1-0.5)/u2
            zz = z*z/4.0
            if zz <= -_log(u2):
                break
        return mu + z*sigma

## -------------------- lognormal distribution --------------------

    def lognormvariate(self, mu, sigma):
        """Log normal distribution.

        If you take the natural logarithm of this distribution, you'll get a
        normal distribution with mean mu and standard deviation sigma.
        mu can have any value, and sigma must be greater than zero.

        """
        return _exp(self.normalvariate(mu, sigma))

## -------------------- exponential distribution --------------------

    def expovariate(self, lambd):
        """Exponential distribution.

        lambd is 1.0 divided by the desired mean.  It should be
        nonzero.  (The parameter would be called "lambda", but that is
        a reserved word in Python.)  Returned values range from 0 to
        positive infinity if lambd is positive, and from negative
        infinity to 0 if lambd is negative.

        """
        # lambd: rate lambd = 1/mean
        # ('lambda' is a Python reserved word)

        # we use 1-random() instead of random() to preclude the
        # possibility of taking the log of zero.
        return -_log(1.0 - self.random())/lambd

## -------------------- von Mises distribution --------------------

    def vonmisesvariate(self, mu, kappa):
        """Circular data distribution.

        mu is the mean angle, expressed in radians between 0 and 2*pi, and
        kappa is the concentration parameter, which must be greater than or
        equal to zero.  If kappa is equal to zero, this distribution reduces
        to a uniform random angle over the range 0 to 2*pi.

        """
        # mu:    mean angle (in radians between 0 and 2*pi)
        # kappa: concentration parameter kappa (>= 0)
        # if kappa = 0 generate uniform random angle

        # Based upon an algorithm published in: Fisher, N.I.,
        # "Statistical Analysis of Circular Data", Cambridge
        # University Press, 1993.

        # Thanks to Magnus Kessler for a correction to the
        # implementation of step 4.

        random = self.random
        if kappa <= 1e-6:
            return TWOPI * random()

        s = 0.5 / kappa
        r = s + _sqrt(1.0 + s * s)

        while 1:
            u1 = random()
            z = _cos(_pi * u1)

            d = z / (r + z)
            u2 = random()
            if u2 < 1.0 - d * d or u2 <= (1.0 - d) * _exp(d):
                break

        q = 1.0 / r
        f = (q + z) / (1.0 + q * z)
        u3 = random()
        if u3 > 0.5:
            theta = (mu + _acos(f)) % TWOPI
        else:
            theta = (mu - _acos(f)) % TWOPI

        return theta

## -------------------- gamma distribution --------------------

    def gammavariate(self, alpha, beta):
        """Gamma distribution.  Not the gamma function!

        Conditions on the parameters are alpha > 0 and beta > 0.

        The probability distribution function is:

                    x ** (alpha - 1) * math.exp(-x / beta)
          pdf(x) =  --------------------------------------
                      math.gamma(alpha) * beta ** alpha

        """

        # alpha > 0, beta > 0, mean is alpha*beta, variance is alpha*beta**2

        # Warning: a few older sources define the gamma distribution in terms
        # of alpha > -1.0
        if alpha <= 0.0 or beta <= 0.0:
            raise ValueError, 'gammavariate: alpha and beta must be > 0.0'

        random = self.random
        if alpha > 1.0:

            # Uses R.C.H. Cheng, "The generation of Gamma
            # variables with non-integral shape parameters",
            # Applied Statistics, (1977), 26, No. 1, p71-74

            ainv = _sqrt(2.0 * alpha - 1.0)
            bbb = alpha - LOG4
            ccc = alpha + ainv

            while 1:
                u1 = random()
                if not 1e-7 < u1 < .9999999:
                    continue
                u2 = 1.0 - random()
                v = _log(u1/(1.0-u1))/ainv
                x = alpha*_exp(v)
                z = u1*u1*u2
                r = bbb+ccc*v-x
                if r + SG_MAGICCONST - 4.5*z >= 0.0 or r >= _log(z):
                    return x * beta

        elif alpha == 1.0:
            # expovariate(1)
            u = random()
            while u <= 1e-7:
                u = random()
            return -_log(u) * beta

        else:   # alpha is between 0 and 1 (exclusive)

            # Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle

            while 1:
                u = random()
                b = (_e + alpha)/_e
                p = b*u
                if p <= 1.0:
                    x = p ** (1.0/alpha)
                else:
                    x = -_log((b-p)/alpha)
                u1 = random()
                if p > 1.0:
                    if u1 <= x ** (alpha - 1.0):
                        break
                elif u1 <= _exp(-x):
                    break
            return x * beta

## -------------------- Gauss (faster alternative) --------------------

    def gauss(self, mu, sigma):
        """Gaussian distribution.

        mu is the mean, and sigma is the standard deviation.  This is
        slightly faster than the normalvariate() function.

        Not thread-safe without a lock around calls.

        """

        # When x and y are two variables from [0, 1), uniformly
        # distributed, then
        #
        #    cos(2*pi*x)*sqrt(-2*log(1-y))
        #    sin(2*pi*x)*sqrt(-2*log(1-y))
        #
        # are two *independent* variables with normal distribution
        # (mu = 0, sigma = 1).
        # (Lambert Meertens)
        # (corrected version; bug discovered by Mike Miller, fixed by LM)

        # Multithreading note: When two threads call this function
        # simultaneously, it is possible that they will receive the
        # same return value.  The window is very small though.  To
        # avoid this, you have to use a lock around all calls.  (I
        # didn't want to slow this down in the serial case by using a
        # lock here.)

        random = self.random
        z = self.gauss_next
        self.gauss_next = None
        if z is None:
            x2pi = random() * TWOPI
            g2rad = _sqrt(-2.0 * _log(1.0 - random()))
            z = _cos(x2pi) * g2rad
            self.gauss_next = _sin(x2pi) * g2rad

        return mu + z*sigma

## -------------------- beta --------------------
## See
## http://mail.python.org/pipermail/python-bugs-list/2001-January/003752.html
## for Ivan Frohne's insightful analysis of why the original implementation:
##
##    def betavariate(self, alpha, beta):
##        # Discrete Event Simulation in C, pp 87-88.
##
##        y = self.expovariate(alpha)
##        z = self.expovariate(1.0/beta)
##        return z/(y+z)
##
## was dead wrong, and how it probably got that way.

    def betavariate(self, alpha, beta):
        """Beta distribution.

        Conditions on the parameters are alpha > 0 and beta > 0.
        Returned values range between 0 and 1.

        """

        # This version due to Janne Sinkkonen, and matches all the std
        # texts (e.g., Knuth Vol 2 Ed 3 pg 134 "the beta distribution").
        y = self.gammavariate(alpha, 1.)
        if y == 0:
            return 0.0
        else:
            return y / (y + self.gammavariate(beta, 1.))

## -------------------- Pareto --------------------

    def paretovariate(self, alpha):
        """Pareto distribution.  alpha is the shape parameter."""
        # Jain, pg. 495

        u = 1.0 - self.random()
        return 1.0 / pow(u, 1.0/alpha)

## -------------------- Weibull --------------------

    def weibullvariate(self, alpha, beta):
        """Weibull distribution.

        alpha is the scale parameter and beta is the shape parameter.

        """
        # Jain, pg. 499; bug fix courtesy Bill Arms

        u = 1.0 - self.random()
        return alpha * pow(-_log(u), 1.0/beta)

## -------------------- Wichmann-Hill -------------------

class WichmannHill(Random):

    VERSION = 1     # used by getstate/setstate

    def seed(self, a=None):
        """Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.

        If a is an int or long, a is used directly.  Distinct values between
        0 and 27814431486575L inclusive are guaranteed to yield distinct
        internal states (this guarantee is specific to the default
        Wichmann-Hill generator).
        """

        if a is None:
            try:
                a = long(_hexlify(_urandom(16)), 16)
            except NotImplementedError:
                import time
                a = long(time.time() * 256) # use fractional seconds

        if not isinstance(a, (int, long)):
            a = hash(a)

        a, x = divmod(a, 30268)
        a, y = divmod(a, 30306)
        a, z = divmod(a, 30322)
        self._seed = int(x)+1, int(y)+1, int(z)+1

        self.gauss_next = None

    def random(self):
        """Get the next random number in the range [0.0, 1.0)."""

        # Wichman-Hill random number generator.
        #
        # Wichmann, B. A. & Hill, I. D. (1982)
        # Algorithm AS 183:
        # An efficient and portable pseudo-random number generator
        # Applied Statistics 31 (1982) 188-190
        #
        # see also:
        #        Correction to Algorithm AS 183
        #        Applied Statistics 33 (1984) 123
        #
        #        McLeod, A. I. (1985)
        #        A remark on Algorithm AS 183
        #        Applied Statistics 34 (1985),198-200

        # This part is thread-unsafe:
        # BEGIN CRITICAL SECTION
        x, y, z = self._seed
        x = (171 * x) % 30269
        y = (172 * y) % 30307
        z = (170 * z) % 30323
        self._seed = x, y, z
        # END CRITICAL SECTION

        # Note:  on a platform using IEEE-754 double arithmetic, this can
        # never return 0.0 (asserted by Tim; proof too long for a comment).
        return (x/30269.0 + y/30307.0 + z/30323.0) % 1.0

    def getstate(self):
        """Return internal state; can be passed to setstate() later."""
        return self.VERSION, self._seed, self.gauss_next

    def setstate(self, state):
        """Restore internal state from object returned by getstate()."""
        version = state[0]
        if version == 1:
            version, self._seed, self.gauss_next = state
        else:
            raise ValueError("state with version %s passed to "
                             "Random.setstate() of version %s" %
                             (version, self.VERSION))

    def jumpahead(self, n):
        """Act as if n calls to random() were made, but quickly.

        n is an int, greater than or equal to 0.

        Example use:  If you have 2 threads and know that each will
        consume no more than a million random numbers, create two Random
        objects r1 and r2, then do
            r2.setstate(r1.getstate())
            r2.jumpahead(1000000)
        Then r1 and r2 will use guaranteed-disjoint segments of the full
        period.
        """

        if not n >= 0:
            raise ValueError("n must be >= 0")
        x, y, z = self._seed
        x = int(x * pow(171, n, 30269)) % 30269
        y = int(y * pow(172, n, 30307)) % 30307
        z = int(z * pow(170, n, 30323)) % 30323
        self._seed = x, y, z

    def __whseed(self, x=0, y=0, z=0):
        """Set the Wichmann-Hill seed from (x, y, z).

        These must be integers in the range [0, 256).
        """

        if not type(x) == type(y) == type(z) == int:
            raise TypeError('seeds must be integers')
        if not (0 <= x < 256 and 0 <= y < 256 and 0 <= z < 256):
            raise ValueError('seeds must be in range(0, 256)')
        if 0 == x == y == z:
            # Initialize from current time
            import time
            t = long(time.time() * 256)
            t = int((t&0xffffff) ^ (t>>24))
            t, x = divmod(t, 256)
            t, y = divmod(t, 256)
            t, z = divmod(t, 256)
        # Zero is a poor seed, so substitute 1
        self._seed = (x or 1, y or 1, z or 1)

        self.gauss_next = None

    def whseed(self, a=None):
        """Seed from hashable object's hash code.

        None or no argument seeds from current time.  It is not guaranteed
        that objects with distinct hash codes lead to distinct internal
        states.

        This is obsolete, provided for compatibility with the seed routine
        used prior to Python 2.1.  Use the .seed() method instead.
        """

        if a is None:
            self.__whseed()
            return
        a = hash(a)
        a, x = divmod(a, 256)
        a, y = divmod(a, 256)
        a, z = divmod(a, 256)
        x = (x + a) % 256 or 1
        y = (y + a) % 256 or 1
        z = (z + a) % 256 or 1
        self.__whseed(x, y, z)

## --------------- Operating System Random Source  ------------------

class SystemRandom(Random):
    """Alternate random number generator using sources provided
    by the operating system (such as /dev/urandom on Unix or
    CryptGenRandom on Windows).

     Not available on all systems (see os.urandom() for details).
    """

    def random(self):
        """Get the next random number in the range [0.0, 1.0)."""
        return (long(_hexlify(_urandom(7)), 16) >> 3) * RECIP_BPF

    def getrandbits(self, k):
        """getrandbits(k) -> x.  Generates a long int with k random bits."""
        if k <= 0:
            raise ValueError('number of bits must be greater than zero')
        if k != int(k):
            raise TypeError('number of bits should be an integer')
        bytes = (k + 7) // 8                    # bits / 8 and rounded up
        x = long(_hexlify(_urandom(bytes)), 16)
        return x >> (bytes * 8 - k)             # trim excess bits

    def _stub(self, *args, **kwds):
        "Stub method.  Not used for a system random number generator."
        return None
    seed = jumpahead = _stub

    def _notimplemented(self, *args, **kwds):
        "Method should not be called for a system random number generator."
        raise NotImplementedError('System entropy source does not have state.')
    getstate = setstate = _notimplemented

## -------------------- test program --------------------

def _test_generator(n, func, args):
    import time
    print n, 'times', func.__name__
    total = 0.0
    sqsum = 0.0
    smallest = 1e10
    largest = -1e10
    t0 = time.time()
    for i in range(n):
        x = func(*args)
        total += x
        sqsum = sqsum + x*x
        smallest = min(x, smallest)
        largest = max(x, largest)
    t1 = time.time()
    print round(t1-t0, 3), 'sec,',
    avg = total/n
    stddev = _sqrt(sqsum/n - avg*avg)
    print 'avg %g, stddev %g, min %g, max %g' % \
              (avg, stddev, smallest, largest)


def _test(N=2000):
    _test_generator(N, random, ())
    _test_generator(N, normalvariate, (0.0, 1.0))
    _test_generator(N, lognormvariate, (0.0, 1.0))
    _test_generator(N, vonmisesvariate, (0.0, 1.0))
    _test_generator(N, gammavariate, (0.01, 1.0))
    _test_generator(N, gammavariate, (0.1, 1.0))
    _test_generator(N, gammavariate, (0.1, 2.0))
    _test_generator(N, gammavariate, (0.5, 1.0))
    _test_generator(N, gammavariate, (0.9, 1.0))
    _test_generator(N, gammavariate, (1.0, 1.0))
    _test_generator(N, gammavariate, (2.0, 1.0))
    _test_generator(N, gammavariate, (20.0, 1.0))
    _test_generator(N, gammavariate, (200.0, 1.0))
    _test_generator(N, gauss, (0.0, 1.0))
    _test_generator(N, betavariate, (3.0, 3.0))
    _test_generator(N, triangular, (0.0, 1.0, 1.0/3.0))

# Create one instance, seeded from current time, and export its methods
# as module-level functions.  The functions share state across all uses
#(both in the user's code and in the Python libraries), but that's fine
# for most programs and is easier for the casual user than making them
# instantiate their own Random() instance.

_inst = Random()
seed = _inst.seed
random = _inst.random
uniform = _inst.uniform
triangular = _inst.triangular
randint = _inst.randint
choice = _inst.choice
randrange = _inst.randrange
sample = _inst.sample
shuffle = _inst.shuffle
normalvariate = _inst.normalvariate
lognormvariate = _inst.lognormvariate
expovariate = _inst.expovariate
vonmisesvariate = _inst.vonmisesvariate
gammavariate = _inst.gammavariate
gauss = _inst.gauss
betavariate = _inst.betavariate
paretovariate = _inst.paretovariate
weibullvariate = _inst.weibullvariate
getstate = _inst.getstate
setstate = _inst.setstate
jumpahead = _inst.jumpahead
getrandbits = _inst.getrandbits

if __name__ == '__main__':
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                             Û
”´[c           @   s£  d  Z  d d l m Z d d l m Z d d l m Z m	 Z
 d d l m Z m Z m Z m Z m Z d d l m Z m Z m Z m Z d d l m Z  d d l! m" Z# d d	 l$ Z% d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" g Z& d# e d$ É e d% É Z' d% e Z( e d& É Z) d' e d( É Z* d) Z+ d* e+ Z, d d	 l- Z- d
 e- j. f d+ Ñ  É  YZ. d  e. f d, Ñ  É  YZ/ d" e. f d- Ñ  É  YZ0 d. Ñ  Z1 d/ d0 Ñ Z2 e. É  Z3 e3 j4 Z4 e3 j5 Z5 e3 j6 Z6 e3 j7 Z7 e3 j8 Z8 e3 j9 Z9 e3 j: Z: e3 j; Z; e3 j< Z< e3 j= Z= e3 j> Z> e3 j? Z? e3 j@ Z@ e3 jA ZA e3 jB ZB e3 jC ZC e3 jD ZD e3 jE ZE e3 jF ZF e3 jG ZG e3 jH ZH e3 jI ZI eJ d1 k rüe2 É  n  d	 S(2   sP  Random variable generators.

    integers
    --------
           uniform within range

    sequences
    ---------
           pick random element
           pick random sample
           generate random permutation

    distributions on the real line:
    ------------------------------
           uniform
           triangular
           normal (Gaussian)
           lognormal
           negative exponential
           gamma
           beta
           pareto
           Weibull

    distributions on the circle (angles 0 to 2pi)
    ---------------------------------------------
           circular uniform
           von Mises

General notes on the underlying Mersenne Twister core generator:

* The period is 2**19937-1.
* It is one of the most extensively tested generators in existence.
* Without a direct way to compute N steps forward, the semantics of
  jumpahead(n) are weakened to simply jump to another distant state and rely
  on the large period to avoid overlapping sequences.
* The random() method is implemented in C, executes in a single Python step,
  and is, therefore, threadsafe.

iˇˇˇˇ(   t   division(   t   warn(   t
   MethodTypet   BuiltinMethodType(   t   logt   expt   pit   et   ceil(   t   sqrtt   acost   cost   sin(   t   urandom(   t   hexlifyNt   Randomt   seedt   randomt   uniformt   randintt   choicet   samplet	   randranget   shufflet   normalvariatet   lognormvariatet   expovariatet   vonmisesvariatet   gammavariatet
   triangulart   gausst   betavariatet   paretovariatet   weibullvariatet   getstatet   setstatet	   jumpaheadt   WichmannHillt   getrandbitst   SystemRandomi   g      ‡øg       @g      @g      ?g      @i5   i   c           B   s*  e  Z d  Z d Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d d
 e d e >d Ñ Z d Ñ  Z e e d e >e e d Ñ Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" RS(    sŒ  Random number generator base class used by bound module functions.

    Used to instantiate instances of Random to get generators that don't
    share state.  Especially useful for multi-threaded programs, creating
    a different instance of Random for each thread, and using the jumpahead()
    method to ensure that the generated sequences seen by each thread don't
    overlap.

    Class Random can also be subclassed if you want to use a different basic
    generator of your own devising: in that case, override the following
    methods: random(), seed(), getstate(), setstate() and jumpahead().
    Optionally, implement a getrandbits() method so that randrange() can cover
    arbitrarily large ranges.

    i   c         C   s   |  j  | É d |  _ d S(   se   Initialize an instance.

        Optional argument x controls seeding, as for Random.seed().
        N(   R   t   Nonet
   gauss_next(   t   selft   x(    (    s   /usr/lib/python2.7/random.pyt   __init__[   s    c         C   sá   | d k rd y t t t d É É d É } Wqd t k
 r` d d l } t | j É  d É } qd Xn  t t |  É j | É d |  _	 d S(   s   Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.
        iƒ	  i   iˇˇˇˇNi   (
   R(   t   longt   _hexlifyt   _urandomt   NotImplementedErrort   timet   superR   R   R)   (   R*   t   aR1   (    (    s   /usr/lib/python2.7/random.pyR   d   s    	c         C   s"   |  j  t t |  É j É  |  j f S(   s9   Return internal state; can be passed to setstate() later.(   t   VERSIONR2   R   R"   R)   (   R*   (    (    s   /usr/lib/python2.7/random.pyR"   y   s    c         C   sŒ   | d } | d k rA | \ } } |  _  t t |  É j | É nâ | d k r± | \ } } |  _  y t d Ñ  | DÉ É } Wn t k
 ró } t | Ç n Xt t |  É j | É n t d | |  j f É Ç d S(   s:   Restore internal state from object returned by getstate().i    i   i   c         s   s   |  ] } t  | É d Vq d S(   i   i    Nl        (   R-   (   t   .0R+   (    (    s   /usr/lib/python2.7/random.pys	   <genexpr>ä   s    s?   state with version %s passed to Random.setstate() of version %sN(   R)   R2   R   R#   t   tuplet
   ValueErrort	   TypeErrorR4   (   R*   t   statet   versiont   internalstateR   (    (    s   /usr/lib/python2.7/random.pyR#   }   s    
c         C   sW   t  | É t  |  j É  É } t t j d | É j É  d É } t t |  É j | É d S(   sÆ   Change the internal state to one that is likely far away
        from the current state.  This method will not be in Py3.x,
        so it is better to simply reseed.
        t   sha512i   N(	   t   reprR"   t   intt   _hashlibt   newt	   hexdigestR2   R   R$   (   R*   t   nt   s(    (    s   /usr/lib/python2.7/random.pyR$   ì   s    !c         C   s
   |  j  É  S(   N(   R"   (   R*   (    (    s   /usr/lib/python2.7/random.pyt   __getstate__§   s    c         C   s   |  j  | É d  S(   N(   R#   (   R*   R9   (    (    s   /usr/lib/python2.7/random.pyt   __setstate__ß   s    c         C   s   |  j  d |  j É  f S(   N(    (   t	   __class__R"   (   R*   (    (    s   /usr/lib/python2.7/random.pyt
   __reduce__™   s    i   l    c         C   sÂ  | | É } | | k r$ t  d Ç n  | d	 k ru | d k ri | | k rU |  j | É S| |  j É  | É St  d Ç n  | | É } | | k rô t  d Ç n  | | } | d k r¸ | d k r¸ | | k rﬁ | | |  j | É É S| | | |  j É  | É É S| d k r!t  d | | | f Ç n  | | É }	 |	 | k rEt  d Ç n  |	 d k rf| |	 d |	 }
 n* |	 d k  rá| |	 d |	 }
 n	 t  d Ç |
 d k r®t  d Ç n  |
 | k r…| |	 |  j |
 É S| |	 | |  j É  |
 É S(
   s¿   Choose a random item from range(start, stop[, step]).

        This fixes the problem with randint() which includes the
        endpoint; in Python this is usually not what you want.

        s!   non-integer arg 1 for randrange()i    s   empty range for randrange()s    non-integer stop for randrange()i   s'   empty range for randrange() (%d,%d, %d)s    non-integer step for randrange()s   zero step for randrange()N(   R7   R(   t
   _randbelowR   (   R*   t   startt   stopt   stept   _intt	   _maxwidtht   istartt   istopt   widtht   istepRB   (    (    s   /usr/lib/python2.7/random.pyR   Ø   s@    

	c         C   s   |  j  | | d É S(   sJ   Return random integer in range [a, b], including both end points.
        i   (   R   (   R*   R3   t   b(    (    s   /usr/lib/python2.7/random.pyR   Ó   s    c   
      C   s¡   y |  j  } Wn t k
 r  nt Xt |  j É | k sH t | É | k rî | d | | d d É É } | | É }	 x |	 | k rè | | É }	 qt W|	 S| | k r≠ t d É n  | |  j É  | É S(   s£   Return a random int in the range [0,n)

        Handles the case where n has more bits than returned
        by a single call to the underlying generator.
        grƒZ|
 ?i   g       @sg   Underlying random() generator does not supply 
enough bits to choose from a population range this large(   R&   t   AttributeErrort   typeR   t   _warn(
   R*   RB   t   _logRL   RM   t   _Methodt   _BuiltinMethodR&   t   kt   r(    (    s   /usr/lib/python2.7/random.pyRH   Ù   s    'c         C   s   | t  |  j É  t | É É S(   s2   Choose a random element from a non-empty sequence.(   R>   R   t   len(   R*   t   seq(    (    s   /usr/lib/python2.7/random.pyR     s    c         C   s|   | d k r |  j } n  t } xW t t d t | É É É D]: } | | É  | d É } | | | | | | <| | <q: Wd S(   sÿ   x, random=random.random -> shuffle list x in place; return None.

        Optional arg random is a 0-argument function returning a random
        float in [0.0, 1.0); by default, the standard random.random.

        i   N(   R(   R   R>   t   reversedt   xrangeR[   (   R*   R+   R   RL   t   it   j(    (    s   /usr/lib/python2.7/random.pyR     s    "c         C   s…  t  | É } d | k o# | k n s7 t d É Ç n  |  j } t } d	 g | } d } | d k râ | d t t | d d É É 7} n  | | k s§ t | d É rt | É } xt	 | É D]A }	 | | É  | |	 É }
 | |
 | |	 <| | |	 d | |
 <qΩ Wn¿ y~ t
 É  } | j } xe t	 | É D]W }	 | | É  | É }
 x# |
 | k re| | É  | É }
 qCW| |
 É | |
 | |	 <q'WWn? t t f k
 rƒt | t É rÆÇ  n  |  j t | É | É SX| S(
   s8  Chooses k unique random elements from a population sequence.

        Returns a new list containing elements from the population while
        leaving the original population unchanged.  The resulting list is
        in selection order so that all sub-slices will also be valid random
        samples.  This allows raffle winners (the sample) to be partitioned
        into grand prize and second place winners (the subslices).

        Members of the population need not be hashable or unique.  If the
        population contains repeats, then each occurrence is a possible
        selection in the sample.

        To choose a sample in a range of integers, use xrange as an argument.
        This is especially fast and space efficient for sampling from a
        large population:   sample(xrange(10000000), 60)
        i    s   sample larger than populationi   i   i   i   t   keysi   N(   R[   R7   R   R>   R(   t   _ceilRV   t   hasattrt   listR^   t   sett   addR8   t   KeyErrort
   isinstanceR   R6   (   R*   t
   populationRY   RB   R   RL   t   resultt   setsizet   poolR_   R`   t   selectedt   selected_add(    (    s   /usr/lib/python2.7/random.pyR   %  s:    	$		
c         C   s   | | | |  j  É  S(   sH   Get a random number in the range [a, b) or [a, b] depending on rounding.(   R   (   R*   R3   RR   (    (    s   /usr/lib/python2.7/random.pyR   f  s    g        g      ?c         C   së   |  j  É  } y( | d k r! d n | | | | } Wn t k
 rH | SX| | k ry d | } d | } | | } } n  | | | | | d S(   s‹   Triangular distribution.

        Continuous distribution bounded by given lower and upper limits,
        and having a given mode value in-between.

        http://en.wikipedia.org/wiki/Triangular_distribution

        g      ‡?g      ?N(   R   R(   t   ZeroDivisionError(   R*   t   lowt   hight   modet   ut   c(    (    s   /usr/lib/python2.7/random.pyR   l  s    	(

c         C   si   |  j  } xQ | É  } d | É  } t | d | } | | d } | t | É k r Pq q W| | | S(   s\   Normal distribution.

        mu is the mean, and sigma is the standard deviation.

        g      ?g      ‡?g      @(   R   t   NV_MAGICCONSTRV   (   R*   t   mut   sigmaR   t   u1t   u2t   zt   zz(    (    s   /usr/lib/python2.7/random.pyR   Ç  s    		c         C   s   t  |  j | | É É S(   s˚   Log normal distribution.

        If you take the natural logarithm of this distribution, you'll get a
        normal distribution with mean mu and standard deviation sigma.
        mu can have any value, and sigma must be greater than zero.

        (   t   _expR   (   R*   Rv   Rw   (    (    s   /usr/lib/python2.7/random.pyR   õ  s    c         C   s   t  d |  j É  É | S(   s^  Exponential distribution.

        lambd is 1.0 divided by the desired mean.  It should be
        nonzero.  (The parameter would be called "lambda", but that is
        a reserved word in Python.)  Returned values range from 0 to
        positive infinity if lambd is positive, and from negative
        infinity to 0 if lambd is negative.

        g      ?(   RV   R   (   R*   t   lambd(    (    s   /usr/lib/python2.7/random.pyR   ß  s    c         C   s  |  j  } | d k r  t | É  Sd | } | t d | | É } xf | É  } t t | É } | | | } | É  }	 |	 d | | k  s£ |	 d | t | É k rE PqE qE Wd | }
 |
 | d |
 | } | É  } | d k r˜ | t | É t } n | t | É t } | S(   sF  Circular data distribution.

        mu is the mean angle, expressed in radians between 0 and 2*pi, and
        kappa is the concentration parameter, which must be greater than or
        equal to zero.  If kappa is equal to zero, this distribution reduces
        to a uniform random angle over the range 0 to 2*pi.

        gçÌµ†˜∆∞>g      ‡?g      ?(   R   t   TWOPIt   _sqrtt   _cost   _piR|   t   _acos(   R*   Rv   t   kappaR   RC   RZ   Rx   Rz   t   dRy   t   qt   ft   u3t   theta(    (    s   /usr/lib/python2.7/random.pyR   ∫  s&    	
		.
	c         C   s
  | d k s | d k r$ t  d Ç n  |  j } | d k rt d | d É } | t } | | } x¢| É  } d | k  oÑ d k  n sè qd n  d | É  } t | d | É | }	 | t |	 É }
 | | | } | | |	 |
 } | t d | d k s| t | É k rd |
 | Sqd WnÈ | d k r]| É  } x | d k rM| É  } q5Wt | É | Sxû | É  } t | t } | | } | d k rû| d | }
 n t | | | É }
 | É  } | d k r„| |
 | d k r˙Pq˙q`| t |
 É k r`Pq`q`W|
 | Sd S(	   sZ  Gamma distribution.  Not the gamma function!

        Conditions on the parameters are alpha > 0 and beta > 0.

        The probability distribution function is:

                    x ** (alpha - 1) * math.exp(-x / beta)
          pdf(x) =  --------------------------------------
                      math.gamma(alpha) * beta ** alpha

        g        s*   gammavariate: alpha and beta must be > 0.0g      ?g       @gHØºöÚ◊z>gÀP ˇˇÔ?g      @N(   R7   R   R   t   LOG4RV   R|   t   SG_MAGICCONSTt   _e(   R*   t   alphat   betaR   t   ainvt   bbbt   cccRx   Ry   t   vR+   Rz   RZ   Rs   RR   t   p(    (    s   /usr/lib/python2.7/random.pyR   Í  sJ    	

	*		
	c         C   sÉ   |  j  } |  j } d |  _ | d k rw | É  t } t d t d | É  É É } t | É | } t | É | |  _ n  | | | S(   sÿ   Gaussian distribution.

        mu is the mean, and sigma is the standard deviation.  This is
        slightly faster than the normalvariate() function.

        Not thread-safe without a lock around calls.

        g       ¿g      ?N(   R   R)   R(   R~   R   RV   RÄ   t   _sin(   R*   Rv   Rw   R   Rz   t   x2pit   g2rad(    (    s   /usr/lib/python2.7/random.pyR   2  s    			c         C   s>   |  j  | d É } | d k r" d S| | |  j  | d É Sd S(   sç   Beta distribution.

        Conditions on the parameters are alpha > 0 and beta > 0.
        Returned values range between 0 and 1.

        g      ?i    g        N(   R   (   R*   Rå   Rç   t   y(    (    s   /usr/lib/python2.7/random.pyR   g  s    
c         C   s%   d |  j  É  } d t | d | É S(   s3   Pareto distribution.  alpha is the shape parameter.g      ?(   R   t   pow(   R*   Rå   Rs   (    (    s   /usr/lib/python2.7/random.pyR    y  s    c         C   s,   d |  j  É  } | t t | É d | É S(   sf   Weibull distribution.

        alpha is the scale parameter and beta is the shape parameter.

        g      ?(   R   Ró   RV   (   R*   Rå   Rç   Rs   (    (    s   /usr/lib/python2.7/random.pyR!   Ç  s    N(#   t   __name__t
   __module__t   __doc__R4   R(   R,   R   R"   R#   R$   RD   RE   RG   R>   t   BPFR   R   RV   t   _MethodTypet   _BuiltinMethodTypeRH   R   R   R   R   R   R   R   R   R   R   R   R   R    R!   (    (    (    s   /usr/lib/python2.7/random.pyR   H   s8   							?			A					0	H	5			c           B   s\   e  Z d  Z d	 d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d d d Ñ Z	 d	 d Ñ Z
 RS(
   i   c         C   s  | d k rd y t t t d É É d É } Wqd t k
 r` d d l } t | j É  d É } qd Xn  t | t t f É sà t | É } n  t	 | d É \ } } t	 | d É \ } } t	 | d É \ } } t | É d t | É d t | É d f |  _
 d |  _ d S(	   s¸  Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.

        If a is an int or long, a is used directly.  Distinct values between
        0 and 27814431486575L inclusive are guaranteed to yield distinct
        internal states (this guarantee is specific to the default
        Wichmann-Hill generator).
        i   iˇˇˇˇNi   i<v  ibv  irv  i   (   R(   R-   R.   R/   R0   R1   Rh   R>   t   hasht   divmodt   _seedR)   (   R*   R3   R1   R+   Rñ   Rz   (    (    s   /usr/lib/python2.7/random.pyR   ì  s    0c         C   sj   |  j  \ } } } d | d } d | d } d | d } | | | f |  _  | d | d | d	 d
 S(   s3   Get the next random number in the range [0.0, 1.0).i´   i=v  i¨   icv  i™   isv  g    @è›@g    ¿ò›@g    ¿ú›@g      ?(   R†   (   R*   R+   Rñ   Rz   (    (    s   /usr/lib/python2.7/random.pyR   ≤  s    c         C   s   |  j  |  j |  j f S(   s9   Return internal state; can be passed to setstate() later.(   R4   R†   R)   (   R*   (    (    s   /usr/lib/python2.7/random.pyR"   —  s    c         C   sK   | d } | d k r. | \ } |  _  |  _ n t d | |  j f É Ç d S(   s:   Restore internal state from object returned by getstate().i    i   s?   state with version %s passed to Random.setstate() of version %sN(   R†   R)   R7   R4   (   R*   R9   R:   (    (    s   /usr/lib/python2.7/random.pyR#   ’  s
    
c         C   s£   | d k s t  d É Ç n  |  j \ } } } t | t d | d É É d } t | t d | d É É d } t | t d | d É É d } | | | f |  _ d	 S(
   s√  Act as if n calls to random() were made, but quickly.

        n is an int, greater than or equal to 0.

        Example use:  If you have 2 threads and know that each will
        consume no more than a million random numbers, create two Random
        objects r1 and r2, then do
            r2.setstate(r1.getstate())
            r2.jumpahead(1000000)
        Then r1 and r2 will use guaranteed-disjoint segments of the full
        period.
        i    s   n must be >= 0i´   i=v  i¨   icv  i™   isv  N(   R7   R†   R>   Ró   (   R*   RB   R+   Rñ   Rz   (    (    s   /usr/lib/python2.7/random.pyR$   ﬂ  s       i    c         C   s  t  | É t  | É k o4 t  | É k o4 t k n sH t d É Ç n  d | k o_ d k  n oô d | k o{ d k  n oô d | k oó d k  n s´ t d É Ç n  d | k oÕ | k oÕ | k n rNd d l } t | j É  d É } t | d @| d ?AÉ } t | d É \ } } t | d É \ } } t | d É \ } } n  | pWd	 | p`d	 | pid	 f |  _ d |  _	 d S(
   sj   Set the Wichmann-Hill seed from (x, y, z).

        These must be integers in the range [0, 256).
        s   seeds must be integersi    i   s   seeds must be in range(0, 256)iˇˇˇˇNiˇˇˇ i   i   (
   RT   R>   R8   R7   R1   R-   Rü   R†   R(   R)   (   R*   R+   Rñ   Rz   R1   t   t(    (    s   /usr/lib/python2.7/random.pyt   __whseedı  s    9T'$c         C   s∏   | d k r |  j É  d St | É } t | d É \ } } t | d É \ } } t | d É \ } } | | d pv d } | | d pä d } | | d pû d } |  j | | | É d S(   sb  Seed from hashable object's hash code.

        None or no argument seeds from current time.  It is not guaranteed
        that objects with distinct hash codes lead to distinct internal
        states.

        This is obsolete, provided for compatibility with the seed routine
        used prior to Python 2.1.  Use the .seed() method instead.
        Ni   i   (   R(   t   _WichmannHill__whseedRû   Rü   (   R*   R3   R+   Rñ   Rz   (    (    s   /usr/lib/python2.7/random.pyt   whseed  s    
N(   Rò   Rô   R4   R(   R   R   R"   R#   R$   R£   R§   (    (    (    s   /usr/lib/python2.7/random.pyR%   è  s   			
	c           B   sF   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z Z d Ñ  Z e Z	 Z
 RS(   s›   Alternate random number generator using sources provided
    by the operating system (such as /dev/urandom on Unix or
    CryptGenRandom on Windows).

     Not available on all systems (see os.urandom() for details).
    c         C   s!   t  t t d É É d É d ?t S(   s3   Get the next random number in the range [0.0, 1.0).i   i   i   (   R-   R.   R/   t	   RECIP_BPF(   R*   (    (    s   /usr/lib/python2.7/random.pyR   -  s    c         C   su   | d k r t  d É Ç n  | t | É k r< t d É Ç n  | d d } t t t | É É d É } | | d | ?S(   s>   getrandbits(k) -> x.  Generates a long int with k random bits.i    s(   number of bits must be greater than zeros#   number of bits should be an integeri   i   i   (   R7   R>   R8   R-   R.   R/   (   R*   RY   t   bytesR+   (    (    s   /usr/lib/python2.7/random.pyR&   1  s    c         O   s   d S(   s<   Stub method.  Not used for a system random number generator.N(   R(   (   R*   t   argst   kwds(    (    s   /usr/lib/python2.7/random.pyt   _stub;  s    c         O   s   t  d É Ç d S(   sA   Method should not be called for a system random number generator.s*   System entropy source does not have state.N(   R0   (   R*   Rß   R®   (    (    s   /usr/lib/python2.7/random.pyt   _notimplemented@  s    (   Rò   Rô   Rö   R   R&   R©   R   R$   R™   R"   R#   (    (    (    s   /usr/lib/python2.7/random.pyR'   %  s   		
	
	c         C   sı   d d  l  } |  Gd G| j GHd } d } d } d } | j  É  } xV t |  É D]H }	 | | å  }
 | |
 7} | |
 |
 } t |
 | É } t |
 | É } qM W| j  É  } t | | d É Gd G| |  } t | |  | | É } d | | | | f GHd  S(	   Niˇˇˇˇt   timesg        g    _†Bg    _†¬i   s   sec,s!   avg %g, stddev %g, min %g, max %g(   R1   Rò   t   ranget   mint   maxt   roundR   (   RB   t   funcRß   R1   t   totalt   sqsumt   smallestt   largestt   t0R_   R+   t   t1t   avgt   stddev(    (    s   /usr/lib/python2.7/random.pyt   _test_generatorG  s&    

i–  c         C   s  t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d É t  |  t d d d f É d  S(   Ng        g      ?g{ÆG·zÑ?göôôôôôπ?g       @g      ‡?gÕÃÃÃÃÃÏ?g      4@g      i@g      @(    (   g        g      ?(   g        g      ?(   g        g      ?(   g{ÆG·zÑ?g      ?(   göôôôôôπ?g      ?(   göôôôôôπ?g       @(   g      ‡?g      ?(   gÕÃÃÃÃÃÏ?g      ?(   g      ?g      ?(   g       @g      ?(   g      4@g      ?(   g      i@g      ?(   g        g      ?(   g      @g      @gUUUUUU’?(	   Rπ   R   R   R   R   R   R   R   R   (   t   N(    (    s   /usr/lib/python2.7/random.pyt   _test]  s     t   __main__(K   Rö   t
   __future__R    t   warningsR   RU   t   typesR   Rú   R   Rù   t   mathR   RV   R   R|   R   RÅ   R   Rã   R   Rb   R	   R   R
   RÇ   R   RÄ   R   Rì   t   osR   R/   t   binasciiR   R.   t   hashlibR?   t   __all__Ru   R~   Râ   Rä   Rõ   R•   t   _randomR   R%   R'   Rπ   Rª   t   _instR   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R    R!   R"   R#   R$   R&   Rò   (    (    (    s   /usr/lib/python2.7/random.pyt   <module>(   sj   ("	
ˇ ˇ Iñ"																								                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   s{  d  Z  d Z d Z d Z d Z d Z d Z d Z d Z d	 Z	 d
 Z
 d Ñ  Z d Ñ  Z d Z d Z d Z d Z d Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Z d Z e Z d Z d Z d Z  d  Z! d! Z" d Z# d Z$ d  Z% d" Z& d# Z' d$ Z( d	 Z) d Z* d Z+ d Z, d Z- d Z. d Z/ d Z0 d	 Z1 d$ Z2 d# Z3 d Z4 d% Z5 d& Z6 d' Z7 d( Z8 d) Z9 d* S(+   so   Constants/functions for interpreting results of os.stat() and os.lstat().

Suggested usage: from stat import *
i    i   i   i   i   i   i   i   i   i	   c         C   s   |  d @S(   Niˇ  (    (   t   mode(    (    s   /usr/lib/python2.7/stat.pyt   S_IMODE   s    c         C   s   |  d @S(   Ni   (    (   R    (    (    s   /usr/lib/python2.7/stat.pyt   S_IFMT   s    i @  i    i `  i Ä  i   i †  i ¿  c         C   s   t  |  É t k S(   N(   R   t   S_IFDIR(   R    (    (    s   /usr/lib/python2.7/stat.pyt   S_ISDIR(   s    c         C   s   t  |  É t k S(   N(   R   t   S_IFCHR(   R    (    (    s   /usr/lib/python2.7/stat.pyt   S_ISCHR+   s    c         C   s   t  |  É t k S(   N(   R   t   S_IFBLK(   R    (    (    s   /usr/lib/python2.7/stat.pyt   S_ISBLK.   s    c         C   s   t  |  É t k S(   N(   R   t   S_IFREG(   R    (    (    s   /usr/lib/python2.7/stat.pyt   S_ISREG1   s    c         C   s   t  |  É t k S(   N(   R   t   S_IFIFO(   R    (    (    s   /usr/lib/python2.7/stat.pyt   S_ISFIFO4   s    c         C   s   t  |  É t k S(   N(   R   t   S_IFLNK(   R    (    (    s   /usr/lib/python2.7/stat.pyt   S_ISLNK7   s    c         C   s   t  |  É t k S(   N(   R   t   S_IFSOCK(   R    (    (    s   /usr/lib/python2.7/stat.pyt   S_ISSOCK:   s    i   i   i   i   iÄ   i@   i¿  i8   i    i   i   i   i   i   i    N(:   t   __doc__t   ST_MODEt   ST_INOt   ST_DEVt   ST_NLINKt   ST_UIDt   ST_GIDt   ST_SIZEt   ST_ATIMEt   ST_MTIMEt   ST_CTIMER   R   R   R   R   R	   R   R   R   R   R   R   R
   R   R   R   t   S_ISUIDt   S_ISGIDt   S_ENFMTt   S_ISVTXt   S_IREADt   S_IWRITEt   S_IEXECt   S_IRWXUt   S_IRUSRt   S_IWUSRt   S_IXUSRt   S_IRWXGt   S_IRGRPt   S_IWGRPt   S_IXGRPt   S_IRWXOt   S_IROTHt   S_IWOTHt   S_IXOTHt	   UF_NODUMPt   UF_IMMUTABLEt	   UF_APPENDt	   UF_OPAQUEt   UF_NOUNLINKt   UF_COMPRESSEDt	   UF_HIDDENt   SF_ARCHIVEDt   SF_IMMUTABLEt	   SF_APPENDt   SF_NOUNLINKt   SF_SNAPSHOT(    (    (    s   /usr/lib/python2.7/stat.pyt   <module>   sr   									                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #
# Secret Labs' Regular Expression Engine
#
# re-compatible interface for the sre matching engine
#
# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
#
# This version of the SRE library can be redistributed under CNRI's
# Python 1.6 license.  For any other use, please contact Secret Labs
# AB (info@pythonware.com).
#
# Portions of this engine have been developed in cooperation with
# CNRI.  Hewlett-Packard provided funding for 1.6 integration and
# other compatibility work.
#

r"""Support for regular expressions (RE).

This module provides regular expression matching operations similar to
those found in Perl.  It supports both 8-bit and Unicode strings; both
the pattern and the strings being processed can contain null bytes and
characters outside the US ASCII range.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like "A", "a", or "0", are the simplest
regular expressions; they simply match themselves.  You can
concatenate ordinary characters, so last matches the string 'last'.

The special characters are:
    "."      Matches any character except a newline.
    "^"      Matches the start of the string.
    "$"      Matches the end of the string or just before the newline at
             the end of the string.
    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
             Greedy means that it will match as many repetitions as possible.
    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    *?,+?,?? Non-greedy versions of the previous three special characters.
    {m,n}    Matches from m to n repetitions of the preceding RE.
    {m,n}?   Non-greedy version of the above.
    "\\"     Either escapes special characters or signals a special sequence.
    []       Indicates a set of characters.
             A "^" as the first character indicates a complementing set.
    "|"      A|B, creates an RE that will match either A or B.
    (...)    Matches the RE inside the parentheses.
             The contents can be retrieved or matched later in the string.
    (?iLmsux) Set the I, L, M, S, U, or X flag for the RE (see below).
    (?:...)  Non-grouping version of regular parentheses.
    (?P<name>...) The substring matched by the group is accessible by name.
    (?P=name)     Matches the text matched earlier by the group named name.
    (?#...)  A comment; ignored.
    (?=...)  Matches if ... matches next, but doesn't consume the string.
    (?!...)  Matches if ... doesn't match next.
    (?<=...) Matches if preceded by ... (must be fixed length).
    (?<!...) Matches if not preceded by ... (must be fixed length).
    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
                       the (optional) no pattern otherwise.

The special sequences consist of "\\" and a character from the list
below.  If the ordinary character is not on the list, then the
resulting RE will match the second character.
    \number  Matches the contents of the group of the same number.
    \A       Matches only at the start of the string.
    \Z       Matches only at the end of the string.
    \b       Matches the empty string, but only at the start or end of a word.
    \B       Matches the empty string, but not at the start or end of a word.
    \d       Matches any decimal digit; equivalent to the set [0-9].
    \D       Matches any non-digit character; equivalent to the set [^0-9].
    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v].
    \S       Matches any non-whitespace character; equiv. to [^ \t\n\r\f\v].
    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_].
             With LOCALE, it will match the set [0-9_] plus characters defined
             as letters for the current locale.
    \W       Matches the complement of \w.
    \\       Matches a literal backslash.

This module exports the following functions:
    match    Match a regular expression pattern to the beginning of a string.
    search   Search a string for the presence of a pattern.
    sub      Substitute occurrences of a pattern found in a string.
    subn     Same as sub, but also return the number of substitutions made.
    split    Split a string by the occurrences of a pattern.
    findall  Find all occurrences of a pattern in a string.
    finditer Return an iterator yielding a match object for each match.
    compile  Compile a pattern into a RegexObject.
    purge    Clear the regular expression cache.
    escape   Backslash all non-alphanumerics in a string.

Some of the functions in this module takes flags as optional parameters:
    I  IGNORECASE  Perform case-insensitive matching.
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
    M  MULTILINE   "^" matches the beginning of lines (after a newline)
                   as well as the string.
                   "$" matches the end of lines (before a newline) as well
                   as the end of the string.
    S  DOTALL      "." matches any character at all, including the newline.
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
    U  UNICODE     Make \w, \W, \b, \B, dependent on the Unicode locale.

This module also defines an exception 'error'.

"""

import sys
import sre_compile
import sre_parse
try:
    import _locale
except ImportError:
    _locale = None

# public symbols
__all__ = [ "match", "search", "sub", "subn", "split", "findall",
    "compile", "purge", "template", "escape", "I", "L", "M", "S", "X",
    "U", "IGNORECASE", "LOCALE", "MULTILINE", "DOTALL", "VERBOSE",
    "UNICODE", "error" ]

__version__ = "2.2.1"

# flags
I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE # ignore case
L = LOCALE = sre_compile.SRE_FLAG_LOCALE # assume current 8-bit locale
U = UNICODE = sre_compile.SRE_FLAG_UNICODE # assume unicode locale
M = MULTILINE = sre_compile.SRE_FLAG_MULTILINE # make anchors look for newline
S = DOTALL = sre_compile.SRE_FLAG_DOTALL # make dot match newline
X = VERBOSE = sre_compile.SRE_FLAG_VERBOSE # ignore whitespace and comments

# sre extensions (experimental, don't rely on these)
T = TEMPLATE = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking
DEBUG = sre_compile.SRE_FLAG_DEBUG # dump pattern after compilation

# sre exception
error = sre_compile.error

# --------------------------------------------------------------------
# public interface

def match(pattern, string, flags=0):
    """Try to apply the pattern at the start of the string, returning
    a match object, or None if no match was found."""
    return _compile(pattern, flags).match(string)

def search(pattern, string, flags=0):
    """Scan through string looking for a match to the pattern, returning
    a match object, or None if no match was found."""
    return _compile(pattern, flags).search(string)

def sub(pattern, repl, string, count=0, flags=0):
    """Return the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in string by the
    replacement repl.  repl can be either a string or a callable;
    if a string, backslash escapes in it are processed.  If it is
    a callable, it's passed the match object and must return
    a replacement string to be used."""
    return _compile(pattern, flags).sub(repl, string, count)

def subn(pattern, repl, string, count=0, flags=0):
    """Return a 2-tuple containing (new_string, number).
    new_string is the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in the source
    string by the replacement repl.  number is the number of
    substitutions that were made. repl can be either a string or a
    callable; if a string, backslash escapes in it are processed.
    If it is a callable, it's passed the match object and must
    return a replacement string to be used."""
    return _compile(pattern, flags).subn(repl, string, count)

def split(pattern, string, maxsplit=0, flags=0):
    """Split the source string by the occurrences of the pattern,
    returning a list containing the resulting substrings."""
    return _compile(pattern, flags).split(string, maxsplit)

def findall(pattern, string, flags=0):
    """Return a list of all non-overlapping matches in the string.

    If one or more groups are present in the pattern, return a
    list of groups; this will be a list of tuples if the pattern
    has more than one group.

    Empty matches are included in the result."""
    return _compile(pattern, flags).findall(string)

if sys.hexversion >= 0x02020000:
    __all__.append("finditer")
    def finditer(pattern, string, flags=0):
        """Return an iterator over all non-overlapping matches in the
        string.  For each match, the iterator returns a match object.

        Empty matches are included in the result."""
        return _compile(pattern, flags).finditer(string)

def compile(pattern, flags=0):
    "Compile a regular expression pattern, returning a pattern object."
    return _compile(pattern, flags)

def purge():
    "Clear the regular expression cache"
    _cache.clear()
    _cache_repl.clear()

def template(pattern, flags=0):
    "Compile a template pattern, returning a pattern object"
    return _compile(pattern, flags|T)

_alphanum = frozenset(
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")

def escape(pattern):
    "Escape all non-alphanumeric characters in pattern."
    s = list(pattern)
    alphanum = _alphanum
    for i, c in enumerate(pattern):
        if c not in alphanum:
            if c == "\000":
                s[i] = "\\000"
            else:
                s[i] = "\\" + c
    return pattern[:0].join(s)

# --------------------------------------------------------------------
# internals

_cache = {}
_cache_repl = {}

_pattern_type = type(sre_compile.compile("", 0))

_MAXCACHE = 100

def _compile(*key):
    # internal: compile pattern
    pattern, flags = key
    bypass_cache = flags & DEBUG
    if not bypass_cache:
        cachekey = (type(key[0]),) + key
        try:
            p, loc = _cache[cachekey]
            if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
                return p
        except KeyError:
            pass
    if isinstance(pattern, _pattern_type):
        if flags:
            raise ValueError('Cannot process flags argument with a compiled pattern')
        return pattern
    if not sre_compile.isstring(pattern):
        raise TypeError, "first argument must be string or compiled pattern"
    try:
        p = sre_compile.compile(pattern, flags)
    except error, v:
        raise error, v # invalid expression
    if not bypass_cache:
        if len(_cache) >= _MAXCACHE:
            _cache.clear()
        if p.flags & LOCALE:
            if not _locale:
                return p
            loc = _locale.setlocale(_locale.LC_CTYPE)
        else:
            loc = None
        _cache[cachekey] = p, loc
    return p

def _compile_repl(*key):
    # internal: compile replacement pattern
    p = _cache_repl.get(key)
    if p is not None:
        return p
    repl, pattern = key
    try:
        p = sre_parse.parse_template(repl, pattern)
    except error, v:
        raise error, v # invalid expression
    if len(_cache_repl) >= _MAXCACHE:
        _cache_repl.clear()
    _cache_repl[key] = p
    return p

def _expand(pattern, match, template):
    # internal: match.expand implementation hook
    template = sre_parse.parse_template(template, pattern)
    return sre_parse.expand_template(template, match)

def _subx(pattern, template):
    # internal: pattern.sub/subn implementation helper
    template = _compile_repl(template, pattern)
    if not template[0] and len(template[1]) == 1:
        # literal replacement
        return template[1][0]
    def filter(match, template=template):
        return sre_parse.expand_template(template, match)
    return filter

# register myself for pickling

import copy_reg

def _pickle(p):
    return _compile, (p.pattern, p.flags)

copy_reg.pickle(_pattern_type, _pickle, _compile)

# --------------------------------------------------------------------
# experimental stuff (see python-dev discussions for details)

class Scanner:
    def __init__(self, lexicon, flags=0):
        from sre_constants import BRANCH, SUBPATTERN
        self.lexicon = lexicon
        # combine phrases into a compound pattern
        p = []
        s = sre_parse.Pattern()
        s.flags = flags
        for phrase, action in lexicon:
            p.append(sre_parse.SubPattern(s, [
                (SUBPATTERN, (len(p)+1, sre_parse.parse(phrase, flags))),
                ]))
        s.groups = len(p)+1
        p = sre_parse.SubPattern(s, [(BRANCH, (None, p))])
        self.scanner = sre_compile.compile(p)
    def scan(self, string):
        result = []
        append = result.append
        match = self.scanner.scanner(string).match
        i = 0
        while 1:
            m = match()
            if not m:
                break
            j = m.end()
            if i == j:
                break
            action = self.lexicon[m.lastindex-1][1]
            if hasattr(action, '__call__'):
                self.match = m
                action = action(self, m.group())
            if action is not None:
                append(action)
            i = j
        return result, string[i:]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Û
”´[c           @   sQ  d  Z  d d l Z d d l Z d d l Z y d d l Z Wn e k
 rS d Z n Xd d d d d d d	 d
 d d d d d d d d d d d d d d d g Z d Z e j	 Z
 Z e j Z Z e j Z Z e j Z Z e j Z Z e j Z Z e j Z Z e j Z e j  Z  d d Ñ Z! d d Ñ Z" d d d Ñ Z# d d d Ñ Z$ d d d  Ñ Z% d d! Ñ Z& e j' d" k rée j( d# É d d$ Ñ Z) n  d d% Ñ Z* d& Ñ  Z+ d d' Ñ Z, e- d( É Z. d) Ñ  Z/ i  Z0 i  Z1 e2 e j* d* d É É Z3 d+ Z4 d, Ñ  Z5 d- Ñ  Z6 d. Ñ  Z7 d/ Ñ  Z8 d d l9 Z9 d0 Ñ  Z: e9 j; e3 e: e5 É d1 d3 d2 Ñ  É  YZ< d S(4   s‚  Support for regular expressions (RE).

This module provides regular expression matching operations similar to
those found in Perl.  It supports both 8-bit and Unicode strings; both
the pattern and the strings being processed can contain null bytes and
characters outside the US ASCII range.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like "A", "a", or "0", are the simplest
regular expressions; they simply match themselves.  You can
concatenate ordinary characters, so last matches the string 'last'.

The special characters are:
    "."      Matches any character except a newline.
    "^"      Matches the start of the string.
    "$"      Matches the end of the string or just before the newline at
             the end of the string.
    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
             Greedy means that it will match as many repetitions as possible.
    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    *?,+?,?? Non-greedy versions of the previous three special characters.
    {m,n}    Matches from m to n repetitions of the preceding RE.
    {m,n}?   Non-greedy version of the above.
    "\\"     Either escapes special characters or signals a special sequence.
    []       Indicates a set of characters.
             A "^" as the first character indicates a complementing set.
    "|"      A|B, creates an RE that will match either A or B.
    (...)    Matches the RE inside the parentheses.
             The contents can be retrieved or matched later in the string.
    (?iLmsux) Set the I, L, M, S, U, or X flag for the RE (see below).
    (?:...)  Non-grouping version of regular parentheses.
    (?P<name>...) The substring matched by the group is accessible by name.
    (?P=name)     Matches the text matched earlier by the group named name.
    (?#...)  A comment; ignored.
    (?=...)  Matches if ... matches next, but doesn't consume the string.
    (?!...)  Matches if ... doesn't match next.
    (?<=...) Matches if preceded by ... (must be fixed length).
    (?<!...) Matches if not preceded by ... (must be fixed length).
    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
                       the (optional) no pattern otherwise.

The special sequences consist of "\\" and a character from the list
below.  If the ordinary character is not on the list, then the
resulting RE will match the second character.
    \number  Matches the contents of the group of the same number.
    \A       Matches only at the start of the string.
    \Z       Matches only at the end of the string.
    \b       Matches the empty string, but only at the start or end of a word.
    \B       Matches the empty string, but not at the start or end of a word.
    \d       Matches any decimal digit; equivalent to the set [0-9].
    \D       Matches any non-digit character; equivalent to the set [^0-9].
    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v].
    \S       Matches any non-whitespace character; equiv. to [^ \t\n\r\f\v].
    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_].
             With LOCALE, it will match the set [0-9_] plus characters defined
             as letters for the current locale.
    \W       Matches the complement of \w.
    \\       Matches a literal backslash.

This module exports the following functions:
    match    Match a regular expression pattern to the beginning of a string.
    search   Search a string for the presence of a pattern.
    sub      Substitute occurrences of a pattern found in a string.
    subn     Same as sub, but also return the number of substitutions made.
    split    Split a string by the occurrences of a pattern.
    findall  Find all occurrences of a pattern in a string.
    finditer Return an iterator yielding a match object for each match.
    compile  Compile a pattern into a RegexObject.
    purge    Clear the regular expression cache.
    escape   Backslash all non-alphanumerics in a string.

Some of the functions in this module takes flags as optional parameters:
    I  IGNORECASE  Perform case-insensitive matching.
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
    M  MULTILINE   "^" matches the beginning of lines (after a newline)
                   as well as the string.
                   "$" matches the end of lines (before a newline) as well
                   as the end of the string.
    S  DOTALL      "." matches any character at all, including the newline.
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
    U  UNICODE     Make \w, \W, \b, \B, dependent on the Unicode locale.

This module also defines an exception 'error'.

iˇˇˇˇNt   matcht   searcht   subt   subnt   splitt   findallt   compilet   purget   templatet   escapet   It   Lt   Mt   St   Xt   Ut
   IGNORECASEt   LOCALEt	   MULTILINEt   DOTALLt   VERBOSEt   UNICODEt   errors   2.2.1i    c         C   s   t  |  | É j | É S(   sq   Try to apply the pattern at the start of the string, returning
    a match object, or None if no match was found.(   t   _compileR    (   t   patternt   stringt   flags(    (    s   /usr/lib/python2.7/re.pyR    ä   s    c         C   s   t  |  | É j | É S(   st   Scan through string looking for a match to the pattern, returning
    a match object, or None if no match was found.(   R   R   (   R   R   R   (    (    s   /usr/lib/python2.7/re.pyR   è   s    c         C   s   t  |  | É j | | | É S(   sZ  Return the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in string by the
    replacement repl.  repl can be either a string or a callable;
    if a string, backslash escapes in it are processed.  If it is
    a callable, it's passed the match object and must return
    a replacement string to be used.(   R   R   (   R   t   replR   t   countR   (    (    s   /usr/lib/python2.7/re.pyR   î   s    c         C   s   t  |  | É j | | | É S(   s€  Return a 2-tuple containing (new_string, number).
    new_string is the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in the source
    string by the replacement repl.  number is the number of
    substitutions that were made. repl can be either a string or a
    callable; if a string, backslash escapes in it are processed.
    If it is a callable, it's passed the match object and must
    return a replacement string to be used.(   R   R   (   R   R   R   R   R   (    (    s   /usr/lib/python2.7/re.pyR   ù   s    	c         C   s   t  |  | É j | | É S(   st   Split the source string by the occurrences of the pattern,
    returning a list containing the resulting substrings.(   R   R   (   R   R   t   maxsplitR   (    (    s   /usr/lib/python2.7/re.pyR   ®   s    c         C   s   t  |  | É j | É S(   s  Return a list of all non-overlapping matches in the string.

    If one or more groups are present in the pattern, return a
    list of groups; this will be a list of tuples if the pattern
    has more than one group.

    Empty matches are included in the result.(   R   R   (   R   R   R   (    (    s   /usr/lib/python2.7/re.pyR   ≠   s    i  t   finditerc         C   s   t  |  | É j | É S(   s≥   Return an iterator over all non-overlapping matches in the
        string.  For each match, the iterator returns a match object.

        Empty matches are included in the result.(   R   R   (   R   R   R   (    (    s   /usr/lib/python2.7/re.pyR   π   s    c         C   s   t  |  | É S(   sA   Compile a regular expression pattern, returning a pattern object.(   R   (   R   R   (    (    s   /usr/lib/python2.7/re.pyR   ¿   s    c           C   s   t  j É  t j É  d S(   s"   Clear the regular expression cacheN(   t   _cachet   cleart   _cache_repl(    (    (    s   /usr/lib/python2.7/re.pyR   ƒ   s    
c         C   s   t  |  | t BÉ S(   s6   Compile a template pattern, returning a pattern object(   R   t   T(   R   R   (    (    s   /usr/lib/python2.7/re.pyR   …   s    t>   abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789c         C   sv   t  |  É } t } xP t |  É D]B \ } } | | k r | d k rP d | | <qa d | | | <q q W|  d  j | É S(   s2   Escape all non-alphanumeric characters in pattern.s    s   \000s   \i    (   t   listt	   _alphanumt	   enumeratet   join(   R   t   st   alphanumt   it   c(    (    s   /usr/lib/python2.7/re.pyR	   –   s    t    id   c          G   sl  |  \ } } | t  @} | sÜ t |  d É f |  } y< t | \ } } | d  k sj | t j t j É k rn | SWqÜ t k
 rÇ qÜ Xn  t | t	 É rÆ | r™ t
 d É Ç n  | St j | É s… t d Ç n  y t j | | É } Wn t k
 r˝ } t | Ç n X| sht t É t k r#t j É  n  | j t @rOt s:| St j t j É } n d  } | | f t | <n  | S(   Ni    s5   Cannot process flags argument with a compiled patterns1   first argument must be string or compiled pattern(   t   DEBUGt   typeR   t   Nonet   _localet	   setlocalet   LC_CTYPEt   KeyErrort
   isinstancet   _pattern_typet
   ValueErrort   sre_compilet   isstringt	   TypeErrorR   R   t   lent	   _MAXCACHER    R   R   (   t   keyR   R   t   bypass_cachet   cachekeyt   pt   loct   v(    (    s   /usr/lib/python2.7/re.pyR   Ê   s<    
$c          G   sç   t  j |  É } | d  k	 r | S|  \ } } y t j | | É } Wn t k
 r_ } t | Ç n Xt t  É t k r t  j É  n  | t  |  <| S(   N(	   R!   t   getR/   t	   sre_parset   parse_templateR   R:   R;   R    (   R<   R?   R   R   RA   (    (    s   /usr/lib/python2.7/re.pyt   _compile_repl  s    
c         C   s"   t  j | |  É } t  j | | É S(   N(   RC   RD   t   expand_template(   R   R    R   (    (    s   /usr/lib/python2.7/re.pyt   _expand  s    c         C   sL   t  | |  É } | d r< t | d É d k r< | d d S| d Ñ } | S(   Ni    i   c         S   s   t  j | |  É S(   N(   RC   RF   (   R    R   (    (    s   /usr/lib/python2.7/re.pyt   filter"  s    (   RE   R:   (   R   R   RH   (    (    s   /usr/lib/python2.7/re.pyt   _subx  s
    !c         C   s   t  |  j |  j f f S(   N(   R   R   R   (   R?   (    (    s   /usr/lib/python2.7/re.pyt   _pickle*  s    t   Scannerc           B   s   e  Z d  d Ñ Z d Ñ  Z RS(   i    c   	   	   C   sŸ   d d l  m } m } | |  _ g  } t j É  } | | _ xR | D]J \ } } | j t j | | t	 | É d t j
 | | É f f g É É qA Wt	 | É d | _ t j | | d  | f f g É } t j | É |  _ d  S(   Niˇˇˇˇ(   t   BRANCHt
   SUBPATTERNi   (   t   sre_constantsRL   RM   t   lexiconRC   t   PatternR   t   appendt
   SubPatternR:   t   parset   groupsR/   R7   R   t   scanner(	   t   selfRO   R   RL   RM   R?   R(   t   phraset   action(    (    s   /usr/lib/python2.7/re.pyt   __init__3  s    		3!c   	      C   s’   g  } | j  } |  j j | É j } d } xö | É  } | s@ Pn  | j É  } | | k r\ Pn  |  j | j d d } t | d É r§ | |  _ | |  | j É  É } n  | d  k	 rΩ | | É n  | } q- W| | | f S(   Ni    i   t   __call__(	   RQ   RU   R    t   endRO   t	   lastindext   hasattrt   groupR/   (	   RV   R   t   resultRQ   R    R*   t   mt   jRX   (    (    s   /usr/lib/python2.7/re.pyt   scanA  s&    			
(   t   __name__t
   __module__RY   Rb   (    (    (    s   /usr/lib/python2.7/re.pyRK   2  s   (    (=   t   __doc__t   sysR7   RC   R0   t   ImportErrorR/   t   __all__t   __version__t   SRE_FLAG_IGNORECASER
   R   t   SRE_FLAG_LOCALER   R   t   SRE_FLAG_UNICODER   R   t   SRE_FLAG_MULTILINER   R   t   SRE_FLAG_DOTALLR   R   t   SRE_FLAG_VERBOSER   R   t   SRE_FLAG_TEMPLATER"   t   TEMPLATEt   SRE_FLAG_DEBUGR-   R   R    R   R   R   R   R   t
   hexversionRQ   R   R   R   R   t	   frozensetR%   R	   R   R!   R.   R5   R;   R   RE   RG   RI   t   copy_regRJ   t   pickleRK   (    (    (    s   /usr/lib/python2.7/re.pyt   <module>f   s`   
			
				"				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     """Redo the builtin repr() (representation) but with limits on most sizes."""

__all__ = ["Repr","repr"]

import __builtin__
from itertools import islice

class Repr:

    def __init__(self):
        self.maxlevel = 6
        self.maxtuple = 6
        self.maxlist = 6
        self.maxarray = 5
        self.maxdict = 4
        self.maxset = 6
        self.maxfrozenset = 6
        self.maxdeque = 6
        self.maxstring = 30
        self.maxlong = 40
        self.maxother = 20

    def repr(self, x):
        return self.repr1(x, self.maxlevel)

    def repr1(self, x, level):
        typename = type(x).__name__
        if ' ' in typename:
            parts = typename.split()
            typename = '_'.join(parts)
        if hasattr(self, 'repr_' + typename):
            return getattr(self, 'repr_' + typename)(x, level)
        else:
            s = __builtin__.repr(x)
            if len(s) > self.maxother:
                i = max(0, (self.maxother-3)//2)
                j = max(0, self.maxother-3-i)
                s = s[:i] + '...' + s[len(s)-j:]
            return s

    def _repr_iterable(self, x, level, left, right, maxiter, trail=''):
        n = len(x)
        if level <= 0 and n:
            s = '...'
        else:
            newlevel = level - 1
            repr1 = self.repr1
            pieces = [repr1(elem, newlevel) for elem in islice(x, maxiter)]
            if n > maxiter:  pieces.append('...')
            s = ', '.join(pieces)
            if n == 1 and trail:  right = trail + right
        return '%s%s%s' % (left, s, right)

    def repr_tuple(self, x, level):
        return self._repr_iterable(x, level, '(', ')', self.maxtuple, ',')

    def repr_list(self, x, level):
        return self._repr_iterable(x, level, '[', ']', self.maxlist)

    def repr_array(self, x, level):
        header = "array('%s', [" % x.typecode
        return self._repr_iterable(x, level, header, '])', self.maxarray)

    def repr_set(self, x, level):
        x = _possibly_sorted(x)
        return self._repr_iterable(x, level, 'set([', '])', self.maxset)

    def repr_frozenset(self, x, level):
        x = _possibly_sorted(x)
        return self._repr_iterable(x, level, 'frozenset([', '])',
                                   self.maxfrozenset)

    def repr_deque(self, x, level):
        return self._repr_iterable(x, level, 'deque([', '])', self.maxdeque)

    def repr_dict(self, x, level):
        n = len(x)
        if n == 0: return '{}'
        if level <= 0: return '{...}'
        newlevel = level - 1
        repr1 = self.repr1
        pieces = []
        for key in islice(_possibly_sorted(x), self.maxdict):
            keyrepr = repr1(key, newlevel)
            valrepr = repr1(x[key], newlevel)
            pieces.append('%s: %s' % (keyrepr, valrepr))
        if n > self.maxdict: pieces.append('...')
        s = ', '.join(pieces)
        return '{%s}' % (s,)

    def repr_str(self, x, level):
        s = __builtin__.repr(x[:self.maxstring])
        if len(s) > self.maxstring:
            i = max(0, (self.maxstring-3)//2)
            j = max(0, self.maxstring-3-i)
            s = __builtin__.repr(x[:i] + x[len(x)-j:])
            s = s[:i] + '...' + s[len(s)-j:]
        return s

    def repr_long(self, x, level):
        s = __builtin__.repr(x) # XXX Hope this isn't too slow...
        if len(s) > self.maxlong:
            i = max(0, (self.maxlong-3)//2)
            j = max(0, self.maxlong-3-i)
            s = s[:i] + '...' + s[len(s)-j:]
        return s

    def repr_instance(self, x, level):
        try:
            s = __builtin__.repr(x)
            # Bugs in x.__repr__() can cause arbitrary
            # exceptions -- then make up something
        except Exception:
            return '<%s instance at %x>' % (x.__class__.__name__, id(x))
        if len(s) > self.maxstring:
            i = max(0, (self.maxstring-3)//2)
            j = max(0, self.maxstring-3-i)
            s = s[:i] + '...' + s[len(s)-j:]
        return s


def _possibly_sorted(x):
    # Since not all sequences of items can be sorted and comparison
    # functions may raise arbitrary exceptions, return an unsorted
    # sequence in that case.
    try:
        return sorted(x)
    except Exception:
        return list(x)

aRepr = Repr()
repr = aRepr.repr
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c           @   s`   d  Z  d d g Z d d l Z d d l m Z d d d Ñ  É  YZ d Ñ  Z e É  Z e j Z d S(	   sG   Redo the builtin repr() (representation) but with limits on most sizes.t   Reprt   repriˇˇˇˇN(   t   islicec           B   sâ   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d	 Ñ  Z
 d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sg   d |  _  d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _	 d |  _
 d  S(   Ni   i   i   i   i(   i   (   t   maxlevelt   maxtuplet   maxlistt   maxarrayt   maxdictt   maxsett   maxfrozensett   maxdequet	   maxstringt   maxlongt   maxother(   t   self(    (    s   /usr/lib/python2.7/repr.pyt   __init__
   s    										c         C   s   |  j  | |  j É S(   N(   t   repr1R   (   R   t   x(    (    s   /usr/lib/python2.7/repr.pyR      s    c         C   sÈ   t  | É j } d | k r9 | j É  } d j | É } n  t |  d | É rf t |  d | É | | É St j | É } t | É |  j	 k r· t
 d |  j	 d d É } t
 d |  j	 d | É } | |  d | t | É | } n  | Sd  S(   Nt    t   _t   repr_i    i   i   s   ...(   t   typet   __name__t   splitt   joint   hasattrt   getattrt   __builtin__R   t   lenR   t   max(   R   R   t   levelt   typenamet   partst   st   it   j(    (    s   /usr/lib/python2.7/repr.pyR      s    #t    c         C   s¿   t  | É } | d k r' | r' d } nà | d }	 |  j }
 g  t | | É D] } |
 | |	 É ^ qJ } | | k rÅ | j d É n  d j | É } | d k rØ | rØ | | } n  d | | | f S(   Ni    s   ...i   s   , s   %s%s%s(   R   R   R   t   appendR   (   R   R   R   t   leftt   rightt   maxitert   trailt   nR!   t   newlevelR   t   elemt   pieces(    (    s   /usr/lib/python2.7/repr.pyt   _repr_iterable)   s    	
	+  c         C   s   |  j  | | d d |  j d É S(   Nt   (t   )t   ,(   R.   R   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt
   repr_tuple6   s    c         C   s   |  j  | | d d |  j É S(   Nt   [t   ](   R.   R   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt	   repr_list9   s    c         C   s)   d | j  } |  j | | | d |  j É S(   Ns   array('%s', [s   ])(   t   typecodeR.   R   (   R   R   R   t   header(    (    s   /usr/lib/python2.7/repr.pyt
   repr_array<   s    c         C   s(   t  | É } |  j | | d d |  j É S(   Ns   set([s   ])(   t   _possibly_sortedR.   R   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt   repr_set@   s    c         C   s(   t  | É } |  j | | d d |  j É S(   Ns   frozenset([s   ])(   R9   R.   R	   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt   repr_frozensetD   s    c         C   s   |  j  | | d d |  j É S(   Ns   deque([s   ])(   R.   R
   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt
   repr_dequeI   s    c         C   s⁄   t  | É } | d k r d S| d k r, d S| d } |  j } g  } xY t t | É |  j É D]? } | | | É } | | | | É }	 | j d | |	 f É q^ W| |  j k r¿ | j d É n  d j | É }
 d |
 f S(	   Ni    s   {}s   {...}i   s   %s: %ss   ...s   , s   {%s}(   R   R   R   R9   R   R%   R   (   R   R   R   R*   R+   R   R-   t   keyt   keyreprt   valreprR!   (    (    s   /usr/lib/python2.7/repr.pyt	   repr_dictL   s       
	 c         C   s´   t  j | |  j  É } t | É |  j k rß t d |  j d d É } t d |  j d | É } t  j | |  | t | É | É } | |  d | t | É | } n  | S(   Ni    i   i   s   ...(   R   R   R   R   R   (   R   R   R   R!   R"   R#   (    (    s   /usr/lib/python2.7/repr.pyt   repr_str[   s    %#c         C   s   t  j | É } t | É |  j k r{ t d |  j d d É } t d |  j d | É } | |  d | t | É | } n  | S(   Ni    i   i   s   ...(   R   R   R   R   R   (   R   R   R   R!   R"   R#   (    (    s   /usr/lib/python2.7/repr.pyt	   repr_longd   s    #c         C   sÆ   y t  j | É } Wn( t k
 r= d | j j t | É f SXt | É |  j k r™ t d |  j d d É } t d |  j d | É } | |  d | t | É | } n  | S(   Ns   <%s instance at %x>i    i   i   s   ...(	   R   R   t	   Exceptiont	   __class__R   t   idR   R   R   (   R   R   R   R!   R"   R#   (    (    s   /usr/lib/python2.7/repr.pyt   repr_instancel   s    #(   R   t
   __module__R   R   R   R.   R2   R5   R8   R:   R;   R<   R@   RA   RB   RF   (    (    (    s   /usr/lib/python2.7/repr.pyR       s   													c         C   s-   y t  |  É SWn t k
 r( t |  É SXd  S(   N(   t   sortedRC   t   list(   R   (    (    s   /usr/lib/python2.7/repr.pyR9   z   s    (    (	   t   __doc__t   __all__R   t	   itertoolsR   R    R9   t   aReprR   (    (    (    s   /usr/lib/python2.7/repr.pyt   <module>   s   r			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """Restricted execution facilities.

The class RExec exports methods r_exec(), r_eval(), r_execfile(), and
r_import(), which correspond roughly to the built-in operations
exec, eval(), execfile() and import, but executing the code in an
environment that only exposes those built-in operations that are
deemed safe.  To this end, a modest collection of 'fake' modules is
created which mimics the standard modules by the same names.  It is a
policy decision which built-in modules and operations are made
available; this module provides a reasonable default, but derived
classes can change the policies e.g. by overriding or extending class
variables like ok_builtin_modules or methods like make_sys().

XXX To do:
- r_open should allow writing tmp dir
- r_exec etc. with explicit globals/locals? (Use rexec("exec ... in ...")?)

"""
from warnings import warnpy3k
warnpy3k("the rexec module has been removed in Python 3.0", stacklevel=2)
del warnpy3k


import sys
import __builtin__
import os
import ihooks
import imp

__all__ = ["RExec"]

class FileBase:

    ok_file_methods = ('fileno', 'flush', 'isatty', 'read', 'readline',
            'readlines', 'seek', 'tell', 'write', 'writelines', 'xreadlines',
            '__iter__')


class FileWrapper(FileBase):

    # XXX This is just like a Bastion -- should use that!

    def __init__(self, f):
        for m in self.ok_file_methods:
            if not hasattr(self, m) and hasattr(f, m):
                setattr(self, m, getattr(f, m))

    def close(self):
        self.flush()


TEMPLATE = """
def %s(self, *args):
        return getattr(self.mod, self.name).%s(*args)
"""

class FileDelegate(FileBase):

    def __init__(self, mod, name):
        self.mod = mod
        self.name = name

    for m in FileBase.ok_file_methods + ('close',):
        exec TEMPLATE % (m, m)


class RHooks(ihooks.Hooks):

    def __init__(self, *args):
        # Hacks to support both old and new interfaces:
        # old interface was RHooks(rexec[, verbose])
        # new interface is RHooks([verbose])
        verbose = 0
        rexec = None
        if args and type(args[-1]) == type(0):
            verbose = args[-1]
            args = args[:-1]
        if args and hasattr(args[0], '__class__'):
            rexec = args[0]
            args = args[1:]
        if args:
            raise TypeError, "too many arguments"
        ihooks.Hooks.__init__(self, verbose)
        self.rexec = rexec

    def set_rexec(self, rexec):
        # Called by RExec instance to complete initialization
        self.rexec = rexec

    def get_suffixes(self):
        return self.rexec.get_suffixes()

    def is_builtin(self, name):
        return self.rexec.is_builtin(name)

    def init_builtin(self, name):
        m = __import__(name)
        return self.rexec.copy_except(m, ())

    def init_frozen(self, name): raise SystemError, "don't use this"
    def load_source(self, *args): raise SystemError, "don't use this"
    def load_compiled(self, *args): raise SystemError, "don't use this"
    def load_package(self, *args): raise SystemError, "don't use this"

    def load_dynamic(self, name, filename, file):
        return self.rexec.load_dynamic(name, filename, file)

    def add_module(self, name):
        return self.rexec.add_module(name)

    def modules_dict(self):
        return self.rexec.modules

    def default_path(self):
        return self.rexec.modules['sys'].path


# XXX Backwards compatibility
RModuleLoader = ihooks.FancyModuleLoader
RModuleImporter = ihooks.ModuleImporter


class RExec(ihooks._Verbose):
    """Basic restricted execution framework.

    Code executed in this restricted environment will only have access to
    modules and functions that are deemed safe; you can subclass RExec to
    add or remove capabilities as desired.

    The RExec class can prevent code from performing unsafe operations like
    reading or writing disk files, or using TCP/IP sockets.  However, it does
    not protect against code using extremely large amounts of memory or
    processor time.

    """

    ok_path = tuple(sys.path)           # That's a policy decision

    ok_builtin_modules = ('audioop', 'array', 'binascii',
                          'cmath', 'errno', 'imageop',
                          'marshal', 'math', 'md5', 'operator',
                          'parser', 'select',
                          'sha', '_sre', 'strop', 'struct', 'time',
                          '_weakref')

    ok_posix_names = ('error', 'fstat', 'listdir', 'lstat', 'readlink',
                      'stat', 'times', 'uname', 'getpid', 'getppid',
                      'getcwd', 'getuid', 'getgid', 'geteuid', 'getegid')

    ok_sys_names = ('byteorder', 'copyright', 'exit', 'getdefaultencoding',
                    'getrefcount', 'hexversion', 'maxint', 'maxunicode',
                    'platform', 'ps1', 'ps2', 'version', 'version_info')

    nok_builtin_names = ('open', 'file', 'reload', '__import__')

    ok_file_types = (imp.C_EXTENSION, imp.PY_SOURCE)

    def __init__(self, hooks = None, verbose = 0):
        """Returns an instance of the RExec class.

        The hooks parameter is an instance of the RHooks class or a subclass
        of it.  If it is omitted or None, the default RHooks class is
        instantiated.

        Whenever the RExec module searches for a module (even a built-in one)
        or reads a module's code, it doesn't actually go out to the file
        system itself.  Rather, it calls methods of an RHooks instance that
        was passed to or created by its constructor.  (Actually, the RExec
        object doesn't make these calls --- they are made by a module loader
        object that's part of the RExec object.  This allows another level of
        flexibility, which can be useful when changing the mechanics of
        import within the restricted environment.)

        By providing an alternate RHooks object, we can control the file
        system accesses made to import a module, without changing the
        actual algorithm that controls the order in which those accesses are
        made.  For instance, we could substitute an RHooks object that
        passes all filesystem requests to a file server elsewhere, via some
        RPC mechanism such as ILU.  Grail's applet loader uses this to support
        importing applets from a URL for a directory.

        If the verbose parameter is true, additional debugging output may be
        sent to standard output.

        """

        raise RuntimeError, "This code is not secure in Python 2.2 and later"

        ihooks._Verbose.__init__(self, verbose)
        # XXX There's a circular reference here:
        self.hooks = hooks or RHooks(verbose)
        self.hooks.set_rexec(self)
        self.modules = {}
        self.ok_dynamic_modules = self.ok_builtin_modules
        list = []
        for mname in self.ok_builtin_modules:
            if mname in sys.builtin_module_names:
                list.append(mname)
        self.ok_builtin_modules = tuple(list)
        self.set_trusted_path()
        self.make_builtin()
        self.make_initial_modules()
        # make_sys must be last because it adds the already created
        # modules to its builtin_module_names
        self.make_sys()
        self.loader = RModuleLoader(self.hooks, verbose)
        self.importer = RModuleImporter(self.loader, verbose)

    def set_trusted_path(self):
        # Set the path from which dynamic modules may be loaded.
        # Those dynamic modules must also occur in ok_builtin_modules
        self.trusted_path = filter(os.path.isabs, sys.path)

    def load_dynamic(self, name, filename, file):
        if name not in self.ok_dynamic_modules:
            raise ImportError, "untrusted dynamic module: %s" % name
        if name in sys.modules:
            src = sys.modules[name]
        else:
            src = imp.load_dynamic(name, filename, file)
        dst = self.copy_except(src, [])
        return dst

    def make_initial_modules(self):
        self.make_main()
        self.make_osname()

    # Helpers for RHooks

    def get_suffixes(self):
        return [item   # (suff, mode, type)
                for item in imp.get_suffixes()
                if item[2] in self.ok_file_types]

    def is_builtin(self, mname):
        return mname in self.ok_builtin_modules

    # The make_* methods create specific built-in modules

    def make_builtin(self):
        m = self.copy_except(__builtin__, self.nok_builtin_names)
        m.__import__ = self.r_import
        m.reload = self.r_reload
        m.open = m.file = self.r_open

    def make_main(self):
        self.add_module('__main__')

    def make_osname(self):
        osname = os.name
        src = __import__(osname)
        dst = self.copy_only(src, self.ok_posix_names)
        dst.environ = e = {}
        for key, value in os.environ.items():
            e[key] = value

    def make_sys(self):
        m = self.copy_only(sys, self.ok_sys_names)
        m.modules = self.modules
        m.argv = ['RESTRICTED']
        m.path = map(None, self.ok_path)
        m.exc_info = self.r_exc_info
        m = self.modules['sys']
        l = self.modules.keys() + list(self.ok_builtin_modules)
        l.sort()
        m.builtin_module_names = tuple(l)

    # The copy_* methods copy existing modules with some changes

    def copy_except(self, src, exceptions):
        dst = self.copy_none(src)
        for name in dir(src):
            setattr(dst, name, getattr(src, name))
        for name in exceptions:
            try:
                delattr(dst, name)
            except AttributeError:
                pass
        return dst

    def copy_only(self, src, names):
        dst = self.copy_none(src)
        for name in names:
            try:
                value = getattr(src, name)
            except AttributeError:
                continue
            setattr(dst, name, value)
        return dst

    def copy_none(self, src):
        m = self.add_module(src.__name__)
        m.__doc__ = src.__doc__
        return m

    # Add a module -- return an existing module or create one

    def add_module(self, mname):
        m = self.modules.get(mname)
        if m is None:
            self.modules[mname] = m = self.hooks.new_module(mname)
        m.__builtins__ = self.modules['__builtin__']
        return m

    # The r* methods are public interfaces

    def r_exec(self, code):
        """Execute code within a restricted environment.

        The code parameter must either be a string containing one or more
        lines of Python code, or a compiled code object, which will be
        executed in the restricted environment's __main__ module.

        """
        m = self.add_module('__main__')
        exec code in m.__dict__

    def r_eval(self, code):
        """Evaluate code within a restricted environment.

        The code parameter must either be a string containing a Python
        expression, or a compiled code object, which will be evaluated in
        the restricted environment's __main__ module.  The value of the
        expression or code object will be returned.

        """
        m = self.add_module('__main__')
        return eval(code, m.__dict__)

    def r_execfile(self, file):
        """Execute the Python code in the file in the restricted
        environment's __main__ module.

        """
        m = self.add_module('__main__')
        execfile(file, m.__dict__)

    def r_import(self, mname, globals={}, locals={}, fromlist=[]):
        """Import a module, raising an ImportError exception if the module
        is considered unsafe.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        """
        return self.importer.import_module(mname, globals, locals, fromlist)

    def r_reload(self, m):
        """Reload the module object, re-parsing and re-initializing it.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        """
        return self.importer.reload(m)

    def r_unload(self, m):
        """Unload the module.

        Removes it from the restricted environment's sys.modules dictionary.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        """
        return self.importer.unload(m)

    # The s_* methods are similar but also swap std{in,out,err}

    def make_delegate_files(self):
        s = self.modules['sys']
        self.delegate_stdin = FileDelegate(s, 'stdin')
        self.delegate_stdout = FileDelegate(s, 'stdout')
        self.delegate_stderr = FileDelegate(s, 'stderr')
        self.restricted_stdin = FileWrapper(sys.stdin)
        self.restricted_stdout = FileWrapper(sys.stdout)
        self.restricted_stderr = FileWrapper(sys.stderr)

    def set_files(self):
        if not hasattr(self, 'save_stdin'):
            self.save_files()
        if not hasattr(self, 'delegate_stdin'):
            self.make_delegate_files()
        s = self.modules['sys']
        s.stdin = self.restricted_stdin
        s.stdout = self.restricted_stdout
        s.stderr = self.restricted_stderr
        sys.stdin = self.delegate_stdin
        sys.stdout = self.delegate_stdout
        sys.stderr = self.delegate_stderr

    def reset_files(self):
        self.restore_files()
        s = self.modules['sys']
        self.restricted_stdin = s.stdin
        self.restricted_stdout = s.stdout
        self.restricted_stderr = s.stderr


    def save_files(self):
        self.save_stdin = sys.stdin
        self.save_stdout = sys.stdout
        self.save_stderr = sys.stderr

    def restore_files(self):
        sys.stdin = self.save_stdin
        sys.stdout = self.save_stdout
        sys.stderr = self.save_stderr

    def s_apply(self, func, args=(), kw={}):
        self.save_files()
        try:
            self.set_files()
            r = func(*args, **kw)
        finally:
            self.restore_files()
        return r

    def s_exec(self, *args):
        """Execute code within a restricted environment.

        Similar to the r_exec() method, but the code will be granted access
        to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        The code parameter must either be a string containing one or more
        lines of Python code, or a compiled code object, which will be
        executed in the restricted environment's __main__ module.

        """
        return self.s_apply(self.r_exec, args)

    def s_eval(self, *args):
        """Evaluate code within a restricted environment.

        Similar to the r_eval() method, but the code will be granted access
        to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        The code parameter must either be a string containing a Python
        expression, or a compiled code object, which will be evaluated in
        the restricted environment's __main__ module.  The value of the
        expression or code object will be returned.

        """
        return self.s_apply(self.r_eval, args)

    def s_execfile(self, *args):
        """Execute the Python code in the file in the restricted
        environment's __main__ module.

        Similar to the r_execfile() method, but the code will be granted
        access to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        """
        return self.s_apply(self.r_execfile, args)

    def s_import(self, *args):
        """Import a module, raising an ImportError exception if the module
        is considered unsafe.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_import() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        """
        return self.s_apply(self.r_import, args)

    def s_reload(self, *args):
        """Reload the module object, re-parsing and re-initializing it.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_reload() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        """
        return self.s_apply(self.r_reload, args)

    def s_unload(self, *args):
        """Unload the module.

        Removes it from the restricted environment's sys.modules dictionary.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_unload() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        """
        return self.s_apply(self.r_unload, args)

    # Restricted open(...)

    def r_open(self, file, mode='r', buf=-1):
        """Method called when open() is called in the restricted environment.

        The arguments are identical to those of the open() function, and a
        file object (or a class instance compatible with file objects)
        should be returned.  RExec's default behaviour is allow opening
        any file for reading, but forbidding any attempt to write a file.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        """
        mode = str(mode)
        if mode not in ('r', 'rb'):
            raise IOError, "can't open files for writing in restricted mode"
        return open(file, mode, buf)

    # Restricted version of sys.exc_info()

    def r_exc_info(self):
        ty, va, tr = sys.exc_info()
        tr = None
        return ty, va, tr


def test():
    import getopt, traceback
    opts, args = getopt.getopt(sys.argv[1:], 'vt:')
    verbose = 0
    trusted = []
    for o, a in opts:
        if o == '-v':
            verbose = verbose+1
        if o == '-t':
            trusted.append(a)
    r = RExec(verbose=verbose)
    if trusted:
        r.ok_builtin_modules = r.ok_builtin_modules + tuple(trusted)
    if args:
        r.modules['sys'].argv = args
        r.modules['sys'].path.insert(0, os.path.dirname(args[0]))
    else:
        r.modules['sys'].path.insert(0, "")
    fp = sys.stdin
    if args and args[0] != '-':
        try:
            fp = open(args[0])
        except IOError, msg:
            print "%s: can't open file %r" % (sys.argv[0], args[0])
            return 1
    if fp.isatty():
        try:
            import readline
        except ImportError:
            pass
        import code
        class RestrictedConsole(code.InteractiveConsole):
            def runcode(self, co):
                self.locals['__builtins__'] = r.modules['__builtin__']
                r.s_apply(code.InteractiveConsole.runcode, (self, co))
        try:
            RestrictedConsole(r.modules['__main__'].__dict__).interact()
        except SystemExit, n:
            return n
    else:
        text = fp.read()
        fp.close()
        c = compile(text, fp.name, 'exec')
        try:
            r.s_exec(c)
        except SystemExit, n:
            return n
        except:
            traceback.print_exc()
            return 1


if __name__ == '__main__':
    sys.exit(test())
                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   s#  d  Z  d d l m Z e d d d É[ d d l Z d d l Z d d l Z d d l Z d d l Z d g Z d f  d	 Ñ  É  YZ	 d
 e	 f d Ñ  É  YZ
 d Z d e	 f d Ñ  É  YZ d e j f d Ñ  É  YZ e j Z e j Z d e j f d Ñ  É  YZ d Ñ  Z e d k re j e É  É n  d S(   s9  Restricted execution facilities.

The class RExec exports methods r_exec(), r_eval(), r_execfile(), and
r_import(), which correspond roughly to the built-in operations
exec, eval(), execfile() and import, but executing the code in an
environment that only exposes those built-in operations that are
deemed safe.  To this end, a modest collection of 'fake' modules is
created which mimics the standard modules by the same names.  It is a
policy decision which built-in modules and operations are made
available; this module provides a reasonable default, but derived
classes can change the policies e.g. by overriding or extending class
variables like ok_builtin_modules or methods like make_sys().

XXX To do:
- r_open should allow writing tmp dir
- r_exec etc. with explicit globals/locals? (Use rexec("exec ... in ...")?)

iˇˇˇˇ(   t   warnpy3ks/   the rexec module has been removed in Python 3.0t
   stackleveli   Nt   RExect   FileBasec           B   s   e  Z d Z RS(   t   filenot   flusht   isattyt   readt   readlinet	   readlinest   seekt   tellt   writet
   writelinest
   xreadlinest   __iter__(   R   R   R   R   R   R	   R
   R   R   R   R   R   (   t   __name__t
   __module__t   ok_file_methods(    (    (    s   /usr/lib/python2.7/rexec.pyR       s     t   FileWrapperc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   sS   xL |  j  D]A } t |  | É r
 t | | É r
 t |  | t | | É É q
 q
 Wd  S(   N(   R   t   hasattrt   setattrt   getattr(   t   selft   ft   m(    (    s   /usr/lib/python2.7/rexec.pyt   __init__+   s    c         C   s   |  j  É  d  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/rexec.pyt   close0   s    (   R   R   R   R   (    (    (    s   /usr/lib/python2.7/rexec.pyR   '   s   	sL   
def %s(self, *args):
        return getattr(self.mod, self.name).%s(*args)
t   FileDelegatec           B   s;   e  Z d  Ñ  Z x' e j d D] Z e e e f d Uq WRS(   c         C   s   | |  _  | |  _ d  S(   N(   t   modt   name(   R   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR   ;   s    	R   N(   R   (   R   R   R   R   R   R   t   TEMPLATE(    (    (    s   /usr/lib/python2.7/rexec.pyR   9   s   	t   RHooksc           B   s}   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z RS(   c         G   sß   d } d  } | rE t | d É t d É k rE | d } | d  } n  | ru t | d d É ru | d } | d } n  | rá t d Ç n  t j j |  | É | |  _ d  S(   Ni    iˇˇˇˇt	   __class__i   s   too many arguments(   t   Nonet   typeR   t	   TypeErrort   ihookst   HooksR   t   rexec(   R   t   argst   verboseR'   (    (    s   /usr/lib/python2.7/rexec.pyR   E   s    "

c         C   s   | |  _  d  S(   N(   R'   (   R   R'   (    (    s   /usr/lib/python2.7/rexec.pyt	   set_rexecV   s    c         C   s   |  j  j É  S(   N(   R'   t   get_suffixes(   R   (    (    s   /usr/lib/python2.7/rexec.pyR+   Z   s    c         C   s   |  j  j | É S(   N(   R'   t
   is_builtin(   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR,   ]   s    c         C   s   t  | É } |  j j | d É S(   N(    (   t
   __import__R'   t   copy_except(   R   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt   init_builtin`   s    c         C   s   t  d Ç d  S(   Ns   don't use this(   t   SystemError(   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt   init_frozend   s    c         G   s   t  d Ç d  S(   Ns   don't use this(   R0   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   load_sourcee   s    c         G   s   t  d Ç d  S(   Ns   don't use this(   R0   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   load_compiledf   s    c         G   s   t  d Ç d  S(   Ns   don't use this(   R0   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   load_packageg   s    c         C   s   |  j  j | | | É S(   N(   R'   t   load_dynamic(   R   R   t   filenamet   file(    (    s   /usr/lib/python2.7/rexec.pyR5   i   s    c         C   s   |  j  j | É S(   N(   R'   t
   add_module(   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR8   l   s    c         C   s
   |  j  j S(   N(   R'   t   modules(   R   (    (    s   /usr/lib/python2.7/rexec.pyt   modules_dicto   s    c         C   s   |  j  j d j S(   Nt   sys(   R'   R9   t   path(   R   (    (    s   /usr/lib/python2.7/rexec.pyt   default_pathr   s    (   R   R   R   R*   R+   R,   R/   R1   R2   R3   R4   R5   R8   R:   R=   (    (    (    s   /usr/lib/python2.7/rexec.pyR    C   s   												c           B   sî  e  Z d  Z e e j É Z dX Z dY Z dZ Z	 d[ Z
 e j e j f Z d\ d3 d4 Ñ Z d5 Ñ  Z d6 Ñ  Z d7 Ñ  Z d8 Ñ  Z d9 Ñ  Z d: Ñ  Z d; Ñ  Z d< Ñ  Z d= Ñ  Z d> Ñ  Z d? Ñ  Z d@ Ñ  Z dA Ñ  Z dB Ñ  Z dC Ñ  Z dD Ñ  Z  i  i  g  dE Ñ Z! dF Ñ  Z" dG Ñ  Z# dH Ñ  Z$ dI Ñ  Z% dJ Ñ  Z& dK Ñ  Z' dL Ñ  Z( d] i  dM Ñ Z) dN Ñ  Z* dO Ñ  Z+ dP Ñ  Z, dQ Ñ  Z- dR Ñ  Z. dS Ñ  Z/ dT dU dV Ñ Z0 dW Ñ  Z1 RS(^   s‚  Basic restricted execution framework.

    Code executed in this restricted environment will only have access to
    modules and functions that are deemed safe; you can subclass RExec to
    add or remove capabilities as desired.

    The RExec class can prevent code from performing unsafe operations like
    reading or writing disk files, or using TCP/IP sockets.  However, it does
    not protect against code using extremely large amounts of memory or
    processor time.

    t   audioopt   arrayt   binasciit   cmatht   errnot   imageopt   marshalt   matht   md5t   operatort   parsert   selectt   shat   _sret   stropt   structt   timet   _weakreft   errort   fstatt   listdirt   lstatt   readlinkt   statt   timest   unamet   getpidt   getppidt   getcwdt   getuidt   getgidt   geteuidt   getegidt	   byteordert	   copyrightt   exitt   getdefaultencodingt   getrefcountt
   hexversiont   maxintt
   maxunicodet   platformt   ps1t   ps2t   versiont   version_infot   openR7   t   reloadR-   i    c         C   sÙ   t  d Ç t j j |  | É | p+ t | É |  _ |  j j |  É i  |  _ |  j |  _	 g  } x0 |  j D]% } | t
 j k rf | j | É qf qf Wt | É |  _ |  j É  |  j É  |  j É  |  j É  t |  j | É |  _ t |  j | É |  _ d S(   sÑ  Returns an instance of the RExec class.

        The hooks parameter is an instance of the RHooks class or a subclass
        of it.  If it is omitted or None, the default RHooks class is
        instantiated.

        Whenever the RExec module searches for a module (even a built-in one)
        or reads a module's code, it doesn't actually go out to the file
        system itself.  Rather, it calls methods of an RHooks instance that
        was passed to or created by its constructor.  (Actually, the RExec
        object doesn't make these calls --- they are made by a module loader
        object that's part of the RExec object.  This allows another level of
        flexibility, which can be useful when changing the mechanics of
        import within the restricted environment.)

        By providing an alternate RHooks object, we can control the file
        system accesses made to import a module, without changing the
        actual algorithm that controls the order in which those accesses are
        made.  For instance, we could substitute an RHooks object that
        passes all filesystem requests to a file server elsewhere, via some
        RPC mechanism such as ILU.  Grail's applet loader uses this to support
        importing applets from a URL for a directory.

        If the verbose parameter is true, additional debugging output may be
        sent to standard output.

        s/   This code is not secure in Python 2.2 and laterN(   t   RuntimeErrorR%   t   _VerboseR   R    t   hooksR*   R9   t   ok_builtin_modulest   ok_dynamic_modulesR;   t   builtin_module_namest   appendt   tuplet   set_trusted_patht   make_builtint   make_initial_modulest   make_syst   RModuleLoadert   loadert   RModuleImportert   importer(   R   Rp   R)   t   listt   mname(    (    s   /usr/lib/python2.7/rexec.pyR   û   s"    		



c         C   s   t  t j j t j É |  _ d  S(   N(   t   filtert   osR<   t   isabsR;   t   trusted_path(   R   (    (    s   /usr/lib/python2.7/rexec.pyRv   —   s    c         C   si   | |  j  k r t d | Ç n  | t j k r> t j | } n t j | | | É } |  j | g  É } | S(   Ns   untrusted dynamic module: %s(   Rr   t   ImportErrorR;   R9   t   impR5   R.   (   R   R   R6   R7   t   srct   dst(    (    s   /usr/lib/python2.7/rexec.pyR5   ÷   s    c         C   s   |  j  É  |  j É  d  S(   N(   t	   make_maint   make_osname(   R   (    (    s   /usr/lib/python2.7/rexec.pyRx   ‡   s    
c         C   s0   g  t  j É  D] } | d |  j k r | ^ q S(   Ni   (   RÖ   R+   t   ok_file_types(   R   t   item(    (    s   /usr/lib/python2.7/rexec.pyR+   Ê   s    c         C   s   | |  j  k S(   N(   Rq   (   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR,   Î   s    c         C   sD   |  j  t |  j É } |  j | _ |  j | _ |  j | _ | _	 d  S(   N(
   R.   t   __builtin__t   nok_builtin_namest   r_importR-   t   r_reloadRm   t   r_openRl   R7   (   R   R   (    (    s   /usr/lib/python2.7/rexec.pyRw      s    c         C   s   |  j  d É d  S(   Nt   __main__(   R8   (   R   (    (    s   /usr/lib/python2.7/rexec.pyRà   ˆ   s    c         C   se   t  j } t | É } |  j | |  j É } i  | _ } x' t  j j É  D] \ } } | | | <qG Wd  S(   N(   RÅ   R   R-   t	   copy_onlyt   ok_posix_namest   environt   items(   R   t   osnameRÜ   Rá   t   et   keyt   value(    (    s   /usr/lib/python2.7/rexec.pyRâ   ˘   s    	c         C   sî   |  j  t |  j É } |  j | _ d g | _ t d  |  j É | _ |  j	 | _
 |  j d } |  j j É  t |  j É } | j É  t | É | _ d  S(   Nt
   RESTRICTEDR;   (   Rí   R;   t   ok_sys_namesR9   t   argvt   mapR"   t   ok_pathR<   t
   r_exc_infot   exc_infot   keysR~   Rq   t   sortRu   Rs   (   R   R   t   l(    (    s   /usr/lib/python2.7/rexec.pyRy     s    
c         C   sy   |  j  | É } x- t | É D] } t | | t | | É É q Wx3 | D]+ } y t | | É WqF t k
 rp qF XqF W| S(   N(   t	   copy_nonet   dirR   R   t   delattrt   AttributeError(   R   RÜ   t
   exceptionsRá   R   (    (    s   /usr/lib/python2.7/rexec.pyR.     s    c         C   s^   |  j  | É } xH | D]@ } y t | | É } Wn t k
 rE q n Xt | | | É q W| S(   N(   R§   R   Rß   R   (   R   RÜ   t   namesRá   R   Rô   (    (    s   /usr/lib/python2.7/rexec.pyRí     s    c         C   s"   |  j  | j É } | j | _ | S(   N(   R8   R   t   __doc__(   R   RÜ   R   (    (    s   /usr/lib/python2.7/rexec.pyR§   #  s    c         C   sR   |  j  j | É } | d  k r> |  j j | É |  j  | <} n  |  j  d | _ | S(   NRå   (   R9   t   getR"   Rp   t
   new_modulet   __builtins__(   R   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR8   *  s
     c         B   s   |  j  d É } | | j Ud S(   s  Execute code within a restricted environment.

        The code parameter must either be a string containing one or more
        lines of Python code, or a compiled code object, which will be
        executed in the restricted environment's __main__ module.

        Rë   N(   R8   t   __dict__(   R   t   codeR   (    (    s   /usr/lib/python2.7/rexec.pyt   r_exec3  s    c         C   s   |  j  d É } t | | j É S(   sF  Evaluate code within a restricted environment.

        The code parameter must either be a string containing a Python
        expression, or a compiled code object, which will be evaluated in
        the restricted environment's __main__ module.  The value of the
        expression or code object will be returned.

        Rë   (   R8   t   evalRÆ   (   R   RØ   R   (    (    s   /usr/lib/python2.7/rexec.pyt   r_eval>  s    	c         C   s#   |  j  d É } t | | j É d S(   sf   Execute the Python code in the file in the restricted
        environment's __main__ module.

        Rë   N(   R8   t   execfileRÆ   (   R   R7   R   (    (    s   /usr/lib/python2.7/rexec.pyt
   r_execfileJ  s    c         C   s   |  j  j | | | | É S(   s=  Import a module, raising an ImportError exception if the module
        is considered unsafe.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        (   R}   t   import_module(   R   R   t   globalst   localst   fromlist(    (    s   /usr/lib/python2.7/rexec.pyRé   R  s    	c         C   s   |  j  j | É S(   s  Reload the module object, re-parsing and re-initializing it.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        (   R}   Rm   (   R   R   (    (    s   /usr/lib/python2.7/rexec.pyRè   ]  s    c         C   s   |  j  j | É S(   s@  Unload the module.

        Removes it from the restricted environment's sys.modules dictionary.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        (   R}   t   unload(   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt   r_unloadg  s    
c         C   s}   |  j  d } t | d É |  _ t | d É |  _ t | d É |  _ t t j É |  _ t t j	 É |  _
 t t j É |  _ d  S(   NR;   t   stdint   stdoutt   stderr(   R9   R   t   delegate_stdint   delegate_stdoutt   delegate_stderrR   R;   Rª   t   restricted_stdinRº   t   restricted_stdoutRΩ   t   restricted_stderr(   R   t   s(    (    s   /usr/lib/python2.7/rexec.pyt   make_delegate_filesu  s    c         C   së   t  |  d É s |  j É  n  t  |  d É s8 |  j É  n  |  j d } |  j | _ |  j | _ |  j | _	 |  j
 t _ |  j t _ |  j t _	 d  S(   Nt
   save_stdinRæ   R;   (   R   t
   save_filesR≈   R9   R¡   Rª   R¬   Rº   R√   RΩ   Ræ   R;   Rø   R¿   (   R   Rƒ   (    (    s   /usr/lib/python2.7/rexec.pyt	   set_files~  s    c         C   s?   |  j  É  |  j d } | j |  _ | j |  _ | j |  _ d  S(   NR;   (   t   restore_filesR9   Rª   R¡   Rº   R¬   RΩ   R√   (   R   Rƒ   (    (    s   /usr/lib/python2.7/rexec.pyt   reset_filesã  s
    
c         C   s(   t  j |  _ t  j |  _ t  j |  _ d  S(   N(   R;   Rª   R∆   Rº   t   save_stdoutRΩ   t   save_stderr(   R   (    (    s   /usr/lib/python2.7/rexec.pyR«   ì  s    c         C   s(   |  j  t _ |  j t _ |  j t _ d  S(   N(   R∆   R;   Rª   RÀ   Rº   RÃ   RΩ   (   R   (    (    s   /usr/lib/python2.7/rexec.pyR…   ò  s    c         C   s9   |  j  É  z |  j É  | | | é  } Wd  |  j É  X| S(   N(   R«   R»   R…   (   R   t   funcR(   t   kwt   r(    (    s   /usr/lib/python2.7/rexec.pyt   s_applyù  s    

c         G   s   |  j  |  j | É S(   s¬  Execute code within a restricted environment.

        Similar to the r_exec() method, but the code will be granted access
        to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        The code parameter must either be a string containing one or more
        lines of Python code, or a compiled code object, which will be
        executed in the restricted environment's __main__ module.

        (   R–   R∞   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_exec¶  s    c         G   s   |  j  |  j | É S(   s˝  Evaluate code within a restricted environment.

        Similar to the r_eval() method, but the code will be granted access
        to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        The code parameter must either be a string containing a Python
        expression, or a compiled code object, which will be evaluated in
        the restricted environment's __main__ module.  The value of the
        expression or code object will be returned.

        (   R–   R≤   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_eval¥  s    c         G   s   |  j  |  j | É S(   s!  Execute the Python code in the file in the restricted
        environment's __main__ module.

        Similar to the r_execfile() method, but the code will be granted
        access to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        (   R–   R¥   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt
   s_execfile√  s    	c         G   s   |  j  |  j | É S(   s·  Import a module, raising an ImportError exception if the module
        is considered unsafe.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_import() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        (   R–   Ré   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_importŒ  s    c         G   s   |  j  |  j | É S(   s¿  Reload the module object, re-parsing and re-initializing it.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_reload() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        (   R–   Rè   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_reload›  s    c         G   s   |  j  |  j | É S(   s‰  Unload the module.

        Removes it from the restricted environment's sys.modules dictionary.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_unload() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        (   R–   R∫   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_unloadÎ  s    Rœ   iˇˇˇˇc         C   s4   t  | É } | d k r$ t d Ç n  t | | | É S(   sG  Method called when open() is called in the restricted environment.

        The arguments are identical to those of the open() function, and a
        file object (or a class instance compatible with file objects)
        should be returned.  RExec's default behaviour is allow opening
        any file for reading, but forbidding any attempt to write a file.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Rœ   t   rbs/   can't open files for writing in restricted mode(   Rœ   R◊   (   t   strt   IOErrorRl   (   R   R7   t   modet   buf(    (    s   /usr/lib/python2.7/rexec.pyRê   ˝  s    c         C   s(   t  j É  \ } } } d  } | | | f S(   N(   R;   R†   R"   (   R   t   tyt   vat   tr(    (    s   /usr/lib/python2.7/rexec.pyRü     s    (   R>   R?   R@   RA   RB   RC   RD   RE   RF   RG   RH   RI   RJ   RK   RL   RM   RN   RO   (   RP   RQ   RR   RS   RT   RU   RV   RW   RX   RY   RZ   R[   R\   R]   R^   (   R_   R`   Ra   Rb   Rc   Rd   Re   Rf   Rg   Rh   Ri   Rj   Rk   (   Rl   R7   Rm   R-   N(    (2   R   R   R™   Ru   R;   R<   Rû   Rq   Rì   Rõ   Rç   RÖ   t   C_EXTENSIONt	   PY_SOURCERä   R"   R   Rv   R5   Rx   R+   R,   Rw   Rà   Râ   Ry   R.   Rí   R§   R8   R∞   R≤   R¥   Ré   Rè   R∫   R≈   R»   R    R«   R…   R–   R—   R“   R”   R‘   R’   R÷   Rê   Rü   (    (    (    s   /usr/lib/python2.7/rexec.pyR   {   sd            3		
									
							
														c             s  d d  l  }  d d  l } |  j  t j d d É \ } } d } g  } xI | D]A \ } } | d k ro | d } n  | d k rJ | j | É qJ qJ Wt d | É â | rΩ à j t | É à _ n  | r | à j d _ à j d j	 j
 d t j	 j | d É É n à j d j	 j
 d d	 É t j } | rÅ| d d
 k rÅy t | d É } WqÅt k
 r}}	 d t j d | d f GHd SXn  | j É  ry d d  l }
 Wn t k
 r∞n Xd d  l â  d à  j f á  á f d Ü  É  Y} y | à j d j É j É  Wq{t k
 r} | SXnd | j É  } | j É  t | | j d É } y à j | É Wn% t k
 ri} | S| j É  d SXd  S(   Niˇˇˇˇi   s   vt:i    s   -vs   -tR)   R;   t    t   -s   %s: can't open file %rt   RestrictedConsolec              s   e  Z á  á f d  Ü  Z RS(   c            s4   à j  d |  j d <à j à  j j |  | f É d  S(   NRå   R≠   (   R9   R∑   R–   t   InteractiveConsolet   runcode(   R   t   co(   RØ   Rœ   (    s   /usr/lib/python2.7/rexec.pyRÂ   7  s    (   R   R   RÂ   (    (   RØ   Rœ   (    s   /usr/lib/python2.7/rexec.pyR„   6  s   Rë   t   exec(   t   getoptt	   tracebackR;   Rú   Rt   R   Rq   Ru   R9   R<   t   insertRÅ   t   dirnameRª   Rl   RŸ   R   R   RÑ   RØ   R‰   RÆ   t   interactt
   SystemExitR   R   t   compileR   R—   t	   print_exc(   RË   RÈ   t   optsR(   R)   t   trustedt   ot   at   fpt   msgR   R„   t   nt   textt   c(    (   RØ   Rœ   s   /usr/lib/python2.7/rexec.pyt   test  sX    -	"

Rë   (   R™   t   warningsR    R;   Rå   RÅ   R%   RÖ   t   __all__R   R   R   R   R&   R    t   FancyModuleLoaderRz   t   ModuleImporterR|   Ro   R   R˘   R   Ra   (    (    (    s   /usr/lib/python2.7/rexec.pyt   <module>   s*   	
4		ˇ ù	4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """RFC 2822 message manipulation.

Note: This is only a very rough sketch of a full RFC-822 parser; in particular
the tokenizing of addresses does not adhere to all the quoting rules.

Note: RFC 2822 is a long awaited update to RFC 822.  This module should
conform to RFC 2822, and is thus mis-named (it's not worth renaming it).  Some
effort at RFC 2822 updates have been made, but a thorough audit has not been
performed.  Consider any RFC 2822 non-conformance to be a bug.

    RFC 2822: http://www.faqs.org/rfcs/rfc2822.html
    RFC 822 : http://www.faqs.org/rfcs/rfc822.html (obsolete)

Directions for use:

To create a Message object: first open a file, e.g.:

  fp = open(file, 'r')

You can use any other legal way of getting an open file object, e.g. use
sys.stdin or call os.popen().  Then pass the open file object to the Message()
constructor:

  m = Message(fp)

This class can work with any input object that supports a readline method.  If
the input object has seek and tell capability, the rewindbody method will
work; also illegal lines will be pushed back onto the input stream.  If the
input object lacks seek but has an `unread' method that can push back a line
of input, Message will use that to push back illegal lines.  Thus this class
can be used to parse messages coming from a buffered stream.

The optional `seekable' argument is provided as a workaround for certain stdio
libraries in which tell() discards buffered data before discovering that the
lseek() system call doesn't work.  For maximum portability, you should set the
seekable argument to zero to prevent that initial \code{tell} when passing in
an unseekable object such as a file object created from a socket object.  If
it is 1 on entry -- which it is by default -- the tell() method of the open
file object is called once; if this raises an exception, seekable is reset to
0.  For other nonzero values of seekable, this test is not made.

To get the text of a particular header there are several methods:

  str = m.getheader(name)
  str = m.getrawheader(name)

where name is the name of the header, e.g. 'Subject'.  The difference is that
getheader() strips the leading and trailing whitespace, while getrawheader()
doesn't.  Both functions retain embedded whitespace (including newlines)
exactly as they are specified in the header, and leave the case of the text
unchanged.

For addresses and address lists there are functions

  realname, mailaddress = m.getaddr(name)
  list = m.getaddrlist(name)

where the latter returns a list of (realname, mailaddr) tuples.

There is also a method

  time = m.getdate(name)

which parses a Date-like field and returns a time-compatible tuple,
i.e. a tuple such as returned by time.localtime() or accepted by
time.mktime().

See the class definition for lower level access methods.

There are also some utility functions here.
"""
# Cleanup and extensions by Eric S. Raymond <esr@thyrsus.com>

import time

from warnings import warnpy3k
warnpy3k("in 3.x, rfc822 has been removed in favor of the email package",
         stacklevel=2)

__all__ = ["Message","AddressList","parsedate","parsedate_tz","mktime_tz"]

_blanklines = ('\r\n', '\n')            # Optimization for islast()


class Message:
    """Represents a single RFC 2822-compliant message."""

    def __init__(self, fp, seekable = 1):
        """Initialize the class instance and read the headers."""
        if seekable == 1:
            # Exercise tell() to make sure it works
            # (and then assume seek() works, too)
            try:
                fp.tell()
            except (AttributeError, IOError):
                seekable = 0
        self.fp = fp
        self.seekable = seekable
        self.startofheaders = None
        self.startofbody = None
        #
        if self.seekable:
            try:
                self.startofheaders = self.fp.tell()
            except IOError:
                self.seekable = 0
        #
        self.readheaders()
        #
        if self.seekable:
            try:
                self.startofbody = self.fp.tell()
            except IOError:
                self.seekable = 0

    def rewindbody(self):
        """Rewind the file to the start of the body (if seekable)."""
        if not self.seekable:
            raise IOError, "unseekable file"
        self.fp.seek(self.startofbody)

    def readheaders(self):
        """Read header lines.

        Read header lines up to the entirely blank line that terminates them.
        The (normally blank) line that ends the headers is skipped, but not
        included in the returned list.  If a non-header line ends the headers,
        (which is an error), an attempt is made to backspace over it; it is
        never included in the returned list.

        The variable self.status is set to the empty string if all went well,
        otherwise it is an error message.  The variable self.headers is a
        completely uninterpreted list of lines contained in the header (so
        printing them will reproduce the header exactly as it appears in the
        file).
        """
        self.dict = {}
        self.unixfrom = ''
        self.headers = lst = []
        self.status = ''
        headerseen = ""
        firstline = 1
        startofline = unread = tell = None
        if hasattr(self.fp, 'unread'):
            unread = self.fp.unread
        elif self.seekable:
            tell = self.fp.tell
        while 1:
            if tell:
                try:
                    startofline = tell()
                except IOError:
                    startofline = tell = None
                    self.seekable = 0
            line = self.fp.readline()
            if not line:
                self.status = 'EOF in headers'
                break
            # Skip unix From name time lines
            if firstline and line.startswith('From '):
                self.unixfrom = self.unixfrom + line
                continue
            firstline = 0
            if headerseen and line[0] in ' \t':
                # It's a continuation line.
                lst.append(line)
                x = (self.dict[headerseen] + "\n " + line.strip())
                self.dict[headerseen] = x.strip()
                continue
            elif self.iscomment(line):
                # It's a comment.  Ignore it.
                continue
            elif self.islast(line):
                # Note! No pushback here!  The delimiter line gets eaten.
                break
            headerseen = self.isheader(line)
            if headerseen:
                # It's a legal header line, save it.
                lst.append(line)
                self.dict[headerseen] = line[len(headerseen)+1:].strip()
                continue
            elif headerseen is not None:
                # An empty header name. These aren't allowed in HTTP, but it's
                # probably a benign mistake. Don't add the header, just keep
                # going.
                continue
            else:
                # It's not a header line; throw it back and stop here.
                if not self.dict:
                    self.status = 'No headers'
                else:
                    self.status = 'Non-header line where header expected'
                # Try to undo the read.
                if unread:
                    unread(line)
                elif tell:
                    self.fp.seek(startofline)
                else:
                    self.status = self.status + '; bad seek'
                break

    def isheader(self, line):
        """Determine whether a given line is a legal header.

        This method should return the header name, suitably canonicalized.
        You may override this method in order to use Message parsing on tagged
        data in RFC 2822-like formats with special header formats.
        """
        i = line.find(':')
        if i > -1:
            return line[:i].lower()
        return None

    def islast(self, line):
        """Determine whether a line is a legal end of RFC 2822 headers.

        You may override this method if your application wants to bend the
        rules, e.g. to strip trailing whitespace, or to recognize MH template
        separators ('--------').  For convenience (e.g. for code reading from
        sockets) a line consisting of \\r\\n also matches.
        """
        return line in _blanklines

    def iscomment(self, line):
        """Determine whether a line should be skipped entirely.

        You may override this method in order to use Message parsing on tagged
        data in RFC 2822-like formats that support embedded comments or
        free-text data.
        """
        return False

    def getallmatchingheaders(self, name):
        """Find all header lines matching a given header name.

        Look through the list of headers and find all lines matching a given
        header name (and their continuation lines).  A list of the lines is
        returned, without interpretation.  If the header does not occur, an
        empty list is returned.  If the header occurs multiple times, all
        occurrences are returned.  Case is not important in the header name.
        """
        name = name.lower() + ':'
        n = len(name)
        lst = []
        hit = 0
        for line in self.headers:
            if line[:n].lower() == name:
                hit = 1
            elif not line[:1].isspace():
                hit = 0
            if hit:
                lst.append(line)
        return lst

    def getfirstmatchingheader(self, name):
        """Get the first header line matching name.

        This is similar to getallmatchingheaders, but it returns only the
        first matching header (and its continuation lines).
        """
        name = name.lower() + ':'
        n = len(name)
        lst = []
        hit = 0
        for line in self.headers:
            if hit:
                if not line[:1].isspace():
                    break
            elif line[:n].lower() == name:
                hit = 1
            if hit:
                lst.append(line)
        return lst

    def getrawheader(self, name):
        """A higher-level interface to getfirstmatchingheader().

        Return a string containing the literal text of the header but with the
        keyword stripped.  All leading, trailing and embedded whitespace is
        kept in the string, however.  Return None if the header does not
        occur.
        """

        lst = self.getfirstmatchingheader(name)
        if not lst:
            return None
        lst[0] = lst[0][len(name) + 1:]
        return ''.join(lst)

    def getheader(self, name, default=None):
        """Get the header value for a name.

        This is the normal interface: it returns a stripped version of the
        header value for a given header name, or None if it doesn't exist.
        This uses the dictionary version which finds the *last* such header.
        """
        return self.dict.get(name.lower(), default)
    get = getheader

    def getheaders(self, name):
        """Get all values for a header.

        This returns a list of values for headers given more than once; each
        value in the result list is stripped in the same way as the result of
        getheader().  If the header is not given, return an empty list.
        """
        result = []
        current = ''
        have_header = 0
        for s in self.getallmatchingheaders(name):
            if s[0].isspace():
                if current:
                    current = "%s\n %s" % (current, s.strip())
                else:
                    current = s.strip()
            else:
                if have_header:
                    result.append(current)
                current = s[s.find(":") + 1:].strip()
                have_header = 1
        if have_header:
            result.append(current)
        return result

    def getaddr(self, name):
        """Get a single address from a header, as a tuple.

        An example return value:
        ('Guido van Rossum', 'guido@cwi.nl')
        """
        # New, by Ben Escoto
        alist = self.getaddrlist(name)
        if alist:
            return alist[0]
        else:
            return (None, None)

    def getaddrlist(self, name):
        """Get a list of addresses from a header.

        Retrieves a list of addresses from a header, where each address is a
        tuple as returned by getaddr().  Scans all named headers, so it works
        properly with multiple To: or Cc: headers for example.
        """
        raw = []
        for h in self.getallmatchingheaders(name):
            if h[0] in ' \t':
                raw.append(h)
            else:
                if raw:
                    raw.append(', ')
                i = h.find(':')
                if i > 0:
                    addr = h[i+1:]
                raw.append(addr)
        alladdrs = ''.join(raw)
        a = AddressList(alladdrs)
        return a.addresslist

    def getdate(self, name):
        """Retrieve a date field from a header.

        Retrieves a date field from the named header, returning a tuple
        compatible with time.mktime().
        """
        try:
            data = self[name]
        except KeyError:
            return None
        return parsedate(data)

    def getdate_tz(self, name):
        """Retrieve a date field from a header as a 10-tuple.

        The first 9 elements make up a tuple compatible with time.mktime(),
        and the 10th is the offset of the poster's time zone from GMT/UTC.
        """
        try:
            data = self[name]
        except KeyError:
            return None
        return parsedate_tz(data)


    # Access as a dictionary (only finds *last* header of each type):

    def __len__(self):
        """Get the number of headers in a message."""
        return len(self.dict)

    def __getitem__(self, name):
        """Get a specific header, as from a dictionary."""
        return self.dict[name.lower()]

    def __setitem__(self, name, value):
        """Set the value of a header.

        Note: This is not a perfect inversion of __getitem__, because any
        changed headers get stuck at the end of the raw-headers list rather
        than where the altered header was.
        """
        del self[name] # Won't fail if it doesn't exist
        self.dict[name.lower()] = value
        text = name + ": " + value
        for line in text.split("\n"):
            self.headers.append(line + "\n")

    def __delitem__(self, name):
        """Delete all occurrences of a specific header, if it is present."""
        name = name.lower()
        if not name in self.dict:
            return
        del self.dict[name]
        name = name + ':'
        n = len(name)
        lst = []
        hit = 0
        for i in range(len(self.headers)):
            line = self.headers[i]
            if line[:n].lower() == name:
                hit = 1
            elif not line[:1].isspace():
                hit = 0
            if hit:
                lst.append(i)
        for i in reversed(lst):
            del self.headers[i]

    def setdefault(self, name, default=""):
        lowername = name.lower()
        if lowername in self.dict:
            return self.dict[lowername]
        else:
            text = name + ": " + default
            for line in text.split("\n"):
                self.headers.append(line + "\n")
            self.dict[lowername] = default
            return default

    def has_key(self, name):
        """Determine whether a message contains the named header."""
        return name.lower() in self.dict

    def __contains__(self, name):
        """Determine whether a message contains the named header."""
        return name.lower() in self.dict

    def __iter__(self):
        return iter(self.dict)

    def keys(self):
        """Get all of a message's header field names."""
        return self.dict.keys()

    def values(self):
        """Get all of a message's header field values."""
        return self.dict.values()

    def items(self):
        """Get all of a message's headers.

        Returns a list of name, value tuples.
        """
        return self.dict.items()

    def __str__(self):
        return ''.join(self.headers)


# Utility functions
# -----------------

# XXX Should fix unquote() and quote() to be really conformant.
# XXX The inverses of the parse functions may also be useful.


def unquote(s):
    """Remove quotes from a string."""
    if len(s) > 1:
        if s.startswith('"') and s.endswith('"'):
            return s[1:-1].replace('\\\\', '\\').replace('\\"', '"')
        if s.startswith('<') and s.endswith('>'):
            return s[1:-1]
    return s


def quote(s):
    """Add quotes around a string."""
    return s.replace('\\', '\\\\').replace('"', '\\"')


def parseaddr(address):
    """Parse an address into a (realname, mailaddr) tuple."""
    a = AddressList(address)
    lst = a.addresslist
    if not lst:
        return (None, None)
    return lst[0]


class AddrlistClass:
    """Address parser class by Ben Escoto.

    To understand what this class does, it helps to have a copy of
    RFC 2822 in front of you.

    http://www.faqs.org/rfcs/rfc2822.html

    Note: this class interface is deprecated and may be removed in the future.
    Use rfc822.AddressList instead.
    """

    def __init__(self, field):
        """Initialize a new instance.

        `field' is an unparsed address header field, containing one or more
        addresses.
        """
        self.specials = '()<>@,:;.\"[]'
        self.pos = 0
        self.LWS = ' \t'
        self.CR = '\r\n'
        self.atomends = self.specials + self.LWS + self.CR
        # Note that RFC 2822 now specifies `.' as obs-phrase, meaning that it
        # is obsolete syntax.  RFC 2822 requires that we recognize obsolete
        # syntax, so allow dots in phrases.
        self.phraseends = self.atomends.replace('.', '')
        self.field = field
        self.commentlist = []

    def gotonext(self):
        """Parse up to the start of the next address."""
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS + '\n\r':
                self.pos = self.pos + 1
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            else: break

    def getaddrlist(self):
        """Parse all addresses.

        Returns a list containing all of the addresses.
        """
        result = []
        ad = self.getaddress()
        while ad:
            result += ad
            ad = self.getaddress()
        return result

    def getaddress(self):
        """Parse the next address."""
        self.commentlist = []
        self.gotonext()

        oldpos = self.pos
        oldcl = self.commentlist
        plist = self.getphraselist()

        self.gotonext()
        returnlist = []

        if self.pos >= len(self.field):
            # Bad email address technically, no domain.
            if plist:
                returnlist = [(' '.join(self.commentlist), plist[0])]

        elif self.field[self.pos] in '.@':
            # email address is just an addrspec
            # this isn't very efficient since we start over
            self.pos = oldpos
            self.commentlist = oldcl
            addrspec = self.getaddrspec()
            returnlist = [(' '.join(self.commentlist), addrspec)]

        elif self.field[self.pos] == ':':
            # address is a group
            returnlist = []

            fieldlen = len(self.field)
            self.pos += 1
            while self.pos < len(self.field):
                self.gotonext()
                if self.pos < fieldlen and self.field[self.pos] == ';':
                    self.pos += 1
                    break
                returnlist = returnlist + self.getaddress()

        elif self.field[self.pos] == '<':
            # Address is a phrase then a route addr
            routeaddr = self.getrouteaddr()

            if self.commentlist:
                returnlist = [(' '.join(plist) + ' (' + \
                         ' '.join(self.commentlist) + ')', routeaddr)]
            else: returnlist = [(' '.join(plist), routeaddr)]

        else:
            if plist:
                returnlist = [(' '.join(self.commentlist), plist[0])]
            elif self.field[self.pos] in self.specials:
                self.pos += 1

        self.gotonext()
        if self.pos < len(self.field) and self.field[self.pos] == ',':
            self.pos += 1
        return returnlist

    def getrouteaddr(self):
        """Parse a route address (Return-path value).

        This method just skips all the route stuff and returns the addrspec.
        """
        if self.field[self.pos] != '<':
            return

        expectroute = 0
        self.pos += 1
        self.gotonext()
        adlist = ""
        while self.pos < len(self.field):
            if expectroute:
                self.getdomain()
                expectroute = 0
            elif self.field[self.pos] == '>':
                self.pos += 1
                break
            elif self.field[self.pos] == '@':
                self.pos += 1
                expectroute = 1
            elif self.field[self.pos] == ':':
                self.pos += 1
            else:
                adlist = self.getaddrspec()
                self.pos += 1
                break
            self.gotonext()

        return adlist

    def getaddrspec(self):
        """Parse an RFC 2822 addr-spec."""
        aslist = []

        self.gotonext()
        while self.pos < len(self.field):
            if self.field[self.pos] == '.':
                aslist.append('.')
                self.pos += 1
            elif self.field[self.pos] == '"':
                aslist.append('"%s"' % self.getquote())
            elif self.field[self.pos] in self.atomends:
                break
            else: aslist.append(self.getatom())
            self.gotonext()

        if self.pos >= len(self.field) or self.field[self.pos] != '@':
            return ''.join(aslist)

        aslist.append('@')
        self.pos += 1
        self.gotonext()
        return ''.join(aslist) + self.getdomain()

    def getdomain(self):
        """Get the complete domain name from an address."""
        sdlist = []
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS:
                self.pos += 1
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            elif self.field[self.pos] == '[':
                sdlist.append(self.getdomainliteral())
            elif self.field[self.pos] == '.':
                self.pos += 1
                sdlist.append('.')
            elif self.field[self.pos] in self.atomends:
                break
            else: sdlist.append(self.getatom())
        return ''.join(sdlist)

    def getdelimited(self, beginchar, endchars, allowcomments = 1):
        """Parse a header fragment delimited by special characters.

        `beginchar' is the start character for the fragment.  If self is not
        looking at an instance of `beginchar' then getdelimited returns the
        empty string.

        `endchars' is a sequence of allowable end-delimiting characters.
        Parsing stops when one of these is encountered.

        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
        within the parsed fragment.
        """
        if self.field[self.pos] != beginchar:
            return ''

        slist = ['']
        quote = 0
        self.pos += 1
        while self.pos < len(self.field):
            if quote == 1:
                slist.append(self.field[self.pos])
                quote = 0
            elif self.field[self.pos] in endchars:
                self.pos += 1
                break
            elif allowcomments and self.field[self.pos] == '(':
                slist.append(self.getcomment())
                continue        # have already advanced pos from getcomment
            elif self.field[self.pos] == '\\':
                quote = 1
            else:
                slist.append(self.field[self.pos])
            self.pos += 1

        return ''.join(slist)

    def getquote(self):
        """Get a quote-delimited fragment from self's field."""
        return self.getdelimited('"', '"\r', 0)

    def getcomment(self):
        """Get a parenthesis-delimited fragment from self's field."""
        return self.getdelimited('(', ')\r', 1)

    def getdomainliteral(self):
        """Parse an RFC 2822 domain-literal."""
        return '[%s]' % self.getdelimited('[', ']\r', 0)

    def getatom(self, atomends=None):
        """Parse an RFC 2822 atom.

        Optional atomends specifies a different set of end token delimiters
        (the default is to use self.atomends).  This is used e.g. in
        getphraselist() since phrase endings must not include the `.' (which
        is legal in phrases)."""
        atomlist = ['']
        if atomends is None:
            atomends = self.atomends

        while self.pos < len(self.field):
            if self.field[self.pos] in atomends:
                break
            else: atomlist.append(self.field[self.pos])
            self.pos += 1

        return ''.join(atomlist)

    def getphraselist(self):
        """Parse a sequence of RFC 2822 phrases.

        A phrase is a sequence of words, which are in turn either RFC 2822
        atoms or quoted-strings.  Phrases are canonicalized by squeezing all
        runs of continuous whitespace into one space.
        """
        plist = []

        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS:
                self.pos += 1
            elif self.field[self.pos] == '"':
                plist.append(self.getquote())
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            elif self.field[self.pos] in self.phraseends:
                break
            else:
                plist.append(self.getatom(self.phraseends))

        return plist

class AddressList(AddrlistClass):
    """An AddressList encapsulates a list of parsed RFC 2822 addresses."""
    def __init__(self, field):
        AddrlistClass.__init__(self, field)
        if field:
            self.addresslist = self.getaddrlist()
        else:
            self.addresslist = []

    def __len__(self):
        return len(self.addresslist)

    def __str__(self):
        return ", ".join(map(dump_address_pair, self.addresslist))

    def __add__(self, other):
        # Set union
        newaddr = AddressList(None)
        newaddr.addresslist = self.addresslist[:]
        for x in other.addresslist:
            if not x in self.addresslist:
                newaddr.addresslist.append(x)
        return newaddr

    def __iadd__(self, other):
        # Set union, in-place
        for x in other.addresslist:
            if not x in self.addresslist:
                self.addresslist.append(x)
        return self

    def __sub__(self, other):
        # Set difference
        newaddr = AddressList(None)
        for x in self.addresslist:
            if not x in other.addresslist:
                newaddr.addresslist.append(x)
        return newaddr

    def __isub__(self, other):
        # Set difference, in-place
        for x in other.addresslist:
            if x in self.addresslist:
                self.addresslist.remove(x)
        return self

    def __getitem__(self, index):
        # Make indexing, slices, and 'in' work
        return self.addresslist[index]

def dump_address_pair(pair):
    """Dump a (name, address) pair in a canonicalized form."""
    if pair[0]:
        return '"' + pair[0] + '" <' + pair[1] + '>'
    else:
        return pair[1]

# Parse a date field

_monthnames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul',
               'aug', 'sep', 'oct', 'nov', 'dec',
               'january', 'february', 'march', 'april', 'may', 'june', 'july',
               'august', 'september', 'october', 'november', 'december']
_daynames = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']

# The timezone table does not include the military time zones defined
# in RFC822, other than Z.  According to RFC1123, the description in
# RFC822 gets the signs wrong, so we can't rely on any such time
# zones.  RFC1123 recommends that numeric timezone indicators be used
# instead of timezone names.

_timezones = {'UT':0, 'UTC':0, 'GMT':0, 'Z':0,
              'AST': -400, 'ADT': -300,  # Atlantic (used in Canada)
              'EST': -500, 'EDT': -400,  # Eastern
              'CST': -600, 'CDT': -500,  # Central
              'MST': -700, 'MDT': -600,  # Mountain
              'PST': -800, 'PDT': -700   # Pacific
              }


def parsedate_tz(data):
    """Convert a date string to a time tuple.

    Accounts for military timezones.
    """
    if not data:
        return None
    data = data.split()
    if data[0][-1] in (',', '.') or data[0].lower() in _daynames:
        # There's a dayname here. Skip it
        del data[0]
    else:
        # no space after the "weekday,"?
        i = data[0].rfind(',')
        if i >= 0:
            data[0] = data[0][i+1:]
    if len(data) == 3: # RFC 850 date, deprecated
        stuff = data[0].split('-')
        if len(stuff) == 3:
            data = stuff + data[1:]
    if len(data) == 4:
        s = data[3]
        i = s.find('+')
        if i > 0:
            data[3:] = [s[:i], s[i+1:]]
        else:
            data.append('') # Dummy tz
    if len(data) < 5:
        return None
    data = data[:5]
    [dd, mm, yy, tm, tz] = data
    mm = mm.lower()
    if not mm in _monthnames:
        dd, mm = mm, dd.lower()
        if not mm in _monthnames:
            return None
    mm = _monthnames.index(mm)+1
    if mm > 12: mm = mm - 12
    if dd[-1] == ',':
        dd = dd[:-1]
    i = yy.find(':')
    if i > 0:
        yy, tm = tm, yy
    if yy[-1] == ',':
        yy = yy[:-1]
    if not yy[0].isdigit():
        yy, tz = tz, yy
    if tm[-1] == ',':
        tm = tm[:-1]
    tm = tm.split(':')
    if len(tm) == 2:
        [thh, tmm] = tm
        tss = '0'
    elif len(tm) == 3:
        [thh, tmm, tss] = tm
    else:
        return None
    try:
        yy = int(yy)
        dd = int(dd)
        thh = int(thh)
        tmm = int(tmm)
        tss = int(tss)
    except ValueError:
        return None
    tzoffset = None
    tz = tz.upper()
    if tz in _timezones:
        tzoffset = _timezones[tz]
    else:
        try:
            tzoffset = int(tz)
        except ValueError:
            pass
    # Convert a timezone offset into seconds ; -0500 -> -18000
    if tzoffset:
        if tzoffset < 0:
            tzsign = -1
            tzoffset = -tzoffset
        else:
            tzsign = 1
        tzoffset = tzsign * ( (tzoffset//100)*3600 + (tzoffset % 100)*60)
    return (yy, mm, dd, thh, tmm, tss, 0, 1, 0, tzoffset)


def parsedate(data):
    """Convert a time string to a time tuple."""
    t = parsedate_tz(data)
    if t is None:
        return t
    return t[:9]


def mktime_tz(data):
    """Turn a 10-tuple as returned by parsedate_tz() into a UTC timestamp."""
    if data[9] is None:
        # No zone info, so localtime is better assumption than GMT
        return time.mktime(data[:8] + (-1,))
    else:
        t = time.mktime(data[:8] + (0,))
        return t - data[9] - time.timezone

def formatdate(timeval=None):
    """Returns time format preferred for Internet standards.

    Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123

    According to RFC 1123, day and month names must always be in
    English.  If not for that, this code could use strftime().  It
    can't because strftime() honors the locale and could generate
    non-English names.
    """
    if timeval is None:
        timeval = time.time()
    timeval = time.gmtime(timeval)
    return "%s, %02d %s %04d %02d:%02d:%02d GMT" % (
            ("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")[timeval[6]],
            timeval[2],
            ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")[timeval[1]-1],
                                timeval[0], timeval[3], timeval[4], timeval[5])


# When used as script, run a small test program.
# The first command line argument must be a filename containing one
# message in RFC-822 format.

if __name__ == '__main__':
    import sys, os
    file = os.path.join(os.environ['HOME'], 'Mail/inbox/1')
    if sys.argv[1:]: file = sys.argv[1]
    f = open(file, 'r')
    m = Message(f)
    print 'From:', m.getaddr('from')
    print 'To:', m.getaddrlist('to')
    print 'Subject:', m.getheader('subject')
    print 'Date:', m.getheader('date')
    date = m.getdate_tz('date')
    tz = date[-1]
    date = time.localtime(mktime_tz(date))
    if date:
        print 'ParsedDate:', time.asctime(date),
        hhmmss = tz
        hhmm, ss = divmod(hhmmss, 60)
        hh, mm = divmod(hhmm, 60)
        print "%+03d%02d" % (hh, mm),
        if ss: print ".%02d" % ss,
        print
    else:
        print 'ParsedDate:', None
    m.rewindbody()
    n = 0
    while f.readline():
        n += 1
    print 'Lines:', n
    print '-'*70
    print 'len =', len(m)
    if 'Date' in m: print 'Date =', m['Date']
    if 'X-Nonsense' in m: pass
    print 'keys =', m.keys()
    print 'values =', m.values()
    print 'items =', m.items()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sπ  d  Z  d d l Z d d l m Z e d d d Éd d d	 d
 d g Z d d f Z d f  d Ñ  É  YZ d Ñ  Z d Ñ  Z d Ñ  Z	 d f  d Ñ  É  YZ
 d e
 f d Ñ  É  YZ d Ñ  Z d d d d d d d d d d d  d! d" d# d$ d% d d& d' d( d) d* d+ d, g Z d- d. d/ d0 d1 d2 d3 g Z i d4 d5 6d4 d6 6d4 d7 6d4 d8 6d9 d: 6d; d< 6d= d> 6d9 d? 6d@ dA 6d= dB 6dC dD 6d@ dE 6dF dG 6dC dH 6Z dI Ñ  Z dJ Ñ  Z dK Ñ  Z e dL Ñ Z e dM k rµd d l Z d d l Z e j j e j dN dO É Z e j dP re j dP Z n  e e dQ É Z e e É Z dR Ge j  dS É GHdT Ge j! dU É GHdV Ge j" dW É GHdX Ge j" dY É GHe j# dY É Z$ e$ d Z% e j& e e$ É É Z$ e$ rdZ Ge j' e$ É Ge% Z( e) e( d[ É \ Z* Z+ e) e* d[ É \ Z, Z- d\ e, e- f Ge+ rˇd] e+ Gn  Hn	 dZ Ge GHe j. É  d4 Z/ x e j0 É  r8e/ dP 7Z/ qWd^ Ge/ GHd_ d` GHda Ge1 e É GHdb e k rvdc Ge db GHn  dd e k rÖn  de Ge j2 É  GHdf Ge j3 É  GHdg Ge j4 É  GHn  d S(h   s*  RFC 2822 message manipulation.

Note: This is only a very rough sketch of a full RFC-822 parser; in particular
the tokenizing of addresses does not adhere to all the quoting rules.

Note: RFC 2822 is a long awaited update to RFC 822.  This module should
conform to RFC 2822, and is thus mis-named (it's not worth renaming it).  Some
effort at RFC 2822 updates have been made, but a thorough audit has not been
performed.  Consider any RFC 2822 non-conformance to be a bug.

    RFC 2822: http://www.faqs.org/rfcs/rfc2822.html
    RFC 822 : http://www.faqs.org/rfcs/rfc822.html (obsolete)

Directions for use:

To create a Message object: first open a file, e.g.:

  fp = open(file, 'r')

You can use any other legal way of getting an open file object, e.g. use
sys.stdin or call os.popen().  Then pass the open file object to the Message()
constructor:

  m = Message(fp)

This class can work with any input object that supports a readline method.  If
the input object has seek and tell capability, the rewindbody method will
work; also illegal lines will be pushed back onto the input stream.  If the
input object lacks seek but has an `unread' method that can push back a line
of input, Message will use that to push back illegal lines.  Thus this class
can be used to parse messages coming from a buffered stream.

The optional `seekable' argument is provided as a workaround for certain stdio
libraries in which tell() discards buffered data before discovering that the
lseek() system call doesn't work.  For maximum portability, you should set the
seekable argument to zero to prevent that initial \code{tell} when passing in
an unseekable object such as a file object created from a socket object.  If
it is 1 on entry -- which it is by default -- the tell() method of the open
file object is called once; if this raises an exception, seekable is reset to
0.  For other nonzero values of seekable, this test is not made.

To get the text of a particular header there are several methods:

  str = m.getheader(name)
  str = m.getrawheader(name)

where name is the name of the header, e.g. 'Subject'.  The difference is that
getheader() strips the leading and trailing whitespace, while getrawheader()
doesn't.  Both functions retain embedded whitespace (including newlines)
exactly as they are specified in the header, and leave the case of the text
unchanged.

For addresses and address lists there are functions

  realname, mailaddress = m.getaddr(name)
  list = m.getaddrlist(name)

where the latter returns a list of (realname, mailaddr) tuples.

There is also a method

  time = m.getdate(name)

which parses a Date-like field and returns a time-compatible tuple,
i.e. a tuple such as returned by time.localtime() or accepted by
time.mktime().

See the class definition for lower level access methods.

There are also some utility functions here.
iˇˇˇˇN(   t   warnpy3ks=   in 3.x, rfc822 has been removed in favor of the email packaget
   stackleveli   t   Messaget   AddressListt	   parsedatet   parsedate_tzt	   mktime_tzs   
s   
c           B   s  e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d	 Ñ  Z
 d
 Ñ  Z d d Ñ Z e Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s/   Represents a single RFC 2822-compliant message.i   c         C   sÌ   | d k r= y | j  É  Wq= t t f k
 r9 d } q= Xn  | |  _ | |  _ d |  _ d |  _ |  j r† y |  j j  É  |  _ Wq† t k
 rú d |  _ q† Xn  |  j É  |  j rÈ y |  j j  É  |  _ WqÈ t k
 rÂ d |  _ qÈ Xn  d S(   s3   Initialize the class instance and read the headers.i   i    N(	   t   tellt   AttributeErrort   IOErrort   fpt   seekablet   Nonet   startofheaderst   startofbodyt   readheaders(   t   selfR
   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   __init__X   s(    					
	c         C   s,   |  j  s t d Ç n  |  j j |  j É d S(   s7   Rewind the file to the start of the body (if seekable).s   unseekable fileN(   R   R	   R
   t   seekR   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyt
   rewindbodyt   s    	c   	      C   sK  i  |  _  d |  _ g  |  _ } d |  _ d } d } d } } } t |  j d É rc |  j j } n |  j r{ |  j j	 } n  x…| rª y | É  } Wqª t
 k
 r∑ d } } d |  _ qª Xn  |  j j É  } | s› d |  _ Pn  | r| j d É r|  j | |  _ q~ n  d } | re| d d k re| j | É |  j  | d | j É  } | j É  |  j  | <q~ n( |  j | É rzq~ n |  j | É rçPn  |  j | É } | r÷| j | É | t | É d j É  |  j  | <q~ q~ | d k	 rËq~ q~ |  j  s˝d	 |  _ n	 d
 |  _ | r| | É n) | r2|  j j | É n |  j d |  _ Pq~ Wd S(   sæ  Read header lines.

        Read header lines up to the entirely blank line that terminates them.
        The (normally blank) line that ends the headers is skipped, but not
        included in the returned list.  If a non-header line ends the headers,
        (which is an error), an attempt is made to backspace over it; it is
        never included in the returned list.

        The variable self.status is set to the empty string if all went well,
        otherwise it is an error message.  The variable self.headers is a
        completely uninterpreted list of lines contained in the header (so
        printing them will reproduce the header exactly as it appears in the
        file).
        t    i   t   unreadi    s   EOF in headerss   From s    	s   
 s
   No headerss%   Non-header line where header expecteds
   ; bad seekN(   t   dictt   unixfromt   headerst   statusR   t   hasattrR
   R   R   R   R	   t   readlinet
   startswitht   appendt   stript	   iscommentt   islastt   isheadert   lenR   (	   R   t   lstt
   headerseent	   firstlinet   startoflineR   R   t   linet   x(    (    s   /usr/lib/python2.7/rfc822.pyR   z   sf    				
	!		c         C   s-   | j  d É } | d k r) | |  j É  Sd S(   s  Determine whether a given line is a legal header.

        This method should return the header name, suitably canonicalized.
        You may override this method in order to use Message parsing on tagged
        data in RFC 2822-like formats with special header formats.
        t   :iˇˇˇˇN(   t   findt   lowerR   (   R   R'   t   i(    (    s   /usr/lib/python2.7/rfc822.pyR!       s    c         C   s
   | t  k S(   sf  Determine whether a line is a legal end of RFC 2822 headers.

        You may override this method if your application wants to bend the
        rules, e.g. to strip trailing whitespace, or to recognize MH template
        separators ('--------').  For convenience (e.g. for code reading from
        sockets) a line consisting of \r\n also matches.
        (   t   _blanklines(   R   R'   (    (    s   /usr/lib/python2.7/rfc822.pyR    ÷   s    c         C   s   t  S(   sÌ   Determine whether a line should be skipped entirely.

        You may override this method in order to use Message parsing on tagged
        data in RFC 2822-like formats that support embedded comments or
        free-text data.
        (   t   False(   R   R'   (    (    s   /usr/lib/python2.7/rfc822.pyR   ‡   s    c         C   sé   | j  É  d } t | É } g  } d } x_ |  j D]T } | |  j  É  | k rW d } n | d  j É  sp d } n  | r2 | j | É q2 q2 W| S(   sπ  Find all header lines matching a given header name.

        Look through the list of headers and find all lines matching a given
        header name (and their continuation lines).  A list of the lines is
        returned, without interpretation.  If the header does not occur, an
        empty list is returned.  If the header occurs multiple times, all
        occurrences are returned.  Case is not important in the header name.
        R)   i    i   (   R+   R"   R   t   isspaceR   (   R   t   namet   nR#   t   hitR'   (    (    s   /usr/lib/python2.7/rfc822.pyt   getallmatchingheadersÈ   s    			c         C   sí   | j  É  d } t | É } g  } d } xc |  j D]X } | rU | d  j É  st Pqt n | |  j  É  | k rt d } n  | r2 | j | É q2 q2 W| S(   s∏   Get the first header line matching name.

        This is similar to getallmatchingheaders, but it returns only the
        first matching header (and its continuation lines).
        R)   i    i   (   R+   R"   R   R/   R   (   R   R0   R1   R#   R2   R'   (    (    s   /usr/lib/python2.7/rfc822.pyt   getfirstmatchingheaderˇ   s    	c         C   sB   |  j  | É } | s d S| d t | É d | d <d j | É S(   s2  A higher-level interface to getfirstmatchingheader().

        Return a string containing the literal text of the header but with the
        keyword stripped.  All leading, trailing and embedded whitespace is
        kept in the string, however.  Return None if the header does not
        occur.
        i    i   R   N(   R4   R   R"   t   join(   R   R0   R#   (    (    s   /usr/lib/python2.7/rfc822.pyt   getrawheader  s
    	c         C   s   |  j  j | j É  | É S(   s  Get the header value for a name.

        This is the normal interface: it returns a stripped version of the
        header value for a given header name, or None if it doesn't exist.
        This uses the dictionary version which finds the *last* such header.
        (   R   t   getR+   (   R   R0   t   default(    (    s   /usr/lib/python2.7/rfc822.pyt	   getheader"  s    c         C   sΩ   g  } d } d } xé |  j  | É D]} } | d j É  rf | rW d | | j É  f } qü | j É  } q" | r| | j | É n  | | j d É d j É  } d } q" W| rπ | j | É n  | S(   s	  Get all values for a header.

        This returns a list of values for headers given more than once; each
        value in the result list is stripped in the same way as the result of
        getheader().  If the header is not given, return an empty list.
        R   i    s   %s
 %sR)   i   (   R3   R/   R   R   R*   (   R   R0   t   resultt   currentt   have_headert   s(    (    s   /usr/lib/python2.7/rfc822.pyt
   getheaders,  s    
c         C   s%   |  j  | É } | r | d Sd Sd S(   sá   Get a single address from a header, as a tuple.

        An example return value:
        ('Guido van Rossum', 'guido@cwi.nl')
        i    N(   NN(   t   getaddrlistR   (   R   R0   t   alist(    (    s   /usr/lib/python2.7/rfc822.pyt   getaddrE  s    c         C   s±   g  } xÜ |  j  | É D]u } | d d k r< | j | É q | rR | j d É n  | j d É } | d k r~ | | d } n  | j | É q Wd j | É } t | É } | j S(   s
  Get a list of addresses from a header.

        Retrieves a list of addresses from a header, where each address is a
        tuple as returned by getaddr().  Scans all named headers, so it works
        properly with multiple To: or Cc: headers for example.
        i    s    	s   , R)   i   R   (   R3   R   R*   R5   R   t   addresslist(   R   R0   t   rawt   hR,   t   addrt   alladdrst   a(    (    s   /usr/lib/python2.7/rfc822.pyR?   R  s    c         C   s-   y |  | } Wn t  k
 r" d SXt | É S(   sù   Retrieve a date field from a header.

        Retrieves a date field from the named header, returning a tuple
        compatible with time.mktime().
        N(   t   KeyErrorR   R   (   R   R0   t   data(    (    s   /usr/lib/python2.7/rfc822.pyt   getdateh  s
    c         C   s-   y |  | } Wn t  k
 r" d SXt | É S(   s”   Retrieve a date field from a header as a 10-tuple.

        The first 9 elements make up a tuple compatible with time.mktime(),
        and the 10th is the offset of the poster's time zone from GMT/UTC.
        N(   RH   R   R   (   R   R0   RI   (    (    s   /usr/lib/python2.7/rfc822.pyt
   getdate_tzt  s
    c         C   s   t  |  j É S(   s'   Get the number of headers in a message.(   R"   R   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   __len__É  s    c         C   s   |  j  | j É  S(   s,   Get a specific header, as from a dictionary.(   R   R+   (   R   R0   (    (    s   /usr/lib/python2.7/rfc822.pyt   __getitem__á  s    c         C   sZ   |  | =| |  j  | j É  <| d | } x+ | j d É D] } |  j j | d É q8 Wd S(   sÂ   Set the value of a header.

        Note: This is not a perfect inversion of __getitem__, because any
        changed headers get stuck at the end of the raw-headers list rather
        than where the altered header was.
        s   : s   
N(   R   R+   t   splitR   R   (   R   R0   t   valuet   textR'   (    (    s   /usr/lib/python2.7/rfc822.pyt   __setitem__ã  s
    c         C   sÎ   | j  É  } | |  j k r d S|  j | =| d } t | É } g  } d } xx t t |  j É É D]a } |  j | } | |  j  É  | k rì d } n | d  j É  s¨ d } n  | ra | j | É qa qa Wx t | É D] } |  j | =q” Wd S(   s>   Delete all occurrences of a specific header, if it is present.NR)   i    i   (   R+   R   R"   t   rangeR   R/   R   t   reversed(   R   R0   R1   R#   R2   R,   R'   (    (    s   /usr/lib/python2.7/rfc822.pyt   __delitem__ò  s$    

		R   c         C   sw   | j  É  } | |  j k r& |  j | S| d | } x+ | j d É D] } |  j j | d É qD W| |  j | <| Sd  S(   Ns   : s   
(   R+   R   RN   R   R   (   R   R0   R8   t	   lowernameRP   R'   (    (    s   /usr/lib/python2.7/rfc822.pyt
   setdefault≠  s    c         C   s   | j  É  |  j k S(   s6   Determine whether a message contains the named header.(   R+   R   (   R   R0   (    (    s   /usr/lib/python2.7/rfc822.pyt   has_key∏  s    c         C   s   | j  É  |  j k S(   s6   Determine whether a message contains the named header.(   R+   R   (   R   R0   (    (    s   /usr/lib/python2.7/rfc822.pyt   __contains__º  s    c         C   s   t  |  j É S(   N(   t   iterR   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   __iter__¿  s    c         C   s   |  j  j É  S(   s*   Get all of a message's header field names.(   R   t   keys(   R   (    (    s   /usr/lib/python2.7/rfc822.pyR[   √  s    c         C   s   |  j  j É  S(   s+   Get all of a message's header field values.(   R   t   values(   R   (    (    s   /usr/lib/python2.7/rfc822.pyR\   «  s    c         C   s   |  j  j É  S(   sW   Get all of a message's headers.

        Returns a list of name, value tuples.
        (   R   t   items(   R   (    (    s   /usr/lib/python2.7/rfc822.pyR]   À  s    c         C   s   d j  |  j É S(   NR   (   R5   R   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   __str__“  s    N(    t   __name__t
   __module__t   __doc__R   R   R   R!   R    R   R3   R4   R6   R   R9   R7   R>   RA   R?   RJ   RK   RL   RM   RQ   RT   RV   RW   RX   RZ   R[   R\   R]   R^   (    (    (    s   /usr/lib/python2.7/rfc822.pyR   U   s:   		P		
																				c         C   sÉ   t  |  É d k r |  j d É rS |  j d É rS |  d d !j d d É j d d É S|  j d É r |  j d É r |  d d !Sn  |  S(	   s   Remove quotes from a string.i   t   "iˇˇˇˇs   \\s   \s   \"t   <t   >(   R"   R   t   endswitht   replace(   R=   (    (    s   /usr/lib/python2.7/rfc822.pyt   unquote›  s    #c         C   s   |  j  d d É j  d d É S(   s   Add quotes around a string.s   \s   \\Rb   s   \"(   Rf   (   R=   (    (    s   /usr/lib/python2.7/rfc822.pyt   quoteÁ  s    c         C   s'   t  |  É } | j } | s d S| d S(   s3   Parse an address into a (realname, mailaddr) tuple.i    N(   NN(   R   RB   R   (   t   addressRG   R#   (    (    s   /usr/lib/python2.7/rfc822.pyt	   parseaddrÏ  s
    	t   AddrlistClassc           B   sâ   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d d	 Ñ Z
 d
 Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z RS(   s)  Address parser class by Ben Escoto.

    To understand what this class does, it helps to have a copy of
    RFC 2822 in front of you.

    http://www.faqs.org/rfcs/rfc2822.html

    Note: this class interface is deprecated and may be removed in the future.
    Use rfc822.AddressList instead.
    c         C   sl   d |  _  d |  _ d |  _ d |  _ |  j  |  j |  j |  _ |  j j d d É |  _ | |  _ g  |  _ d S(   sÉ   Initialize a new instance.

        `field' is an unparsed address header field, containing one or more
        addresses.
        s   ()<>@,:;."[]i    s    	s   
t   .R   N(	   t   specialst   post   LWSt   CRt   atomendsRf   t
   phraseendst   fieldt   commentlist(   R   Rs   (    (    s   /usr/lib/python2.7/rfc822.pyR     s    					c         C   sÉ   x| |  j  t |  j É k  r~ |  j |  j  |  j d k rK |  j  d |  _  q |  j |  j  d k rz |  j j |  j É  É q Pq Wd S(   s*   Parse up to the start of the next address.s   
i   t   (N(   Rn   R"   Rs   Ro   Rt   R   t
   getcomment(   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   gotonext  s    c         C   s9   g  } |  j  É  } x  | r4 | | 7} |  j  É  } q W| S(   sV   Parse all addresses.

        Returns a list containing all of the addresses.
        (   t
   getaddress(   R   R:   t   ad(    (    s   /usr/lib/python2.7/rfc822.pyR?     s    	
c         C   sû  g  |  _  |  j É  |  j } |  j  } |  j É  } |  j É  g  } |  j t |  j É k rÑ | rPd j |  j  É | d f g } qPnÃ|  j |  j d k r÷ | |  _ | |  _  |  j É  } d j |  j  É | f g } nz|  j |  j d k rÑg  } t |  j É } |  j d 7_ x=|  j t |  j É k  rÄ|  j É  |  j | k  rm|  j |  j d k rm|  j d 7_ Pn  | |  j É  } qWnÃ |  j |  j d k r˝|  j	 É  } |  j  r‚d j | É d d j |  j  É d	 | f g } qPd j | É | f g } nS | r%d j |  j  É | d f g } n+ |  j |  j |  j
 k rP|  j d 7_ n  |  j É  |  j t |  j É k  rö|  j |  j d
 k rö|  j d 7_ n  | S(   s   Parse the next address.t    i    s   .@R)   i   t   ;Rc   s    (t   )t   ,(   Rt   Rw   Rn   t   getphraselistR"   Rs   R5   t   getaddrspecRx   t   getrouteaddrRm   (   R   t   oldpost   oldclt   plistt
   returnlistt   addrspect   fieldlent	   routeaddr(    (    s   /usr/lib/python2.7/rfc822.pyRx   (  sL    	
		
%		
%	3"
.c         C   s   |  j  |  j d k r d Sd } |  j d 7_ |  j É  d } x⁄ |  j t |  j  É k  r| rs |  j É  d } nõ |  j  |  j d k rú |  j d 7_ Pnr |  j  |  j d k r  |  j d 7_ d } nD |  j  |  j d k rÚ |  j d 7_ n |  j É  } |  j d 7_ P|  j É  qB W| S(	   sÅ   Parse a route address (Return-path value).

        This method just skips all the route stuff and returns the addrspec.
        Rc   Ni    i   R   Rd   t   @R)   (   Rs   Rn   Rw   R"   t	   getdomainR   (   R   t   expectroutet   adlist(    (    s   /usr/lib/python2.7/rfc822.pyRÄ   b  s.    

		c         C   sF  g  } |  j  É  xª |  j t |  j É k  rÕ |  j |  j d k r` | j d É |  j d 7_ n` |  j |  j d k rê | j d |  j É  É n0 |  j |  j |  j k r≠ Pn | j |  j É  É |  j  É  q W|  j t |  j É k s¸ |  j |  j d k r	d j | É S| j d É |  j d 7_ |  j  É  d j | É |  j	 É  S(   s   Parse an RFC 2822 addr-spec.Rl   i   Rb   s   "%s"Rà   R   (
   Rw   Rn   R"   Rs   R   t   getquoteRq   t   getatomR5   Râ   (   R   t   aslist(    (    s   /usr/lib/python2.7/rfc822.pyR   Ç  s$    
.
c         C   s  g  } x|  j  t |  j É k  r|  j |  j  |  j k rL |  j  d 7_  q	 |  j |  j  d k r{ |  j j |  j É  É q	 |  j |  j  d k rß | j |  j É  É q	 |  j |  j  d k r‹ |  j  d 7_  | j d É q	 |  j |  j  |  j k r˘ Pq	 | j |  j	 É  É q	 Wd j
 | É S(   s-   Get the complete domain name from an address.i   Ru   t   [Rl   R   (   Rn   R"   Rs   Ro   Rt   R   Rv   t   getdomainliteralRq   Rç   R5   (   R   t   sdlist(    (    s   /usr/lib/python2.7/rfc822.pyRâ   ö  s    i   c         C   s3  |  j  |  j | k r d Sd g } d } |  j d 7_ xÎ |  j t |  j  É k  r%| d k r | j |  j  |  j É d } nî |  j  |  j | k r® |  j d 7_ Pnk | r› |  j  |  j d k r› | j |  j É  É q; n6 |  j  |  j d k r¸ d } n | j |  j  |  j É |  j d 7_ q; Wd j | É S(   sÁ  Parse a header fragment delimited by special characters.

        `beginchar' is the start character for the fragment.  If self is not
        looking at an instance of `beginchar' then getdelimited returns the
        empty string.

        `endchars' is a sequence of allowable end-delimiting characters.
        Parsing stops when one of these is encountered.

        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
        within the parsed fragment.
        R   i    i   Ru   s   \(   Rs   Rn   R"   R   Rv   R5   (   R   t	   beginchart   endcharst   allowcommentst   slistRh   (    (    s   /usr/lib/python2.7/rfc822.pyt   getdelimited¨  s(    			c         C   s   |  j  d d d É S(   s1   Get a quote-delimited fragment from self's field.Rb   s   "i    (   Rñ   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyRå   —  s    c         C   s   |  j  d d d É S(   s7   Get a parenthesis-delimited fragment from self's field.Ru   s   )i   (   Rñ   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyRv   ’  s    c         C   s   d |  j  d d d É S(   s!   Parse an RFC 2822 domain-literal.s   [%s]Rè   s   ]i    (   Rñ   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyRê   Ÿ  s    c         C   sç   d g } | d k r! |  j } n  x\ |  j t |  j É k  r |  j |  j | k rV Pn | j |  j |  j É |  j d 7_ q$ Wd j | É S(   s  Parse an RFC 2822 atom.

        Optional atomends specifies a different set of end token delimiters
        (the default is to use self.atomends).  This is used e.g. in
        getphraselist() since phrase endings must not include the `.' (which
        is legal in phrases).R   i   N(   R   Rq   Rn   R"   Rs   R   R5   (   R   Rq   t   atomlist(    (    s   /usr/lib/python2.7/rfc822.pyRç   ›  s    	c         C   sÂ   g  } xÿ |  j  t |  j É k  r‡ |  j |  j  |  j k rL |  j  d 7_  q	 |  j |  j  d k rx | j |  j É  É q	 |  j |  j  d k rß |  j j |  j É  É q	 |  j |  j  |  j k rƒ Pq	 | j |  j	 |  j É É q	 W| S(   s˝   Parse a sequence of RFC 2822 phrases.

        A phrase is a sequence of words, which are in turn either RFC 2822
        atoms or quoted-strings.  Phrases are canonicalized by squeezing all
        runs of continuous whitespace into one space.
        i   Rb   Ru   (
   Rn   R"   Rs   Ro   R   Rå   Rt   Rv   Rr   Rç   (   R   RÉ   (    (    s   /usr/lib/python2.7/rfc822.pyR~     s    N(   R_   R`   Ra   R   Rw   R?   Rx   RÄ   R   Râ   Rñ   Rå   Rv   Rê   R   Rç   R~   (    (    (    s   /usr/lib/python2.7/rfc822.pyRk   ı  s   
					:	 		%			c           B   sV   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   s@   An AddressList encapsulates a list of parsed RFC 2822 addresses.c         C   s5   t  j |  | É | r( |  j É  |  _ n	 g  |  _ d  S(   N(   Rk   R   R?   RB   (   R   Rs   (    (    s   /usr/lib/python2.7/rfc822.pyR   	  s    c         C   s   t  |  j É S(   N(   R"   RB   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyRL     s    c         C   s   d j  t t |  j É É S(   Ns   , (   R5   t   mapt   dump_address_pairRB   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyR^     s    c         C   sS   t  d  É } |  j | _ x3 | j D]( } | |  j k r# | j j | É q# q# W| S(   N(   R   R   RB   R   (   R   t   othert   newaddrR(   (    (    s   /usr/lib/python2.7/rfc822.pyt   __add__  s    c         C   s:   x3 | j  D]( } | |  j  k r
 |  j  j | É q
 q
 W|  S(   N(   RB   R   (   R   Rö   R(   (    (    s   /usr/lib/python2.7/rfc822.pyt   __iadd__  s    c         C   sF   t  d  É } x3 |  j D]( } | | j k r | j j | É q q W| S(   N(   R   R   RB   R   (   R   Rö   Rõ   R(   (    (    s   /usr/lib/python2.7/rfc822.pyt   __sub__&  s
    c         C   s:   x3 | j  D]( } | |  j  k r
 |  j  j | É q
 q
 W|  S(   N(   RB   t   remove(   R   Rö   R(   (    (    s   /usr/lib/python2.7/rfc822.pyt   __isub__.  s    c         C   s   |  j  | S(   N(   RB   (   R   t   index(    (    s   /usr/lib/python2.7/rfc822.pyRM   5  s    (   R_   R`   Ra   R   RL   R^   Rú   Rù   Rû   R†   RM   (    (    (    s   /usr/lib/python2.7/rfc822.pyR     s   								c         C   s2   |  d r& d |  d d |  d d S|  d Sd S(   s4   Dump a (name, address) pair in a canonicalized form.i    Rb   s   " <i   Rd   N(    (   t   pair(    (    s   /usr/lib/python2.7/rfc822.pyRô   9  s    
t   jant   febt   mart   aprt   mayt   junt   jult   augt   sept   octt   novt   dect   januaryt   februaryt   marcht   aprilt   junet   julyt   augustt	   septembert   octobert   novembert   decembert   mont   tuet   wedt   thut   frit   satt   suni    t   UTt   UTCt   GMTt   Zip˛ˇˇt   ASTi‘˛ˇˇt   ADTi˛ˇˇt   ESTt   EDTi®˝ˇˇt   CSTt   CDTiD˝ˇˇt   MSTt   MDTi‡¸ˇˇt   PSTt   PDTc      
   C   s·  |  s
 d S|  j É  }  |  d d d k s@ |  d j É  t k rJ |  d =n8 |  d j d É } | d k rÇ |  d | d |  d <n  t |  É d k rÕ |  d j d É } t | É d k rÕ | |  d }  qÕ n  t |  É d k r3|  d } | j d	 É } | d k r#| |  | | d g |  d )q3|  j d
 É n  t |  É d k  rId S|  d  }  |  \ } } } } } | j É  } | t k r¶| | j É  } } | t k r¶d Sn  t j	 | É d } | d k r“| d } n  | d d k rÔ| d  } n  | j d É } | d k r| | } } n  | d d k r7| d  } n  | d j
 É  sW| | } } n  | d d k rt| d  } n  | j d É } t | É d k r™| \ }	 }
 d } n( t | É d k rŒ| \ }	 }
 } n d Sy@ t | É } t | É } t |	 É }	 t |
 É }
 t | É } Wn t k
 r&d SXd } | j É  } | t k rRt | } n$ y t | É } Wn t k
 run X| rø| d k  ròd } | } n d } | | d d | d d } n  | | | |	 |
 | d d d | f
 S(   sQ   Convert a date string to a time tuple.

    Accounts for military timezones.
    i    iˇˇˇˇR}   Rl   i   i   t   -i   t   +R   i   i   R)   i   t   0id   i  i<   N(   R}   Rl   (   R   RN   R+   t	   _daynamest   rfindR"   R*   R   t   _monthnamesR°   t   isdigitt   intt
   ValueErrort   uppert
   _timezones(   RI   R,   t   stuffR=   t   ddt   mmt   yyt   tmt   tzt   thht   tmmt   tsst   tzoffsett   tzsign(    (    s   /usr/lib/python2.7/rfc822.pyR   W  sé    *


 	
!c         C   s$   t  |  É } | d k r | S| d  S(   s&   Convert a time string to a time tuple.i	   N(   R   R   (   RI   t   t(    (    s   /usr/lib/python2.7/rfc822.pyR   ¨  s    c         C   sS   |  d d k r% t j |  d  d É St j |  d  d É } | |  d t j Sd S(   sC   Turn a 10-tuple as returned by parsedate_tz() into a UTC timestamp.i	   i   iˇˇˇˇi    N(   iˇˇˇˇ(   i    (   R   t   timet   mktimet   timezone(   RI   RÂ   (    (    s   /usr/lib/python2.7/rfc822.pyR   ¥  s    c         C   so   |  d k r t j É  }  n  t j |  É }  d d |  d	 |  d
 d |  d d |  d |  d |  d |  d f S(   s[  Returns time format preferred for Internet standards.

    Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123

    According to RFC 1123, day and month names must always be in
    English.  If not for that, this code could use strftime().  It
    can't because strftime() honors the locale and could generate
    non-English names.
    s#   %s, %02d %s %04d %02d:%02d:%02d GMTt   Mont   Tuet   Wedt   Thut   Frit   Satt   Suni   i   t   Jant   Febt   Mart   Aprt   Mayt   Junt   Jult   Augt   Sept   Octt   Novt   Deci   i    i   i   i   N(   RÈ   RÍ   RÎ   RÏ   RÌ   RÓ   RÔ   (   R   RÒ   RÚ   RÛ   RÙ   Rı   Rˆ   R˜   R¯   R˘   R˙   R˚   (   R   RÊ   t   gmtime(   t   timeval(    (    s   /usr/lib/python2.7/rfc822.pyt
   formatdateΩ  s    
 t   __main__t   HOMEs   Mail/inbox/1i   t   rs   From:t   froms   To:t   tos   Subject:t   subjects   Date:t   dates   ParsedDate:i<   s	   %+03d%02ds   .%02ds   Lines:Rœ   iF   s   len =t   Dates   Date =s
   X-Nonsenses   keys =s   values =s   items =(5   Ra   RÊ   t   warningsR    t   __all__R-   R   Rg   Rh   Rj   Rk   R   Rô   R‘   R“   RŸ   R   R   R   R   R˛   R_   t   syst   ost   pathR5   t   environt   filet   argvt   opent   ft   mRA   R?   R9   RK   R  Rﬂ   t	   localtimet   asctimet   hhmmsst   divmodt   hhmmt   sst   hhR‹   R   R1   R   R"   R[   R\   R]   (    (    (    s   /usr/lib/python2.7/rfc822.pyt   <module>G   sà   	ˇ â	
			ˇ 2			U			 
 	
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     """Word completion for GNU readline.

The completer completes keywords, built-ins and globals in a selectable
namespace (which defaults to __main__); when completing NAME.NAME..., it
evaluates (!) the expression up to the last dot and completes its attributes.

It's very cool to do "import sys" type "sys.", hit the completion key (twice),
and see the list of names defined by the sys module!

Tip: to use the tab key as the completion key, call

    readline.parse_and_bind("tab: complete")

Notes:

- Exceptions raised by the completer function are *ignored* (and generally cause
  the completion to fail).  This is a feature -- since readline sets the tty
  device in raw (or cbreak) mode, printing a traceback wouldn't work well
  without some complicated hoopla to save, reset and restore the tty state.

- The evaluation of the NAME.NAME... form may cause arbitrary application
  defined code to be executed if an object with a __getattr__ hook is found.
  Since it is the responsibility of the application (or the user) to enable this
  feature, I consider this an acceptable risk.  More complicated expressions
  (e.g. function calls or indexing operations) are *not* evaluated.

- GNU readline is also used by the built-in functions input() and
raw_input(), and thus these also benefit/suffer from the completer
features.  Clearly an interactive application can benefit by
specifying its own completer function and using raw_input() for all
its input.

- When the original stdin is not a tty device, GNU readline is never
  used, and this module (and the readline module) are silently inactive.

"""

import __builtin__
import __main__

__all__ = ["Completer"]

class Completer:
    def __init__(self, namespace = None):
        """Create a new completer for the command line.

        Completer([namespace]) -> completer instance.

        If unspecified, the default namespace where completions are performed
        is __main__ (technically, __main__.__dict__). Namespaces should be
        given as dictionaries.

        Completer instances should be used as the completion mechanism of
        readline via the set_completer() call:

        readline.set_completer(Completer(my_namespace).complete)
        """

        if namespace and not isinstance(namespace, dict):
            raise TypeError,'namespace must be a dictionary'

        # Don't bind to namespace quite yet, but flag whether the user wants a
        # specific namespace or to use __main__.__dict__. This will allow us
        # to bind to __main__.__dict__ at completion time, not now.
        if namespace is None:
            self.use_main_ns = 1
        else:
            self.use_main_ns = 0
            self.namespace = namespace

    def complete(self, text, state):
        """Return the next possible completion for 'text'.

        This is called successively with state == 0, 1, 2, ... until it
        returns None.  The completion should begin with 'text'.

        """
        if self.use_main_ns:
            self.namespace = __main__.__dict__

        if state == 0:
            if "." in text:
                self.matches = self.attr_matches(text)
            else:
                self.matches = self.global_matches(text)
        try:
            return self.matches[state]
        except IndexError:
            return None

    def _callable_postfix(self, val, word):
        if hasattr(val, '__call__'):
            word = word + "("
        return word

    def global_matches(self, text):
        """Compute matches when text is a simple name.

        Return a list of all keywords, built-in functions and names currently
        defined in self.namespace that match.

        """
        import keyword
        matches = []
        seen = {"__builtins__"}
        n = len(text)
        for word in keyword.kwlist:
            if word[:n] == text:
                seen.add(word)
                matches.append(word)
        for nspace in [self.namespace, __builtin__.__dict__]:
            for word, val in nspace.items():
                if word[:n] == text and word not in seen:
                    seen.add(word)
                    matches.append(self._callable_postfix(val, word))
        return matches

    def attr_matches(self, text):
        """Compute matches when text contains a dot.

        Assuming the text is of the form NAME.NAME....[NAME], and is
        evaluable in self.namespace, it will be evaluated and its attributes
        (as revealed by dir()) are used as possible completions.  (For class
        instances, class members are also considered.)

        WARNING: this can still invoke arbitrary C code, if an object
        with a __getattr__ hook is evaluated.

        """
        import re
        m = re.match(r"(\w+(\.\w+)*)\.(\w*)", text)
        if not m:
            return []
        expr, attr = m.group(1, 3)
        try:
            thisobject = eval(expr, self.namespace)
        except Exception:
            return []

        # get the content of the object, except __builtins__
        words = set(dir(thisobject))
        words.discard("__builtins__")

        if hasattr(thisobject, '__class__'):
            words.add('__class__')
            words.update(get_class_members(thisobject.__class__))
        matches = []
        n = len(attr)
        for word in words:
            if word[:n] == attr:
                try:
                    val = getattr(thisobject, word)
                except Exception:
                    continue  # Exclude properties that are not set
                word = self._callable_postfix(val, "%s.%s" % (expr, word))
                matches.append(word)
        matches.sort()
        return matches

def get_class_members(klass):
    ret = dir(klass)
    if hasattr(klass,'__bases__'):
        for base in klass.__bases__:
            ret = ret + get_class_members(base)
    return ret

try:
    import readline
except ImportError:
    pass
else:
    readline.set_completer(Completer().complete)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   s~   d  Z  d d l Z d d l Z d g Z d d d Ñ  É  YZ d Ñ  Z y d d l Z Wn e k
 rf n Xe j e É  j	 É d S(   sC  Word completion for GNU readline.

The completer completes keywords, built-ins and globals in a selectable
namespace (which defaults to __main__); when completing NAME.NAME..., it
evaluates (!) the expression up to the last dot and completes its attributes.

It's very cool to do "import sys" type "sys.", hit the completion key (twice),
and see the list of names defined by the sys module!

Tip: to use the tab key as the completion key, call

    readline.parse_and_bind("tab: complete")

Notes:

- Exceptions raised by the completer function are *ignored* (and generally cause
  the completion to fail).  This is a feature -- since readline sets the tty
  device in raw (or cbreak) mode, printing a traceback wouldn't work well
  without some complicated hoopla to save, reset and restore the tty state.

- The evaluation of the NAME.NAME... form may cause arbitrary application
  defined code to be executed if an object with a __getattr__ hook is found.
  Since it is the responsibility of the application (or the user) to enable this
  feature, I consider this an acceptable risk.  More complicated expressions
  (e.g. function calls or indexing operations) are *not* evaluated.

- GNU readline is also used by the built-in functions input() and
raw_input(), and thus these also benefit/suffer from the completer
features.  Clearly an interactive application can benefit by
specifying its own completer function and using raw_input() for all
its input.

- When the original stdin is not a tty device, GNU readline is never
  used, and this module (and the readline module) are silently inactive.

iˇˇˇˇNt	   Completerc           B   s8   e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sP   | r" t  | t É r" t d Ç n  | d k r: d |  _ n d |  _ | |  _ d S(   s·  Create a new completer for the command line.

        Completer([namespace]) -> completer instance.

        If unspecified, the default namespace where completions are performed
        is __main__ (technically, __main__.__dict__). Namespaces should be
        given as dictionaries.

        Completer instances should be used as the completion mechanism of
        readline via the set_completer() call:

        readline.set_completer(Completer(my_namespace).complete)
        s   namespace must be a dictionaryi   i    N(   t
   isinstancet   dictt	   TypeErrort   Nonet   use_main_nst	   namespace(   t   selfR   (    (    s!   /usr/lib/python2.7/rlcompleter.pyt   __init__,   s    	c         C   sÇ   |  j  r t j |  _ n  | d k rZ d | k rE |  j | É |  _ qZ |  j | É |  _ n  y |  j | SWn t k
 r} d SXd S(   s¬   Return the next possible completion for 'text'.

        This is called successively with state == 0, 1, 2, ... until it
        returns None.  The completion should begin with 'text'.

        i    t   .N(	   R   t   __main__t   __dict__R   t   attr_matchest   matchest   global_matchest
   IndexErrorR   (   R   t   textt   state(    (    s!   /usr/lib/python2.7/rlcompleter.pyt   completeG   s    	c         C   s    t  | d É r | d } n  | S(   Nt   __call__t   ((   t   hasattr(   R   t   valt   word(    (    s!   /usr/lib/python2.7/rlcompleter.pyt   _callable_postfix[   s    c   	      C   sÎ   d d l  } g  } d h } t | É } x> | j D]3 } | |  | k r1 | j | É | j | É q1 q1 Wx| |  j t j g D]h } x_ | j É  D]Q \ } } | |  | k ré | | k ré | j | É | j |  j	 | | É É qé qé Wq{ W| S(   s≤   Compute matches when text is a simple name.

        Return a list of all keywords, built-in functions and names currently
        defined in self.namespace that match.

        iˇˇˇˇNt   __builtins__(
   t   keywordt   lent   kwlistt   addt   appendR   t   __builtin__R   t   itemsR   (	   R   R   R   R   t   seent   nR   t   nspaceR   (    (    s!   /usr/lib/python2.7/rlcompleter.pyR   `   s    	$c         C   sV  d d l  } | j d | É } | s( g  S| j d d É \ } } y t | |  j É } Wn t k
 rj g  SXt t | É É } | j d É t	 | d É rø | j
 d É | j t | j É É n  g  } t | É }	 xt | D]l }
 |
 |	  | k rÿ y t | |
 É } Wn t k
 rqÿ n X|  j | d | |
 f É }
 | j |
 É qÿ qÿ W| j É  | S(	   sø  Compute matches when text contains a dot.

        Assuming the text is of the form NAME.NAME....[NAME], and is
        evaluable in self.namespace, it will be evaluated and its attributes
        (as revealed by dir()) are used as possible completions.  (For class
        instances, class members are also considered.)

        WARNING: this can still invoke arbitrary C code, if an object
        with a __getattr__ hook is evaluated.

        iˇˇˇˇNs   (\w+(\.\w+)*)\.(\w*)i   i   R   t	   __class__s   %s.%s(   t   ret   matcht   groupt   evalR   t	   Exceptiont   sett   dirt   discardR   R   t   updatet   get_class_membersR$   R   t   getattrR   R   t   sort(   R   R   R%   t   mt   exprt   attrt
   thisobjectt   wordsR   R"   R   R   (    (    s!   /usr/lib/python2.7/rlcompleter.pyR   v   s4    
N(   t   __name__t
   __module__R   R   R   R   R   R   (    (    (    s!   /usr/lib/python2.7/rlcompleter.pyR    +   s
   			c         C   sF   t  |  É } t |  d É rB x$ |  j D] } | t | É } q% Wn  | S(   Nt	   __bases__(   R+   R   R8   R.   (   t   klasst   rett   base(    (    s!   /usr/lib/python2.7/rlcompleter.pyR.   †   s
    (    (
   t   __doc__R   R
   t   __all__R    R.   t   readlinet   ImportErrort   set_completerR   (    (    (    s!   /usr/lib/python2.7/rlcompleter.pyt   <module>$   s   	u	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """ robotparser.py

    Copyright (C) 2000  Bastian Kleineidam

    You can choose between two licenses when using this package:
    1) GNU GPLv2
    2) PSF license for Python 2.2

    The robots.txt Exclusion Protocol is implemented as specified in
    http://www.robotstxt.org/norobots-rfc.txt

"""
import urlparse
import urllib

__all__ = ["RobotFileParser"]


class RobotFileParser:
    """ This class provides a set of methods to read, parse and answer
    questions about a single robots.txt file.

    """

    def __init__(self, url=''):
        self.entries = []
        self.default_entry = None
        self.disallow_all = False
        self.allow_all = False
        self.set_url(url)
        self.last_checked = 0

    def mtime(self):
        """Returns the time the robots.txt file was last fetched.

        This is useful for long-running web spiders that need to
        check for new robots.txt files periodically.

        """
        return self.last_checked

    def modified(self):
        """Sets the time the robots.txt file was last fetched to the
        current time.

        """
        import time
        self.last_checked = time.time()

    def set_url(self, url):
        """Sets the URL referring to a robots.txt file."""
        self.url = url
        self.host, self.path = urlparse.urlparse(url)[1:3]

    def read(self):
        """Reads the robots.txt URL and feeds it to the parser."""
        opener = URLopener()
        f = opener.open(self.url)
        lines = [line.strip() for line in f]
        f.close()
        self.errcode = opener.errcode
        if self.errcode in (401, 403):
            self.disallow_all = True
        elif self.errcode >= 400 and self.errcode < 500:
            self.allow_all = True
        elif self.errcode == 200 and lines:
            self.parse(lines)

    def _add_entry(self, entry):
        if "*" in entry.useragents:
            # the default entry is considered last
            if self.default_entry is None:
                # the first default entry wins
                self.default_entry = entry
        else:
            self.entries.append(entry)

    def parse(self, lines):
        """parse the input lines from a robots.txt file.
           We allow that a user-agent: line is not preceded by
           one or more blank lines."""
        # states:
        #   0: start state
        #   1: saw user-agent line
        #   2: saw an allow or disallow line
        state = 0
        linenumber = 0
        entry = Entry()

        self.modified()
        for line in lines:
            linenumber += 1
            if not line:
                if state == 1:
                    entry = Entry()
                    state = 0
                elif state == 2:
                    self._add_entry(entry)
                    entry = Entry()
                    state = 0
            # remove optional comment and strip line
            i = line.find('#')
            if i >= 0:
                line = line[:i]
            line = line.strip()
            if not line:
                continue
            line = line.split(':', 1)
            if len(line) == 2:
                line[0] = line[0].strip().lower()
                line[1] = urllib.unquote(line[1].strip())
                if line[0] == "user-agent":
                    if state == 2:
                        self._add_entry(entry)
                        entry = Entry()
                    entry.useragents.append(line[1])
                    state = 1
                elif line[0] == "disallow":
                    if state != 0:
                        entry.rulelines.append(RuleLine(line[1], False))
                        state = 2
                elif line[0] == "allow":
                    if state != 0:
                        entry.rulelines.append(RuleLine(line[1], True))
                        state = 2
        if state == 2:
            self._add_entry(entry)


    def can_fetch(self, useragent, url):
        """using the parsed robots.txt decide if useragent can fetch url"""
        if self.disallow_all:
            return False
        if self.allow_all:
            return True

        # Until the robots.txt file has been read or found not
        # to exist, we must assume that no url is allowable.
        # This prevents false positives when a user erroneously
        # calls can_fetch() before calling read().
        if not self.last_checked:
            return False

        # search for given user agent matches
        # the first match counts
        parsed_url = urlparse.urlparse(urllib.unquote(url))
        url = urlparse.urlunparse(('', '', parsed_url.path,
            parsed_url.params, parsed_url.query, parsed_url.fragment))
        url = urllib.quote(url)
        if not url:
            url = "/"
        for entry in self.entries:
            if entry.applies_to(useragent):
                return entry.allowance(url)
        # try the default entry last
        if self.default_entry:
            return self.default_entry.allowance(url)
        # agent not found ==> access granted
        return True


    def __str__(self):
        return ''.join([str(entry) + "\n" for entry in self.entries])


class RuleLine:
    """A rule line is a single "Allow:" (allowance==True) or "Disallow:"
       (allowance==False) followed by a path."""
    def __init__(self, path, allowance):
        if path == '' and not allowance:
            # an empty value means allow all
            allowance = True
        path = urlparse.urlunparse(urlparse.urlparse(path))
        self.path = urllib.quote(path)
        self.allowance = allowance

    def applies_to(self, filename):
        return self.path == "*" or filename.startswith(self.path)

    def __str__(self):
        return (self.allowance and "Allow" or "Disallow") + ": " + self.path


class Entry:
    """An entry has one or more user-agents and zero or more rulelines"""
    def __init__(self):
        self.useragents = []
        self.rulelines = []

    def __str__(self):
        ret = []
        for agent in self.useragents:
            ret.extend(["User-agent: ", agent, "\n"])
        for line in self.rulelines:
            ret.extend([str(line), "\n"])
        return ''.join(ret)

    def applies_to(self, useragent):
        """check if this entry applies to the specified agent"""
        # split the name token and make it lower case
        useragent = useragent.split("/")[0].lower()
        for agent in self.useragents:
            if agent == '*':
                # we have the catch-all agent
                return True
            agent = agent.lower()
            if agent in useragent:
                return True
        return False

    def allowance(self, filename):
        """Preconditions:
        - our agent applies to this entry
        - filename is URL decoded"""
        for line in self.rulelines:
            if line.applies_to(filename):
                return line.allowance
        return True

class URLopener(urllib.FancyURLopener):
    def __init__(self, *args):
        urllib.FancyURLopener.__init__(self, *args)
        self.errcode = 200

    def prompt_user_passwd(self, host, realm):
        ## If robots.txt file is accessible only with a password,
        ## we act as if the file wasn't there.
        return None, None

    def http_error_default(self, url, fp, errcode, errmsg, headers):
        self.errcode = errcode
        return urllib.FancyURLopener.http_error_default(self, url, fp, errcode,
                                                        errmsg, headers)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Û
”´[c           @   s}   d  Z  d d l Z d d l Z d g Z d d d Ñ  É  YZ d d d Ñ  É  YZ d d d Ñ  É  YZ d	 e j f d
 Ñ  É  YZ d S(   s&   robotparser.py

    Copyright (C) 2000  Bastian Kleineidam

    You can choose between two licenses when using this package:
    1) GNU GPLv2
    2) PSF license for Python 2.2

    The robots.txt Exclusion Protocol is implemented as specified in
    http://www.robotstxt.org/norobots-rfc.txt

iˇˇˇˇNt   RobotFileParserc           B   sb   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d	 Ñ  Z
 d
 Ñ  Z RS(   ss    This class provides a set of methods to read, parse and answer
    questions about a single robots.txt file.

    t    c         C   s>   g  |  _  d  |  _ t |  _ t |  _ |  j | É d |  _ d  S(   Ni    (   t   entriest   Nonet   default_entryt   Falset   disallow_allt	   allow_allt   set_urlt   last_checked(   t   selft   url(    (    s!   /usr/lib/python2.7/robotparser.pyt   __init__   s    				c         C   s   |  j  S(   s∑   Returns the time the robots.txt file was last fetched.

        This is useful for long-running web spiders that need to
        check for new robots.txt files periodically.

        (   R	   (   R
   (    (    s!   /usr/lib/python2.7/robotparser.pyt   mtime!   s    c         C   s   d d l  } | j  É  |  _ d S(   sY   Sets the time the robots.txt file was last fetched to the
        current time.

        iˇˇˇˇN(   t   timeR	   (   R
   R   (    (    s!   /usr/lib/python2.7/robotparser.pyt   modified*   s    c         C   s/   | |  _  t j | É d d !\ |  _ |  _ d S(   s,   Sets the URL referring to a robots.txt file.i   i   N(   R   t   urlparset   hostt   path(   R
   R   (    (    s!   /usr/lib/python2.7/robotparser.pyR   2   s    	c         C   sæ   t  É  } | j |  j É } g  | D] } | j É  ^ q" } | j É  | j |  _ |  j d k rk t |  _ nO |  j d k rï |  j d k  rï t |  _ n% |  j d k r∫ | r∫ |  j	 | É n  d S(   s4   Reads the robots.txt URL and feeds it to the parser.ië  iì  iê  iÙ  i»   N(   ië  iì  (
   t	   URLopenert   openR   t   stript   closet   errcodet   TrueR   R   t   parse(   R
   t   openert   ft   linet   lines(    (    s!   /usr/lib/python2.7/robotparser.pyt   read7   s    	
c         C   sA   d | j  k r- |  j d  k r= | |  _ q= n |  j j | É d  S(   Nt   *(   t
   useragentsR   R   R   t   append(   R
   t   entry(    (    s!   /usr/lib/python2.7/robotparser.pyt
   _add_entryE   s    c         C   s&  d } d } t  É  } |  j É  x‰| D]‹} | d 7} | sà | d k rZ t  É  } d } qà | d k rà |  j | É t  É  } d } qà n  | j d É } | d k r∞ | |  } n  | j É  } | s» q& n  | j d d É } t | É d k r& | d j É  j É  | d <t j	 | d j É  É | d <| d d k ru| d k rX|  j | É t  É  } n  | j
 j | d É d } q| d d k r∫| d k rˇ| j j t | d t É É d } qˇq| d d k r| d k rˇ| j j t | d t É É d } qˇqq& q& W| d k r"|  j | É n  d	 S(
   sê   parse the input lines from a robots.txt file.
           We allow that a user-agent: line is not preceded by
           one or more blank lines.i    i   i   t   #t   :s
   user-agentt   disallowt   allowN(   t   EntryR   R#   t   findR   t   splitt   lent   lowert   urllibt   unquoteR    R!   t	   rulelinest   RuleLineR   R   (   R
   R   t   statet
   linenumberR"   R   t   i(    (    s!   /usr/lib/python2.7/robotparser.pyR   N   sP    	

				c         C   s◊   |  j  r t S|  j r t S|  j s' t St j t j | É É } t j d d | j	 | j
 | j | j f É } t j | É } | sä d } n  x- |  j D]" } | j | É rî | j | É Sqî W|  j r” |  j j | É St S(   s=   using the parsed robots.txt decide if useragent can fetch urlR   t   /(   R   R   R   R   R	   R   R-   R.   t
   urlunparseR   t   paramst   queryt   fragmentt   quoteR   t
   applies_tot	   allowanceR   (   R
   t	   useragentR   t
   parsed_urlR"   (    (    s!   /usr/lib/python2.7/robotparser.pyt	   can_fetchÇ   s$    					c         C   s-   d j  g  |  j D] } t | É d ^ q É S(   NR   s   
(   t   joinR   t   str(   R
   R"   (    (    s!   /usr/lib/python2.7/robotparser.pyt   __str__¢   s    (   t   __name__t
   __module__t   __doc__R   R   R   R   R   R#   R   R>   RA   (    (    (    s!   /usr/lib/python2.7/robotparser.pyR       s   								4	 R0   c           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   so   A rule line is a single "Allow:" (allowance==True) or "Disallow:"
       (allowance==False) followed by a path.c         C   sS   | d k r | r t  } n  t j t j | É É } t j | É |  _ | |  _ d  S(   NR   (   R   R   R5   R-   R9   R   R;   (   R
   R   R;   (    (    s!   /usr/lib/python2.7/robotparser.pyR   ©   s
    	c         C   s   |  j  d k p | j |  j  É S(   NR   (   R   t
   startswith(   R
   t   filename(    (    s!   /usr/lib/python2.7/robotparser.pyR:   ±   s    c         C   s   |  j  r d p d d |  j S(   Nt   Allowt   Disallows   : (   R;   R   (   R
   (    (    s!   /usr/lib/python2.7/robotparser.pyRA   ¥   s    (   RB   RC   RD   R   R:   RA   (    (    (    s!   /usr/lib/python2.7/robotparser.pyR0   ¶   s   		R(   c           B   s2   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s?   An entry has one or more user-agents and zero or more rulelinesc         C   s   g  |  _  g  |  _ d  S(   N(   R    R/   (   R
   (    (    s!   /usr/lib/python2.7/robotparser.pyR   ∫   s    	c         C   sj   g  } x' |  j  D] } | j d | d g É q Wx* |  j D] } | j t | É d g É q: Wd j | É S(   Ns   User-agent: s   
R   (   R    t   extendR/   R@   R?   (   R
   t   rett   agentR   (    (    s!   /usr/lib/python2.7/robotparser.pyRA   æ   s    c         C   s]   | j  d É d j É  } x= |  j D]2 } | d k r9 t S| j É  } | | k r# t Sq# Wt S(   s2   check if this entry applies to the specified agentR4   i    R   (   R*   R,   R    R   R   (   R
   R<   RK   (    (    s!   /usr/lib/python2.7/robotparser.pyR:   ∆   s    c         C   s.   x' |  j  D] } | j | É r
 | j Sq
 Wt S(   sZ   Preconditions:
        - our agent applies to this entry
        - filename is URL decoded(   R/   R:   R;   R   (   R
   RF   R   (    (    s!   /usr/lib/python2.7/robotparser.pyR;   ”   s    (   RB   RC   RD   R   RA   R:   R;   (    (    (    s!   /usr/lib/python2.7/robotparser.pyR(   ∏   s
   			R   c           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         G   s    t  j j |  | å d |  _ d  S(   Ni»   (   R-   t   FancyURLopenerR   R   (   R
   t   args(    (    s!   /usr/lib/python2.7/robotparser.pyR   ›   s    c         C   s   d S(   N(   NN(   R   (   R
   R   t   realm(    (    s!   /usr/lib/python2.7/robotparser.pyt   prompt_user_passwd·   s    c         C   s(   | |  _  t j j |  | | | | | É S(   N(   R   R-   RL   t   http_error_default(   R
   R   t   fpR   t   errmsgt   headers(    (    s!   /usr/lib/python2.7/robotparser.pyRP   Ê   s    	(   RB   RC   R   RO   RP   (    (    (    s!   /usr/lib/python2.7/robotparser.pyR   ‹   s   		(    (    (    (	   RD   R   R-   t   __all__R    R0   R(   RL   R   (    (    (    s!   /usr/lib/python2.7/robotparser.pyt   <module>   s   	ì$                                                                                                                                                                                                                                                                                        """runpy.py - locating and running Python code using the module namespace

Provides support for locating and running Python scripts using the Python
module namespace instead of the native filesystem.

This allows Python code to play nicely with non-filesystem based PEP 302
importers when locating support scripts as well as when importing modules.
"""
# Written by Nick Coghlan <ncoghlan at gmail.com>
#    to implement PEP 338 (Executing Modules as Scripts)

import sys
import imp
from pkgutil import read_code
try:
    from imp import get_loader
except ImportError:
    from pkgutil import get_loader

__all__ = [
    "run_module", "run_path",
]

class _TempModule(object):
    """Temporarily replace a module in sys.modules with an empty namespace"""
    def __init__(self, mod_name):
        self.mod_name = mod_name
        self.module = imp.new_module(mod_name)
        self._saved_module = []

    def __enter__(self):
        mod_name = self.mod_name
        try:
            self._saved_module.append(sys.modules[mod_name])
        except KeyError:
            pass
        sys.modules[mod_name] = self.module
        return self

    def __exit__(self, *args):
        if self._saved_module:
            sys.modules[self.mod_name] = self._saved_module[0]
        else:
            del sys.modules[self.mod_name]
        self._saved_module = []

class _ModifiedArgv0(object):
    def __init__(self, value):
        self.value = value
        self._saved_value = self._sentinel = object()

    def __enter__(self):
        if self._saved_value is not self._sentinel:
            raise RuntimeError("Already preserving saved value")
        self._saved_value = sys.argv[0]
        sys.argv[0] = self.value

    def __exit__(self, *args):
        self.value = self._sentinel
        sys.argv[0] = self._saved_value

def _run_code(code, run_globals, init_globals=None,
              mod_name=None, mod_fname=None,
              mod_loader=None, pkg_name=None):
    """Helper to run code in nominated namespace"""
    if init_globals is not None:
        run_globals.update(init_globals)
    run_globals.update(__name__ = mod_name,
                       __file__ = mod_fname,
                       __loader__ = mod_loader,
                       __package__ = pkg_name)
    exec code in run_globals
    return run_globals

def _run_module_code(code, init_globals=None,
                    mod_name=None, mod_fname=None,
                    mod_loader=None, pkg_name=None):
    """Helper to run code in new namespace with sys modified"""
    with _TempModule(mod_name) as temp_module, _ModifiedArgv0(mod_fname):
        mod_globals = temp_module.module.__dict__
        _run_code(code, mod_globals, init_globals,
                  mod_name, mod_fname, mod_loader, pkg_name)
    # Copy the globals of the temporary module, as they
    # may be cleared when the temporary module goes away
    return mod_globals.copy()


# This helper is needed due to a missing component in the PEP 302
# loader protocol (specifically, "get_filename" is non-standard)
# Since we can't introduce new features in maintenance releases,
# support was added to zipimporter under the name '_get_filename'
def _get_filename(loader, mod_name):
    for attr in ("get_filename", "_get_filename"):
        meth = getattr(loader, attr, None)
        if meth is not None:
            return meth(mod_name)
    return None

# Helper to get the loader, code and filename for a module
def _get_module_details(mod_name, error=ImportError):
    try:
        loader = get_loader(mod_name)
        if loader is None:
            raise error("No module named %s" % mod_name)
        ispkg = loader.is_package(mod_name)
    except ImportError as e:
        raise error(format(e))
    if ispkg:
        if mod_name == "__main__" or mod_name.endswith(".__main__"):
            raise error("Cannot use package as __main__ module")
        __import__(mod_name)  # Do not catch exceptions initializing package
        try:
            pkg_main_name = mod_name + ".__main__"
            return _get_module_details(pkg_main_name)
        except ImportError, e:
            raise error(("%s; %r is a package and cannot " +
                               "be directly executed") %(e, mod_name))
    try:
        code = loader.get_code(mod_name)
    except ImportError as e:
        raise error(format(e))
    if code is None:
        raise error("No code object available for %s" % mod_name)
    filename = _get_filename(loader, mod_name)
    return mod_name, loader, code, filename


def _get_main_module_details(error=ImportError):
    # Helper that gives a nicer error message when attempting to
    # execute a zipfile or directory by invoking __main__.py
    main_name = "__main__"
    try:
        return _get_module_details(main_name)
    except ImportError as exc:
        if main_name in str(exc):
            raise error("can't find %r module in %r" %
                              (main_name, sys.path[0]))
        raise

class _Error(Exception):
    """Error that _run_module_as_main() should report without a traceback"""

# This function is the actual implementation of the -m switch and direct
# execution of zipfiles and directories and is deliberately kept private.
# This avoids a repeat of the situation where run_module() no longer met the
# needs of mainmodule.c, but couldn't be changed because it was public
def _run_module_as_main(mod_name, alter_argv=True):
    """Runs the designated module in the __main__ namespace

       Note that the executed module will have full access to the
       __main__ namespace. If this is not desirable, the run_module()
       function should be used to run the module code in a fresh namespace.

       At the very least, these variables in __main__ will be overwritten:
           __name__
           __file__
           __loader__
           __package__
    """
    try:
        if alter_argv or mod_name != "__main__": # i.e. -m switch
            mod_name, loader, code, fname = _get_module_details(
                mod_name, _Error)
        else:          # i.e. directory or zipfile execution
            mod_name, loader, code, fname = _get_main_module_details(_Error)
    except _Error as exc:
        msg = "%s: %s" % (sys.executable, exc)
        sys.exit(msg)
    pkg_name = mod_name.rpartition('.')[0]
    main_globals = sys.modules["__main__"].__dict__
    if alter_argv:
        sys.argv[0] = fname
    return _run_code(code, main_globals, None,
                     "__main__", fname, loader, pkg_name)

def run_module(mod_name, init_globals=None,
               run_name=None, alter_sys=False):
    """Execute a module's code without importing it

       Returns the resulting top level namespace dictionary
    """
    mod_name, loader, code, fname = _get_module_details(mod_name)
    if run_name is None:
        run_name = mod_name
    pkg_name = mod_name.rpartition('.')[0]
    if alter_sys:
        return _run_module_code(code, init_globals, run_name,
                                fname, loader, pkg_name)
    else:
        # Leave the sys module alone
        return _run_code(code, {}, init_globals, run_name,
                         fname, loader, pkg_name)


# XXX (ncoghlan): Perhaps expose the C API function
# as imp.get_importer instead of reimplementing it in Python?
def _get_importer(path_name):
    """Python version of PyImport_GetImporter C API function"""
    cache = sys.path_importer_cache
    try:
        importer = cache[path_name]
    except KeyError:
        # Not yet cached. Flag as using the
        # standard machinery until we finish
        # checking the hooks
        cache[path_name] = None
        for hook in sys.path_hooks:
            try:
                importer = hook(path_name)
                break
            except ImportError:
                pass
        else:
            # The following check looks a bit odd. The trick is that
            # NullImporter raises ImportError if the supplied path is a
            # *valid* directory entry (and hence able to be handled
            # by the standard import machinery)
            try:
                importer = imp.NullImporter(path_name)
            except ImportError:
                return None
        cache[path_name] = importer
    return importer

def _get_code_from_file(fname):
    # Check for a compiled file first
    with open(fname, "rb") as f:
        code = read_code(f)
    if code is None:
        # That didn't work, so try it as normal source code
        with open(fname, "rU") as f:
            code = compile(f.read(), fname, 'exec')
    return code

def run_path(path_name, init_globals=None, run_name=None):
    """Execute code located at the specified filesystem location

       Returns the resulting top level namespace dictionary

       The file path may refer directly to a Python script (i.e.
       one that could be directly executed with execfile) or else
       it may refer to a zipfile or directory containing a top
       level __main__.py script.
    """
    if run_name is None:
        run_name = "<run_path>"
    importer = _get_importer(path_name)
    if isinstance(importer, imp.NullImporter):
        # Not a valid sys.path entry, so run the code directly
        # execfile() doesn't help as we want to allow compiled files
        code = _get_code_from_file(path_name)
        return _run_module_code(code, init_globals, run_name, path_name)
    else:
        # Importer is defined for path, so add it to
        # the start of sys.path
        sys.path.insert(0, path_name)
        try:
            # Here's where things are a little different from the run_module
            # case. There, we only had to replace the module in sys while the
            # code was running and doing so was somewhat optional. Here, we
            # have no choice and we have to remove it even while we read the
            # code. If we don't do this, a __loader__ attribute in the
            # existing __main__ module may prevent location of the new module.
            main_name = "__main__"
            saved_main = sys.modules[main_name]
            del sys.modules[main_name]
            try:
                mod_name, loader, code, fname = _get_main_module_details()
            finally:
                sys.modules[main_name] = saved_main
            pkg_name = ""
            with _TempModule(run_name) as temp_module, \
                 _ModifiedArgv0(path_name):
                mod_globals = temp_module.module.__dict__
                return _run_code(code, mod_globals, init_globals,
                                    run_name, fname, loader, pkg_name).copy()
        finally:
            try:
                sys.path.remove(path_name)
            except ValueError:
                pass


if __name__ == "__main__":
    # Run the module specified as the next command line argument
    if len(sys.argv) < 2:
        print >> sys.stderr, "No module specified for execution"
    else:
        del sys.argv[0] # Make the requested module sys.argv[0]
        _run_module_as_main(sys.argv[0])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   só  d  Z  d d l Z d d l Z d d l m Z y d d l m Z Wn! e k
 re d d l m Z n Xd d g Z d e f d Ñ  É  YZ	 d	 e f d
 Ñ  É  YZ
 d d d d d d Ñ Z d d d d d d Ñ Z d Ñ  Z e d Ñ Z e d Ñ Z d e f d Ñ  É  YZ e d Ñ Z d d e d Ñ Z d Ñ  Z d Ñ  Z d d d Ñ Z e d k rìe e j É d k  rue j d IJqìe j d =e e j d É n  d S(   sZ  runpy.py - locating and running Python code using the module namespace

Provides support for locating and running Python scripts using the Python
module namespace instead of the native filesystem.

This allows Python code to play nicely with non-filesystem based PEP 302
importers when locating support scripts as well as when importing modules.
iˇˇˇˇN(   t	   read_code(   t
   get_loadert
   run_modulet   run_patht   _TempModulec           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sC   Temporarily replace a module in sys.modules with an empty namespacec         C   s(   | |  _  t j | É |  _ g  |  _ d  S(   N(   t   mod_namet   impt
   new_modulet   modulet   _saved_module(   t   selfR   (    (    s   /usr/lib/python2.7/runpy.pyt   __init__   s    	c         C   sL   |  j  } y |  j j t j | É Wn t k
 r7 n X|  j t j | <|  S(   N(   R   R	   t   appendt   syst   modulest   KeyErrorR   (   R
   R   (    (    s   /usr/lib/python2.7/runpy.pyt	   __enter__   s    	c         G   s=   |  j  r# |  j  d t j |  j <n t j |  j =g  |  _  d  S(   Ni    (   R	   R   R   R   (   R
   t   args(    (    s   /usr/lib/python2.7/runpy.pyt   __exit__(   s    	(   t   __name__t
   __module__t   __doc__R   R   R   (    (    (    s   /usr/lib/python2.7/runpy.pyR      s   			t   _ModifiedArgv0c           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s    | |  _  t É  |  _ |  _ d  S(   N(   t   valuet   objectt   _saved_valuet	   _sentinel(   R
   R   (    (    s   /usr/lib/python2.7/runpy.pyR   0   s    	c         C   sE   |  j  |  j k	 r! t d É Ç n  t j d |  _  |  j t j d <d  S(   Ns   Already preserving saved valuei    (   R   R   t   RuntimeErrorR   t   argvR   (   R
   (    (    s   /usr/lib/python2.7/runpy.pyR   4   s    c         G   s    |  j  |  _ |  j t j d <d  S(   Ni    (   R   R   R   R   R   (   R
   R   (    (    s   /usr/lib/python2.7/runpy.pyR   :   s    (   R   R   R   R   R   (    (    (    s   /usr/lib/python2.7/runpy.pyR   /   s   		c      	   B   sJ   | d k	 r | j | É n  | j d | d | d | d | É |  | U| S(   s)   Helper to run code in nominated namespaceR   t   __file__t
   __loader__t   __package__N(   t   Nonet   update(   t   codet   run_globalst   init_globalsR   t	   mod_fnamet
   mod_loadert   pkg_name(    (    s   /usr/lib/python2.7/runpy.pyt	   _run_code>   s    c         C   sZ   t  | É èB } t | É è- | j j } t |  | | | | | | É Wd QXWd QX| j É  S(   s5   Helper to run code in new namespace with sys modifiedN(   R   R   R   t   __dict__R(   t   copy(   R"   R$   R   R%   R&   R'   t   temp_modulet   mod_globals(    (    s   /usr/lib/python2.7/runpy.pyt   _run_module_codeK   s     c         C   s=   x6 d D]. } t  |  | d  É } | d  k	 r | | É Sq Wd  S(   Nt   get_filenamet   _get_filename(   R.   R/   (   t   getattrR    (   t   loaderR   t   attrt   meth(    (    s   /usr/lib/python2.7/runpy.pyR/   \   s
    c         C   sd  y> t  |  É } | d  k r. | d |  É Ç n  | j |  É } Wn% t k
 re } | t | É É Ç n X| rÎ |  d k sá |  j d É rñ | d É Ç n  t |  É y |  d } t | É SWqÎ t k
 rÁ } | d d | |  f É Ç qÎ Xn  y | j |  É } Wn% t k
 r%} | t | É É Ç n X| d  k rE| d |  É Ç n  t	 | |  É } |  | | | f S(   Ns   No module named %st   __main__s	   .__main__s%   Cannot use package as __main__ modules   %s; %r is a package and cannot s   be directly executeds   No code object available for %s(
   R   R    t
   is_packaget   ImportErrort   formatt   endswitht
   __import__t   _get_module_detailst   get_codeR/   (   R   t   errorR1   t   ispkgt   et   pkg_main_nameR"   t   filename(    (    s   /usr/lib/python2.7/runpy.pyR:   d   s2    

c         C   sc   d } y t  | É SWnH t k
 r^ } | t | É k rX |  d | t j d f É Ç n  Ç  n Xd  S(   NR4   s   can't find %r module in %ri    (   R:   R6   t   strR   t   path(   R<   t	   main_namet   exc(    (    s   /usr/lib/python2.7/runpy.pyt   _get_main_module_detailsÄ   s    t   _Errorc           B   s   e  Z d  Z RS(   sB   Error that _run_module_as_main() should report without a traceback(   R   R   R   (    (    (    s   /usr/lib/python2.7/runpy.pyRF   å   s   c   	      C   s◊   yL | s |  d k r3 t  |  t É \ }  } } } n t t É \ }  } } } Wn3 t k
 rÅ } d t j | f } t j | É n X|  j d É d } t j d j } | rª | t j	 d <n  t
 | | d d | | | É S(   sØ  Runs the designated module in the __main__ namespace

       Note that the executed module will have full access to the
       __main__ namespace. If this is not desirable, the run_module()
       function should be used to run the module code in a fresh namespace.

       At the very least, these variables in __main__ will be overwritten:
           __name__
           __file__
           __loader__
           __package__
    R4   s   %s: %st   .i    N(   R:   RF   RE   R   t
   executablet   exitt
   rpartitionR   R)   R   R(   R    (	   R   t
   alter_argvR1   R"   t   fnameRD   t   msgR'   t   main_globals(    (    s   /usr/lib/python2.7/runpy.pyt   _run_module_as_mainì   s    c         C   s   t  |  É \ }  } } } | d k r- |  } n  |  j d É d } | r_ t | | | | | | É St | i  | | | | | É Sd S(   sn   Execute a module's code without importing it

       Returns the resulting top level namespace dictionary
    RG   i    N(   R:   R    RJ   R-   R(   (   R   R$   t   run_namet	   alter_sysR1   R"   RL   R'   (    (    s   /usr/lib/python2.7/runpy.pyR   ∞   s    	c         C   s§   t  j } y | |  } WnÜ t k
 rü d | |  <x^ t  j D]+ } y | |  É } PWq; t k
 re q; Xq; Wy t j |  É } Wn t k
 rë d SX| | |  <n X| S(   s5   Python version of PyImport_GetImporter C API functionN(   R   t   path_importer_cacheR   R    t
   path_hooksR6   R   t   NullImporter(   t	   path_namet   cachet   importert   hook(    (    s   /usr/lib/python2.7/runpy.pyt   _get_importer≈   s"    	
c      	   C   sg   t  |  d É è } t | É } Wd  QX| d  k rc t  |  d É è } t | j É  |  d É } Wd  QXn  | S(   Nt   rbt   rUt   exec(   t   openR    R    t   compilet   read(   RL   t   fR"   (    (    s   /usr/lib/python2.7/runpy.pyt   _get_code_from_file·   s    !c         C   s<  | d k r d } n  t |  É } t | t j É rR t |  É } t | | | |  É St j j	 d |  É zß d } t j
 | } t j
 | =z t É  \ } } } }	 Wd | t j
 | <Xd }
 t | É èH } t |  É è3 | j j } t | | | | |	 | |
 É j É  SWd QXWd QXWd y t j j |  É Wn t k
 r6n XXd S(   s_  Execute code located at the specified filesystem location

       Returns the resulting top level namespace dictionary

       The file path may refer directly to a Python script (i.e.
       one that could be directly executed with execfile) or else
       it may refer to a zipfile or directory containing a top
       level __main__.py script.
    s
   <run_path>i    R4   Nt    (   R    RY   t
   isinstanceR   RT   Ra   R-   R   RB   t   insertR   RE   R   R   R   R)   R(   R*   t   removet
   ValueError(   RU   R$   RP   RW   R"   RC   t
   saved_mainR   R1   RL   R'   R+   R,   (    (    s   /usr/lib/python2.7/runpy.pyR   Î   s0    
	
&R4   i   s!   No module specified for executioni    (   R   R   R   t   pkgutilR    R   R6   t   __all__R   R   R   R    R(   R-   R/   R:   RE   t	   ExceptionRF   t   TrueRO   t   FalseR   RY   Ra   R   R   t   lenR   t   stderr(    (    (    s   /usr/lib/python2.7/runpy.pyt   <module>   s>   			
1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     """A generally useful event scheduler class.

Each instance of this class manages its own queue.
No multi-threading is implied; you are supposed to hack that
yourself, or use a single instance per application.

Each instance is parametrized with two functions, one that is
supposed to return the current time, one that is supposed to
implement a delay.  You can implement real-time scheduling by
substituting time and sleep from built-in module time, or you can
implement simulated time by writing your own functions.  This can
also be used to integrate scheduling with STDWIN events; the delay
function is allowed to modify the queue.  Time can be expressed as
integers or floating point numbers, as long as it is consistent.

Events are specified by tuples (time, priority, action, argument).
As in UNIX, lower priority numbers mean higher priority; in this
way the queue can be maintained as a priority queue.  Execution of the
event means calling the action function, passing it the argument
sequence in "argument" (remember that in Python, multiple function
arguments are be packed in a sequence).
The action function may be an instance method so it
has another way to reference private data (besides global variables).
"""

# XXX The timefunc and delayfunc should have been defined as methods
# XXX so you can define new kinds of schedulers using subclassing
# XXX instead of having to define a module or class just to hold
# XXX the global state of your particular time and delay functions.

import heapq
from collections import namedtuple

__all__ = ["scheduler"]

Event = namedtuple('Event', 'time, priority, action, argument')

class scheduler:
    def __init__(self, timefunc, delayfunc):
        """Initialize a new instance, passing the time and delay
        functions"""
        self._queue = []
        self.timefunc = timefunc
        self.delayfunc = delayfunc

    def enterabs(self, time, priority, action, argument):
        """Enter a new event in the queue at an absolute time.

        Returns an ID for the event which can be used to remove it,
        if necessary.

        """
        event = Event(time, priority, action, argument)
        heapq.heappush(self._queue, event)
        return event # The ID

    def enter(self, delay, priority, action, argument):
        """A variant that specifies the time as a relative time.

        This is actually the more commonly used interface.

        """
        time = self.timefunc() + delay
        return self.enterabs(time, priority, action, argument)

    def cancel(self, event):
        """Remove an event from the queue.

        This must be presented the ID as returned by enter().
        If the event is not in the queue, this raises ValueError.

        """
        self._queue.remove(event)
        heapq.heapify(self._queue)

    def empty(self):
        """Check whether the queue is empty."""
        return not self._queue

    def run(self):
        """Execute events until the queue is empty.

        When there is a positive delay until the first event, the
        delay function is called and the event is left in the queue;
        otherwise, the event is removed from the queue and executed
        (its action function is called, passing it the argument).  If
        the delay function returns prematurely, it is simply
        restarted.

        It is legal for both the delay function and the action
        function to modify the queue or to raise an exception;
        exceptions are not caught but the scheduler's state remains
        well-defined so run() may be called again.

        A questionable hack is added to allow other threads to run:
        just after an event is executed, a delay of 0 is executed, to
        avoid monopolizing the CPU when other threads are also
        runnable.

        """
        # localize variable access to minimize overhead
        # and to improve thread safety
        q = self._queue
        delayfunc = self.delayfunc
        timefunc = self.timefunc
        pop = heapq.heappop
        while q:
            time, priority, action, argument = checked_event = q[0]
            now = timefunc()
            if now < time:
                delayfunc(time - now)
            else:
                event = pop(q)
                # Verify that the event was not removed or altered
                # by another thread after we last looked at q[0].
                if event is checked_event:
                    action(*argument)
                    delayfunc(0)   # Let other threads run
                else:
                    heapq.heappush(q, event)

    @property
    def queue(self):
        """An ordered list of upcoming events.

        Events are named tuples with fields for:
            time, priority, action, arguments

        """
        # Use heapq to sort the queue rather than using 'sorted(self._queue)'.
        # With heapq, two events scheduled at the same time will show in
        # the actual order they would be retrieved.
        events = self._queue[:]
        return map(heapq.heappop, [events]*len(events))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Û
”´[c           @   sQ   d  Z  d d l Z d d l m Z d g Z e d d É Z d d d Ñ  É  YZ d S(	   s∆  A generally useful event scheduler class.

Each instance of this class manages its own queue.
No multi-threading is implied; you are supposed to hack that
yourself, or use a single instance per application.

Each instance is parametrized with two functions, one that is
supposed to return the current time, one that is supposed to
implement a delay.  You can implement real-time scheduling by
substituting time and sleep from built-in module time, or you can
implement simulated time by writing your own functions.  This can
also be used to integrate scheduling with STDWIN events; the delay
function is allowed to modify the queue.  Time can be expressed as
integers or floating point numbers, as long as it is consistent.

Events are specified by tuples (time, priority, action, argument).
As in UNIX, lower priority numbers mean higher priority; in this
way the queue can be maintained as a priority queue.  Execution of the
event means calling the action function, passing it the argument
sequence in "argument" (remember that in Python, multiple function
arguments are be packed in a sequence).
The action function may be an instance method so it
has another way to reference private data (besides global variables).
iˇˇˇˇN(   t
   namedtuplet	   schedulert   Events    time, priority, action, argumentc           B   sM   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z	 RS(   c         C   s   g  |  _  | |  _ | |  _ d S(   sG   Initialize a new instance, passing the time and delay
        functionsN(   t   _queuet   timefunct	   delayfunc(   t   selfR   R   (    (    s   /usr/lib/python2.7/sched.pyt   __init__'   s    		c         C   s,   t  | | | | É } t j |  j | É | S(   sò   Enter a new event in the queue at an absolute time.

        Returns an ID for the event which can be used to remove it,
        if necessary.

        (   R   t   heapqt   heappushR   (   R   t   timet   priorityt   actiont   argumentt   event(    (    s   /usr/lib/python2.7/sched.pyt   enterabs.   s    c         C   s&   |  j  É  | } |  j | | | | É S(   s{   A variant that specifies the time as a relative time.

        This is actually the more commonly used interface.

        (   R   R   (   R   t   delayR   R   R   R
   (    (    s   /usr/lib/python2.7/sched.pyt   enter9   s    c         C   s$   |  j  j | É t j |  j  É d S(   s™   Remove an event from the queue.

        This must be presented the ID as returned by enter().
        If the event is not in the queue, this raises ValueError.

        N(   R   t   removeR   t   heapify(   R   R   (    (    s   /usr/lib/python2.7/sched.pyt   cancelB   s    c         C   s   |  j  S(   s!   Check whether the queue is empty.(   R   (   R   (    (    s   /usr/lib/python2.7/sched.pyt   emptyL   s    c         C   s¥   |  j  } |  j } |  j } t j } xâ | rØ | d \ } } } } }	 | É  }
 |
 | k  rm | | |
 É q' | | É } | |	 k rú | | å  | d É q' t j | | É q' Wd S(   sf  Execute events until the queue is empty.

        When there is a positive delay until the first event, the
        delay function is called and the event is left in the queue;
        otherwise, the event is removed from the queue and executed
        (its action function is called, passing it the argument).  If
        the delay function returns prematurely, it is simply
        restarted.

        It is legal for both the delay function and the action
        function to modify the queue or to raise an exception;
        exceptions are not caught but the scheduler's state remains
        well-defined so run() may be called again.

        A questionable hack is added to allow other threads to run:
        just after an event is executed, a delay of 0 is executed, to
        avoid monopolizing the CPU when other threads are also
        runnable.

        i    N(   R   R   R   R   t   heappopR	   (   R   t   qR   R   t   popR
   R   R   R   t   checked_eventt   nowR   (    (    s   /usr/lib/python2.7/sched.pyt   runP   s    						
c         C   s'   |  j  } t t j | g t | É É S(   sç   An ordered list of upcoming events.

        Events are named tuples with fields for:
            time, priority, action, arguments

        (   R   t   mapR   R   t   len(   R   t   events(    (    s   /usr/lib/python2.7/sched.pyt   queuez   s    
(
   t   __name__t
   __module__R   R   R   R   R   R   t   propertyR   (    (    (    s   /usr/lib/python2.7/sched.pyR   &   s   					
		*(    (   t   __doc__R   t   collectionsR    t   __all__R   R   (    (    (    s   /usr/lib/python2.7/sched.pyt   <module>   s
   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """Classes to represent arbitrary sets (including sets of sets).

This module implements sets using dictionaries whose values are
ignored.  The usual operations (union, intersection, deletion, etc.)
are provided as both methods and operators.

Important: sets are not sequences!  While they support 'x in s',
'len(s)', and 'for x in s', none of those operations are unique for
sequences; for example, mappings support all three as well.  The
characteristic operation for sequences is subscripting with small
integers: s[i], for i in range(len(s)).  Sets don't support
subscripting at all.  Also, sequences allow multiple occurrences and
their elements have a definite order; sets on the other hand don't
record multiple occurrences and don't remember the order of element
insertion (which is why they don't support s[i]).

The following classes are provided:

BaseSet -- All the operations common to both mutable and immutable
    sets. This is an abstract class, not meant to be directly
    instantiated.

Set -- Mutable sets, subclass of BaseSet; not hashable.

ImmutableSet -- Immutable sets, subclass of BaseSet; hashable.
    An iterable argument is mandatory to create an ImmutableSet.

_TemporarilyImmutableSet -- A wrapper around a Set, hashable,
    giving the same hash value as the immutable set equivalent
    would have.  Do not use this class directly.

Only hashable objects can be added to a Set. In particular, you cannot
really add a Set as an element to another Set; if you try, what is
actually added is an ImmutableSet built from it (it compares equal to
the one you tried adding).

When you ask if `x in y' where x is a Set and y is a Set or
ImmutableSet, x is wrapped into a _TemporarilyImmutableSet z, and
what's tested is actually `z in y'.

"""

# Code history:
#
# - Greg V. Wilson wrote the first version, using a different approach
#   to the mutable/immutable problem, and inheriting from dict.
#
# - Alex Martelli modified Greg's version to implement the current
#   Set/ImmutableSet approach, and make the data an attribute.
#
# - Guido van Rossum rewrote much of the code, made some API changes,
#   and cleaned up the docstrings.
#
# - Raymond Hettinger added a number of speedups and other
#   improvements.

from itertools import ifilter, ifilterfalse

__all__ = ['BaseSet', 'Set', 'ImmutableSet']

import warnings
warnings.warn("the sets module is deprecated", DeprecationWarning,
                stacklevel=2)

class BaseSet(object):
    """Common base class for mutable and immutable sets."""

    __slots__ = ['_data']

    # Constructor

    def __init__(self):
        """This is an abstract class."""
        # Don't call this from a concrete subclass!
        if self.__class__ is BaseSet:
            raise TypeError, ("BaseSet is an abstract class.  "
                              "Use Set or ImmutableSet.")

    # Standard protocols: __len__, __repr__, __str__, __iter__

    def __len__(self):
        """Return the number of elements of a set."""
        return len(self._data)

    def __repr__(self):
        """Return string representation of a set.

        This looks like 'Set([<list of elements>])'.
        """
        return self._repr()

    # __str__ is the same as __repr__
    __str__ = __repr__

    def _repr(self, sorted=False):
        elements = self._data.keys()
        if sorted:
            elements.sort()
        return '%s(%r)' % (self.__class__.__name__, elements)

    def __iter__(self):
        """Return an iterator over the elements or a set.

        This is the keys iterator for the underlying dict.
        """
        return self._data.iterkeys()

    # Three-way comparison is not supported.  However, because __eq__ is
    # tried before __cmp__, if Set x == Set y, x.__eq__(y) returns True and
    # then cmp(x, y) returns 0 (Python doesn't actually call __cmp__ in this
    # case).

    def __cmp__(self, other):
        raise TypeError, "can't compare sets using cmp()"

    # Equality comparisons using the underlying dicts.  Mixed-type comparisons
    # are allowed here, where Set == z for non-Set z always returns False,
    # and Set != z always True.  This allows expressions like "x in y" to
    # give the expected result when y is a sequence of mixed types, not
    # raising a pointless TypeError just because y contains a Set, or x is
    # a Set and y contain's a non-set ("in" invokes only __eq__).
    # Subtle:  it would be nicer if __eq__ and __ne__ could return
    # NotImplemented instead of True or False.  Then the other comparand
    # would get a chance to determine the result, and if the other comparand
    # also returned NotImplemented then it would fall back to object address
    # comparison (which would always return False for __eq__ and always
    # True for __ne__).  However, that doesn't work, because this type
    # *also* implements __cmp__:  if, e.g., __eq__ returns NotImplemented,
    # Python tries __cmp__ next, and the __cmp__ here then raises TypeError.

    def __eq__(self, other):
        if isinstance(other, BaseSet):
            return self._data == other._data
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, BaseSet):
            return self._data != other._data
        else:
            return True

    # Copying operations

    def copy(self):
        """Return a shallow copy of a set."""
        result = self.__class__()
        result._data.update(self._data)
        return result

    __copy__ = copy # For the copy module

    def __deepcopy__(self, memo):
        """Return a deep copy of a set; used by copy module."""
        # This pre-creates the result and inserts it in the memo
        # early, in case the deep copy recurses into another reference
        # to this same set.  A set can't be an element of itself, but
        # it can certainly contain an object that has a reference to
        # itself.
        from copy import deepcopy
        result = self.__class__()
        memo[id(self)] = result
        data = result._data
        value = True
        for elt in self:
            data[deepcopy(elt, memo)] = value
        return result

    # Standard set operations: union, intersection, both differences.
    # Each has an operator version (e.g. __or__, invoked with |) and a
    # method version (e.g. union).
    # Subtle:  Each pair requires distinct code so that the outcome is
    # correct when the type of other isn't suitable.  For example, if
    # we did "union = __or__" instead, then Set().union(3) would return
    # NotImplemented instead of raising TypeError (albeit that *why* it
    # raises TypeError as-is is also a bit subtle).

    def __or__(self, other):
        """Return the union of two sets as a new set.

        (I.e. all elements that are in either set.)
        """
        if not isinstance(other, BaseSet):
            return NotImplemented
        return self.union(other)

    def union(self, other):
        """Return the union of two sets as a new set.

        (I.e. all elements that are in either set.)
        """
        result = self.__class__(self)
        result._update(other)
        return result

    def __and__(self, other):
        """Return the intersection of two sets as a new set.

        (I.e. all elements that are in both sets.)
        """
        if not isinstance(other, BaseSet):
            return NotImplemented
        return self.intersection(other)

    def intersection(self, other):
        """Return the intersection of two sets as a new set.

        (I.e. all elements that are in both sets.)
        """
        if not isinstance(other, BaseSet):
            other = Set(other)
        if len(self) <= len(other):
            little, big = self, other
        else:
            little, big = other, self
        common = ifilter(big._data.__contains__, little)
        return self.__class__(common)

    def __xor__(self, other):
        """Return the symmetric difference of two sets as a new set.

        (I.e. all elements that are in exactly one of the sets.)
        """
        if not isinstance(other, BaseSet):
            return NotImplemented
        return self.symmetric_difference(other)

    def symmetric_difference(self, other):
        """Return the symmetric difference of two sets as a new set.

        (I.e. all elements that are in exactly one of the sets.)
        """
        result = self.__class__()
        data = result._data
        value = True
        selfdata = self._data
        try:
            otherdata = other._data
        except AttributeError:
            otherdata = Set(other)._data
        for elt in ifilterfalse(otherdata.__contains__, selfdata):
            data[elt] = value
        for elt in ifilterfalse(selfdata.__contains__, otherdata):
            data[elt] = value
        return result

    def  __sub__(self, other):
        """Return the difference of two sets as a new Set.

        (I.e. all elements that are in this set and not in the other.)
        """
        if not isinstance(other, BaseSet):
            return NotImplemented
        return self.difference(other)

    def difference(self, other):
        """Return the difference of two sets as a new Set.

        (I.e. all elements that are in this set and not in the other.)
        """
        result = self.__class__()
        data = result._data
        try:
            otherdata = other._data
        except AttributeError:
            otherdata = Set(other)._data
        value = True
        for elt in ifilterfalse(otherdata.__contains__, self):
            data[elt] = value
        return result

    # Membership test

    def __contains__(self, element):
        """Report whether an element is a member of a set.

        (Called in response to the expression `element in self'.)
        """
        try:
            return element in self._data
        except TypeError:
            transform = getattr(element, "__as_temporarily_immutable__", None)
            if transform is None:
                raise # re-raise the TypeError exception we caught
            return transform() in self._data

    # Subset and superset test

    def issubset(self, other):
        """Report whether another set contains this set."""
        self._binary_sanity_check(other)
        if len(self) > len(other):  # Fast check for obvious cases
            return False
        for elt in ifilterfalse(other._data.__contains__, self):
            return False
        return True

    def issuperset(self, other):
        """Report whether this set contains another set."""
        self._binary_sanity_check(other)
        if len(self) < len(other):  # Fast check for obvious cases
            return False
        for elt in ifilterfalse(self._data.__contains__, other):
            return False
        return True

    # Inequality comparisons using the is-subset relation.
    __le__ = issubset
    __ge__ = issuperset

    def __lt__(self, other):
        self._binary_sanity_check(other)
        return len(self) < len(other) and self.issubset(other)

    def __gt__(self, other):
        self._binary_sanity_check(other)
        return len(self) > len(other) and self.issuperset(other)

    # We inherit object.__hash__, so we must deny this explicitly
    __hash__ = None

    # Assorted helpers

    def _binary_sanity_check(self, other):
        # Check that the other argument to a binary operation is also
        # a set, raising a TypeError otherwise.
        if not isinstance(other, BaseSet):
            raise TypeError, "Binary operation only permitted between sets"

    def _compute_hash(self):
        # Calculate hash code for a set by xor'ing the hash codes of
        # the elements.  This ensures that the hash code does not depend
        # on the order in which elements are added to the set.  This is
        # not called __hash__ because a BaseSet should not be hashable;
        # only an ImmutableSet is hashable.
        result = 0
        for elt in self:
            result ^= hash(elt)
        return result

    def _update(self, iterable):
        # The main loop for update() and the subclass __init__() methods.
        data = self._data

        # Use the fast update() method when a dictionary is available.
        if isinstance(iterable, BaseSet):
            data.update(iterable._data)
            return

        value = True

        if type(iterable) in (list, tuple, xrange):
            # Optimized: we know that __iter__() and next() can't
            # raise TypeError, so we can move 'try:' out of the loop.
            it = iter(iterable)
            while True:
                try:
                    for element in it:
                        data[element] = value
                    return
                except TypeError:
                    transform = getattr(element, "__as_immutable__", None)
                    if transform is None:
                        raise # re-raise the TypeError exception we caught
                    data[transform()] = value
        else:
            # Safe: only catch TypeError where intended
            for element in iterable:
                try:
                    data[element] = value
                except TypeError:
                    transform = getattr(element, "__as_immutable__", None)
                    if transform is None:
                        raise # re-raise the TypeError exception we caught
                    data[transform()] = value


class ImmutableSet(BaseSet):
    """Immutable set class."""

    __slots__ = ['_hashcode']

    # BaseSet + hashing

    def __init__(self, iterable=None):
        """Construct an immutable set from an optional iterable."""
        self._hashcode = None
        self._data = {}
        if iterable is not None:
            self._update(iterable)

    def __hash__(self):
        if self._hashcode is None:
            self._hashcode = self._compute_hash()
        return self._hashcode

    def __getstate__(self):
        return self._data, self._hashcode

    def __setstate__(self, state):
        self._data, self._hashcode = state

class Set(BaseSet):
    """ Mutable set class."""

    __slots__ = []

    # BaseSet + operations requiring mutability; no hashing

    def __init__(self, iterable=None):
        """Construct a set from an optional iterable."""
        self._data = {}
        if iterable is not None:
            self._update(iterable)

    def __getstate__(self):
        # getstate's results are ignored if it is not
        return self._data,

    def __setstate__(self, data):
        self._data, = data

    # In-place union, intersection, differences.
    # Subtle:  The xyz_update() functions deliberately return None,
    # as do all mutating operations on built-in container types.
    # The __xyz__ spellings have to return self, though.

    def __ior__(self, other):
        """Update a set with the union of itself and another."""
        self._binary_sanity_check(other)
        self._data.update(other._data)
        return self

    def union_update(self, other):
        """Update a set with the union of itself and another."""
        self._update(other)

    def __iand__(self, other):
        """Update a set with the intersection of itself and another."""
        self._binary_sanity_check(other)
        self._data = (self & other)._data
        return self

    def intersection_update(self, other):
        """Update a set with the intersection of itself and another."""
        if isinstance(other, BaseSet):
            self &= other
        else:
            self._data = (self.intersection(other))._data

    def __ixor__(self, other):
        """Update a set with the symmetric difference of itself and another."""
        self._binary_sanity_check(other)
        self.symmetric_difference_update(other)
        return self

    def symmetric_difference_update(self, other):
        """Update a set with the symmetric difference of itself and another."""
        data = self._data
        value = True
        if not isinstance(other, BaseSet):
            other = Set(other)
        if self is other:
            self.clear()
        for elt in other:
            if elt in data:
                del data[elt]
            else:
                data[elt] = value

    def __isub__(self, other):
        """Remove all elements of another set from this set."""
        self._binary_sanity_check(other)
        self.difference_update(other)
        return self

    def difference_update(self, other):
        """Remove all elements of another set from this set."""
        data = self._data
        if not isinstance(other, BaseSet):
            other = Set(other)
        if self is other:
            self.clear()
        for elt in ifilter(data.__contains__, other):
            del data[elt]

    # Python dict-like mass mutations: update, clear

    def update(self, iterable):
        """Add all values from an iterable (such as a list or file)."""
        self._update(iterable)

    def clear(self):
        """Remove all elements from this set."""
        self._data.clear()

    # Single-element mutations: add, remove, discard

    def add(self, element):
        """Add an element to a set.

        This has no effect if the element is already present.
        """
        try:
            self._data[element] = True
        except TypeError:
            transform = getattr(element, "__as_immutable__", None)
            if transform is None:
                raise # re-raise the TypeError exception we caught
            self._data[transform()] = True

    def remove(self, element):
        """Remove an element from a set; it must be a member.

        If the element is not a member, raise a KeyError.
        """
        try:
            del self._data[element]
        except TypeError:
            transform = getattr(element, "__as_temporarily_immutable__", None)
            if transform is None:
                raise # re-raise the TypeError exception we caught
            del self._data[transform()]

    def discard(self, element):
        """Remove an element from a set if it is a member.

        If the element is not a member, do nothing.
        """
        try:
            self.remove(element)
        except KeyError:
            pass

    def pop(self):
        """Remove and return an arbitrary set element."""
        return self._data.popitem()[0]

    def __as_immutable__(self):
        # Return a copy of self as an immutable set
        return ImmutableSet(self)

    def __as_temporarily_immutable__(self):
        # Return self wrapped in a temporarily immutable set
        return _TemporarilyImmutableSet(self)


class _TemporarilyImmutableSet(BaseSet):
    # Wrap a mutable set as if it was temporarily immutable.
    # This only supplies hashing and equality comparisons.

    def __init__(self, set):
        self._set = set
        self._data = set._data  # Needed by ImmutableSet.__eq__()

    def __hash__(self):
        return self._set._compute_hash()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Û
”´[c           @   s©   d  Z  d d l m Z m Z d d d g Z d d l Z e j d e d d	 Éd e f d
 Ñ  É  YZ	 d e	 f d Ñ  É  YZ
 d e	 f d Ñ  É  YZ d e	 f d Ñ  É  YZ d S(   sÂ  Classes to represent arbitrary sets (including sets of sets).

This module implements sets using dictionaries whose values are
ignored.  The usual operations (union, intersection, deletion, etc.)
are provided as both methods and operators.

Important: sets are not sequences!  While they support 'x in s',
'len(s)', and 'for x in s', none of those operations are unique for
sequences; for example, mappings support all three as well.  The
characteristic operation for sequences is subscripting with small
integers: s[i], for i in range(len(s)).  Sets don't support
subscripting at all.  Also, sequences allow multiple occurrences and
their elements have a definite order; sets on the other hand don't
record multiple occurrences and don't remember the order of element
insertion (which is why they don't support s[i]).

The following classes are provided:

BaseSet -- All the operations common to both mutable and immutable
    sets. This is an abstract class, not meant to be directly
    instantiated.

Set -- Mutable sets, subclass of BaseSet; not hashable.

ImmutableSet -- Immutable sets, subclass of BaseSet; hashable.
    An iterable argument is mandatory to create an ImmutableSet.

_TemporarilyImmutableSet -- A wrapper around a Set, hashable,
    giving the same hash value as the immutable set equivalent
    would have.  Do not use this class directly.

Only hashable objects can be added to a Set. In particular, you cannot
really add a Set as an element to another Set; if you try, what is
actually added is an ImmutableSet built from it (it compares equal to
the one you tried adding).

When you ask if `x in y' where x is a Set and y is a Set or
ImmutableSet, x is wrapped into a _TemporarilyImmutableSet z, and
what's tested is actually `z in y'.

iˇˇˇˇ(   t   ifiltert   ifilterfalset   BaseSett   Sett   ImmutableSetNs   the sets module is deprecatedt
   stackleveli   c           B   s"  e  Z d  Z d g Z d Ñ  Z d Ñ  Z d Ñ  Z e Z e d Ñ Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z e Z d Ñ  Z d Ñ  Z d Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ RS(   s1   Common base class for mutable and immutable sets.t   _datac         C   s   |  j  t k r t d Ç n  d S(   s   This is an abstract class.s7   BaseSet is an abstract class.  Use Set or ImmutableSet.N(   t	   __class__R   t	   TypeError(   t   self(    (    s   /usr/lib/python2.7/sets.pyt   __init__H   s    c         C   s   t  |  j É S(   s'   Return the number of elements of a set.(   t   lenR   (   R	   (    (    s   /usr/lib/python2.7/sets.pyt   __len__Q   s    c         C   s
   |  j  É  S(   se   Return string representation of a set.

        This looks like 'Set([<list of elements>])'.
        (   t   _repr(   R	   (    (    s   /usr/lib/python2.7/sets.pyt   __repr__U   s    c         C   s6   |  j  j É  } | r" | j É  n  d |  j j | f S(   Ns   %s(%r)(   R   t   keyst   sortR   t   __name__(   R	   t   sortedt   elements(    (    s   /usr/lib/python2.7/sets.pyR   _   s    c         C   s   |  j  j É  S(   ss   Return an iterator over the elements or a set.

        This is the keys iterator for the underlying dict.
        (   R   t   iterkeys(   R	   (    (    s   /usr/lib/python2.7/sets.pyt   __iter__e   s    c         C   s   t  d Ç d  S(   Ns   can't compare sets using cmp()(   R   (   R	   t   other(    (    s   /usr/lib/python2.7/sets.pyt   __cmp__q   s    c         C   s'   t  | t É r |  j | j k St Sd  S(   N(   t
   isinstanceR   R   t   False(   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __eq__É   s    c         C   s'   t  | t É r |  j | j k St Sd  S(   N(   R   R   R   t   True(   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __ne__â   s    c         C   s#   |  j  É  } | j j |  j É | S(   s   Return a shallow copy of a set.(   R   R   t   update(   R	   t   result(    (    s   /usr/lib/python2.7/sets.pyt   copyë   s    c         C   sc   d d l  m } |  j É  } | | t |  É <| j } t } x! |  D] } | | | | | É <qB W| S(   s1   Return a deep copy of a set; used by copy module.iˇˇˇˇ(   t   deepcopy(   R   R    R   t   idR   R   (   R	   t   memoR    R   t   datat   valuet   elt(    (    s   /usr/lib/python2.7/sets.pyt   __deepcopy__ô   s    	c         C   s    t  | t É s t S|  j | É S(   sh   Return the union of two sets as a new set.

        (I.e. all elements that are in either set.)
        (   R   R   t   NotImplementedt   union(   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __or__≤   s    c         C   s    |  j  |  É } | j | É | S(   sh   Return the union of two sets as a new set.

        (I.e. all elements that are in either set.)
        (   R   t   _update(   R	   R   R   (    (    s   /usr/lib/python2.7/sets.pyR(   ª   s    c         C   s    t  | t É s t S|  j | É S(   sn   Return the intersection of two sets as a new set.

        (I.e. all elements that are in both sets.)
        (   R   R   R'   t   intersection(   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __and__ƒ   s    c         C   su   t  | t É s t | É } n  t |  É t | É k rF |  | } } n | |  } } t | j j | É } |  j | É S(   sn   Return the intersection of two sets as a new set.

        (I.e. all elements that are in both sets.)
        (   R   R   R   R   R    R   t   __contains__R   (   R	   R   t   littlet   bigt   common(    (    s   /usr/lib/python2.7/sets.pyR+   Õ   s    c         C   s    t  | t É s t S|  j | É S(   sÑ   Return the symmetric difference of two sets as a new set.

        (I.e. all elements that are in exactly one of the sets.)
        (   R   R   R'   t   symmetric_difference(   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __xor__€   s    c         C   s¶   |  j  É  } | j } t } |  j } y | j } Wn  t k
 rS t | É j } n Xx$ t | j | É D] } | | | <qg Wx$ t | j | É D] } | | | <qé W| S(   sÑ   Return the symmetric difference of two sets as a new set.

        (I.e. all elements that are in exactly one of the sets.)
        (   R   R   R   t   AttributeErrorR   R   R-   (   R	   R   R   R#   R$   t   selfdatat	   otherdataR%   (    (    s   /usr/lib/python2.7/sets.pyR1   ‰   s    		c         C   s    t  | t É s t S|  j | É S(   sÄ   Return the difference of two sets as a new Set.

        (I.e. all elements that are in this set and not in the other.)
        (   R   R   R'   t
   difference(   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __sub__˜   s    c         C   sv   |  j  É  } | j } y | j } Wn  t k
 rD t | É j } n Xt } x$ t | j |  É D] } | | | <q^ W| S(   sÄ   Return the difference of two sets as a new Set.

        (I.e. all elements that are in this set and not in the other.)
        (   R   R   R3   R   R   R   R-   (   R	   R   R   R#   R5   R$   R%   (    (    s   /usr/lib/python2.7/sets.pyR6      s    	c         C   sZ   y | |  j  k SWnB t k
 rU t | d d É } | d k rE Ç  n  | É  |  j  k SXd S(   s{   Report whether an element is a member of a set.

        (Called in response to the expression `element in self'.)
        t   __as_temporarily_immutable__N(   R   R   t   getattrt   None(   R	   t   elementt	   transform(    (    s   /usr/lib/python2.7/sets.pyR-     s    c         C   sN   |  j  | É t |  É t | É k r) t Sx t | j j |  É D] } t SWt S(   s-   Report whether another set contains this set.(   t   _binary_sanity_checkR   R   R   R   R-   R   (   R	   R   R%   (    (    s   /usr/lib/python2.7/sets.pyt   issubset!  s    c         C   sN   |  j  | É t |  É t | É k  r) t Sx t |  j j | É D] } t SWt S(   s-   Report whether this set contains another set.(   R=   R   R   R   R   R-   R   (   R	   R   R%   (    (    s   /usr/lib/python2.7/sets.pyt
   issuperset*  s    c         C   s2   |  j  | É t |  É t | É k  o1 |  j | É S(   N(   R=   R   R>   (   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __lt__7  s    c         C   s2   |  j  | É t |  É t | É k o1 |  j | É S(   N(   R=   R   R?   (   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __gt__;  s    c         C   s   t  | t É s t d Ç n  d  S(   Ns,   Binary operation only permitted between sets(   R   R   R   (   R	   R   (    (    s   /usr/lib/python2.7/sets.pyR=   D  s    c         C   s+   d } x |  D] } | t  | É N} q W| S(   Ni    (   t   hash(   R	   R   R%   (    (    s   /usr/lib/python2.7/sets.pyt   _compute_hashJ  s    c         C   s9  |  j  } t | t É r, | j | j  É d  St } t | É t t t f k r— t	 | É } xŸ t rÕ y# x | D] } | | | <ql Wd  SWq\ t
 k
 r… t | d d  É } | d  k rπ Ç  n  | | | É  <q\ Xq\ Wnd xa | D]Y } y | | | <Wqÿ t
 k
 r0t | d d  É } | d  k r Ç  n  | | | É  <qÿ Xqÿ Wd  S(   Nt   __as_immutable__(   R   R   R   R   R   t   typet   listt   tuplet   xranget   iterR   R9   R:   (   R	   t   iterableR#   R$   t   itR;   R<   (    (    s   /usr/lib/python2.7/sets.pyR*   U  s2    		N(%   R   t
   __module__t   __doc__t	   __slots__R
   R   R   t   __str__R   R   R   R   R   R   R   t   __copy__R&   R)   R(   R,   R+   R2   R1   R7   R6   R-   R>   R?   t   __le__t   __ge__R@   RA   R:   t   __hash__R=   RC   R*   (    (    (    s   /usr/lib/python2.7/sets.pyR   A   sB   																												
				c           B   s>   e  Z d  Z d g Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s   Immutable set class.t	   _hashcodec         C   s2   d |  _ i  |  _ | d k	 r. |  j | É n  d S(   s5   Construct an immutable set from an optional iterable.N(   R:   RT   R   R*   (   R	   RJ   (    (    s   /usr/lib/python2.7/sets.pyR
   Å  s    		c         C   s(   |  j  d  k r! |  j É  |  _  n  |  j  S(   N(   RT   R:   RC   (   R	   (    (    s   /usr/lib/python2.7/sets.pyRS   à  s    c         C   s   |  j  |  j f S(   N(   R   RT   (   R	   (    (    s   /usr/lib/python2.7/sets.pyt   __getstate__ç  s    c         C   s   | \ |  _  |  _ d  S(   N(   R   RT   (   R	   t   state(    (    s   /usr/lib/python2.7/sets.pyt   __setstate__ê  s    N(	   R   RL   RM   RN   R:   R
   RS   RU   RW   (    (    (    s   /usr/lib/python2.7/sets.pyR   z  s   			c           B   s¬   e  Z d  Z g  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s    Mutable set class.c         C   s)   i  |  _  | d k	 r% |  j | É n  d S(   s*   Construct a set from an optional iterable.N(   R   R:   R*   (   R	   RJ   (    (    s   /usr/lib/python2.7/sets.pyR
   ö  s    	c         C   s
   |  j  f S(   N(   R   (   R	   (    (    s   /usr/lib/python2.7/sets.pyRU   †  s    c         C   s   | \ |  _  d  S(   N(   R   (   R	   R#   (    (    s   /usr/lib/python2.7/sets.pyRW   §  s    c         C   s$   |  j  | É |  j j | j É |  S(   s2   Update a set with the union of itself and another.(   R=   R   R   (   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __ior__¨  s    c         C   s   |  j  | É d S(   s2   Update a set with the union of itself and another.N(   R*   (   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   union_update≤  s    c         C   s!   |  j  | É |  | @j |  _ |  S(   s9   Update a set with the intersection of itself and another.(   R=   R   (   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __iand__∂  s    c         C   s5   t  | t É r |  | M}  n |  j | É j |  _ d S(   s9   Update a set with the intersection of itself and another.N(   R   R   R+   R   (   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   intersection_updateº  s    c         C   s   |  j  | É |  j | É |  S(   sA   Update a set with the symmetric difference of itself and another.(   R=   t   symmetric_difference_update(   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __ixor__√  s    c         C   s{   |  j  } t } t | t É s- t | É } n  |  | k rF |  j É  n  x. | D]& } | | k ri | | =qM | | | <qM Wd S(   sA   Update a set with the symmetric difference of itself and another.N(   R   R   R   R   R   t   clear(   R	   R   R#   R$   R%   (    (    s   /usr/lib/python2.7/sets.pyR\   …  s    	
c         C   s   |  j  | É |  j | É |  S(   s1   Remove all elements of another set from this set.(   R=   t   difference_update(   R	   R   (    (    s   /usr/lib/python2.7/sets.pyt   __isub__◊  s    c         C   sh   |  j  } t | t É s' t | É } n  |  | k r@ |  j É  n  x! t | j | É D] } | | =qS Wd S(   s1   Remove all elements of another set from this set.N(   R   R   R   R   R^   R    R-   (   R	   R   R#   R%   (    (    s   /usr/lib/python2.7/sets.pyR_   ›  s    	c         C   s   |  j  | É d S(   s9   Add all values from an iterable (such as a list or file).N(   R*   (   R	   RJ   (    (    s   /usr/lib/python2.7/sets.pyR   È  s    c         C   s   |  j  j É  d S(   s"   Remove all elements from this set.N(   R   R^   (   R	   (    (    s   /usr/lib/python2.7/sets.pyR^   Ì  s    c         C   s]   y t  |  j | <WnE t k
 rX t | d d É } | d k rE Ç  n  t  |  j | É  <n Xd S(   s`   Add an element to a set.

        This has no effect if the element is already present.
        RD   N(   R   R   R   R9   R:   (   R	   R;   R<   (    (    s   /usr/lib/python2.7/sets.pyt   addÛ  s    c         C   sW   y |  j  | =WnB t k
 rR t | d d É } | d k rB Ç  n  |  j  | É  =n Xd S(   sv   Remove an element from a set; it must be a member.

        If the element is not a member, raise a KeyError.
        R8   N(   R   R   R9   R:   (   R	   R;   R<   (    (    s   /usr/lib/python2.7/sets.pyt   remove   s    c         C   s)   y |  j  | É Wn t k
 r$ n Xd S(   sm   Remove an element from a set if it is a member.

        If the element is not a member, do nothing.
        N(   Rb   t   KeyError(   R	   R;   (    (    s   /usr/lib/python2.7/sets.pyt   discard  s    c         C   s   |  j  j É  d S(   s+   Remove and return an arbitrary set element.i    (   R   t   popitem(   R	   (    (    s   /usr/lib/python2.7/sets.pyt   pop  s    c         C   s
   t  |  É S(   N(   R   (   R	   (    (    s   /usr/lib/python2.7/sets.pyRD     s    c         C   s
   t  |  É S(   N(   t   _TemporarilyImmutableSet(   R	   (    (    s   /usr/lib/python2.7/sets.pyR8     s    N(   R   RL   RM   RN   R:   R
   RU   RW   RX   RY   RZ   R[   R]   R\   R`   R_   R   R^   Ra   Rb   Rd   Rf   RD   R8   (    (    (    s   /usr/lib/python2.7/sets.pyR   ì  s*   															
		Rg   c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s   | |  _  | j |  _ d  S(   N(   t   _setR   (   R	   t   set(    (    s   /usr/lib/python2.7/sets.pyR
   (  s    	c         C   s   |  j  j É  S(   N(   Rh   RC   (   R	   (    (    s   /usr/lib/python2.7/sets.pyRS   ,  s    (   R   RL   R
   RS   (    (    (    s   /usr/lib/python2.7/sets.pyRg   $  s   	(   RM   t	   itertoolsR    R   t   __all__t   warningst   warnt   DeprecationWarningt   objectR   R   R   Rg   (    (    (    s   /usr/lib/python2.7/sets.pyt   <module>)   s   ˇ :ë                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """A parser for SGML, using the derived class as a static DTD."""

# XXX This only supports those SGML features used by HTML.

# XXX There should be a way to distinguish between PCDATA (parsed
# character data -- the normal case), RCDATA (replaceable character
# data -- only char and entity references and end tags are special)
# and CDATA (character data -- only end tags are special).  RCDATA is
# not supported at all.


from warnings import warnpy3k
warnpy3k("the sgmllib module has been removed in Python 3.0",
         stacklevel=2)
del warnpy3k

import markupbase
import re

__all__ = ["SGMLParser", "SGMLParseError"]

# Regular expressions used for parsing

interesting = re.compile('[&<]')
incomplete = re.compile('&([a-zA-Z][a-zA-Z0-9]*|#[0-9]*)?|'
                           '<([a-zA-Z][^<>]*|'
                              '/([a-zA-Z][^<>]*)?|'
                              '![^<>]*)?')

entityref = re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')
charref = re.compile('&#([0-9]+)[^0-9]')

starttagopen = re.compile('<[>a-zA-Z]')
shorttagopen = re.compile('<[a-zA-Z][-.a-zA-Z0-9]*/')
shorttag = re.compile('<([a-zA-Z][-.a-zA-Z0-9]*)/([^/]*)/')
piclose = re.compile('>')
endbracket = re.compile('[<>]')
tagfind = re.compile('[a-zA-Z][-_.a-zA-Z0-9]*')
attrfind = re.compile(
    r'\s*([a-zA-Z_][-:.a-zA-Z_0-9]*)(\s*=\s*'
    r'(\'[^\']*\'|"[^"]*"|[][\-a-zA-Z0-9./,:;+*%?!&$\(\)_#=~\'"@]*))?')


class SGMLParseError(RuntimeError):
    """Exception raised for all parse errors."""
    pass


# SGML parser base class -- find tags and call handler functions.
# Usage: p = SGMLParser(); p.feed(data); ...; p.close().
# The dtd is defined by deriving a class which defines methods
# with special names to handle tags: start_foo and end_foo to handle
# <foo> and </foo>, respectively, or do_foo to handle <foo> by itself.
# (Tags are converted to lower case for this purpose.)  The data
# between tags is passed to the parser by calling self.handle_data()
# with some data as argument (the data may be split up in arbitrary
# chunks).  Entity references are passed by calling
# self.handle_entityref() with the entity reference as argument.

class SGMLParser(markupbase.ParserBase):
    # Definition of entities -- derived classes may override
    entity_or_charref = re.compile('&(?:'
      '([a-zA-Z][-.a-zA-Z0-9]*)|#([0-9]+)'
      ')(;?)')

    def __init__(self, verbose=0):
        """Initialize and reset this instance."""
        self.verbose = verbose
        self.reset()

    def reset(self):
        """Reset this instance. Loses all unprocessed data."""
        self.__starttag_text = None
        self.rawdata = ''
        self.stack = []
        self.lasttag = '???'
        self.nomoretags = 0
        self.literal = 0
        markupbase.ParserBase.reset(self)

    def setnomoretags(self):
        """Enter literal mode (CDATA) till EOF.

        Intended for derived classes only.
        """
        self.nomoretags = self.literal = 1

    def setliteral(self, *args):
        """Enter literal mode (CDATA).

        Intended for derived classes only.
        """
        self.literal = 1

    def feed(self, data):
        """Feed some data to the parser.

        Call this as often as you want, with as little or as much text
        as you want (may include '\n').  (This just saves the text,
        all the processing is done by goahead().)
        """

        self.rawdata = self.rawdata + data
        self.goahead(0)

    def close(self):
        """Handle the remaining data."""
        self.goahead(1)

    def error(self, message):
        raise SGMLParseError(message)

    # Internal -- handle data as far as reasonable.  May leave state
    # and data to be processed by a subsequent call.  If 'end' is
    # true, force handling all data as if followed by EOF marker.
    def goahead(self, end):
        rawdata = self.rawdata
        i = 0
        n = len(rawdata)
        while i < n:
            if self.nomoretags:
                self.handle_data(rawdata[i:n])
                i = n
                break
            match = interesting.search(rawdata, i)
            if match: j = match.start()
            else: j = n
            if i < j:
                self.handle_data(rawdata[i:j])
            i = j
            if i == n: break
            if rawdata[i] == '<':
                if starttagopen.match(rawdata, i):
                    if self.literal:
                        self.handle_data(rawdata[i])
                        i = i+1
                        continue
                    k = self.parse_starttag(i)
                    if k < 0: break
                    i = k
                    continue
                if rawdata.startswith("</", i):
                    k = self.parse_endtag(i)
                    if k < 0: break
                    i = k
                    self.literal = 0
                    continue
                if self.literal:
                    if n > (i + 1):
                        self.handle_data("<")
                        i = i+1
                    else:
                        # incomplete
                        break
                    continue
                if rawdata.startswith("<!--", i):
                        # Strictly speaking, a comment is --.*--
                        # within a declaration tag <!...>.
                        # This should be removed,
                        # and comments handled only in parse_declaration.
                    k = self.parse_comment(i)
                    if k < 0: break
                    i = k
                    continue
                if rawdata.startswith("<?", i):
                    k = self.parse_pi(i)
                    if k < 0: break
                    i = i+k
                    continue
                if rawdata.startswith("<!", i):
                    # This is some sort of declaration; in "HTML as
                    # deployed," this should only be the document type
                    # declaration ("<!DOCTYPE html...>").
                    k = self.parse_declaration(i)
                    if k < 0: break
                    i = k
                    continue
            elif rawdata[i] == '&':
                if self.literal:
                    self.handle_data(rawdata[i])
                    i = i+1
                    continue
                match = charref.match(rawdata, i)
                if match:
                    name = match.group(1)
                    self.handle_charref(name)
                    i = match.end(0)
                    if rawdata[i-1] != ';': i = i-1
                    continue
                match = entityref.match(rawdata, i)
                if match:
                    name = match.group(1)
                    self.handle_entityref(name)
                    i = match.end(0)
                    if rawdata[i-1] != ';': i = i-1
                    continue
            else:
                self.error('neither < nor & ??')
            # We get here only if incomplete matches but
            # nothing else
            match = incomplete.match(rawdata, i)
            if not match:
                self.handle_data(rawdata[i])
                i = i+1
                continue
            j = match.end(0)
            if j == n:
                break # Really incomplete
            self.handle_data(rawdata[i:j])
            i = j
        # end while
        if end and i < n:
            self.handle_data(rawdata[i:n])
            i = n
        self.rawdata = rawdata[i:]
        # XXX if end: check for empty stack

    # Extensions for the DOCTYPE scanner:
    _decl_otherchars = '='

    # Internal -- parse processing instr, return length or -1 if not terminated
    def parse_pi(self, i):
        rawdata = self.rawdata
        if rawdata[i:i+2] != '<?':
            self.error('unexpected call to parse_pi()')
        match = piclose.search(rawdata, i+2)
        if not match:
            return -1
        j = match.start(0)
        self.handle_pi(rawdata[i+2: j])
        j = match.end(0)
        return j-i

    def get_starttag_text(self):
        return self.__starttag_text

    # Internal -- handle starttag, return length or -1 if not terminated
    def parse_starttag(self, i):
        self.__starttag_text = None
        start_pos = i
        rawdata = self.rawdata
        if shorttagopen.match(rawdata, i):
            # SGML shorthand: <tag/data/ == <tag>data</tag>
            # XXX Can data contain &... (entity or char refs)?
            # XXX Can data contain < or > (tag characters)?
            # XXX Can there be whitespace before the first /?
            match = shorttag.match(rawdata, i)
            if not match:
                return -1
            tag, data = match.group(1, 2)
            self.__starttag_text = '<%s/' % tag
            tag = tag.lower()
            k = match.end(0)
            self.finish_shorttag(tag, data)
            self.__starttag_text = rawdata[start_pos:match.end(1) + 1]
            return k
        # XXX The following should skip matching quotes (' or ")
        # As a shortcut way to exit, this isn't so bad, but shouldn't
        # be used to locate the actual end of the start tag since the
        # < or > characters may be embedded in an attribute value.
        match = endbracket.search(rawdata, i+1)
        if not match:
            return -1
        j = match.start(0)
        # Now parse the data between i+1 and j into a tag and attrs
        attrs = []
        if rawdata[i:i+2] == '<>':
            # SGML shorthand: <> == <last open tag seen>
            k = j
            tag = self.lasttag
        else:
            match = tagfind.match(rawdata, i+1)
            if not match:
                self.error('unexpected call to parse_starttag')
            k = match.end(0)
            tag = rawdata[i+1:k].lower()
            self.lasttag = tag
        while k < j:
            match = attrfind.match(rawdata, k)
            if not match: break
            attrname, rest, attrvalue = match.group(1, 2, 3)
            if not rest:
                attrvalue = attrname
            else:
                if (attrvalue[:1] == "'" == attrvalue[-1:] or
                    attrvalue[:1] == '"' == attrvalue[-1:]):
                    # strip quotes
                    attrvalue = attrvalue[1:-1]
                attrvalue = self.entity_or_charref.sub(
                    self._convert_ref, attrvalue)
            attrs.append((attrname.lower(), attrvalue))
            k = match.end(0)
        if rawdata[j] == '>':
            j = j+1
        self.__starttag_text = rawdata[start_pos:j]
        self.finish_starttag(tag, attrs)
        return j

    # Internal -- convert entity or character reference
    def _convert_ref(self, match):
        if match.group(2):
            return self.convert_charref(match.group(2)) or \
                '&#%s%s' % match.groups()[1:]
        elif match.group(3):
            return self.convert_entityref(match.group(1)) or \
                '&%s;' % match.group(1)
        else:
            return '&%s' % match.group(1)

    # Internal -- parse endtag
    def parse_endtag(self, i):
        rawdata = self.rawdata
        match = endbracket.search(rawdata, i+1)
        if not match:
            return -1
        j = match.start(0)
        tag = rawdata[i+2:j].strip().lower()
        if rawdata[j] == '>':
            j = j+1
        self.finish_endtag(tag)
        return j

    # Internal -- finish parsing of <tag/data/ (same as <tag>data</tag>)
    def finish_shorttag(self, tag, data):
        self.finish_starttag(tag, [])
        self.handle_data(data)
        self.finish_endtag(tag)

    # Internal -- finish processing of start tag
    # Return -1 for unknown tag, 0 for open-only tag, 1 for balanced tag
    def finish_starttag(self, tag, attrs):
        try:
            method = getattr(self, 'start_' + tag)
        except AttributeError:
            try:
                method = getattr(self, 'do_' + tag)
            except AttributeError:
                self.unknown_starttag(tag, attrs)
                return -1
            else:
                self.handle_starttag(tag, method, attrs)
                return 0
        else:
            self.stack.append(tag)
            self.handle_starttag(tag, method, attrs)
            return 1

    # Internal -- finish processing of end tag
    def finish_endtag(self, tag):
        if not tag:
            found = len(self.stack) - 1
            if found < 0:
                self.unknown_endtag(tag)
                return
        else:
            if tag not in self.stack:
                try:
                    method = getattr(self, 'end_' + tag)
                except AttributeError:
                    self.unknown_endtag(tag)
                else:
                    self.report_unbalanced(tag)
                return
            found = len(self.stack)
            for i in range(found):
                if self.stack[i] == tag: found = i
        while len(self.stack) > found:
            tag = self.stack[-1]
            try:
                method = getattr(self, 'end_' + tag)
            except AttributeError:
                method = None
            if method:
                self.handle_endtag(tag, method)
            else:
                self.unknown_endtag(tag)
            del self.stack[-1]

    # Overridable -- handle start tag
    def handle_starttag(self, tag, method, attrs):
        method(attrs)

    # Overridable -- handle end tag
    def handle_endtag(self, tag, method):
        method()

    # Example -- report an unbalanced </...> tag.
    def report_unbalanced(self, tag):
        if self.verbose:
            print '*** Unbalanced </' + tag + '>'
            print '*** Stack:', self.stack

    def convert_charref(self, name):
        """Convert character reference, may be overridden."""
        try:
            n = int(name)
        except ValueError:
            return
        if not 0 <= n <= 127:
            return
        return self.convert_codepoint(n)

    def convert_codepoint(self, codepoint):
        return chr(codepoint)

    def handle_charref(self, name):
        """Handle character reference, no need to override."""
        replacement = self.convert_charref(name)
        if replacement is None:
            self.unknown_charref(name)
        else:
            self.handle_data(replacement)

    # Definition of entities -- derived classes may override
    entitydefs = \
            {'lt': '<', 'gt': '>', 'amp': '&', 'quot': '"', 'apos': '\''}

    def convert_entityref(self, name):
        """Convert entity references.

        As an alternative to overriding this method; one can tailor the
        results by setting up the self.entitydefs mapping appropriately.
        """
        table = self.entitydefs
        if name in table:
            return table[name]
        else:
            return

    def handle_entityref(self, name):
        """Handle entity references, no need to override."""
        replacement = self.convert_entityref(name)
        if replacement is None:
            self.unknown_entityref(name)
        else:
            self.handle_data(replacement)

    # Example -- handle data, should be overridden
    def handle_data(self, data):
        pass

    # Example -- handle comment, could be overridden
    def handle_comment(self, data):
        pass

    # Example -- handle declaration, could be overridden
    def handle_decl(self, decl):
        pass

    # Example -- handle processing instruction, could be overridden
    def handle_pi(self, data):
        pass

    # To be overridden -- handlers for unknown objects
    def unknown_starttag(self, tag, attrs): pass
    def unknown_endtag(self, tag): pass
    def unknown_charref(self, ref): pass
    def unknown_entityref(self, ref): pass


class TestSGMLParser(SGMLParser):

    def __init__(self, verbose=0):
        self.testdata = ""
        SGMLParser.__init__(self, verbose)

    def handle_data(self, data):
        self.testdata = self.testdata + data
        if len(repr(self.testdata)) >= 70:
            self.flush()

    def flush(self):
        data = self.testdata
        if data:
            self.testdata = ""
            print 'data:', repr(data)

    def handle_comment(self, data):
        self.flush()
        r = repr(data)
        if len(r) > 68:
            r = r[:32] + '...' + r[-32:]
        print 'comment:', r

    def unknown_starttag(self, tag, attrs):
        self.flush()
        if not attrs:
            print 'start tag: <' + tag + '>'
        else:
            print 'start tag: <' + tag,
            for name, value in attrs:
                print name + '=' + '"' + value + '"',
            print '>'

    def unknown_endtag(self, tag):
        self.flush()
        print 'end tag: </' + tag + '>'

    def unknown_entityref(self, ref):
        self.flush()
        print '*** unknown entity ref: &' + ref + ';'

    def unknown_charref(self, ref):
        self.flush()
        print '*** unknown char ref: &#' + ref + ';'

    def unknown_decl(self, data):
        self.flush()
        print '*** unknown decl: [' + data + ']'

    def close(self):
        SGMLParser.close(self)
        self.flush()


def test(args = None):
    import sys

    if args is None:
        args = sys.argv[1:]

    if args and args[0] == '-s':
        args = args[1:]
        klass = SGMLParser
    else:
        klass = TestSGMLParser

    if args:
        file = args[0]
    else:
        file = 'test.html'

    if file == '-':
        f = sys.stdin
    else:
        try:
            f = open(file, 'r')
        except IOError, msg:
            print file, ":", msg
            sys.exit(1)

    data = f.read()
    if f is not sys.stdin:
        f.close()

    x = klass()
    for c in data:
        x.feed(c)
    x.close()


if __name__ == '__main__':
    test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """Constants for interpreting the results of os.statvfs() and os.fstatvfs()."""
from warnings import warnpy3k
warnpy3k("the statvfs module has been removed in Python 3.0", stacklevel=2)
del warnpy3k

# Indices for statvfs struct members in the tuple returned by
# os.statvfs() and os.fstatvfs().

F_BSIZE   = 0           # Preferred file system block size
F_FRSIZE  = 1           # Fundamental file system block size
F_BLOCKS  = 2           # Total number of file system blocks (FRSIZE)
F_BFREE   = 3           # Total number of free blocks
F_BAVAIL  = 4           # Free blocks available to non-superuser
F_FILES   = 5           # Total number of file nodes
F_FFREE   = 6           # Total number of free file nodes
F_FAVAIL  = 7           # Free nodes available to non-superuser
F_FLAG    = 8           # Flags (see your local statvfs man page)
F_NAMEMAX = 9           # Maximum file name length
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              """Manage shelves of pickled objects.

A "shelf" is a persistent, dictionary-like object.  The difference
with dbm databases is that the values (not the keys!) in a shelf can
be essentially arbitrary Python objects -- anything that the "pickle"
module can handle.  This includes most class instances, recursive data
types, and objects containing lots of shared sub-objects.  The keys
are ordinary strings.

To summarize the interface (key is a string, data is an arbitrary
object):

        import shelve
        d = shelve.open(filename) # open, with (g)dbm filename -- no suffix

        d[key] = data   # store data at key (overwrites old data if
                        # using an existing key)
        data = d[key]   # retrieve a COPY of the data at key (raise
                        # KeyError if no such key) -- NOTE that this
                        # access returns a *copy* of the entry!
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = d.has_key(key)   # true if the key exists; same as "key in d"
        list = d.keys() # a list of all existing keys (slow!)

        d.close()       # close it

Dependent on the implementation, closing a persistent dictionary may
or may not be necessary to flush changes to disk.

Normally, d[key] returns a COPY of the entry.  This needs care when
mutable entries are mutated: for example, if d[key] is a list,
        d[key].append(anitem)
does NOT modify the entry d[key] itself, as stored in the persistent
mapping -- it only modifies the copy, which is then immediately
discarded, so that the append has NO effect whatsoever.  To append an
item to d[key] in a way that will affect the persistent mapping, use:
        data = d[key]
        data.append(anitem)
        d[key] = data

To avoid the problem with mutable entries, you may pass the keyword
argument writeback=True in the call to shelve.open.  When you use:
        d = shelve.open(filename, writeback=True)
then d keeps a cache of all entries you access, and writes them all back
to the persistent mapping when you call d.close().  This ensures that
such usage as d[key].append(anitem) works as intended.

However, using keyword argument writeback=True may consume vast amount
of memory for the cache, and it may make d.close() very slow, if you
access many of d's entries after opening it in this way: d has no way to
check which of the entries you access are mutable and/or which ones you
actually mutate, so it must cache, and write back at close, all of the
entries that you access.  You can call d.sync() to write back all the
entries in the cache, and empty the cache (d.sync() also synchronizes
the persistent dictionary on disk, if feasible).
"""

# Try using cPickle and cStringIO if available.

try:
    from cPickle import Pickler, Unpickler
except ImportError:
    from pickle import Pickler, Unpickler

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

import UserDict

__all__ = ["Shelf","BsdDbShelf","DbfilenameShelf","open"]

class _ClosedDict(UserDict.DictMixin):
    'Marker for a closed dict.  Access attempts raise a ValueError.'

    def closed(self, *args):
        raise ValueError('invalid operation on closed shelf')
    __getitem__ = __setitem__ = __delitem__ = keys = closed

    def __repr__(self):
        return '<Closed Dictionary>'

class Shelf(UserDict.DictMixin):
    """Base class for shelf implementations.

    This is initialized with a dictionary-like object.
    See the module's __doc__ string for an overview of the interface.
    """

    def __init__(self, dict, protocol=None, writeback=False):
        self.dict = dict
        if protocol is None:
            protocol = 0
        self._protocol = protocol
        self.writeback = writeback
        self.cache = {}

    def keys(self):
        return self.dict.keys()

    def __len__(self):
        return len(self.dict)

    def has_key(self, key):
        return key in self.dict

    def __contains__(self, key):
        return key in self.dict

    def get(self, key, default=None):
        if key in self.dict:
            return self[key]
        return default

    def __getitem__(self, key):
        try:
            value = self.cache[key]
        except KeyError:
            f = StringIO(self.dict[key])
            value = Unpickler(f).load()
            if self.writeback:
                self.cache[key] = value
        return value

    def __setitem__(self, key, value):
        if self.writeback:
            self.cache[key] = value
        f = StringIO()
        p = Pickler(f, self._protocol)
        p.dump(value)
        self.dict[key] = f.getvalue()

    def __delitem__(self, key):
        del self.dict[key]
        try:
            del self.cache[key]
        except KeyError:
            pass

    def close(self):
        if self.dict is None:
            return
        try:
            self.sync()
            try:
                self.dict.close()
            except AttributeError:
                pass
        finally:
            # Catch errors that may happen when close is called from __del__
            # because CPython is in interpreter shutdown.
            try:
                self.dict = _ClosedDict()
            except:
                self.dict = None

    def __del__(self):
        if not hasattr(self, 'writeback'):
            # __init__ didn't succeed, so don't bother closing
            return
        self.close()

    def sync(self):
        if self.writeback and self.cache:
            self.writeback = False
            for key, entry in self.cache.iteritems():
                self[key] = entry
            self.writeback = True
            self.cache = {}
        if hasattr(self.dict, 'sync'):
            self.dict.sync()


class BsdDbShelf(Shelf):
    """Shelf implementation using the "BSD" db interface.

    This adds methods first(), next(), previous(), last() and
    set_location() that have no counterpart in [g]dbm databases.

    The actual database must be opened using one of the "bsddb"
    modules "open" routines (i.e. bsddb.hashopen, bsddb.btopen or
    bsddb.rnopen) and passed to the constructor.

    See the module's __doc__ string for an overview of the interface.
    """

    def __init__(self, dict, protocol=None, writeback=False):
        Shelf.__init__(self, dict, protocol, writeback)

    def set_location(self, key):
        (key, value) = self.dict.set_location(key)
        f = StringIO(value)
        return (key, Unpickler(f).load())

    def next(self):
        (key, value) = self.dict.next()
        f = StringIO(value)
        return (key, Unpickler(f).load())

    def previous(self):
        (key, value) = self.dict.previous()
        f = StringIO(value)
        return (key, Unpickler(f).load())

    def first(self):
        (key, value) = self.dict.first()
        f = StringIO(value)
        return (key, Unpickler(f).load())

    def last(self):
        (key, value) = self.dict.last()
        f = StringIO(value)
        return (key, Unpickler(f).load())


class DbfilenameShelf(Shelf):
    """Shelf implementation using the "anydbm" generic dbm interface.

    This is initialized with the filename for the dbm database.
    See the module's __doc__ string for an overview of the interface.
    """

    def __init__(self, filename, flag='c', protocol=None, writeback=False):
        import anydbm
        Shelf.__init__(self, anydbm.open(filename, flag), protocol, writeback)


def open(filename, flag='c', protocol=None, writeback=False):
    """Open a persistent dictionary for reading and writing.

    The filename parameter is the base filename for the underlying
    database.  As a side-effect, an extension may be added to the
    filename and more than one file may be created.  The optional flag
    parameter has the same interpretation as the flag parameter of
    anydbm.open(). The optional protocol parameter specifies the
    version of the pickle protocol (0, 1, or 2).

    See the module's __doc__ string for an overview of the interface.
    """

    return DbfilenameShelf(filename, flag, protocol, writeback)
              Û
”´[c           @   s]  d  Z  d d l m Z e d d d É[ d d l Z d d l Z d d g Z e j d	 É Z e j d
 É Z e j d É Z	 e j d É Z
 e j d É Z e j d É Z e j d É Z e j d É Z e j d É Z e j d É Z e j d É Z d e f d Ñ  É  YZ d e j f d Ñ  É  YZ d e f d Ñ  É  YZ e d Ñ Z e d k rYe É  n  d S(   s;   A parser for SGML, using the derived class as a static DTD.iˇˇˇˇ(   t   warnpy3ks1   the sgmllib module has been removed in Python 3.0t
   stackleveli   Nt
   SGMLParsert   SGMLParseErrors   [&<]sN   &([a-zA-Z][a-zA-Z0-9]*|#[0-9]*)?|<([a-zA-Z][^<>]*|/([a-zA-Z][^<>]*)?|![^<>]*)?s%   &([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]s   &#([0-9]+)[^0-9]s
   <[>a-zA-Z]s   <[a-zA-Z][-.a-zA-Z0-9]*/s"   <([a-zA-Z][-.a-zA-Z0-9]*)/([^/]*)/t   >s   [<>]s   [a-zA-Z][-_.a-zA-Z0-9]*se   \s*([a-zA-Z_][-:.a-zA-Z_0-9]*)(\s*=\s*(\'[^\']*\'|"[^"]*"|[][\-a-zA-Z0-9./,:;+*%?!&$\(\)_#=~\'"@]*))?c           B   s   e  Z d  Z RS(   s&   Exception raised for all parse errors.(   t   __name__t
   __module__t   __doc__(    (    (    s   /usr/lib/python2.7/sgmllib.pyR   ,   s   c           B   si  e  Z e j d  É Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z i d d 6d d 6d d 6d d  6d! d" 6Z d# Ñ  Z d$ Ñ  Z d% Ñ  Z d& Ñ  Z  d' Ñ  Z! d( Ñ  Z" d) Ñ  Z# d* Ñ  Z$ d+ Ñ  Z% d, Ñ  Z& RS(-   s+   &(?:([a-zA-Z][-.a-zA-Z0-9]*)|#([0-9]+))(;?)i    c         C   s   | |  _  |  j É  d S(   s#   Initialize and reset this instance.N(   t   verboset   reset(   t   selfR   (    (    s   /usr/lib/python2.7/sgmllib.pyt   __init__B   s    	c         C   sJ   d |  _ d |  _ g  |  _ d |  _ d |  _ d |  _ t j j	 |  É d S(   s0   Reset this instance. Loses all unprocessed data.t    s   ???i    N(
   t   Nonet   _SGMLParser__starttag_textt   rawdatat   stackt   lasttagt
   nomoretagst   literalt
   markupbaset
   ParserBaseR	   (   R
   (    (    s   /usr/lib/python2.7/sgmllib.pyR	   G   s    						c         C   s   d |  _  |  _ d S(   sY   Enter literal mode (CDATA) till EOF.

        Intended for derived classes only.
        i   N(   R   R   (   R
   (    (    s   /usr/lib/python2.7/sgmllib.pyt   setnomoretagsQ   s    c         G   s   d |  _  d S(   sP   Enter literal mode (CDATA).

        Intended for derived classes only.
        i   N(   R   (   R
   t   args(    (    s   /usr/lib/python2.7/sgmllib.pyt
   setliteralX   s    c         C   s!   |  j  | |  _  |  j d É d S(   s„   Feed some data to the parser.

        Call this as often as you want, with as little or as much text
        as you want (may include '
').  (This just saves the text,
        all the processing is done by goahead().)
        i    N(   R   t   goahead(   R
   t   data(    (    s   /usr/lib/python2.7/sgmllib.pyt   feed_   s    c         C   s   |  j  d É d S(   s   Handle the remaining data.i   N(   R   (   R
   (    (    s   /usr/lib/python2.7/sgmllib.pyt   closej   s    c         C   s   t  | É Ç d  S(   N(   R   (   R
   t   message(    (    s   /usr/lib/python2.7/sgmllib.pyt   errorn   s    c   	      C   s@  |  j  } d } t | É } x‚| | k  rˇ|  j rQ |  j | | | !É | } Pn  t j | | É } | rx | j É  } n | } | | k  r° |  j | | | !É n  | } | | k r∑ Pn  | | d k rlt j | | É r.|  j	 r|  j | | É | d } q n  |  j
 | É } | d k  r"Pn  | } q n  | j d | É rt|  j | É } | d k  r_Pn  | } d |  _	 q n  |  j	 rÆ| | d k rß|  j d É | d } q Pq n  | j d | É rÎ|  j | É } | d k  rﬂPn  | } q n  | j d | É r,|  j | É } | d k  rPn  | | } q n  | j d | É rä|  j | É } | d k  r]Pn  | } q qän| | d k r}|  j	 r¶|  j | | É | d } q n  t j | | É } | r| j d É } |  j | É | j d É } | | d d	 k r | d } q q n  t j | | É } | rä| j d É } |  j | É | j d É } | | d d	 k r | d } q q qän |  j d
 É t j | | É } | s√|  j | | É | d } q n  | j d É } | | k r‚Pn  |  j | | | !É | } q W| r/| | k  r/|  j | | | !É | } n  | | |  _  d  S(   Ni    t   <i   s   </s   <!--s   <?s   <!t   &t   ;s   neither < nor & ??(   R   t   lenR   t   handle_datat   interestingt   searcht   startt   starttagopent   matchR   t   parse_starttagt
   startswitht   parse_endtagt   parse_commentt   parse_pit   parse_declarationt   charreft   groupt   handle_charreft   endt	   entityreft   handle_entityrefR   t
   incomplete(	   R
   R2   R   t   it   nR(   t   jt   kt   name(    (    s   /usr/lib/python2.7/sgmllib.pyR   t   sæ    		  	
  		  
 		
  	

	t   =c         C   sé   |  j  } | | | d !d k r0 |  j d É n  t j | | d É } | sP d S| j d É } |  j | | d | !É | j d É } | | S(   Ni   s   <?s   unexpected call to parse_pi()iˇˇˇˇi    (   R   R   t   picloseR%   R&   t	   handle_piR2   (   R
   R6   R   R(   R8   (    (    s   /usr/lib/python2.7/sgmllib.pyR-   ﬁ   s    	c         C   s   |  j  S(   N(   R   (   R
   (    (    s   /usr/lib/python2.7/sgmllib.pyt   get_starttag_textÍ   s    c         C   s•  d  |  _ | } |  j } t j | | É r∑ t j | | É } | sF d S| j d d É \ } } d | |  _ | j É  } | j d É } |  j	 | | É | | | j d É d !|  _ | St
 j | | d É } | s◊ d S| j d É } g  }	 | | | d !d k r| } |  j } n[ t j | | d É } | sA|  j d É n  | j d É } | | d | !j É  } | |  _ xÒ | | k  rct j | | É } | sõPn  | j d d d É \ }
 } } | s»|
 } np | d  d	 k oÁ| d k n s| d  d
 k o| d k n r | d d !} n  |  j j |  j | É } |	 j |
 j É  | f É | j d É } qsW| | d k rÅ| d } n  | | | !|  _ |  j | |	 É | S(   Niˇˇˇˇi   i   s   <%s/i    s   <>s!   unexpected call to parse_starttagi   t   't   "R   (   R   R   R   t   shorttagopenR(   t   shorttagR0   t   lowerR2   t   finish_shorttagt
   endbracketR%   R&   R   t   tagfindR   t   attrfindt   entity_or_charreft   subt   _convert_reft   appendt   finish_starttag(   R
   R6   t	   start_posR   R(   t   tagR   R9   R8   t   attrst   attrnamet   restt	   attrvalue(    (    s   /usr/lib/python2.7/sgmllib.pyR)   Ó   s^    			 	$$	c         C   sÜ   | j  d É r9 |  j | j  d É É p8 d | j É  d S| j  d É rq |  j | j  d É É pp d | j  d É Sd | j  d É Sd  S(   Ni   s   &#%s%si   i   s   &%s;s   &%s(   R0   t   convert_charreft   groupst   convert_entityref(   R
   R(   (    (    s   /usr/lib/python2.7/sgmllib.pyRJ   ,  s    c         C   sÉ   |  j  } t j | | d É } | s) d S| j d É } | | d | !j É  j É  } | | d k rr | d } n  |  j | É | S(   Ni   iˇˇˇˇi    i   R   (   R   RE   R%   R&   t   stripRC   t   finish_endtag(   R
   R6   R   R(   R8   RN   (    (    s   /usr/lib/python2.7/sgmllib.pyR+   7  s    	c         C   s.   |  j  | g  É |  j | É |  j | É d  S(   N(   RL   R#   RW   (   R
   RN   R   (    (    s   /usr/lib/python2.7/sgmllib.pyRD   D  s    c         C   s©   y t  |  d | É } Wnd t k
 r} y t  |  d | É } Wn" t k
 rb |  j | | É d SX|  j | | | É d Sn( X|  j j | É |  j | | | É d Sd  S(   Nt   start_t   do_iˇˇˇˇi    i   (   t   getattrt   AttributeErrort   unknown_starttagt   handle_starttagR   RK   (   R
   RN   RO   t   method(    (    s   /usr/lib/python2.7/sgmllib.pyRL   K  s    c         C   sa  | s9 t  |  j É d } | d k  r” |  j | É d  Snö | |  j k rë y t |  d | É } Wn t k
 r |  j | É n X|  j | É d  St  |  j É } x0 t | É D]" } |  j | | k r≠ | } q≠ q≠ Wxá t  |  j É | k r\|  j d } y t |  d | É } Wn t k
 r(d  } n X| rB|  j | | É n |  j | É |  j d =q÷ Wd  S(   Ni   i    t   end_iˇˇˇˇ(	   R"   R   t   unknown_endtagRZ   R[   t   report_unbalancedt   rangeR   t   handle_endtag(   R
   RN   t   foundR^   R6   (    (    s   /usr/lib/python2.7/sgmllib.pyRW   ]  s4     
c         C   s   | | É d  S(   N(    (   R
   RN   R^   RO   (    (    s   /usr/lib/python2.7/sgmllib.pyR]   |  s    c         C   s   | É  d  S(   N(    (   R
   RN   R^   (    (    s   /usr/lib/python2.7/sgmllib.pyRc   Ä  s    c         C   s)   |  j  r% d | d GHd G|  j GHn  d  S(   Ns   *** Unbalanced </R   s
   *** Stack:(   R   R   (   R
   RN   (    (    s   /usr/lib/python2.7/sgmllib.pyRa   Ñ  s    	c         C   sR   y t  | É } Wn t k
 r$ d SXd | k o< d k n sE d S|  j | É S(   s/   Convert character reference, may be overridden.Ni    i   (   t   intt
   ValueErrort   convert_codepoint(   R
   R:   R7   (    (    s   /usr/lib/python2.7/sgmllib.pyRS   â  s    c         C   s
   t  | É S(   N(   t   chr(   R
   t	   codepoint(    (    s   /usr/lib/python2.7/sgmllib.pyRg   ì  s    c         C   s<   |  j  | É } | d k r+ |  j | É n |  j | É d S(   s0   Handle character reference, no need to override.N(   RS   R   t   unknown_charrefR#   (   R
   R:   t   replacement(    (    s   /usr/lib/python2.7/sgmllib.pyR1   ñ  s    R   t   ltR   t   gtR    t   ampR@   t   quots   't   aposc         C   s%   |  j  } | | k r | | Sd Sd S(   sµ   Convert entity references.

        As an alternative to overriding this method; one can tailor the
        results by setting up the self.entitydefs mapping appropriately.
        N(   t
   entitydefs(   R
   R:   t   table(    (    s   /usr/lib/python2.7/sgmllib.pyRU   ¢  s    	c         C   s<   |  j  | É } | d k r+ |  j | É n |  j | É d S(   s.   Handle entity references, no need to override.N(   RU   R   t   unknown_entityrefR#   (   R
   R:   Rk   (    (    s   /usr/lib/python2.7/sgmllib.pyR4   Æ  s    c         C   s   d  S(   N(    (   R
   R   (    (    s   /usr/lib/python2.7/sgmllib.pyR#   ∑  s    c         C   s   d  S(   N(    (   R
   R   (    (    s   /usr/lib/python2.7/sgmllib.pyt   handle_commentª  s    c         C   s   d  S(   N(    (   R
   t   decl(    (    s   /usr/lib/python2.7/sgmllib.pyt   handle_declø  s    c         C   s   d  S(   N(    (   R
   R   (    (    s   /usr/lib/python2.7/sgmllib.pyR=   √  s    c         C   s   d  S(   N(    (   R
   RN   RO   (    (    s   /usr/lib/python2.7/sgmllib.pyR\   «  s    c         C   s   d  S(   N(    (   R
   RN   (    (    s   /usr/lib/python2.7/sgmllib.pyR`   »  s    c         C   s   d  S(   N(    (   R
   t   ref(    (    s   /usr/lib/python2.7/sgmllib.pyRj   …  s    c         C   s   d  S(   N(    (   R
   Rw   (    (    s   /usr/lib/python2.7/sgmllib.pyRs      s    ('   R   R   t   ret   compileRH   R   R	   R   R   R   R   R   R   t   _decl_othercharsR-   R>   R)   RJ   R+   RD   RL   RW   R]   Rc   Ra   RS   Rg   R1   Rq   RU   R4   R#   Rt   Rv   R=   R\   R`   Rj   Rs   (    (    (    s   /usr/lib/python2.7/sgmllib.pyR   <   sF   	
						g			>									
		
)										t   TestSGMLParserc           B   se   e  Z d  d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d	 Ñ  Z
 d
 Ñ  Z RS(   i    c         C   s   d |  _  t j |  | É d  S(   NR   (   t   testdataR   R   (   R
   R   (    (    s   /usr/lib/python2.7/sgmllib.pyR   œ  s    	c         C   s<   |  j  | |  _  t t |  j  É É d k r8 |  j É  n  d  S(   NiF   (   R|   R"   t   reprt   flush(   R
   R   (    (    s   /usr/lib/python2.7/sgmllib.pyR#   ”  s    c         C   s.   |  j  } | r* d |  _  d Gt | É GHn  d  S(   NR   s   data:(   R|   R}   (   R
   R   (    (    s   /usr/lib/python2.7/sgmllib.pyR~   ÿ  s    		c         C   sN   |  j  É  t | É } t | É d k rA | d  d | d } n  d G| GHd  S(   NiD   i    s   ...i‡ˇˇˇs   comment:(   R~   R}   R"   (   R
   R   t   r(    (    s   /usr/lib/python2.7/sgmllib.pyRt   ﬁ  s
    
c         C   s\   |  j  É  | s  d | d GHn8 d | Gx( | D]  \ } } | d d | d Gq/ Wd GHd  S(   Ns   start tag: <R   R;   R@   (   R~   (   R
   RN   RO   R:   t   value(    (    s   /usr/lib/python2.7/sgmllib.pyR\   Â  s    
c         C   s   |  j  É  d | d GHd  S(   Ns   end tag: </R   (   R~   (   R
   RN   (    (    s   /usr/lib/python2.7/sgmllib.pyR`   Ô  s    
c         C   s   |  j  É  d | d GHd  S(   Ns   *** unknown entity ref: &R!   (   R~   (   R
   Rw   (    (    s   /usr/lib/python2.7/sgmllib.pyRs   Û  s    
c         C   s   |  j  É  d | d GHd  S(   Ns   *** unknown char ref: &#R!   (   R~   (   R
   Rw   (    (    s   /usr/lib/python2.7/sgmllib.pyRj   ˜  s    
c         C   s   |  j  É  d | d GHd  S(   Ns   *** unknown decl: [t   ](   R~   (   R
   R   (    (    s   /usr/lib/python2.7/sgmllib.pyt   unknown_decl˚  s    
c         C   s   t  j |  É |  j É  d  S(   N(   R   R   R~   (   R
   (    (    s   /usr/lib/python2.7/sgmllib.pyR   ˇ  s    (   R   R   R   R#   R~   Rt   R\   R`   Rs   Rj   RÇ   R   (    (    (    s   /usr/lib/python2.7/sgmllib.pyR{   Õ  s   				
				c   	      C   s(  d d  l  } |  d  k r( | j d }  n  |  rQ |  d d k rQ |  d }  t } n t } |  rj |  d } n d } | d k rà | j } nC y t | d É } Wn- t k
 r  } | Gd G| GH| j d É n X| j	 É  } | | j k	 rÛ | j
 É  n  | É  } x | D] } | j | É qW| j
 É  d  S(	   Niˇˇˇˇi   i    s   -ss	   test.htmlt   -R   t   :(   t   sysR   t   argvR   R{   t   stdint   opent   IOErrort   exitt   readR   R   (	   R   RÖ   t   klasst   filet   ft   msgR   t   xt   c(    (    s   /usr/lib/python2.7/sgmllib.pyt   test  s0    
		t   __main__(   R   t   warningsR    R   Rx   t   __all__Ry   R$   R5   R3   R/   R'   RA   RB   R<   RE   RF   RG   t   RuntimeErrorR   R   R   R{   R   Rí   R   (    (    (    s   /usr/lib/python2.7/sgmllib.pyt   <module>   s4   		ˇ í7$                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   s  d  Z  y d d l m Z m Z Wn' e k
 rI d d l m Z m Z n Xy d d l m Z Wn! e k
 rÅ d d l m Z n Xd d l Z d d d d g Z	 d	 e j
 f d
 Ñ  É  YZ d e j
 f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d d e d Ñ Z d S(   s¥
  Manage shelves of pickled objects.

A "shelf" is a persistent, dictionary-like object.  The difference
with dbm databases is that the values (not the keys!) in a shelf can
be essentially arbitrary Python objects -- anything that the "pickle"
module can handle.  This includes most class instances, recursive data
types, and objects containing lots of shared sub-objects.  The keys
are ordinary strings.

To summarize the interface (key is a string, data is an arbitrary
object):

        import shelve
        d = shelve.open(filename) # open, with (g)dbm filename -- no suffix

        d[key] = data   # store data at key (overwrites old data if
                        # using an existing key)
        data = d[key]   # retrieve a COPY of the data at key (raise
                        # KeyError if no such key) -- NOTE that this
                        # access returns a *copy* of the entry!
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = d.has_key(key)   # true if the key exists; same as "key in d"
        list = d.keys() # a list of all existing keys (slow!)

        d.close()       # close it

Dependent on the implementation, closing a persistent dictionary may
or may not be necessary to flush changes to disk.

Normally, d[key] returns a COPY of the entry.  This needs care when
mutable entries are mutated: for example, if d[key] is a list,
        d[key].append(anitem)
does NOT modify the entry d[key] itself, as stored in the persistent
mapping -- it only modifies the copy, which is then immediately
discarded, so that the append has NO effect whatsoever.  To append an
item to d[key] in a way that will affect the persistent mapping, use:
        data = d[key]
        data.append(anitem)
        d[key] = data

To avoid the problem with mutable entries, you may pass the keyword
argument writeback=True in the call to shelve.open.  When you use:
        d = shelve.open(filename, writeback=True)
then d keeps a cache of all entries you access, and writes them all back
to the persistent mapping when you call d.close().  This ensures that
such usage as d[key].append(anitem) works as intended.

However, using keyword argument writeback=True may consume vast amount
of memory for the cache, and it may make d.close() very slow, if you
access many of d's entries after opening it in this way: d has no way to
check which of the entries you access are mutable and/or which ones you
actually mutate, so it must cache, and write back at close, all of the
entries that you access.  You can call d.sync() to write back all the
entries in the cache, and empty the cache (d.sync() also synchronizes
the persistent dictionary on disk, if feasible).
iˇˇˇˇ(   t   Picklert	   Unpickler(   t   StringIONt   Shelft
   BsdDbShelft   DbfilenameShelft   opent   _ClosedDictc           B   s2   e  Z d  Z d Ñ  Z e Z Z Z Z d Ñ  Z RS(   s>   Marker for a closed dict.  Access attempts raise a ValueError.c         G   s   t  d É Ç d  S(   Ns!   invalid operation on closed shelf(   t
   ValueError(   t   selft   args(    (    s   /usr/lib/python2.7/shelve.pyt   closedN   s    c         C   s   d S(   Ns   <Closed Dictionary>(    (   R	   (    (    s   /usr/lib/python2.7/shelve.pyt   __repr__R   s    (	   t   __name__t
   __module__t   __doc__R   t   __getitem__t   __setitem__t   __delitem__t   keysR   (    (    (    s   /usr/lib/python2.7/shelve.pyR   K   s   	c           B   sÉ   e  Z d  Z d e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d d Ñ Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z RS(   s®   Base class for shelf implementations.

    This is initialized with a dictionary-like object.
    See the module's __doc__ string for an overview of the interface.
    c         C   s=   | |  _  | d  k r d } n  | |  _ | |  _ i  |  _ d  S(   Ni    (   t   dictt   Nonet	   _protocolt	   writebackt   cache(   R	   R   t   protocolR   (    (    s   /usr/lib/python2.7/shelve.pyt   __init__\   s    				c         C   s   |  j  j É  S(   N(   R   R   (   R	   (    (    s   /usr/lib/python2.7/shelve.pyR   d   s    c         C   s   t  |  j É S(   N(   t   lenR   (   R	   (    (    s   /usr/lib/python2.7/shelve.pyt   __len__g   s    c         C   s   | |  j  k S(   N(   R   (   R	   t   key(    (    s   /usr/lib/python2.7/shelve.pyt   has_keyj   s    c         C   s   | |  j  k S(   N(   R   (   R	   R   (    (    s   /usr/lib/python2.7/shelve.pyt   __contains__m   s    c         C   s   | |  j  k r |  | S| S(   N(   R   (   R	   R   t   default(    (    s   /usr/lib/python2.7/shelve.pyt   getp   s    c         C   sg   y |  j  | } WnO t k
 rb t |  j | É } t | É j É  } |  j rc | |  j  | <qc n X| S(   N(   R   t   KeyErrorR   R   R   t   loadR   (   R	   R   t   valuet   f(    (    s   /usr/lib/python2.7/shelve.pyR   u   s    	c         C   sX   |  j  r | |  j | <n  t É  } t | |  j É } | j | É | j É  |  j | <d  S(   N(   R   R   R   R    R   t   dumpt   getvalueR   (   R	   R   R$   R%   t   p(    (    s   /usr/lib/python2.7/shelve.pyR      s    		c         C   s0   |  j  | =y |  j | =Wn t k
 r+ n Xd  S(   N(   R   R   R"   (   R	   R   (    (    s   /usr/lib/python2.7/shelve.pyR   á   s
    
c         C   sq   |  j  d  k r d  Sz3 |  j É  y |  j  j É  Wn t k
 rD n XWd  y t É  |  _  Wn d  |  _  n XXd  S(   N(   R   R   t   synct   closet   AttributeErrorR   (   R	   (    (    s   /usr/lib/python2.7/shelve.pyR*   é   s    
c         C   s!   t  |  d É s d  S|  j É  d  S(   NR   (   t   hasattrR*   (   R	   (    (    s   /usr/lib/python2.7/shelve.pyt   __del__ü   s    c         C   sÄ   |  j  rZ |  j rZ t |  _  x' |  j j É  D] \ } } | |  | <q+ Wt |  _  i  |  _ n  t |  j d É r| |  j j É  n  d  S(   NR)   (   R   R   t   Falset	   iteritemst   TrueR,   R   R)   (   R	   R   t   entry(    (    s   /usr/lib/python2.7/shelve.pyR)   •   s    		N(   R   R   R   R   R.   R   R   R   R   R   R!   R   R   R   R*   R-   R)   (    (    (    s   /usr/lib/python2.7/shelve.pyR   U   s   					
				c           B   sJ   e  Z d  Z d e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   s≤  Shelf implementation using the "BSD" db interface.

    This adds methods first(), next(), previous(), last() and
    set_location() that have no counterpart in [g]dbm databases.

    The actual database must be opened using one of the "bsddb"
    modules "open" routines (i.e. bsddb.hashopen, bsddb.btopen or
    bsddb.rnopen) and passed to the constructor.

    See the module's __doc__ string for an overview of the interface.
    c         C   s   t  j |  | | | É d  S(   N(   R   R   (   R	   R   R   R   (    (    s   /usr/lib/python2.7/shelve.pyR   Ω   s    c         C   s:   |  j  j | É \ } } t | É } | t | É j É  f S(   N(   R   t   set_locationR   R   R#   (   R	   R   R$   R%   (    (    s   /usr/lib/python2.7/shelve.pyR2   ¿   s    c         C   s7   |  j  j É  \ } } t | É } | t | É j É  f S(   N(   R   t   nextR   R   R#   (   R	   R   R$   R%   (    (    s   /usr/lib/python2.7/shelve.pyR3   ≈   s    c         C   s7   |  j  j É  \ } } t | É } | t | É j É  f S(   N(   R   t   previousR   R   R#   (   R	   R   R$   R%   (    (    s   /usr/lib/python2.7/shelve.pyR4       s    c         C   s7   |  j  j É  \ } } t | É } | t | É j É  f S(   N(   R   t   firstR   R   R#   (   R	   R   R$   R%   (    (    s   /usr/lib/python2.7/shelve.pyR5   œ   s    c         C   s7   |  j  j É  \ } } t | É } | t | É j É  f S(   N(   R   t   lastR   R   R#   (   R	   R   R$   R%   (    (    s   /usr/lib/python2.7/shelve.pyR6   ‘   s    N(   R   R   R   R   R.   R   R2   R3   R4   R5   R6   (    (    (    s   /usr/lib/python2.7/shelve.pyR   ∞   s   				c           B   s    e  Z d  Z d d e d Ñ Z RS(   s    Shelf implementation using the "anydbm" generic dbm interface.

    This is initialized with the filename for the dbm database.
    See the module's __doc__ string for an overview of the interface.
    t   cc         C   s2   d d  l  } t j |  | j | | É | | É d  S(   Niˇˇˇˇ(   t   anydbmR   R   R   (   R	   t   filenamet   flagR   R   R8   (    (    s   /usr/lib/python2.7/shelve.pyR   ·   s    N(   R   R   R   R   R.   R   (    (    (    s   /usr/lib/python2.7/shelve.pyR   ⁄   s   R7   c         C   s   t  |  | | | É S(   s  Open a persistent dictionary for reading and writing.

    The filename parameter is the base filename for the underlying
    database.  As a side-effect, an extension may be added to the
    filename and more than one file may be created.  The optional flag
    parameter has the same interpretation as the flag parameter of
    anydbm.open(). The optional protocol parameter specifies the
    version of the pickle protocol (0, 1, or 2).

    See the module's __doc__ string for an overview of the interface.
    (   R   (   R9   R:   R   R   (    (    s   /usr/lib/python2.7/shelve.pyR   Ê   s    (   R   t   cPickleR    R   t   ImportErrort   picklet	   cStringIOR   t   UserDictt   __all__t	   DictMixinR   R   R   R   R   R.   R   (    (    (    s   /usr/lib/python2.7/shelve.pyt   <module>9   s   
[*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # -*- coding: iso-8859-1 -*-
"""A lexical analyzer class for simple shell-like syntaxes."""

# Module and documentation by Eric S. Raymond, 21 Dec 1998
# Input stacking and error message cleanup added by ESR, March 2000
# push_source() and pop_source() made explicit by ESR, January 2001.
# Posix compliance, split(), string arguments, and
# iterator interface by Gustavo Niemeyer, April 2003.

import os.path
import sys
from collections import deque

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

__all__ = ["shlex", "split"]

class shlex:
    "A lexical analyzer class for simple shell-like syntaxes."
    def __init__(self, instream=None, infile=None, posix=False):
        if isinstance(instream, basestring):
            instream = StringIO(instream)
        if instream is not None:
            self.instream = instream
            self.infile = infile
        else:
            self.instream = sys.stdin
            self.infile = None
        self.posix = posix
        if posix:
            self.eof = None
        else:
            self.eof = ''
        self.commenters = '#'
        self.wordchars = ('abcdfeghijklmnopqrstuvwxyz'
                          'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_')
        if self.posix:
            self.wordchars += ('ﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ¯˘˙˚¸˝˛ˇ'
                               '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷ÿŸ⁄€‹›ﬁ')
        self.whitespace = ' \t\r\n'
        self.whitespace_split = False
        self.quotes = '\'"'
        self.escape = '\\'
        self.escapedquotes = '"'
        self.state = ' '
        self.pushback = deque()
        self.lineno = 1
        self.debug = 0
        self.token = ''
        self.filestack = deque()
        self.source = None
        if self.debug:
            print 'shlex: reading from %s, line %d' \
                  % (self.instream, self.lineno)

    def push_token(self, tok):
        "Push a token onto the stack popped by the get_token method"
        if self.debug >= 1:
            print "shlex: pushing token " + repr(tok)
        self.pushback.appendleft(tok)

    def push_source(self, newstream, newfile=None):
        "Push an input source onto the lexer's input source stack."
        if isinstance(newstream, basestring):
            newstream = StringIO(newstream)
        self.filestack.appendleft((self.infile, self.instream, self.lineno))
        self.infile = newfile
        self.instream = newstream
        self.lineno = 1
        if self.debug:
            if newfile is not None:
                print 'shlex: pushing to file %s' % (self.infile,)
            else:
                print 'shlex: pushing to stream %s' % (self.instream,)

    def pop_source(self):
        "Pop the input source stack."
        self.instream.close()
        (self.infile, self.instream, self.lineno) = self.filestack.popleft()
        if self.debug:
            print 'shlex: popping to %s, line %d' \
                  % (self.instream, self.lineno)
        self.state = ' '

    def get_token(self):
        "Get a token from the input stream (or from stack if it's nonempty)"
        if self.pushback:
            tok = self.pushback.popleft()
            if self.debug >= 1:
                print "shlex: popping token " + repr(tok)
            return tok
        # No pushback.  Get a token.
        raw = self.read_token()
        # Handle inclusions
        if self.source is not None:
            while raw == self.source:
                spec = self.sourcehook(self.read_token())
                if spec:
                    (newfile, newstream) = spec
                    self.push_source(newstream, newfile)
                raw = self.get_token()
        # Maybe we got EOF instead?
        while raw == self.eof:
            if not self.filestack:
                return self.eof
            else:
                self.pop_source()
                raw = self.get_token()
        # Neither inclusion nor EOF
        if self.debug >= 1:
            if raw != self.eof:
                print "shlex: token=" + repr(raw)
            else:
                print "shlex: token=EOF"
        return raw

    def read_token(self):
        quoted = False
        escapedstate = ' '
        while True:
            nextchar = self.instream.read(1)
            if nextchar == '\n':
                self.lineno = self.lineno + 1
            if self.debug >= 3:
                print "shlex: in state", repr(self.state), \
                      "I see character:", repr(nextchar)
            if self.state is None:
                self.token = ''        # past end of file
                break
            elif self.state == ' ':
                if not nextchar:
                    self.state = None  # end of file
                    break
                elif nextchar in self.whitespace:
                    if self.debug >= 2:
                        print "shlex: I see whitespace in whitespace state"
                    if self.token or (self.posix and quoted):
                        break   # emit current token
                    else:
                        continue
                elif nextchar in self.commenters:
                    self.instream.readline()
                    self.lineno = self.lineno + 1
                elif self.posix and nextchar in self.escape:
                    escapedstate = 'a'
                    self.state = nextchar
                elif nextchar in self.wordchars:
                    self.token = nextchar
                    self.state = 'a'
                elif nextchar in self.quotes:
                    if not self.posix:
                        self.token = nextchar
                    self.state = nextchar
                elif self.whitespace_split:
                    self.token = nextchar
                    self.state = 'a'
                else:
                    self.token = nextchar
                    if self.token or (self.posix and quoted):
                        break   # emit current token
                    else:
                        continue
            elif self.state in self.quotes:
                quoted = True
                if not nextchar:      # end of file
                    if self.debug >= 2:
                        print "shlex: I see EOF in quotes state"
                    # XXX what error should be raised here?
                    raise ValueError, "No closing quotation"
                if nextchar == self.state:
                    if not self.posix:
                        self.token = self.token + nextchar
                        self.state = ' '
                        break
                    else:
                        self.state = 'a'
                elif self.posix and nextchar in self.escape and \
                     self.state in self.escapedquotes:
                    escapedstate = self.state
                    self.state = nextchar
                else:
                    self.token = self.token + nextchar
            elif self.state in self.escape:
                if not nextchar:      # end of file
                    if self.debug >= 2:
                        print "shlex: I see EOF in escape state"
                    # XXX what error should be raised here?
                    raise ValueError, "No escaped character"
                # In posix shells, only the quote itself or the escape
                # character may be escaped within quotes.
                if escapedstate in self.quotes and \
                   nextchar != self.state and nextchar != escapedstate:
                    self.token = self.token + self.state
                self.token = self.token + nextchar
                self.state = escapedstate
            elif self.state == 'a':
                if not nextchar:
                    self.state = None   # end of file
                    break
                elif nextchar in self.whitespace:
                    if self.debug >= 2:
                        print "shlex: I see whitespace in word state"
                    self.state = ' '
                    if self.token or (self.posix and quoted):
                        break   # emit current token
                    else:
                        continue
                elif nextchar in self.commenters:
                    self.instream.readline()
                    self.lineno = self.lineno + 1
                    if self.posix:
                        self.state = ' '
                        if self.token or (self.posix and quoted):
                            break   # emit current token
                        else:
                            continue
                elif self.posix and nextchar in self.quotes:
                    self.state = nextchar
                elif self.posix and nextchar in self.escape:
                    escapedstate = 'a'
                    self.state = nextchar
                elif nextchar in self.wordchars or nextchar in self.quotes \
                    or self.whitespace_split:
                    self.token = self.token + nextchar
                else:
                    self.pushback.appendleft(nextchar)
                    if self.debug >= 2:
                        print "shlex: I see punctuation in word state"
                    self.state = ' '
                    if self.token or (self.posix and quoted):
                        break   # emit current token
                    else:
                        continue
        result = self.token
        self.token = ''
        if self.posix and not quoted and result == '':
            result = None
        if self.debug > 1:
            if result:
                print "shlex: raw token=" + repr(result)
            else:
                print "shlex: raw token=EOF"
        return result

    def sourcehook(self, newfile):
        "Hook called on a filename to be sourced."
        if newfile[0] == '"':
            newfile = newfile[1:-1]
        # This implements cpp-like semantics for relative-path inclusion.
        if isinstance(self.infile, basestring) and not os.path.isabs(newfile):
            newfile = os.path.join(os.path.dirname(self.infile), newfile)
        return (newfile, open(newfile, "r"))

    def error_leader(self, infile=None, lineno=None):
        "Emit a C-compiler-like, Emacs-friendly error-message leader."
        if infile is None:
            infile = self.infile
        if lineno is None:
            lineno = self.lineno
        return "\"%s\", line %d: " % (infile, lineno)

    def __iter__(self):
        return self

    def next(self):
        token = self.get_token()
        if token == self.eof:
            raise StopIteration
        return token

def split(s, comments=False, posix=True):
    lex = shlex(s, posix=posix)
    lex.whitespace_split = True
    if not comments:
        lex.commenters = ''
    return list(lex)

if __name__ == '__main__':
    if len(sys.argv) == 1:
        lexer = shlex()
    else:
        file = sys.argv[1]
        lexer = shlex(open(file), file)
    while 1:
        tt = lexer.get_token()
        if tt:
            print "Token: " + repr(tt)
        else:
            break
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   s  d  Z  d d l Z d d l Z d d l m Z y d d l m Z Wn! e k
 re d d l m Z n Xd d g Z	 d d d Ñ  É  YZ
 e e d Ñ Z e d	 k re e j É d
 k r¡ e
 É  Z n" e j d
 Z e
 e e É e É Z x, e j É  Z e r
d e e É GHqÊ PqÊ Wn  d S(   s8   A lexical analyzer class for simple shell-like syntaxes.iˇˇˇˇN(   t   deque(   t   StringIOt   shlext   splitc           B   sz   e  Z d  Z d d e d Ñ Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d d d Ñ Z d	 Ñ  Z d
 Ñ  Z RS(   s8   A lexical analyzer class for simple shell-like syntaxes.c         C   s<  t  | t É r t | É } n  | d  k	 r? | |  _ | |  _ n t j |  _ d  |  _ | |  _ | ro d  |  _	 n	 d |  _	 d |  _
 d |  _ |  j r• |  j d 7_ n  d |  _ t |  _ d |  _ d |  _ d |  _ d	 |  _ t É  |  _ d
 |  _ d |  _ d |  _ t É  |  _ d  |  _ |  j r8d |  j |  j f GHn  d  S(   Nt    t   #t?   abcdfeghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_s>   ﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ¯˘˙˚¸˝˛ˇ¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷ÿŸ⁄€‹›ﬁs    	
s   '"s   \t   "t    i   i    s   shlex: reading from %s, line %d(   t
   isinstancet
   basestringR   t   Nonet   instreamt   infilet   syst   stdint   posixt   eoft
   commenterst	   wordcharst
   whitespacet   Falset   whitespace_splitt   quotest   escapet   escapedquotest   stateR    t   pushbackt   linenot   debugt   tokent	   filestackt   source(   t   selfR   R   R   (    (    s   /usr/lib/python2.7/shlex.pyt   __init__   s<    																		c         C   s5   |  j  d k r! d t | É GHn  |  j j | É d S(   s:   Push a token onto the stack popped by the get_token methodi   s   shlex: pushing token N(   R   t   reprR   t
   appendleft(   R!   t   tok(    (    s   /usr/lib/python2.7/shlex.pyt
   push_token;   s    c         C   sò   t  | t É r t | É } n  |  j j |  j |  j |  j f É | |  _ | |  _ d |  _ |  j rî | d k	 rÇ d |  j f GHqî d |  j f GHn  d S(   s9   Push an input source onto the lexer's input source stack.i   s   shlex: pushing to file %ss   shlex: pushing to stream %sN(
   R	   R
   R   R   R$   R   R   R   R   R   (   R!   t	   newstreamt   newfile(    (    s   /usr/lib/python2.7/shlex.pyt   push_sourceA   s    "				c         C   s\   |  j  j É  |  j j É  \ |  _ |  _  |  _ |  j rO d |  j  |  j f GHn  d |  _ d S(   s   Pop the input source stack.s   shlex: popping to %s, line %dR   N(   R   t   closeR   t   popleftR   R   R   R   (   R!   (    (    s   /usr/lib/python2.7/shlex.pyt
   pop_sourceO   s    !	c         C   s/  |  j  r= |  j  j É  } |  j d k r9 d t | É GHn  | S|  j É  } |  j d k	 r∑ x\ | |  j k r≥ |  j |  j É  É } | r§ | \ } } |  j | | É n  |  j	 É  } q[ Wn  x9 | |  j
 k rÚ |  j sŸ |  j
 S|  j É  |  j	 É  } q∫ W|  j d k r+| |  j
 k r#d t | É GHq+d GHn  | S(   sB   Get a token from the input stream (or from stack if it's nonempty)i   s   shlex: popping token s   shlex: token=s   shlex: token=EOFN(   R   R+   R   R#   t
   read_tokenR    R   t
   sourcehookR)   t	   get_tokenR   R   R,   (   R!   R%   t   rawt   specR(   R'   (    (    s   /usr/lib/python2.7/shlex.pyR/   X   s.    		
c         C   s}  t  } d } xt r|  j j d É } | d k rF |  j d |  _ n  |  j d k rx d Gt |  j É Gd Gt | É GHn  |  j d  k rî d |  _	 Pq |  j d k rÙ| s∂ d  |  _ Pq| |  j
 k r˛ |  j d k r‹ d	 GHn  |  j	 sÙ |  j r | r PqÒq q| |  j k r-|  j j É  |  j d |  _ q|  j rW| |  j k rWd
 } | |  _ q| |  j k r{| |  _	 d
 |  _ q| |  j k r´|  j sü| |  _	 n  | |  _ q|  j r…| |  _	 d
 |  _ q| |  _	 |  j	 sÍ|  j r | r Pqq q |  j |  j k r»t } | s5|  j d k r)d GHn  t d Ç n  | |  j k rv|  j sj|  j	 | |  _	 d |  _ Pq≈d
 |  _ q|  j rµ| |  j k rµ|  j |  j k rµ|  j } | |  _ q|  j	 | |  _	 q |  j |  j k r_| s|  j d k r˜d GHn  t d Ç n  | |  j k rC| |  j k rC| | k rC|  j	 |  j |  _	 n  |  j	 | |  _	 | |  _ q |  j d
 k r | sÅd  |  _ Pq| |  j
 k r“|  j d k rßd GHn  d |  _ |  j	 s»|  j r | r Pqq q| |  j k r5|  j j É  |  j d |  _ |  j rd |  _ |  j	 s(|  j r | r Pq2q qq|  j rY| |  j k rY| |  _ q|  j rÉ| |  j k rÉd
 } | |  _ q| |  j k s™| |  j k s™|  j rΩ|  j	 | |  _	 q|  j j | É |  j d k r‰d GHn  d |  _ |  j	 s|  j r | r Pqq q q W|  j	 } d |  _	 |  j rJ| rJ| d k rJd  } n  |  j d k ry| rqd t | É GHqyd GHn  | S(   NR   i   s   
i   s   shlex: in states   I see character:R   i   s+   shlex: I see whitespace in whitespace statet   as    shlex: I see EOF in quotes states   No closing quotations    shlex: I see EOF in escape states   No escaped characters%   shlex: I see whitespace in word states&   shlex: I see punctuation in word states   shlex: raw token=s   shlex: raw token=EOF(   R   t   TrueR   t   readR   R   R#   R   R   R   R   R   R   t   readlineR   R   R   R   t
   ValueErrorR   R   R$   (   R!   t   quotedt   escapedstatet   nextchart   result(    (    s   /usr/lib/python2.7/shlex.pyR-   x   s‡    																		
			c         C   s   | d d k r  | d d !} n  t  |  j t É rl t j j | É rl t j j t j j |  j É | É } n  | t | d É f S(   s(   Hook called on a filename to be sourced.i    R   i   iˇˇˇˇt   r(	   R	   R   R
   t   ost   patht   isabst   joint   dirnamet   open(   R!   R(   (    (    s   /usr/lib/python2.7/shlex.pyR.   ¯   s
    %'c         C   s>   | d k r |  j } n  | d k r0 |  j } n  d | | f S(   s<   Emit a C-compiler-like, Emacs-friendly error-message leader.s   "%s", line %d: N(   R   R   R   (   R!   R   R   (    (    s   /usr/lib/python2.7/shlex.pyt   error_leader  s
    c         C   s   |  S(   N(    (   R!   (    (    s   /usr/lib/python2.7/shlex.pyt   __iter__	  s    c         C   s(   |  j  É  } | |  j k r$ t Ç n  | S(   N(   R/   R   t   StopIteration(   R!   R   (    (    s   /usr/lib/python2.7/shlex.pyt   next  s    	N(   t   __name__t
   __module__t   __doc__R   R   R"   R&   R)   R,   R/   R-   R.   RB   RC   RE   (    (    (    s   /usr/lib/python2.7/shlex.pyR      s   $				 	Ä			c         C   s7   t  |  d | É} t | _ | s- d | _ n  t | É S(   NR   R   (   R   R3   R   R   t   list(   t   st   commentsR   t   lex(    (    s   /usr/lib/python2.7/shlex.pyR     s
    	t   __main__i   s   Token: (    (   RH   t   os.pathR<   R   t   collectionsR    t	   cStringIOR   t   ImportErrort   __all__R   R   R3   R   RF   t   lent   argvt   lexert   fileRA   R/   t   ttR#   (    (    (    s   /usr/lib/python2.7/shlex.pyt   <module>   s(   ˝                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """Utility functions for copying and archiving files and directory trees.

XXX The functions here don't copy the resource fork or other metadata on Mac.

"""

import os
import sys
import stat
from os.path import abspath
import fnmatch
import collections
import errno

try:
    from pwd import getpwnam
except ImportError:
    getpwnam = None

try:
    from grp import getgrnam
except ImportError:
    getgrnam = None

__all__ = ["copyfileobj", "copyfile", "copymode", "copystat", "copy", "copy2",
           "copytree", "move", "rmtree", "Error", "SpecialFileError",
           "ExecError", "make_archive", "get_archive_formats",
           "register_archive_format", "unregister_archive_format",
           "ignore_patterns"]

class Error(EnvironmentError):
    pass

class SpecialFileError(EnvironmentError):
    """Raised when trying to do a kind of operation (e.g. copying) which is
    not supported on a special file (e.g. a named pipe)"""

class ExecError(EnvironmentError):
    """Raised when a command could not be executed"""

try:
    WindowsError
except NameError:
    WindowsError = None

def copyfileobj(fsrc, fdst, length=16*1024):
    """copy data from file-like object fsrc to file-like object fdst"""
    while 1:
        buf = fsrc.read(length)
        if not buf:
            break
        fdst.write(buf)

def _samefile(src, dst):
    # Macintosh, Unix.
    if hasattr(os.path, 'samefile'):
        try:
            return os.path.samefile(src, dst)
        except OSError:
            return False

    # All other platforms: check for same pathname.
    return (os.path.normcase(os.path.abspath(src)) ==
            os.path.normcase(os.path.abspath(dst)))

def copyfile(src, dst):
    """Copy data from src to dst"""
    if _samefile(src, dst):
        raise Error("`%s` and `%s` are the same file" % (src, dst))

    for fn in [src, dst]:
        try:
            st = os.stat(fn)
        except OSError:
            # File most likely does not exist
            pass
        else:
            # XXX What about other special files? (sockets, devices...)
            if stat.S_ISFIFO(st.st_mode):
                raise SpecialFileError("`%s` is a named pipe" % fn)

    with open(src, 'rb') as fsrc:
        with open(dst, 'wb') as fdst:
            copyfileobj(fsrc, fdst)

def copymode(src, dst):
    """Copy mode bits from src to dst"""
    if hasattr(os, 'chmod'):
        st = os.stat(src)
        mode = stat.S_IMODE(st.st_mode)
        os.chmod(dst, mode)

def copystat(src, dst):
    """Copy all stat info (mode bits, atime, mtime, flags) from src to dst"""
    st = os.stat(src)
    mode = stat.S_IMODE(st.st_mode)
    if hasattr(os, 'utime'):
        os.utime(dst, (st.st_atime, st.st_mtime))
    if hasattr(os, 'chmod'):
        os.chmod(dst, mode)
    if hasattr(os, 'chflags') and hasattr(st, 'st_flags'):
        try:
            os.chflags(dst, st.st_flags)
        except OSError, why:
            for err in 'EOPNOTSUPP', 'ENOTSUP':
                if hasattr(errno, err) and why.errno == getattr(errno, err):
                    break
            else:
                raise

def copy(src, dst):
    """Copy data and mode bits ("cp src dst").

    The destination may be a directory.

    """
    if os.path.isdir(dst):
        dst = os.path.join(dst, os.path.basename(src))
    copyfile(src, dst)
    copymode(src, dst)

def copy2(src, dst):
    """Copy data and all stat info ("cp -p src dst").

    The destination may be a directory.

    """
    if os.path.isdir(dst):
        dst = os.path.join(dst, os.path.basename(src))
    copyfile(src, dst)
    copystat(src, dst)

def ignore_patterns(*patterns):
    """Function that can be used as copytree() ignore parameter.

    Patterns is a sequence of glob-style patterns
    that are used to exclude files"""
    def _ignore_patterns(path, names):
        ignored_names = []
        for pattern in patterns:
            ignored_names.extend(fnmatch.filter(names, pattern))
        return set(ignored_names)
    return _ignore_patterns

def copytree(src, dst, symlinks=False, ignore=None):
    """Recursively copy a directory tree using copy2().

    The destination directory must not already exist.
    If exception(s) occur, an Error is raised with a list of reasons.

    If the optional symlinks flag is true, symbolic links in the
    source tree result in symbolic links in the destination tree; if
    it is false, the contents of the files pointed to by symbolic
    links are copied.

    The optional ignore argument is a callable. If given, it
    is called with the `src` parameter, which is the directory
    being visited by copytree(), and `names` which is the list of
    `src` contents, as returned by os.listdir():

        callable(src, names) -> ignored_names

    Since copytree() is called recursively, the callable will be
    called once for each directory that is copied. It returns a
    list of names relative to the `src` directory that should
    not be copied.

    XXX Consider this example code rather than the ultimate tool.

    """
    names = os.listdir(src)
    if ignore is not None:
        ignored_names = ignore(src, names)
    else:
        ignored_names = set()

    os.makedirs(dst)
    errors = []
    for name in names:
        if name in ignored_names:
            continue
        srcname = os.path.join(src, name)
        dstname = os.path.join(dst, name)
        try:
            if symlinks and os.path.islink(srcname):
                linkto = os.readlink(srcname)
                os.symlink(linkto, dstname)
            elif os.path.isdir(srcname):
                copytree(srcname, dstname, symlinks, ignore)
            else:
                # Will raise a SpecialFileError for unsupported file types
                copy2(srcname, dstname)
        # catch the Error from the recursive copytree so that we can
        # continue with other files
        except Error, err:
            errors.extend(err.args[0])
        except EnvironmentError, why:
            errors.append((srcname, dstname, str(why)))
    try:
        copystat(src, dst)
    except OSError, why:
        if WindowsError is not None and isinstance(why, WindowsError):
            # Copying file access times may fail on Windows
            pass
        else:
            errors.append((src, dst, str(why)))
    if errors:
        raise Error, errors

def rmtree(path, ignore_errors=False, onerror=None):
    """Recursively delete a directory tree.

    If ignore_errors is set, errors are ignored; otherwise, if onerror
    is set, it is called to handle the error with arguments (func,
    path, exc_info) where func is os.listdir, os.remove, or os.rmdir;
    path is the argument to that function that caused it to fail; and
    exc_info is a tuple returned by sys.exc_info().  If ignore_errors
    is false and onerror is None, an exception is raised.

    """
    if ignore_errors:
        def onerror(*args):
            pass
    elif onerror is None:
        def onerror(*args):
            raise
    try:
        if os.path.islink(path):
            # symlinks to directories are forbidden, see bug #1669
            raise OSError("Cannot call rmtree on a symbolic link")
    except OSError:
        onerror(os.path.islink, path, sys.exc_info())
        # can't continue even if onerror hook returns
        return
    names = []
    try:
        names = os.listdir(path)
    except os.error, err:
        onerror(os.listdir, path, sys.exc_info())
    for name in names:
        fullname = os.path.join(path, name)
        try:
            mode = os.lstat(fullname).st_mode
        except os.error:
            mode = 0
        if stat.S_ISDIR(mode):
            rmtree(fullname, ignore_errors, onerror)
        else:
            try:
                os.remove(fullname)
            except os.error, err:
                onerror(os.remove, fullname, sys.exc_info())
    try:
        os.rmdir(path)
    except os.error:
        onerror(os.rmdir, path, sys.exc_info())


def _basename(path):
    # A basename() variant which first strips the trailing slash, if present.
    # Thus we always get the last component of the path, even for directories.
    sep = os.path.sep + (os.path.altsep or '')
    return os.path.basename(path.rstrip(sep))

def move(src, dst):
    """Recursively move a file or directory to another location. This is
    similar to the Unix "mv" command.

    If the destination is a directory or a symlink to a directory, the source
    is moved inside the directory. The destination path must not already
    exist.

    If the destination already exists but is not a directory, it may be
    overwritten depending on os.rename() semantics.

    If the destination is on our current filesystem, then rename() is used.
    Otherwise, src is copied to the destination and then removed.
    A lot more could be done here...  A look at a mv.c shows a lot of
    the issues this implementation glosses over.

    """
    real_dst = dst
    if os.path.isdir(dst):
        if _samefile(src, dst):
            # We might be on a case insensitive filesystem,
            # perform the rename anyway.
            os.rename(src, dst)
            return

        real_dst = os.path.join(dst, _basename(src))
        if os.path.exists(real_dst):
            raise Error, "Destination path '%s' already exists" % real_dst
    try:
        os.rename(src, real_dst)
    except OSError:
        if os.path.isdir(src):
            if _destinsrc(src, dst):
                raise Error, "Cannot move a directory '%s' into itself '%s'." % (src, dst)
            copytree(src, real_dst, symlinks=True)
            rmtree(src)
        else:
            copy2(src, real_dst)
            os.unlink(src)

def _destinsrc(src, dst):
    src = abspath(src)
    dst = abspath(dst)
    if not src.endswith(os.path.sep):
        src += os.path.sep
    if not dst.endswith(os.path.sep):
        dst += os.path.sep
    return dst.startswith(src)

def _get_gid(name):
    """Returns a gid, given a group name."""
    if getgrnam is None or name is None:
        return None
    try:
        result = getgrnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def _get_uid(name):
    """Returns an uid, given a user name."""
    if getpwnam is None or name is None:
        return None
    try:
        result = getpwnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def _make_tarball(base_name, base_dir, compress="gzip", verbose=0, dry_run=0,
                  owner=None, group=None, logger=None):
    """Create a (possibly compressed) tar file from all the files under
    'base_dir'.

    'compress' must be "gzip" (the default), "bzip2", or None.

    'owner' and 'group' can be used to define an owner and a group for the
    archive that is being built. If not provided, the current owner and group
    will be used.

    The output tar file will be named 'base_name' +  ".tar", possibly plus
    the appropriate compression extension (".gz", or ".bz2").

    Returns the output filename.
    """
    tar_compression = {'gzip': 'gz', 'bzip2': 'bz2', None: ''}
    compress_ext = {'gzip': '.gz', 'bzip2': '.bz2'}

    # flags for compression program, each element of list will be an argument
    if compress is not None and compress not in compress_ext.keys():
        raise ValueError, \
              ("bad value for 'compress': must be None, 'gzip' or 'bzip2'")

    archive_name = base_name + '.tar' + compress_ext.get(compress, '')
    archive_dir = os.path.dirname(archive_name)

    if archive_dir and not os.path.exists(archive_dir):
        if logger is not None:
            logger.info("creating %s", archive_dir)
        if not dry_run:
            os.makedirs(archive_dir)


    # creating the tarball
    import tarfile  # late import so Python build itself doesn't break

    if logger is not None:
        logger.info('Creating tar archive')

    uid = _get_uid(owner)
    gid = _get_gid(group)

    def _set_uid_gid(tarinfo):
        if gid is not None:
            tarinfo.gid = gid
            tarinfo.gname = group
        if uid is not None:
            tarinfo.uid = uid
            tarinfo.uname = owner
        return tarinfo

    if not dry_run:
        tar = tarfile.open(archive_name, 'w|%s' % tar_compression[compress])
        try:
            tar.add(base_dir, filter=_set_uid_gid)
        finally:
            tar.close()

    return archive_name

def _call_external_zip(base_dir, zip_filename, verbose, dry_run, logger):
    # XXX see if we want to keep an external call here
    if verbose:
        zipoptions = "-r"
    else:
        zipoptions = "-rq"
    cmd = ["zip", zipoptions, zip_filename, base_dir]
    if logger is not None:
        logger.info(' '.join(cmd))
    if dry_run:
        return
    import subprocess
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError:
        # XXX really should distinguish between "couldn't find
        # external 'zip' command" and "zip failed".
        raise ExecError, \
            ("unable to create zip file '%s': "
            "could neither import the 'zipfile' module nor "
            "find a standalone zip utility") % zip_filename

def _make_zipfile(base_name, base_dir, verbose=0, dry_run=0, logger=None):
    """Create a zip file from all the files under 'base_dir'.

    The output zip file will be named 'base_name' + ".zip".  Uses either the
    "zipfile" Python module (if available) or the InfoZIP "zip" utility
    (if installed and found on the default search path).  If neither tool is
    available, raises ExecError.  Returns the name of the output zip
    file.
    """
    zip_filename = base_name + ".zip"
    archive_dir = os.path.dirname(base_name)

    if archive_dir and not os.path.exists(archive_dir):
        if logger is not None:
            logger.info("creating %s", archive_dir)
        if not dry_run:
            os.makedirs(archive_dir)

    # If zipfile module is not available, try spawning an external 'zip'
    # command.
    try:
        import zipfile
    except ImportError:
        zipfile = None

    if zipfile is None:
        _call_external_zip(base_dir, zip_filename, verbose, dry_run, logger)
    else:
        if logger is not None:
            logger.info("creating '%s' and adding '%s' to it",
                        zip_filename, base_dir)

        if not dry_run:
            with zipfile.ZipFile(zip_filename, "w",
                                 compression=zipfile.ZIP_DEFLATED) as zf:
                path = os.path.normpath(base_dir)
                if path != os.curdir:
                    zf.write(path, path)
                    if logger is not None:
                        logger.info("adding '%s'", path)
                for dirpath, dirnames, filenames in os.walk(base_dir):
                    for name in sorted(dirnames):
                        path = os.path.normpath(os.path.join(dirpath, name))
                        zf.write(path, path)
                        if logger is not None:
                            logger.info("adding '%s'", path)
                    for name in filenames:
                        path = os.path.normpath(os.path.join(dirpath, name))
                        if os.path.isfile(path):
                            zf.write(path, path)
                            if logger is not None:
                                logger.info("adding '%s'", path)

    return zip_filename

_ARCHIVE_FORMATS = {
    'gztar': (_make_tarball, [('compress', 'gzip')], "gzip'ed tar-file"),
    'bztar': (_make_tarball, [('compress', 'bzip2')], "bzip2'ed tar-file"),
    'tar':   (_make_tarball, [('compress', None)], "uncompressed tar file"),
    'zip':   (_make_zipfile, [],"ZIP file")
    }

def get_archive_formats():
    """Returns a list of supported formats for archiving and unarchiving.

    Each element of the returned sequence is a tuple (name, description)
    """
    formats = [(name, registry[2]) for name, registry in
               _ARCHIVE_FORMATS.items()]
    formats.sort()
    return formats

def register_archive_format(name, function, extra_args=None, description=''):
    """Registers an archive format.

    name is the name of the format. function is the callable that will be
    used to create archives. If provided, extra_args is a sequence of
    (name, value) tuples that will be passed as arguments to the callable.
    description can be provided to describe the format, and will be returned
    by the get_archive_formats() function.
    """
    if extra_args is None:
        extra_args = []
    if not isinstance(function, collections.Callable):
        raise TypeError('The %s object is not callable' % function)
    if not isinstance(extra_args, (tuple, list)):
        raise TypeError('extra_args needs to be a sequence')
    for element in extra_args:
        if not isinstance(element, (tuple, list)) or len(element) !=2 :
            raise TypeError('extra_args elements are : (arg_name, value)')

    _ARCHIVE_FORMATS[name] = (function, extra_args, description)

def unregister_archive_format(name):
    del _ARCHIVE_FORMATS[name]

def make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,
                 dry_run=0, owner=None, group=None, logger=None):
    """Create an archive file (eg. zip or tar).

    'base_name' is the name of the file to create, minus any format-specific
    extension; 'format' is the archive format: one of "zip", "tar", "bztar"
    or "gztar".

    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.

    'owner' and 'group' are used when creating a tar archive. By default,
    uses the current owner and group.
    """
    save_cwd = os.getcwd()
    if root_dir is not None:
        if logger is not None:
            logger.debug("changing into '%s'", root_dir)
        base_name = os.path.abspath(base_name)
        if not dry_run:
            os.chdir(root_dir)

    if base_dir is None:
        base_dir = os.curdir

    kwargs = {'dry_run': dry_run, 'logger': logger}

    try:
        format_info = _ARCHIVE_FORMATS[format]
    except KeyError:
        raise ValueError, "unknown archive format '%s'" % format

    func = format_info[0]
    for arg, val in format_info[1]:
        kwargs[arg] = val

    if format != 'zip':
        kwargs['owner'] = owner
        kwargs['group'] = group

    try:
        filename = func(base_name, base_dir, **kwargs)
    finally:
        if root_dir is not None:
            if logger is not None:
                logger.debug("changing back to '%s'", save_cwd)
            os.chdir(save_cwd)

    return filename
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Û
”´[c           @   sµ  d  Z  d d l Z d d l Z d d l Z d d l m Z d d l Z d d l Z d d l Z y d d l	 m
 Z
 Wn e k
 rã d Z
 n Xy d d l m Z Wn e k
 rπ d Z n Xd d d d	 d
 d d d d d d d d d d d d g Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ y e Wn e k
 rVd Z n Xd? d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d  Ñ  Z d! Ñ  Z d" Ñ  Z d# Ñ  Z e d d$ Ñ Z e d d% Ñ Z  d& Ñ  Z! d' Ñ  Z" d( Ñ  Z# d) Ñ  Z$ d* Ñ  Z% d+ d, d, d d d d- Ñ Z& d. Ñ  Z' d, d, d d/ Ñ Z( i e& d@ g d1 f d2 6e& dA g d4 f d5 6e& dB g d6 f d7 6e( g  d8 f d9 6Z) d: Ñ  Z* d d; d< Ñ Z+ d= Ñ  Z, d d d, d, d d d d> Ñ Z- d S(C   só   Utility functions for copying and archiving files and directory trees.

XXX The functions here don't copy the resource fork or other metadata on Mac.

iˇˇˇˇN(   t   abspath(   t   getpwnam(   t   getgrnamt   copyfileobjt   copyfilet   copymodet   copystatt   copyt   copy2t   copytreet   movet   rmtreet   Errort   SpecialFileErrort	   ExecErrort   make_archivet   get_archive_formatst   register_archive_formatt   unregister_archive_formatt   ignore_patternsc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/shutil.pyR      s   c           B   s   e  Z d  Z RS(   s|   Raised when trying to do a kind of operation (e.g. copying) which is
    not supported on a special file (e.g. a named pipe)(   R   R   t   __doc__(    (    (    s   /usr/lib/python2.7/shutil.pyR   "   s   c           B   s   e  Z d  Z RS(   s+   Raised when a command could not be executed(   R   R   R   (    (    (    s   /usr/lib/python2.7/shutil.pyR   &   s   i   i   c         C   s1   x* |  j  | É } | s Pn  | j | É q Wd S(   s=   copy data from file-like object fsrc to file-like object fdstN(   t   readt   write(   t   fsrct   fdstt   lengtht   buf(    (    s   /usr/lib/python2.7/shutil.pyR   .   s
    c         C   s{   t  t j d É rA y t j j |  | É SWqA t k
 r= t SXn  t j j t j j |  É É t j j t j j | É É k S(   Nt   samefile(   t   hasattrt   ost   pathR   t   OSErrort   Falset   normcaseR    (   t   srct   dst(    (    s   /usr/lib/python2.7/shutil.pyt	   _samefile6   s    c         C   sÃ   t  |  | É r( t d |  | f É Ç n  x` |  | g D]R } y t j | É } Wn t k
 ra q5 Xt j | j É r5 t d | É Ç q5 q5 Wt |  d É è, } t | d É è } t	 | | É Wd QXWd QXd S(   s   Copy data from src to dsts   `%s` and `%s` are the same files   `%s` is a named pipet   rbt   wbN(
   R&   R   R   t   statR!   t   S_ISFIFOt   st_modeR   t   openR   (   R$   R%   t   fnt   stR   R   (    (    s   /usr/lib/python2.7/shutil.pyR   B   s    c         C   sG   t  t d É rC t j |  É } t j | j É } t j | | É n  d S(   s   Copy mode bits from src to dstt   chmodN(   R   R   R)   t   S_IMODER+   R/   (   R$   R%   R.   t   mode(    (    s   /usr/lib/python2.7/shutil.pyR   V   s    c         C   s  t  j |  É } t j | j É } t t  d É rO t  j | | j | j f É n  t t  d É rq t  j | | É n  t t  d É r˛ t | d É r˛ y t  j	 | | j
 É Wq˛ t k
 r˙ } x@ d D]1 } t t | É rø | j t t | É k rø Pqø qø WÇ  q˛ Xn  d S(	   sC   Copy all stat info (mode bits, atime, mtime, flags) from src to dstt   utimeR/   t   chflagst   st_flagst
   EOPNOTSUPPt   ENOTSUPN(   R5   R6   (   R   R)   R0   R+   R   R2   t   st_atimet   st_mtimeR/   R3   R4   R!   t   errnot   getattr(   R$   R%   R.   R1   t   whyt   err(    (    s   /usr/lib/python2.7/shutil.pyR   ]   s    'c         C   sT   t  j j | É r6 t  j j | t  j j |  É É } n  t |  | É t |  | É d S(   sV   Copy data and mode bits ("cp src dst").

    The destination may be a directory.

    N(   R   R    t   isdirt   joint   basenameR   R   (   R$   R%   (    (    s   /usr/lib/python2.7/shutil.pyR   o   s    $c         C   sT   t  j j | É r6 t  j j | t  j j |  É É } n  t |  | É t |  | É d S(   s]   Copy data and all stat info ("cp -p src dst").

    The destination may be a directory.

    N(   R   R    R=   R>   R?   R   R   (   R$   R%   (    (    s   /usr/lib/python2.7/shutil.pyR   z   s    $c             s   á  f d Ü  } | S(   sè   Function that can be used as copytree() ignore parameter.

    Patterns is a sequence of glob-style patterns
    that are used to exclude filesc            s:   g  } x' à  D] } | j  t j | | É É q Wt | É S(   N(   t   extendt   fnmatcht   filtert   set(   R    t   namest   ignored_namest   pattern(   t   patterns(    s   /usr/lib/python2.7/shutil.pyt   _ignore_patternsä   s    (    (   RG   RH   (    (   RG   s   /usr/lib/python2.7/shutil.pyR   Ö   s    c         C   sÿ  t  j |  É } | d k	 r- | |  | É } n	 t É  } t  j | É g  } x| D]} | | k rh qP n  t  j j |  | É } t  j j | | É }	 ys | rœ t  j j | É rœ t  j | É }
 t  j	 |
 |	 É n5 t  j j
 | É r˜ t | |	 | | É n t | |	 É WqP t k
 r.} | j | j d É qP t k
 r\} | j | |	 t | É f É qP XqP Wy t |  | É WnM t k
 r¡} t d k	 r¢t | t É r¢q¬| j |  | t | É f É n X| r‘t | Ç n  d S(   s«  Recursively copy a directory tree using copy2().

    The destination directory must not already exist.
    If exception(s) occur, an Error is raised with a list of reasons.

    If the optional symlinks flag is true, symbolic links in the
    source tree result in symbolic links in the destination tree; if
    it is false, the contents of the files pointed to by symbolic
    links are copied.

    The optional ignore argument is a callable. If given, it
    is called with the `src` parameter, which is the directory
    being visited by copytree(), and `names` which is the list of
    `src` contents, as returned by os.listdir():

        callable(src, names) -> ignored_names

    Since copytree() is called recursively, the callable will be
    called once for each directory that is copied. It returns a
    list of names relative to the `src` directory that should
    not be copied.

    XXX Consider this example code rather than the ultimate tool.

    i    N(   R   t   listdirt   NoneRC   t   makedirsR    R>   t   islinkt   readlinkt   symlinkR=   R	   R   R   R@   t   argst   EnvironmentErrort   appendt   strR   R!   t   WindowsErrort
   isinstance(   R$   R%   t   symlinkst   ignoreRD   RE   t   errorst   namet   srcnamet   dstnamet   linktoR<   R;   (    (    s   /usr/lib/python2.7/shutil.pyR	   ë   s<    	$ c         C   sŒ  | r d Ñ  } n | d k r* d Ñ  } n  y% t j j |  É rN t d É Ç n  Wn. t k
 r | t j j |  t j É  É d SXg  } y t j |  É } Wn/ t j k
 r  } | t j |  t j É  É n Xxª | D]≥ } t j j	 |  | É } y t j
 | É j } Wn t j k
 rd } n Xt j | É rBt | | | É q“ y t j | É Wq“ t j k
 rÑ} | t j | t j É  É q“ Xq“ Wy t j |  É Wn- t j k
 r…| t j |  t j É  É n Xd S(   s¡  Recursively delete a directory tree.

    If ignore_errors is set, errors are ignored; otherwise, if onerror
    is set, it is called to handle the error with arguments (func,
    path, exc_info) where func is os.listdir, os.remove, or os.rmdir;
    path is the argument to that function that caused it to fail; and
    exc_info is a tuple returned by sys.exc_info().  If ignore_errors
    is false and onerror is None, an exception is raised.

    c          W   s   d  S(   N(    (   RO   (    (    s   /usr/lib/python2.7/shutil.pyt   onerrorﬁ   s    c          W   s   Ç  d  S(   N(    (   RO   (    (    s   /usr/lib/python2.7/shutil.pyR\   ·   s    s%   Cannot call rmtree on a symbolic linkNi    (   RJ   R   R    RL   R!   t   syst   exc_infoRI   t   errorR>   t   lstatR+   R)   t   S_ISDIRR   t   removet   rmdir(   R    t   ignore_errorsR\   RD   R<   RX   t   fullnameR1   (    (    s   /usr/lib/python2.7/shutil.pyR   “   s>    
!c         C   s5   t  j j t  j j p d } t  j j |  j | É É S(   Nt    (   R   R    t   sept   altsepR?   t   rstrip(   R    Rg   (    (    s   /usr/lib/python2.7/shutil.pyt	   _basename  s    c         C   s  | } t  j j | É r{ t |  | É r; t  j |  | É d St  j j | t |  É É } t  j j | É r{ t d | Ç q{ n  y t  j |  | É WnÇ t	 k
 rt  j j |  É rˆ t
 |  | É r÷ t d |  | f Ç n  t |  | d t Ét |  É qt |  | É t  j |  É n Xd S(   sì  Recursively move a file or directory to another location. This is
    similar to the Unix "mv" command.

    If the destination is a directory or a symlink to a directory, the source
    is moved inside the directory. The destination path must not already
    exist.

    If the destination already exists but is not a directory, it may be
    overwritten depending on os.rename() semantics.

    If the destination is on our current filesystem, then rename() is used.
    Otherwise, src is copied to the destination and then removed.
    A lot more could be done here...  A look at a mv.c shows a lot of
    the issues this implementation glosses over.

    Ns$   Destination path '%s' already existss.   Cannot move a directory '%s' into itself '%s'.RU   (   R   R    R=   R&   t   renameR>   Rj   t   existsR   R!   t
   _destinsrcR	   t   TrueR   R   t   unlink(   R$   R%   t   real_dst(    (    s   /usr/lib/python2.7/shutil.pyR
   	  s$    c         C   su   t  |  É }  t  | É } |  j t j j É s@ |  t j j 7}  n  | j t j j É sh | t j j 7} n  | j |  É S(   N(   R    t   endswithR   R    Rg   t
   startswith(   R$   R%   (    (    s   /usr/lib/python2.7/shutil.pyRm   1  s    c         C   s^   t  d k s |  d k r d Sy t  |  É } Wn t k
 rE d } n X| d k	 rZ | d Sd S(   s"   Returns a gid, given a group name.i   N(   R   RJ   t   KeyError(   RX   t   result(    (    s   /usr/lib/python2.7/shutil.pyt   _get_gid:  s    
c         C   s^   t  d k s |  d k r d Sy t  |  É } Wn t k
 rE d } n X| d k	 rZ | d Sd S(   s"   Returns an uid, given a user name.i   N(   R   RJ   Rs   (   RX   Rt   (    (    s   /usr/lib/python2.7/shutil.pyt   _get_uidF  s    
t   gzipi    c            sz  i d d 6d d 6d d 6} i d d 6d d 6}	 | d k	 rY | |	 j É  k rY t d Ç n  |  d	 |	 j | d É }
 t j j |
 É } | r÷ t j j | É r÷ | d k	 rΩ | j d
 | É n  | s÷ t j	 | É q÷ n  d d l
 } | d k	 r˛ | j d É n  t à É â t à É â  á  á á á f d Ü  } | sv| j |
 d | | É } z | j | d | ÉWd | j É  Xn  |
 S(   sÌ  Create a (possibly compressed) tar file from all the files under
    'base_dir'.

    'compress' must be "gzip" (the default), "bzip2", or None.

    'owner' and 'group' can be used to define an owner and a group for the
    archive that is being built. If not provided, the current owner and group
    will be used.

    The output tar file will be named 'base_name' +  ".tar", possibly plus
    the appropriate compression extension (".gz", or ".bz2").

    Returns the output filename.
    t   gzRw   t   bz2t   bzip2Rf   s   .gzs   .bz2s9   bad value for 'compress': must be None, 'gzip' or 'bzip2's   .tars   creating %siˇˇˇˇNs   Creating tar archivec            sF   à  d  k	 r! à  |  _ à |  _ n  à d  k	 rB à |  _ à |  _ n  |  S(   N(   RJ   t   gidt   gnamet   uidt   uname(   t   tarinfo(   R{   t   groupt   ownerR}   (    s   /usr/lib/python2.7/shutil.pyt   _set_uid_gid}  s    		s   w|%sRB   (   RJ   t   keyst
   ValueErrort   getR   R    t   dirnameRl   t   infoRK   t   tarfileRv   Ru   R,   t   addt   close(   t	   base_namet   base_dirt   compresst   verboset   dry_runRÅ   RÄ   t   loggert   tar_compressiont   compress_extt   archive_namet   archive_dirRà   RÇ   t   tar(    (   R{   RÄ   RÅ   R}   s   /usr/lib/python2.7/shutil.pyt   _make_tarballR  s0    		c         C   sõ   | r d } n d } d | | |  g } | d  k	 rL | j d j | É É n  | rV d  Sd d  l } y | j | É Wn! | j k
 rñ t d | Ç n Xd  S(   Ns   -rs   -rqt   zipt    iˇˇˇˇsk   unable to create zip file '%s': could neither import the 'zipfile' module nor find a standalone zip utility(   RJ   Rá   R>   t
   subprocesst
   check_callt   CalledProcessErrorR   (   Rå   t   zip_filenameRé   Rè   Rê   t
   zipoptionst   cmdRô   (    (    s   /usr/lib/python2.7/shutil.pyt   _call_external_zipè  s    	c      
   C   sb  |  d } t  j j |  É } | rm t  j j | É rm | d k	 rT | j d | É n  | sm t  j | É qm n  y d d l } Wn t k
 rñ d } n X| d k rº t	 | | | | | É n¢| d k	 rﬁ | j d | | É n  | s^| j
 | d d | j ÉèZ} t  j j | É }	 |	 t  j k rU| j |	 |	 É | d k	 rU| j d |	 É qUn  x˝ t  j | É D]Ï \ }
 } } xd t | É D]V } t  j j t  j j |
 | É É }	 | j |	 |	 É | d k	 rÅ| j d |	 É qÅqÅWxs | D]k } t  j j t  j j |
 | É É }	 t  j j |	 É r‚| j |	 |	 É | d k	 rM| j d |	 É qMq‚q‚WqeWWd QXn  | S(	   sm  Create a zip file from all the files under 'base_dir'.

    The output zip file will be named 'base_name' + ".zip".  Uses either the
    "zipfile" Python module (if available) or the InfoZIP "zip" utility
    (if installed and found on the default search path).  If neither tool is
    available, raises ExecError.  Returns the name of the output zip
    file.
    s   .zips   creating %siˇˇˇˇNs#   creating '%s' and adding '%s' to itt   wt   compressions   adding '%s'(   R   R    RÜ   Rl   RJ   Rá   RK   t   zipfilet   ImportErrorRü   t   ZipFilet   ZIP_DEFLATEDt   normpatht   curdirR   t   walkt   sortedR>   t   isfile(   Rã   Rå   Ré   Rè   Rê   Rú   Rî   R¢   t   zfR    t   dirpatht   dirnamest	   filenamesRX   (    (    s   /usr/lib/python2.7/shutil.pyt   _make_zipfile•  sJ    	

	!!'Rç   s   gzip'ed tar-filet   gztarRz   s   bzip2'ed tar-filet   bztars   uncompressed tar fileRï   s   ZIP fileRó   c          C   s=   g  t  j É  D] \ }  } |  | d f ^ q } | j É  | S(   së   Returns a list of supported formats for archiving and unarchiving.

    Each element of the returned sequence is a tuple (name, description)
    i   (   t   _ARCHIVE_FORMATSt   itemst   sort(   RX   t   registryt   formats(    (    s   /usr/lib/python2.7/shutil.pyR   „  s    ,
Rf   c         C   sΩ   | d k r g  } n  t | t j É s: t d | É Ç n  t | t t f É s^ t d É Ç n  xE | D]= } t | t t f É sì t | É d k re t d É Ç qe qe W| | | f t |  <d S(   su  Registers an archive format.

    name is the name of the format. function is the callable that will be
    used to create archives. If provided, extra_args is a sequence of
    (name, value) tuples that will be passed as arguments to the callable.
    description can be provided to describe the format, and will be returned
    by the get_archive_formats() function.
    s   The %s object is not callables!   extra_args needs to be a sequencei   s+   extra_args elements are : (arg_name, value)N(	   RJ   RT   t   collectionst   Callablet	   TypeErrort   tuplet   listt   lenR≤   (   RX   t   functiont
   extra_argst   descriptiont   element(    (    s   /usr/lib/python2.7/shutil.pyR   Ì  s    		(c         C   s   t  |  =d  S(   N(   R≤   (   RX   (    (    s   /usr/lib/python2.7/shutil.pyR     s    c	         C   sh  t  j É  }	 | d
 k	 rb | d
 k	 r7 | j d | É n  t  j j |  É }  | sb t  j | É qb n  | d
 k rz t  j } n  i | d 6| d 6}
 y t | } Wn t	 k
 rº t
 d | Ç n X| d } x" | d D] \ } } | |
 | <q“ W| d k r| |
 d <| |
 d	 <n  z | |  | |
 ç } Wd
 | d
 k	 rc| d
 k	 rS| j d |	 É n  t  j |	 É n  X| S(   sÍ  Create an archive file (eg. zip or tar).

    'base_name' is the name of the file to create, minus any format-specific
    extension; 'format' is the archive format: one of "zip", "tar", "bztar"
    or "gztar".

    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.

    'owner' and 'group' are used when creating a tar archive. By default,
    uses the current owner and group.
    s   changing into '%s'Rè   Rê   s   unknown archive format '%s'i    i   Ró   RÅ   RÄ   Ns   changing back to '%s'(   R   t   getcwdRJ   t   debugR    R    t   chdirRß   R≤   Rs   RÑ   (   Rã   t   formatt   root_dirRå   Ré   Rè   RÅ   RÄ   Rê   t   save_cwdt   kwargst   format_infot   funct   argt   valt   filename(    (    s   /usr/lib/python2.7/shutil.pyR     s6    

i @  (   Rç   Rw   (   Rç   Rz   (   Rç   N(.   R   R   R]   R)   t   os.pathR    RA   R∑   R9   t   pwdR   R£   RJ   t   grpR   t   __all__RP   R   R   R   RS   t	   NameErrorR   R&   R   R   R   R   R   R   R"   R	   R   Rj   R
   Rm   Ru   Rv   Rñ   Rü   RØ   R≤   R   R   R   R   (    (    (    s   /usr/lib/python2.7/shutil.pyt   <module>   sp   

		
							A1		(					<	7	
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """Append module search paths for third-party packages to sys.path.

****************************************************************
* This module is automatically imported during initialization. *
****************************************************************

In earlier versions of Python (up to 1.5a3), scripts or modules that
needed to use site-specific modules would place ``import site''
somewhere near the top of their code.  Because of the automatic
import, this is no longer necessary (but code that does it still
works).

This will append site-specific paths to the module search path.  On
Unix (including Mac OSX), it starts with sys.prefix and
sys.exec_prefix (if different) and appends
lib/python<version>/site-packages as well as lib/site-python.
On other platforms (such as Windows), it tries each of the
prefixes directly, as well as with lib/site-packages appended.  The
resulting directories, if they exist, are appended to sys.path, and
also inspected for path configuration files.

For Debian and derivatives, this sys.path is augmented with directories
for packages distributed within the distribution. Local addons go
into /usr/local/lib/python<version>/dist-packages, Debian addons
install into /usr/{lib,share}/python<version>/dist-packages.
/usr/lib/python<version>/site-packages is not used.

A path configuration file is a file whose name has the form
<package>.pth; its contents are additional directories (one per line)
to be added to sys.path.  Non-existing directories (or
non-directories) are never added to sys.path; no directory is added to
sys.path more than once.  Blank lines and lines beginning with
'#' are skipped. Lines starting with 'import' are executed.

For example, suppose sys.prefix and sys.exec_prefix are set to
/usr/local and there is a directory /usr/local/lib/python2.5/site-packages
with three subdirectories, foo, bar and spam, and two path
configuration files, foo.pth and bar.pth.  Assume foo.pth contains the
following:

  # foo package configuration
  foo
  bar
  bletch

and bar.pth contains:

  # bar package configuration
  bar

Then the following directories are added to sys.path, in this order:

  /usr/local/lib/python2.5/site-packages/bar
  /usr/local/lib/python2.5/site-packages/foo

Note that bletch is omitted because it doesn't exist; bar precedes foo
because bar.pth comes alphabetically before foo.pth; and spam is
omitted because it is not mentioned in either path configuration file.

After these path manipulations, an attempt is made to import a module
named sitecustomize, which can perform arbitrary additional
site-specific customizations.  If this import fails with an
ImportError exception, it is silently ignored.

"""

import sys
import os
import __builtin__
import traceback

# Prefixes for site-packages; add additional prefixes like /usr/local here
PREFIXES = [sys.prefix, sys.exec_prefix]
# Enable per user site-packages directory
# set it to False to disable the feature or True to force the feature
ENABLE_USER_SITE = None

# for distutils.commands.install
# These values are initialized by the getuserbase() and getusersitepackages()
# functions, through the main() function when Python starts.
USER_SITE = None
USER_BASE = None


def makepath(*paths):
    dir = os.path.join(*paths)
    try:
        dir = os.path.abspath(dir)
    except OSError:
        pass
    return dir, os.path.normcase(dir)


def abs__file__():
    """Set all module' __file__ attribute to an absolute path"""
    for m in sys.modules.values():
        if hasattr(m, '__loader__'):
            continue   # don't mess with a PEP 302-supplied __file__
        try:
            m.__file__ = os.path.abspath(m.__file__)
        except (AttributeError, OSError):
            pass


def removeduppaths():
    """ Remove duplicate entries from sys.path along with making them
    absolute"""
    # This ensures that the initial path provided by the interpreter contains
    # only absolute pathnames, even if we're running from the build directory.
    L = []
    known_paths = set()
    for dir in sys.path:
        # Filter out duplicate paths (on case-insensitive file systems also
        # if they only differ in case); turn relative paths into absolute
        # paths.
        dir, dircase = makepath(dir)
        if not dircase in known_paths:
            L.append(dir)
            known_paths.add(dircase)
    sys.path[:] = L
    return known_paths


def _init_pathinfo():
    """Return a set containing all existing directory entries from sys.path"""
    d = set()
    for dir in sys.path:
        try:
            if os.path.isdir(dir):
                dir, dircase = makepath(dir)
                d.add(dircase)
        except TypeError:
            continue
    return d


def addpackage(sitedir, name, known_paths):
    """Process a .pth file within the site-packages directory:
       For each line in the file, either combine it with sitedir to a path
       and add that to known_paths, or execute it if it starts with 'import '.
    """
    if known_paths is None:
        _init_pathinfo()
        reset = 1
    else:
        reset = 0
    fullname = os.path.join(sitedir, name)
    try:
        f = open(fullname, "rU")
    except IOError:
        return
    with f:
        for n, line in enumerate(f):
            if line.startswith("#"):
                continue
            try:
                if line.startswith(("import ", "import\t")):
                    exec line
                    continue
                line = line.rstrip()
                dir, dircase = makepath(sitedir, line)
                if not dircase in known_paths and os.path.exists(dir):
                    sys.path.append(dir)
                    known_paths.add(dircase)
            except Exception as err:
                print >>sys.stderr, "Error processing line {:d} of {}:\n".format(
                    n+1, fullname)
                for record in traceback.format_exception(*sys.exc_info()):
                    for line in record.splitlines():
                        print >>sys.stderr, '  '+line
                print >>sys.stderr, "\nRemainder of file ignored"
                break
    if reset:
        known_paths = None
    return known_paths


def addsitedir(sitedir, known_paths=None):
    """Add 'sitedir' argument to sys.path if missing and handle .pth files in
    'sitedir'"""
    if known_paths is None:
        known_paths = _init_pathinfo()
        reset = 1
    else:
        reset = 0
    sitedir, sitedircase = makepath(sitedir)
    if not sitedircase in known_paths:
        sys.path.append(sitedir)        # Add path component
    try:
        names = os.listdir(sitedir)
    except os.error:
        return
    dotpth = os.extsep + "pth"
    names = [name for name in names if name.endswith(dotpth)]
    for name in sorted(names):
        addpackage(sitedir, name, known_paths)
    if reset:
        known_paths = None
    return known_paths


def check_enableusersite():
    """Check if user site directory is safe for inclusion

    The function tests for the command line flag (including environment var),
    process uid/gid equal to effective uid/gid.

    None: Disabled for security reasons
    False: Disabled by user (command line option)
    True: Safe and enabled
    """
    if sys.flags.no_user_site:
        return False

    if hasattr(os, "getuid") and hasattr(os, "geteuid"):
        # check process uid == effective uid
        if os.geteuid() != os.getuid():
            return None
    if hasattr(os, "getgid") and hasattr(os, "getegid"):
        # check process gid == effective gid
        if os.getegid() != os.getgid():
            return None

    return True

def getuserbase():
    """Returns the `user base` directory path.

    The `user base` directory can be used to store data. If the global
    variable ``USER_BASE`` is not initialized yet, this function will also set
    it.
    """
    global USER_BASE
    if USER_BASE is not None:
        return USER_BASE
    from sysconfig import get_config_var
    USER_BASE = get_config_var('userbase')
    return USER_BASE

def getusersitepackages():
    """Returns the user-specific site-packages directory path.

    If the global variable ``USER_SITE`` is not initialized yet, this
    function will also set it.
    """
    global USER_SITE
    user_base = getuserbase() # this will also set USER_BASE

    if USER_SITE is not None:
        return USER_SITE

    from sysconfig import get_path
    import os

    if sys.platform == 'darwin':
        from sysconfig import get_config_var
        if get_config_var('PYTHONFRAMEWORK'):
            USER_SITE = get_path('purelib', 'osx_framework_user')
            return USER_SITE

    USER_SITE = get_path('purelib', '%s_user' % os.name)
    return USER_SITE

def addusersitepackages(known_paths):
    """Add a per user site-package to sys.path

    Each user has its own python directory with site-packages in the
    home directory.
    """
    # get the per user site-package path
    # this call will also make sure USER_BASE and USER_SITE are set
    user_site = getusersitepackages()

    if ENABLE_USER_SITE and os.path.isdir(user_site):
        addsitedir(user_site, known_paths)
    if ENABLE_USER_SITE:
        for dist_libdir in ("local/lib", "lib"):
            user_site = os.path.join(USER_BASE, dist_libdir,
                                     "python" + sys.version[:3],
                                     "dist-packages")
            if os.path.isdir(user_site):
                addsitedir(user_site, known_paths)
    return known_paths

def getsitepackages():
    """Returns a list containing all global site-packages directories
    (and possibly site-python).

    For each directory present in the global ``PREFIXES``, this function
    will find its `site-packages` subdirectory depending on the system
    environment, and will return a list of full paths.
    """
    sitepackages = []
    seen = set()

    for prefix in PREFIXES:
        if not prefix or prefix in seen:
            continue
        seen.add(prefix)

        if sys.platform in ('os2emx', 'riscos'):
            sitepackages.append(os.path.join(prefix, "Lib", "site-packages"))
        elif os.sep == '/':
            sitepackages.append(os.path.join(prefix, "local/lib",
                                        "python" + sys.version[:3],
                                        "dist-packages"))
            sitepackages.append(os.path.join(prefix, "lib",
                                        "python" + sys.version[:3],
                                        "dist-packages"))
        else:
            sitepackages.append(prefix)
            sitepackages.append(os.path.join(prefix, "lib", "site-packages"))
    return sitepackages

def addsitepackages(known_paths):
    """Add site-packages (and possibly site-python) to sys.path"""
    for sitedir in getsitepackages():
        if os.path.isdir(sitedir):
            addsitedir(sitedir, known_paths)

    return known_paths

def setBEGINLIBPATH():
    """The OS/2 EMX port has optional extension modules that do double duty
    as DLLs (and must use the .DLL file extension) for other extensions.
    The library search path needs to be amended so these will be found
    during module import.  Use BEGINLIBPATH so that these are at the start
    of the library search path.

    """
    dllpath = os.path.join(sys.prefix, "Lib", "lib-dynload")
    libpath = os.environ['BEGINLIBPATH'].split(';')
    if libpath[-1]:
        libpath.append(dllpath)
    else:
        libpath[-1] = dllpath
    os.environ['BEGINLIBPATH'] = ';'.join(libpath)


def setquit():
    """Define new builtins 'quit' and 'exit'.

    These are objects which make the interpreter exit when called.
    The repr of each object contains a hint at how it works.

    """
    if os.sep == ':':
        eof = 'Cmd-Q'
    elif os.sep == '\\':
        eof = 'Ctrl-Z plus Return'
    else:
        eof = 'Ctrl-D (i.e. EOF)'

    class Quitter(object):
        def __init__(self, name):
            self.name = name
        def __repr__(self):
            return 'Use %s() or %s to exit' % (self.name, eof)
        def __call__(self, code=None):
            # Shells like IDLE catch the SystemExit, but listen when their
            # stdin wrapper is closed.
            try:
                sys.stdin.close()
            except:
                pass
            raise SystemExit(code)
    __builtin__.quit = Quitter('quit')
    __builtin__.exit = Quitter('exit')


class _Printer(object):
    """interactive prompt objects for printing the license text, a list of
    contributors and the copyright notice."""

    MAXLINES = 23

    def __init__(self, name, data, files=(), dirs=()):
        self.__name = name
        self.__data = data
        self.__files = files
        self.__dirs = dirs
        self.__lines = None

    def __setup(self):
        if self.__lines:
            return
        data = None
        for dir in self.__dirs:
            for filename in self.__files:
                filename = os.path.join(dir, filename)
                try:
                    fp = file(filename, "rU")
                    data = fp.read()
                    fp.close()
                    break
                except IOError:
                    pass
            if data:
                break
        if not data:
            data = self.__data
        self.__lines = data.split('\n')
        self.__linecnt = len(self.__lines)

    def __repr__(self):
        self.__setup()
        if len(self.__lines) <= self.MAXLINES:
            return "\n".join(self.__lines)
        else:
            return "Type %s() to see the full %s text" % ((self.__name,)*2)

    def __call__(self):
        self.__setup()
        prompt = 'Hit Return for more, or q (and Return) to quit: '
        lineno = 0
        while 1:
            try:
                for i in range(lineno, lineno + self.MAXLINES):
                    print self.__lines[i]
            except IndexError:
                break
            else:
                lineno += self.MAXLINES
                key = None
                while key is None:
                    key = raw_input(prompt)
                    if key not in ('', 'q'):
                        key = None
                if key == 'q':
                    break

def setcopyright():
    """Set 'copyright' and 'credits' in __builtin__"""
    __builtin__.copyright = _Printer("copyright", sys.copyright)
    if sys.platform[:4] == 'java':
        __builtin__.credits = _Printer(
            "credits",
            "Jython is maintained by the Jython developers (www.jython.org).")
    else:
        __builtin__.credits = _Printer("credits", """\
    Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
    for supporting Python development.  See www.python.org for more information.""")
    here = os.path.dirname(os.__file__)
    __builtin__.license = _Printer(
        "license", "See https://www.python.org/psf/license/",
        ["LICENSE.txt", "LICENSE"],
        [os.path.join(here, os.pardir), here, os.curdir])


class _Helper(object):
    """Define the builtin 'help'.
    This is a wrapper around pydoc.help (with a twist).

    """

    def __repr__(self):
        return "Type help() for interactive help, " \
               "or help(object) for help about object."
    def __call__(self, *args, **kwds):
        import pydoc
        return pydoc.help(*args, **kwds)

def sethelper():
    __builtin__.help = _Helper()

def aliasmbcs():
    """On Windows, some default encodings are not provided by Python,
    while they are always available as "mbcs" in each locale. Make
    them usable by aliasing to "mbcs" in such a case."""
    if sys.platform == 'win32':
        import locale, codecs
        enc = locale.getdefaultlocale()[1]
        if enc.startswith('cp'):            # "cp***" ?
            try:
                codecs.lookup(enc)
            except LookupError:
                import encodings
                encodings._cache[enc] = encodings._unknown
                encodings.aliases.aliases[enc] = 'mbcs'

def setencoding():
    """Set the string encoding used by the Unicode implementation.  The
    default is 'ascii', but if you're willing to experiment, you can
    change this."""
    encoding = "ascii" # Default value set by _PyUnicode_Init()
    if 0:
        # Enable to support locale aware default string encodings.
        import locale
        loc = locale.getdefaultlocale()
        if loc[1]:
            encoding = loc[1]
    if 0:
        # Enable to switch off string to Unicode coercion and implicit
        # Unicode to string conversion.
        encoding = "undefined"
    if encoding != "ascii":
        # On Non-Unicode builds this will raise an AttributeError...
        sys.setdefaultencoding(encoding) # Needs Python Unicode build !


def execsitecustomize():
    """Run custom site specific code, if available."""
    try:
        import sitecustomize
    except ImportError:
        pass
    except Exception:
        if sys.flags.verbose:
            sys.excepthook(*sys.exc_info())
        else:
            print >>sys.stderr, \
                "'import sitecustomize' failed; use -v for traceback"


def execusercustomize():
    """Run custom user specific code, if available."""
    try:
        import usercustomize
    except ImportError:
        pass
    except Exception:
        if sys.flags.verbose:
            sys.excepthook(*sys.exc_info())
        else:
            print>>sys.stderr, \
                "'import usercustomize' failed; use -v for traceback"


def main():
    global ENABLE_USER_SITE

    abs__file__()
    known_paths = removeduppaths()
    if ENABLE_USER_SITE is None:
        ENABLE_USER_SITE = check_enableusersite()
    known_paths = addusersitepackages(known_paths)
    known_paths = addsitepackages(known_paths)
    if sys.platform == 'os2emx':
        setBEGINLIBPATH()
    setquit()
    setcopyright()
    sethelper()
    aliasmbcs()
    setencoding()
    execsitecustomize()
    if ENABLE_USER_SITE:
        execusercustomize()
    # Remove sys.setdefaultencoding() so that users cannot change the
    # encoding after initialization.  The test for presence is needed when
    # this module is run as a script, because this code is executed twice.
    if hasattr(sys, "setdefaultencoding"):
        del sys.setdefaultencoding

main()

def _script():
    help = """\
    %s [--user-base] [--user-site]

    Without arguments print some useful information
    With arguments print the value of USER_BASE and/or USER_SITE separated
    by '%s'.

    Exit codes with --user-base or --user-site:
      0 - user site directory is enabled
      1 - user site directory is disabled by user
      2 - uses site directory is disabled by super user
          or for security reasons
     >2 - unknown error
    """
    args = sys.argv[1:]
    if not args:
        print "sys.path = ["
        for dir in sys.path:
            print "    %r," % (dir,)
        print "]"
        print "USER_BASE: %r (%s)" % (USER_BASE,
            "exists" if os.path.isdir(USER_BASE) else "doesn't exist")
        print "USER_SITE: %r (%s)" % (USER_SITE,
            "exists" if os.path.isdir(USER_SITE) else "doesn't exist")
        print "ENABLE_USER_SITE: %r" %  ENABLE_USER_SITE
        sys.exit(0)

    buffer = []
    if '--user-base' in args:
        buffer.append(USER_BASE)
    if '--user-site' in args:
        buffer.append(USER_SITE)

    if buffer:
        print os.pathsep.join(buffer)
        if ENABLE_USER_SITE:
            sys.exit(0)
        elif ENABLE_USER_SITE is False:
            sys.exit(1)
        elif ENABLE_USER_SITE is None:
            sys.exit(2)
        else:
            sys.exit(3)
    else:
        import textwrap
        print textwrap.dedent(help % (sys.argv[0], os.pathsep))
        sys.exit(10)

if __name__ == '__main__':
    _script()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   sp  d  Z  d d l Z d d l Z d d l Z d d l Z e j e j g Z d a	 d a
 d a d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d e f d Ñ  É  YZ d Ñ  Z d e f d Ñ  É  YZ d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# e# É  d Ñ  Z$ e% d k rle$ É  n  d S(   sã
  Append module search paths for third-party packages to sys.path.

****************************************************************
* This module is automatically imported during initialization. *
****************************************************************

In earlier versions of Python (up to 1.5a3), scripts or modules that
needed to use site-specific modules would place ``import site''
somewhere near the top of their code.  Because of the automatic
import, this is no longer necessary (but code that does it still
works).

This will append site-specific paths to the module search path.  On
Unix (including Mac OSX), it starts with sys.prefix and
sys.exec_prefix (if different) and appends
lib/python<version>/site-packages as well as lib/site-python.
On other platforms (such as Windows), it tries each of the
prefixes directly, as well as with lib/site-packages appended.  The
resulting directories, if they exist, are appended to sys.path, and
also inspected for path configuration files.

For Debian and derivatives, this sys.path is augmented with directories
for packages distributed within the distribution. Local addons go
into /usr/local/lib/python<version>/dist-packages, Debian addons
install into /usr/{lib,share}/python<version>/dist-packages.
/usr/lib/python<version>/site-packages is not used.

A path configuration file is a file whose name has the form
<package>.pth; its contents are additional directories (one per line)
to be added to sys.path.  Non-existing directories (or
non-directories) are never added to sys.path; no directory is added to
sys.path more than once.  Blank lines and lines beginning with
'#' are skipped. Lines starting with 'import' are executed.

For example, suppose sys.prefix and sys.exec_prefix are set to
/usr/local and there is a directory /usr/local/lib/python2.5/site-packages
with three subdirectories, foo, bar and spam, and two path
configuration files, foo.pth and bar.pth.  Assume foo.pth contains the
following:

  # foo package configuration
  foo
  bar
  bletch

and bar.pth contains:

  # bar package configuration
  bar

Then the following directories are added to sys.path, in this order:

  /usr/local/lib/python2.5/site-packages/bar
  /usr/local/lib/python2.5/site-packages/foo

Note that bletch is omitted because it doesn't exist; bar precedes foo
because bar.pth comes alphabetically before foo.pth; and spam is
omitted because it is not mentioned in either path configuration file.

After these path manipulations, an attempt is made to import a module
named sitecustomize, which can perform arbitrary additional
site-specific customizations.  If this import fails with an
ImportError exception, it is silently ignored.

iˇˇˇˇNc          G   sR   t  j j |  å  } y t  j j | É } Wn t k
 r; n X| t  j j | É f S(   N(   t   ost   patht   joint   abspatht   OSErrort   normcase(   t   pathst   dir(    (    s   /usr/lib/python2.7/site.pyt   makepathU   s    c          C   si   xb t  j j É  D]Q }  t |  d É r+ q n  y t j j |  j É |  _ Wq t t	 f k
 r` q Xq Wd S(   s6   Set all module' __file__ attribute to an absolute patht
   __loader__N(
   t   syst   modulest   valuest   hasattrR    R   R   t   __file__t   AttributeErrorR   (   t   m(    (    s   /usr/lib/python2.7/site.pyt   abs__file__^   s    c          C   sl   g  }  t  É  } xL t j D]A } t | É \ } } | | k r |  j | É | j | É q q W|  t j (| S(   sK    Remove duplicate entries from sys.path along with making them
    absolute(   t   setR
   R   R   t   appendt   add(   t   Lt   known_pathsR   t   dircase(    (    s   /usr/lib/python2.7/site.pyt   removeduppathsi   s    	
c          C   sp   t  É  }  x` t j D]U } y8 t j j | É rP t | É \ } } |  j | É n  Wq t k
 rg q q Xq W|  S(   sD   Return a set containing all existing directory entries from sys.path(   R   R
   R   R    t   isdirR   R   t	   TypeError(   t   dR   R   (    (    s   /usr/lib/python2.7/site.pyt   _init_pathinfo|   s    	c         B   s∫  | d k r e É  d } n d } e j j |  | É } y e | d É } Wn e k
 r^ d SX| è@x8e | É D]*\ } } | j d É rî qs n  yÄ | j d É r¥ | d Uws n  | j	 É  } e
 |  | É \ } }	 |	 | k re j j | É re j j | É | j |	 É n  Wqs e k
 rú}
 e j d j | d | É IJxE e j e j É  å  D]. } x% | j É  D] } e j d	 | IJqlWqYWe j d
 IJPqs Xqs WWd QX| r∂d } n  | S(   s÷   Process a .pth file within the site-packages directory:
       For each line in the file, either combine it with sitedir to a path
       and add that to known_paths, or execute it if it starts with 'import '.
    i   i    t   rUNt   #s   import s   import	s"   Error processing line {:d} of {}:
s     s   
Remainder of file ignored(   s   import s   import	(   t   NoneR   R    R   R   t   opent   IOErrort	   enumeratet
   startswitht   rstripR   t   existsR
   R   R   t	   Exceptiont   stderrt   formatt	   tracebackt   format_exceptiont   exc_infot
   splitlines(   t   sitedirt   nameR   t   resett   fullnamet   ft   nt   lineR   R   t   errt   record(    (    s   /usr/lib/python2.7/site.pyt
   addpackageâ   sB    		c         C   sÔ   | d k r t É  } d } n d } t |  É \ }  } | | k rU t j j |  É n  y t j |  É } Wn t j k
 r d SXt j	 d } g  | D] } | j
 | É rî | ^ qî } x$ t | É D] } t |  | | É q¬ W| rÎ d } n  | S(   sT   Add 'sitedir' argument to sys.path if missing and handle .pth files in
    'sitedir'i   i    Nt   pth(   R   R   R   R
   R   R   R    t   listdirt   errort   extsept   endswitht   sortedR6   (   R-   R   R/   t   sitedircaset   namest   dotpthR.   (    (    s   /usr/lib/python2.7/site.pyt
   addsitedir≤   s$    		(	c           C   sé   t  j j r t St t d É rM t t d É rM t j É  t j É  k rM d Sn  t t d É rä t t d É rä t j	 É  t j
 É  k rä d Sn  t S(   s,  Check if user site directory is safe for inclusion

    The function tests for the command line flag (including environment var),
    process uid/gid equal to effective uid/gid.

    None: Disabled for security reasons
    False: Disabled by user (command line option)
    True: Safe and enabled
    t   getuidt   geteuidt   getgidt   getegidN(   R
   t   flagst   no_user_sitet   FalseR   R    RB   RA   R   RD   RC   t   True(    (    (    s   /usr/lib/python2.7/site.pyt   check_enableusersite    s    
c          C   s0   t  d k	 r t  Sd d l m }  |  d É a  t  S(   sÀ   Returns the `user base` directory path.

    The `user base` directory can be used to store data. If the global
    variable ``USER_BASE`` is not initialized yet, this function will also set
    it.
    iˇˇˇˇ(   t   get_config_vart   userbaseN(   t	   USER_BASER   t	   sysconfigRJ   (   RJ   (    (    s   /usr/lib/python2.7/site.pyt   getuserbase‚   s
    c          C   sê   t  É  }  t d k	 r t Sd d l m } d d l } t j d k rv d d l m } | d É rv | d d É a t Sn  | d d	 | j	 É a t S(
   s¢   Returns the user-specific site-packages directory path.

    If the global variable ``USER_SITE`` is not initialized yet, this
    function will also set it.
    iˇˇˇˇ(   t   get_pathNt   darwin(   RJ   t   PYTHONFRAMEWORKt   purelibt   osx_framework_users   %s_user(
   RN   t	   USER_SITER   RM   RO   R    R
   t   platformRJ   R.   (   t	   user_baseRO   R    RJ   (    (    s   /usr/lib/python2.7/site.pyt   getusersitepackages   s    	c         C   só   t  É  } t r1 t j j | É r1 t | |  É n  t rì xY d D]N } t j j t | d t j	 d  d É } t j j | É r> t | |  É q> q> Wn  |  S(   sÜ   Add a per user site-package to sys.path

    Each user has its own python directory with site-packages in the
    home directory.
    s	   local/libt   libt   pythoni   s   dist-packages(   s	   local/libRX   (
   RW   t   ENABLE_USER_SITER    R   R   R@   R   RL   R
   t   version(   R   t	   user_sitet   dist_libdir(    (    s   /usr/lib/python2.7/site.pyt   addusersitepackages  s    		c          C   s  g  }  t  É  } x˝ t D]ı } | s | | k r5 q n  | j | É t j d k rs |  j t j j | d d É É q t j	 d k rﬂ |  j t j j | d d t j
 d  d	 É É |  j t j j | d
 d t j
 d  d	 É É q |  j | É |  j t j j | d
 d É É q W|  S(   s+  Returns a list containing all global site-packages directories
    (and possibly site-python).

    For each directory present in the global ``PREFIXES``, this function
    will find its `site-packages` subdirectory depending on the system
    environment, and will return a list of full paths.
    t   os2emxt   riscost   Libs   site-packagest   /s	   local/libRY   i   s   dist-packagesRX   (   R_   R`   (   R   t   PREFIXESR   R
   RU   R   R    R   R   t   sepR[   (   t   sitepackagest   seent   prefix(    (    s   /usr/lib/python2.7/site.pyt   getsitepackages  s$    	"
#c         C   s:   x3 t  É  D]( } t j j | É r
 t | |  É q
 q
 W|  S(   s8   Add site-packages (and possibly site-python) to sys.path(   Rh   R    R   R   R@   (   R   R-   (    (    s   /usr/lib/python2.7/site.pyt   addsitepackages;  s    c          C   so   t  j j t j d d É }  t  j d j d É } | d rK | j |  É n
 |  | d <d j | É t  j d <d S(   sE  The OS/2 EMX port has optional extension modules that do double duty
    as DLLs (and must use the .DLL file extension) for other extensions.
    The library search path needs to be amended so these will be found
    during module import.  Use BEGINLIBPATH so that these are at the start
    of the library search path.

    Ra   s   lib-dynloadt   BEGINLIBPATHt   ;iˇˇˇˇN(   R    R   R   R
   Rg   t   environt   splitR   (   t   dllpatht   libpath(    (    s   /usr/lib/python2.7/site.pyt   setBEGINLIBPATHC  s    

c             st   t  j d k r d â  n t  j d k r0 d â  n d â  d t f á  f d Ü  É  Y}  |  d É t _ |  d	 É t _ d
 S(   s≠   Define new builtins 'quit' and 'exit'.

    These are objects which make the interpreter exit when called.
    The repr of each object contains a hint at how it works.

    t   :s   Cmd-Qs   \s   Ctrl-Z plus Returns   Ctrl-D (i.e. EOF)t   Quitterc              s,   e  Z d  Ñ  Z á  f d Ü  Z d d Ñ Z RS(   c         S   s   | |  _  d  S(   N(   R.   (   t   selfR.   (    (    s   /usr/lib/python2.7/site.pyt   __init__c  s    c            s   d |  j  à  f S(   Ns   Use %s() or %s to exit(   R.   (   Rs   (   t   eof(    s   /usr/lib/python2.7/site.pyt   __repr__e  s    c         S   s+   y t  j j É  Wn n Xt | É Ç d  S(   N(   R
   t   stdint   closet
   SystemExit(   Rs   t   code(    (    s   /usr/lib/python2.7/site.pyt   __call__g  s
    N(   t   __name__t
   __module__Rt   Rv   R   R{   (    (   Ru   (    s   /usr/lib/python2.7/site.pyRr   b  s   	t   quitt   exitN(   R    Rd   t   objectt   __builtin__R~   R   (   Rr   (    (   Ru   s   /usr/lib/python2.7/site.pyt   setquitT  s    		t   _Printerc           B   s>   e  Z d  Z d Z d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sn   interactive prompt objects for printing the license text, a list of
    contributors and the copyright notice.i   c         C   s1   | |  _  | |  _ | |  _ | |  _ d  |  _ d  S(   N(   t   _Printer__namet   _Printer__datat   _Printer__filest   _Printer__dirsR   t   _Printer__lines(   Rs   R.   t   datat   filest   dirs(    (    s   /usr/lib/python2.7/site.pyRt   y  s
    				c         C   s“   |  j  r d  Sd  } xÇ |  j D]w } xd |  j D]Y } t j j | | É } y* t | d É } | j É  } | j	 É  PWq- t
 k
 rÖ q- Xq- W| r Pq q W| s™ |  j } n  | j d É |  _  t |  j  É |  _ d  S(   NR   s   
(   Rà   R   Rá   RÜ   R    R   R   t   filet   readRx   R!   RÖ   Rm   t   lent   _Printer__linecnt(   Rs   Râ   R   t   filenamet   fp(    (    s   /usr/lib/python2.7/site.pyt   __setupÄ  s&    	
c         C   sH   |  j  É  t |  j É |  j k r2 d j |  j É Sd |  j f d Sd  S(   Ns   
s!   Type %s() to see the full %s texti   (   t   _Printer__setupRé   Rà   t   MAXLINESR   RÑ   (   Rs   (    (    s   /usr/lib/python2.7/site.pyRv   ï  s    
c         C   sæ   |  j  É  d } d } x° y1 x* t | | |  j É D] } |  j | GHq3 WWn t k
 r^ Pq X| |  j 7} d  } x1 | d  k r• t | É } | d k ru d  } qu qu W| d k r Pq q Wd  S(   Ns0   Hit Return for more, or q (and Return) to quit: i    t    t   q(   Rï   Rñ   (   Rì   t   rangeRî   Rà   t
   IndexErrorR   t	   raw_input(   Rs   t   promptt   linenot   it   key(    (    s   /usr/lib/python2.7/site.pyR{   ú  s"    
(    (    (   R|   R}   t   __doc__Rî   Rt   Rì   Rv   R{   (    (    (    s   /usr/lib/python2.7/site.pyRÉ   s  s   		c          C   s§   t  d t j É t _ t j d  d k r= t  d d É t _ n t  d d É t _ t j j t j	 É }  t  d d d	 d
 g t j j
 |  t j É |  t j g É t _ d S(   s,   Set 'copyright' and 'credits' in __builtin__t	   copyrighti   t   javat   creditss?   Jython is maintained by the Jython developers (www.jython.org).sû       Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
    for supporting Python development.  See www.python.org for more information.t   licenses'   See https://www.python.org/psf/license/s   LICENSE.txtt   LICENSEN(   RÉ   R
   Rü   RÅ   RU   R°   R    R   t   dirnameR   R   t   pardirt   curdirR¢   (   t   here(    (    s   /usr/lib/python2.7/site.pyt   setcopyright∞  s    	t   _Helperc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sX   Define the builtin 'help'.
    This is a wrapper around pydoc.help (with a twist).

    c         C   s   d S(   NsH   Type help() for interactive help, or help(object) for help about object.(    (   Rs   (    (    s   /usr/lib/python2.7/site.pyRv   »  s    c         O   s   d d  l  } | j | | é  S(   Niˇˇˇˇ(   t   pydoct   help(   Rs   t   argst   kwdsR™   (    (    s   /usr/lib/python2.7/site.pyR{   À  s    (   R|   R}   Rû   Rv   R{   (    (    (    s   /usr/lib/python2.7/site.pyR©   ¬  s   	c           C   s   t  É  t _ d  S(   N(   R©   RÅ   R´   (    (    (    s   /usr/lib/python2.7/site.pyt	   sethelperœ  s    c          C   s°   t  j d k rù d d l }  d d l } |  j É  d } | j d É rù y | j | É Wqö t k
 rñ d d l } | j	 | j
 | <d | j j | <qö Xqù n  d S(   s∑   On Windows, some default encodings are not provided by Python,
    while they are always available as "mbcs" in each locale. Make
    them usable by aliasing to "mbcs" in such a case.t   win32iˇˇˇˇNi   t   cpt   mbcs(   R
   RU   t   localet   codecst   getdefaultlocaleR#   t   lookupt   LookupErrort	   encodingst   _unknownt   _cachet   aliases(   R≤   R≥   t   encR∑   (    (    s   /usr/lib/python2.7/site.pyt	   aliasmbcs“  s    c          C   s&   d }  |  d k r" t  j |  É n  d S(   sñ   Set the string encoding used by the Unicode implementation.  The
    default is 'ascii', but if you're willing to experiment, you can
    change this.t   asciiN(   R
   t   setdefaultencoding(   t   encoding(    (    s   /usr/lib/python2.7/site.pyt   setencoding·  s    c          C   sg   y d d l  }  WnP t k
 r# n@ t k
 rb t j j rR t j t j É  å  qc t j d IJn Xd S(   s,   Run custom site specific code, if available.iˇˇˇˇNs3   'import sitecustomize' failed; use -v for traceback(	   t   sitecustomizet   ImportErrorR&   R
   RE   t   verboset
   excepthookR+   R'   (   R¡   (    (    s   /usr/lib/python2.7/site.pyt   execsitecustomizeı  s    c          C   sg   y d d l  }  WnP t k
 r# n@ t k
 rb t j j rR t j t j É  å  qc t j d IJn Xd S(   s,   Run custom user specific code, if available.iˇˇˇˇNs3   'import usercustomize' failed; use -v for traceback(	   t   usercustomizeR¬   R&   R
   RE   R√   Rƒ   R+   R'   (   R∆   (    (    s   /usr/lib/python2.7/site.pyt   execusercustomize  s    c          C   sØ   t  É  t É  }  t d  k r( t É  a n  t |  É }  t |  É }  t j d k rY t	 É  n  t
 É  t É  t É  t É  t É  t É  t rì t É  n  t t d É r´ t ` n  d  S(   NR_   Ræ   (   R   R   RZ   R   RI   R^   Ri   R
   RU   Rp   RÇ   R®   RÆ   Rº   R¿   R≈   R«   R   Ræ   (   R   (    (    s   /usr/lib/python2.7/site.pyt   main  s$    	

c          C   sú  d }  t  j d } | s™ d GHx t  j D] } d | f GHq( Wd GHd t t j j t É ra d n d f GHd	 t t j j t É rà d n d f GHd
 t GHt  j d É n  g  } d | k rÃ | j	 t É n  d | k rË | j	 t É n  | r]t j
 j | É GHt rt  j d É qòt t k r1t  j d É qòt d  k rMt  j d É qòt  j d É n; d d  l } | j |  t  j d t j
 f É GHt  j d É d  S(   Ns≤      %s [--user-base] [--user-site]

    Without arguments print some useful information
    With arguments print the value of USER_BASE and/or USER_SITE separated
    by '%s'.

    Exit codes with --user-base or --user-site:
      0 - user site directory is enabled
      1 - user site directory is disabled by user
      2 - uses site directory is disabled by super user
          or for security reasons
     >2 - unknown error
    i   s   sys.path = [s       %r,t   ]s   USER_BASE: %r (%s)R%   s   doesn't exists   USER_SITE: %r (%s)s   ENABLE_USER_SITE: %ri    s   --user-bases   --user-sitei   i   iˇˇˇˇi
   (   R
   t   argvR   RL   R    R   RT   RZ   R   R   t   pathsepR   RG   R   t   textwrapt   dedent(   R´   R¨   R   t   bufferRÃ   (    (    s   /usr/lib/python2.7/site.pyt   _script,  s<    !!	"t   __main__(&   Rû   R
   R    RÅ   R)   Rg   t   exec_prefixRc   R   RZ   RT   RL   R   R   R   R   R6   R@   RI   RN   RW   R^   Rh   Ri   Rp   RÇ   RÄ   RÉ   R®   R©   RÆ   Rº   R¿   R≈   R«   R»   Rœ   R|   (    (    (    s   /usr/lib/python2.7/site.pyt   <module>A   sF   						)								=								1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #! /usr/bin/python2.7
"""An RFC 2821 smtp proxy.

Usage: %(program)s [options] [localhost:localport [remotehost:remoteport]]

Options:

    --nosetuid
    -n
        This program generally tries to setuid `nobody', unless this flag is
        set.  The setuid call will fail if this program is not run as root (in
        which case, use this flag).

    --version
    -V
        Print the version number and exit.

    --class classname
    -c classname
        Use `classname' as the concrete SMTP proxy class.  Uses `PureProxy' by
        default.

    --debug
    -d
        Turn on debugging prints.

    --help
    -h
        Print this message and exit.

Version: %(__version__)s

If localhost is not given then `localhost' is used, and if localport is not
given then 8025 is used.  If remotehost is not given then `localhost' is used,
and if remoteport is not given, then 25 is used.
"""

# Overview:
#
# This file implements the minimal SMTP protocol as defined in RFC 821.  It
# has a hierarchy of classes which implement the backend functionality for the
# smtpd.  A number of classes are provided:
#
#   SMTPServer - the base class for the backend.  Raises NotImplementedError
#   if you try to use it.
#
#   DebuggingServer - simply prints each message it receives on stdout.
#
#   PureProxy - Proxies all messages to a real smtpd which does final
#   delivery.  One known problem with this class is that it doesn't handle
#   SMTP errors from the backend server at all.  This should be fixed
#   (contributions are welcome!).
#
#   MailmanProxy - An experimental hack to work with GNU Mailman
#   <www.list.org>.  Using this server as your real incoming smtpd, your
#   mailhost will automatically recognize and accept mail destined to Mailman
#   lists when those lists are created.  Every message not destined for a list
#   gets forwarded to a real backend smtpd, as with PureProxy.  Again, errors
#   are not handled correctly yet.
#
# Please note that this script requires Python 2.0
#
# Author: Barry Warsaw <barry@python.org>
#
# TODO:
#
# - support mailbox delivery
# - alias files
# - ESMTP
# - handle error codes from the backend smtpd

import sys
import os
import errno
import getopt
import time
import socket
import asyncore
import asynchat

__all__ = ["SMTPServer","DebuggingServer","PureProxy","MailmanProxy"]

program = sys.argv[0]
__version__ = 'Python SMTP proxy version 0.2'


class Devnull:
    def write(self, msg): pass
    def flush(self): pass


DEBUGSTREAM = Devnull()
NEWLINE = '\n'
EMPTYSTRING = ''
COMMASPACE = ', '


def usage(code, msg=''):
    print >> sys.stderr, __doc__ % globals()
    if msg:
        print >> sys.stderr, msg
    sys.exit(code)


class SMTPChannel(asynchat.async_chat):
    COMMAND = 0
    DATA = 1

    def __init__(self, server, conn, addr):
        asynchat.async_chat.__init__(self, conn)
        self.__server = server
        self.__conn = conn
        self.__addr = addr
        self.__line = []
        self.__state = self.COMMAND
        self.__greeting = 0
        self.__mailfrom = None
        self.__rcpttos = []
        self.__data = ''
        self.__fqdn = socket.getfqdn()
        try:
            self.__peer = conn.getpeername()
        except socket.error, err:
            # a race condition  may occur if the other end is closing
            # before we can get the peername
            self.close()
            if err[0] != errno.ENOTCONN:
                raise
            return
        print >> DEBUGSTREAM, 'Peer:', repr(self.__peer)
        self.push('220 %s %s' % (self.__fqdn, __version__))
        self.set_terminator('\r\n')

    # Overrides base class for convenience
    def push(self, msg):
        asynchat.async_chat.push(self, msg + '\r\n')

    # Implementation of base class abstract method
    def collect_incoming_data(self, data):
        self.__line.append(data)

    # Implementation of base class abstract method
    def found_terminator(self):
        line = EMPTYSTRING.join(self.__line)
        print >> DEBUGSTREAM, 'Data:', repr(line)
        self.__line = []
        if self.__state == self.COMMAND:
            if not line:
                self.push('500 Error: bad syntax')
                return
            method = None
            i = line.find(' ')
            if i < 0:
                command = line.upper()
                arg = None
            else:
                command = line[:i].upper()
                arg = line[i+1:].strip()
            method = getattr(self, 'smtp_' + command, None)
            if not method:
                self.push('502 Error: command "%s" not implemented' % command)
                return
            method(arg)
            return
        else:
            if self.__state != self.DATA:
                self.push('451 Internal confusion')
                return
            # Remove extraneous carriage returns and de-transparency according
            # to RFC 821, Section 4.5.2.
            data = []
            for text in line.split('\r\n'):
                if text and text[0] == '.':
                    data.append(text[1:])
                else:
                    data.append(text)
            self.__data = NEWLINE.join(data)
            status = self.__server.process_message(self.__peer,
                                                   self.__mailfrom,
                                                   self.__rcpttos,
                                                   self.__data)
            self.__rcpttos = []
            self.__mailfrom = None
            self.__state = self.COMMAND
            self.set_terminator('\r\n')
            if not status:
                self.push('250 Ok')
            else:
                self.push(status)

    # SMTP and ESMTP commands
    def smtp_HELO(self, arg):
        if not arg:
            self.push('501 Syntax: HELO hostname')
            return
        if self.__greeting:
            self.push('503 Duplicate HELO/EHLO')
        else:
            self.__greeting = arg
            self.push('250 %s' % self.__fqdn)

    def smtp_NOOP(self, arg):
        if arg:
            self.push('501 Syntax: NOOP')
        else:
            self.push('250 Ok')

    def smtp_QUIT(self, arg):
        # args is ignored
        self.push('221 Bye')
        self.close_when_done()

    # factored
    def __getaddr(self, keyword, arg):
        address = None
        keylen = len(keyword)
        if arg[:keylen].upper() == keyword:
            address = arg[keylen:].strip()
            if not address:
                pass
            elif address[0] == '<' and address[-1] == '>' and address != '<>':
                # Addresses can be in the form <person@dom.com> but watch out
                # for null address, e.g. <>
                address = address[1:-1]
        return address

    def smtp_MAIL(self, arg):
        print >> DEBUGSTREAM, '===> MAIL', arg
        address = self.__getaddr('FROM:', arg) if arg else None
        if not address:
            self.push('501 Syntax: MAIL FROM:<address>')
            return
        if self.__mailfrom:
            self.push('503 Error: nested MAIL command')
            return
        self.__mailfrom = address
        print >> DEBUGSTREAM, 'sender:', self.__mailfrom
        self.push('250 Ok')

    def smtp_RCPT(self, arg):
        print >> DEBUGSTREAM, '===> RCPT', arg
        if not self.__mailfrom:
            self.push('503 Error: need MAIL command')
            return
        address = self.__getaddr('TO:', arg) if arg else None
        if not address:
            self.push('501 Syntax: RCPT TO: <address>')
            return
        self.__rcpttos.append(address)
        print >> DEBUGSTREAM, 'recips:', self.__rcpttos
        self.push('250 Ok')

    def smtp_RSET(self, arg):
        if arg:
            self.push('501 Syntax: RSET')
            return
        # Resets the sender, recipients, and data, but not the greeting
        self.__mailfrom = None
        self.__rcpttos = []
        self.__data = ''
        self.__state = self.COMMAND
        self.push('250 Ok')

    def smtp_DATA(self, arg):
        if not self.__rcpttos:
            self.push('503 Error: need RCPT command')
            return
        if arg:
            self.push('501 Syntax: DATA')
            return
        self.__state = self.DATA
        self.set_terminator('\r\n.\r\n')
        self.push('354 End data with <CR><LF>.<CR><LF>')


class SMTPServer(asyncore.dispatcher):
    def __init__(self, localaddr, remoteaddr):
        self._localaddr = localaddr
        self._remoteaddr = remoteaddr
        asyncore.dispatcher.__init__(self)
        try:
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            # try to re-use a server port if possible
            self.set_reuse_addr()
            self.bind(localaddr)
            self.listen(5)
        except:
            # cleanup asyncore.socket_map before raising
            self.close()
            raise
        else:
            print >> DEBUGSTREAM, \
                  '%s started at %s\n\tLocal addr: %s\n\tRemote addr:%s' % (
                self.__class__.__name__, time.ctime(time.time()),
                localaddr, remoteaddr)

    def handle_accept(self):
        pair = self.accept()
        if pair is not None:
            conn, addr = pair
            print >> DEBUGSTREAM, 'Incoming connection from %s' % repr(addr)
            channel = SMTPChannel(self, conn, addr)

    # API for "doing something useful with the message"
    def process_message(self, peer, mailfrom, rcpttos, data):
        """Override this abstract method to handle messages from the client.

        peer is a tuple containing (ipaddr, port) of the client that made the
        socket connection to our smtp port.

        mailfrom is the raw address the client claims the message is coming
        from.

        rcpttos is a list of raw addresses the client wishes to deliver the
        message to.

        data is a string containing the entire full text of the message,
        headers (if supplied) and all.  It has been `de-transparencied'
        according to RFC 821, Section 4.5.2.  In other words, a line
        containing a `.' followed by other text has had the leading dot
        removed.

        This function should return None, for a normal `250 Ok' response;
        otherwise it returns the desired response string in RFC 821 format.

        """
        raise NotImplementedError


class DebuggingServer(SMTPServer):
    # Do something with the gathered message
    def process_message(self, peer, mailfrom, rcpttos, data):
        inheaders = 1
        lines = data.split('\n')
        print '---------- MESSAGE FOLLOWS ----------'
        for line in lines:
            # headers first
            if inheaders and not line:
                print 'X-Peer:', peer[0]
                inheaders = 0
            print line
        print '------------ END MESSAGE ------------'


class PureProxy(SMTPServer):
    def process_message(self, peer, mailfrom, rcpttos, data):
        lines = data.split('\n')
        # Look for the last header
        i = 0
        for line in lines:
            if not line:
                break
            i += 1
        lines.insert(i, 'X-Peer: %s' % peer[0])
        data = NEWLINE.join(lines)
        refused = self._deliver(mailfrom, rcpttos, data)
        # TBD: what to do with refused addresses?
        print >> DEBUGSTREAM, 'we got some refusals:', refused

    def _deliver(self, mailfrom, rcpttos, data):
        import smtplib
        refused = {}
        try:
            s = smtplib.SMTP()
            s.connect(self._remoteaddr[0], self._remoteaddr[1])
            try:
                refused = s.sendmail(mailfrom, rcpttos, data)
            finally:
                s.quit()
        except smtplib.SMTPRecipientsRefused, e:
            print >> DEBUGSTREAM, 'got SMTPRecipientsRefused'
            refused = e.recipients
        except (socket.error, smtplib.SMTPException), e:
            print >> DEBUGSTREAM, 'got', e.__class__
            # All recipients were refused.  If the exception had an associated
            # error code, use it.  Otherwise,fake it with a non-triggering
            # exception code.
            errcode = getattr(e, 'smtp_code', -1)
            errmsg = getattr(e, 'smtp_error', 'ignore')
            for r in rcpttos:
                refused[r] = (errcode, errmsg)
        return refused


class MailmanProxy(PureProxy):
    def process_message(self, peer, mailfrom, rcpttos, data):
        from cStringIO import StringIO
        from Mailman import Utils
        from Mailman import Message
        from Mailman import MailList
        # If the message is to a Mailman mailing list, then we'll invoke the
        # Mailman script directly, without going through the real smtpd.
        # Otherwise we'll forward it to the local proxy for disposition.
        listnames = []
        for rcpt in rcpttos:
            local = rcpt.lower().split('@')[0]
            # We allow the following variations on the theme
            #   listname
            #   listname-admin
            #   listname-owner
            #   listname-request
            #   listname-join
            #   listname-leave
            parts = local.split('-')
            if len(parts) > 2:
                continue
            listname = parts[0]
            if len(parts) == 2:
                command = parts[1]
            else:
                command = ''
            if not Utils.list_exists(listname) or command not in (
                    '', 'admin', 'owner', 'request', 'join', 'leave'):
                continue
            listnames.append((rcpt, listname, command))
        # Remove all list recipients from rcpttos and forward what we're not
        # going to take care of ourselves.  Linear removal should be fine
        # since we don't expect a large number of recipients.
        for rcpt, listname, command in listnames:
            rcpttos.remove(rcpt)
        # If there's any non-list destined recipients left,
        print >> DEBUGSTREAM, 'forwarding recips:', ' '.join(rcpttos)
        if rcpttos:
            refused = self._deliver(mailfrom, rcpttos, data)
            # TBD: what to do with refused addresses?
            print >> DEBUGSTREAM, 'we got refusals:', refused
        # Now deliver directly to the list commands
        mlists = {}
        s = StringIO(data)
        msg = Message.Message(s)
        # These headers are required for the proper execution of Mailman.  All
        # MTAs in existence seem to add these if the original message doesn't
        # have them.
        if not msg.getheader('from'):
            msg['From'] = mailfrom
        if not msg.getheader('date'):
            msg['Date'] = time.ctime(time.time())
        for rcpt, listname, command in listnames:
            print >> DEBUGSTREAM, 'sending message to', rcpt
            mlist = mlists.get(listname)
            if not mlist:
                mlist = MailList.MailList(listname, lock=0)
                mlists[listname] = mlist
            # dispatch on the type of command
            if command == '':
                # post
                msg.Enqueue(mlist, tolist=1)
            elif command == 'admin':
                msg.Enqueue(mlist, toadmin=1)
            elif command == 'owner':
                msg.Enqueue(mlist, toowner=1)
            elif command == 'request':
                msg.Enqueue(mlist, torequest=1)
            elif command in ('join', 'leave'):
                # TBD: this is a hack!
                if command == 'join':
                    msg['Subject'] = 'subscribe'
                else:
                    msg['Subject'] = 'unsubscribe'
                msg.Enqueue(mlist, torequest=1)


class Options:
    setuid = 1
    classname = 'PureProxy'


def parseargs():
    global DEBUGSTREAM
    try:
        opts, args = getopt.getopt(
            sys.argv[1:], 'nVhc:d',
            ['class=', 'nosetuid', 'version', 'help', 'debug'])
    except getopt.error, e:
        usage(1, e)

    options = Options()
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt in ('-V', '--version'):
            print >> sys.stderr, __version__
            sys.exit(0)
        elif opt in ('-n', '--nosetuid'):
            options.setuid = 0
        elif opt in ('-c', '--class'):
            options.classname = arg
        elif opt in ('-d', '--debug'):
            DEBUGSTREAM = sys.stderr

    # parse the rest of the arguments
    if len(args) < 1:
        localspec = 'localhost:8025'
        remotespec = 'localhost:25'
    elif len(args) < 2:
        localspec = args[0]
        remotespec = 'localhost:25'
    elif len(args) < 3:
        localspec = args[0]
        remotespec = args[1]
    else:
        usage(1, 'Invalid arguments: %s' % COMMASPACE.join(args))

    # split into host/port pairs
    i = localspec.find(':')
    if i < 0:
        usage(1, 'Bad local spec: %s' % localspec)
    options.localhost = localspec[:i]
    try:
        options.localport = int(localspec[i+1:])
    except ValueError:
        usage(1, 'Bad local port: %s' % localspec)
    i = remotespec.find(':')
    if i < 0:
        usage(1, 'Bad remote spec: %s' % remotespec)
    options.remotehost = remotespec[:i]
    try:
        options.remoteport = int(remotespec[i+1:])
    except ValueError:
        usage(1, 'Bad remote port: %s' % remotespec)
    return options


if __name__ == '__main__':
    options = parseargs()
    # Become nobody
    classname = options.classname
    if "." in classname:
        lastdot = classname.rfind(".")
        mod = __import__(classname[:lastdot], globals(), locals(), [""])
        classname = classname[lastdot+1:]
    else:
        import __main__ as mod
    class_ = getattr(mod, classname)
    proxy = class_((options.localhost, options.localport),
                   (options.remotehost, options.remoteport))
    if options.setuid:
        try:
            import pwd
        except ImportError:
            print >> sys.stderr, \
                  'Cannot import module "pwd"; try running with -n option.'
            sys.exit(1)
        nobody = pwd.getpwnam('nobody')[2]
        try:
            os.setuid(nobody)
        except OSError, e:
            if e.errno != errno.EPERM: raise
            print >> sys.stderr, \
                  'Cannot setuid "nobody"; try running with -n option.'
            sys.exit(1)
    try:
        asyncore.loop()
    except KeyboardInterrupt:
        pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   si   d  Z  d d l m Z e d d d É[ d Z d Z d Z d Z d	 Z d
 Z d Z	 d Z
 d Z d Z d S(   sI   Constants for interpreting the results of os.statvfs() and os.fstatvfs().iˇˇˇˇ(   t   warnpy3ks1   the statvfs module has been removed in Python 3.0t
   stackleveli   i    i   i   i   i   i   i   i   i	   N(   t   __doc__t   warningsR    t   F_BSIZEt   F_FRSIZEt   F_BLOCKSt   F_BFREEt   F_BAVAILt   F_FILESt   F_FFREEt   F_FAVAILt   F_FLAGt	   F_NAMEMAX(    (    (    s   /usr/lib/python2.7/statvfs.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """Routines to help recognizing sound files.

Function whathdr() recognizes various types of sound file headers.
It understands almost all headers that SOX can decode.

The return tuple contains the following items, in this order:
- file type (as SOX understands it)
- sampling rate (0 if unknown or hard to decode)
- number of channels (0 if unknown or hard to decode)
- number of frames in the file (-1 if unknown or hard to decode)
- number of bits/sample, or 'U' for U-LAW, or 'A' for A-LAW

If the file doesn't have a recognizable type, it returns None.
If the file can't be opened, IOError is raised.

To compute the total time, divide the number of frames by the
sampling rate (a frame contains a sample for each channel).

Function what() calls whathdr().  (It used to also use some
heuristics for raw data, but this doesn't work very well.)

Finally, the function test() is a simple main program that calls
what() for all files mentioned on the argument list.  For directory
arguments it calls what() for all files in that directory.  Default
argument is "." (testing all files in the current directory).  The
option -r tells it to recurse down directories found inside
explicitly given directories.
"""

# The file structure is top-down except that the test program and its
# subroutine come last.

__all__ = ["what","whathdr"]

def what(filename):
    """Guess the type of a sound file"""
    res = whathdr(filename)
    return res


def whathdr(filename):
    """Recognize sound headers"""
    f = open(filename, 'rb')
    h = f.read(512)
    for tf in tests:
        res = tf(h, f)
        if res:
            return res
    return None


#-----------------------------------#
# Subroutines per sound header type #
#-----------------------------------#

tests = []

def test_aifc(h, f):
    import aifc
    if h[:4] != 'FORM':
        return None
    if h[8:12] == 'AIFC':
        fmt = 'aifc'
    elif h[8:12] == 'AIFF':
        fmt = 'aiff'
    else:
        return None
    f.seek(0)
    try:
        a = aifc.openfp(f, 'r')
    except (EOFError, aifc.Error):
        return None
    return (fmt, a.getframerate(), a.getnchannels(), \
            a.getnframes(), 8*a.getsampwidth())

tests.append(test_aifc)


def test_au(h, f):
    if h[:4] == '.snd':
        f = get_long_be
    elif h[:4] in ('\0ds.', 'dns.'):
        f = get_long_le
    else:
        return None
    type = 'au'
    hdr_size = f(h[4:8])
    data_size = f(h[8:12])
    encoding = f(h[12:16])
    rate = f(h[16:20])
    nchannels = f(h[20:24])
    sample_size = 1 # default
    if encoding == 1:
        sample_bits = 'U'
    elif encoding == 2:
        sample_bits = 8
    elif encoding == 3:
        sample_bits = 16
        sample_size = 2
    else:
        sample_bits = '?'
    frame_size = sample_size * nchannels
    return type, rate, nchannels, data_size//frame_size, sample_bits

tests.append(test_au)


def test_hcom(h, f):
    if h[65:69] != 'FSSD' or h[128:132] != 'HCOM':
        return None
    divisor = get_long_be(h[128+16:128+20])
    return 'hcom', 22050//divisor, 1, -1, 8

tests.append(test_hcom)


def test_voc(h, f):
    if h[:20] != 'Creative Voice File\032':
        return None
    sbseek = get_short_le(h[20:22])
    rate = 0
    if 0 <= sbseek < 500 and h[sbseek] == '\1':
        ratecode = ord(h[sbseek+4])
        rate = int(1000000.0 / (256 - ratecode))
    return 'voc', rate, 1, -1, 8

tests.append(test_voc)


def test_wav(h, f):
    # 'RIFF' <len> 'WAVE' 'fmt ' <len>
    if h[:4] != 'RIFF' or h[8:12] != 'WAVE' or h[12:16] != 'fmt ':
        return None
    style = get_short_le(h[20:22])
    nchannels = get_short_le(h[22:24])
    rate = get_long_le(h[24:28])
    sample_bits = get_short_le(h[34:36])
    return 'wav', rate, nchannels, -1, sample_bits

tests.append(test_wav)


def test_8svx(h, f):
    if h[:4] != 'FORM' or h[8:12] != '8SVX':
        return None
    # Should decode it to get #channels -- assume always 1
    return '8svx', 0, 1, 0, 8

tests.append(test_8svx)


def test_sndt(h, f):
    if h[:5] == 'SOUND':
        nsamples = get_long_le(h[8:12])
        rate = get_short_le(h[20:22])
        return 'sndt', rate, 1, nsamples, 8

tests.append(test_sndt)


def test_sndr(h, f):
    if h[:2] == '\0\0':
        rate = get_short_le(h[2:4])
        if 4000 <= rate <= 25000:
            return 'sndr', rate, 1, -1, 8

tests.append(test_sndr)


#---------------------------------------------#
# Subroutines to extract numbers from strings #
#---------------------------------------------#

def get_long_be(s):
    return (ord(s[0])<<24) | (ord(s[1])<<16) | (ord(s[2])<<8) | ord(s[3])

def get_long_le(s):
    return (ord(s[3])<<24) | (ord(s[2])<<16) | (ord(s[1])<<8) | ord(s[0])

def get_short_be(s):
    return (ord(s[0])<<8) | ord(s[1])

def get_short_le(s):
    return (ord(s[1])<<8) | ord(s[0])


#--------------------#
# Small test program #
#--------------------#

def test():
    import sys
    recursive = 0
    if sys.argv[1:] and sys.argv[1] == '-r':
        del sys.argv[1:2]
        recursive = 1
    try:
        if sys.argv[1:]:
            testall(sys.argv[1:], recursive, 1)
        else:
            testall(['.'], recursive, 1)
    except KeyboardInterrupt:
        sys.stderr.write('\n[Interrupted]\n')
        sys.exit(1)

def testall(list, recursive, toplevel):
    import sys
    import os
    for filename in list:
        if os.path.isdir(filename):
            print filename + '/:',
            if recursive or toplevel:
                print 'recursing down:'
                import glob
                names = glob.glob(os.path.join(filename, '*'))
                testall(names, recursive, 0)
            else:
                print '*** directory (use -r) ***'
        else:
            print filename + ':',
            sys.stdout.flush()
            try:
                print what(filename)
            except IOError:
                print '*** not found ***'

if __name__ == '__main__':
    test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   s‚  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d d d g Z	 e j
 d Z d Z d	 d d
 Ñ  É  YZ e É  a d Z d Z d Z d d Ñ Z d e j f d Ñ  É  YZ d e j f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d d  d Ñ  É  YZ d Ñ  Z e d k rﬁe É  Z e j Z d e k r¡e j d É Z  e! e e   e" É  e# É  d g É Z$ e e  d Z n d d l% Z$ e& e$ e É Z' e' e j( e j) f e j* e j+ f É Z, e j- rπy d d l. Z. Wn+ e/ k
 rIe j0 d IJe j1 d É n Xe. j2 d É d Z3 y e j- e3 É Wqπe4 k
 rµZ5 e5 j e j6 k ròÇ  n  e j0 d IJe j1 d É qπXn  y e j7 É  Wqﬁe8 k
 r⁄qﬁXn  d S(!   sc  An RFC 2821 smtp proxy.

Usage: %(program)s [options] [localhost:localport [remotehost:remoteport]]

Options:

    --nosetuid
    -n
        This program generally tries to setuid `nobody', unless this flag is
        set.  The setuid call will fail if this program is not run as root (in
        which case, use this flag).

    --version
    -V
        Print the version number and exit.

    --class classname
    -c classname
        Use `classname' as the concrete SMTP proxy class.  Uses `PureProxy' by
        default.

    --debug
    -d
        Turn on debugging prints.

    --help
    -h
        Print this message and exit.

Version: %(__version__)s

If localhost is not given then `localhost' is used, and if localport is not
given then 8025 is used.  If remotehost is not given then `localhost' is used,
and if remoteport is not given, then 25 is used.
iˇˇˇˇNt
   SMTPServert   DebuggingServert	   PureProxyt   MailmanProxyi    s   Python SMTP proxy version 0.2t   Devnullc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s   d  S(   N(    (   t   selft   msg(    (    s   /usr/lib/python2.7/smtpd.pyt   writeX   s    c         C   s   d  S(   N(    (   R   (    (    s   /usr/lib/python2.7/smtpd.pyt   flushY   s    (   t   __name__t
   __module__R   R   (    (    (    s   /usr/lib/python2.7/smtpd.pyR   W   s   	s   
t    s   , c         C   s;   t  j t t É  IJ| r* t  j | IJn  t  j |  É d  S(   N(   t   syst   stderrt   __doc__t   globalst   exit(   t   codeR   (    (    s   /usr/lib/python2.7/smtpd.pyt   usageb   s    t   SMTPChannelc           B   sÄ   e  Z d  Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   i    i   c         C   s
  t  j j |  | É | |  _ | |  _ | |  _ g  |  _ |  j |  _ d |  _	 d  |  _ g  |  _ d |  _ t j É  |  _ y | j É  |  _ Wn: t j k
 r≈ } |  j É  | d t j k r¡ Ç  n  d  SXt d It |  j É IJ|  j d |  j t f É |  j d É d  S(   Ni    R   s   Peer:s	   220 %s %ss   
(   t   asynchatt
   async_chatt   __init__t   _SMTPChannel__servert   _SMTPChannel__connt   _SMTPChannel__addrt   _SMTPChannel__linet   COMMANDt   _SMTPChannel__statet   _SMTPChannel__greetingt   Nonet   _SMTPChannel__mailfromt   _SMTPChannel__rcpttost   _SMTPChannel__datat   sockett   getfqdnt   _SMTPChannel__fqdnt   getpeernamet   _SMTPChannel__peert   errort   closet   errnot   ENOTCONNt   DEBUGSTREAMt   reprt   pusht   __version__t   set_terminator(   R   t   servert   connt   addrt   err(    (    s   /usr/lib/python2.7/smtpd.pyR   m   s*    								
c         C   s   t  j j |  | d É d  S(   Ns   
(   R   R   R-   (   R   R   (    (    s   /usr/lib/python2.7/smtpd.pyR-   á   s    c         C   s   |  j  j | É d  S(   N(   R   t   append(   R   t   data(    (    s   /usr/lib/python2.7/smtpd.pyt   collect_incoming_dataã   s    c   	      C   s¯  t  j |  j É } t d It | É IJg  |  _ |  j |  j k rÛ | sZ |  j d É d  Sd  } | j	 d É } | d k  rê | j
 É  } d  } n$ | |  j
 É  } | | d j É  } t |  d | d  É } | sÂ |  j d | É d  S| | É d  S|  j |  j k r|  j d É d  Sg  } xN | j d	 É D]= } | r\| d d
 k r\| j | d É q,| j | É q,Wt j | É |  _ |  j j |  j |  j |  j |  j É } g  |  _ d  |  _ |  j |  _ |  j d	 É | sÁ|  j d É n |  j | É d  S(   Ns   Data:s   500 Error: bad syntaxt    i    i   t   smtp_s'   502 Error: command "%s" not implementeds   451 Internal confusions   
t   .s   250 Ok(   t   EMPTYSTRINGt   joinR   R+   R,   R   R   R-   R   t   findt   uppert   stript   getattrt   DATAt   splitR4   t   NEWLINER!   R   t   process_messageR&   R   R    R/   (	   R   t   linet   methodt   it   commandt   argR5   t   textt   status(    (    s   /usr/lib/python2.7/smtpd.pyt   found_terminatorè   sP    		
		c         C   sQ   | s |  j  d É d  S|  j r0 |  j  d É n | |  _ |  j  d |  j É d  S(   Ns   501 Syntax: HELO hostnames   503 Duplicate HELO/EHLOs   250 %s(   R-   R   R$   (   R   RH   (    (    s   /usr/lib/python2.7/smtpd.pyt	   smtp_HELO¿   s    		c         C   s'   | r |  j  d É n |  j  d É d  S(   Ns   501 Syntax: NOOPs   250 Ok(   R-   (   R   RH   (    (    s   /usr/lib/python2.7/smtpd.pyt	   smtp_NOOP    s    c         C   s   |  j  d É |  j É  d  S(   Ns   221 Bye(   R-   t   close_when_done(   R   RH   (    (    s   /usr/lib/python2.7/smtpd.pyt	   smtp_QUIT–   s    c         C   sÑ   d  } t | É } | |  j É  | k rÄ | | j É  } | sA qÄ | d d k rÄ | d d k rÄ | d k rÄ | d d !} qÄ n  | S(   Ni    t   <iˇˇˇˇt   >s   <>i   (   R   t   lenR=   R>   (   R   t   keywordRH   t   addresst   keylen(    (    s   /usr/lib/python2.7/smtpd.pyt	   __getaddr÷   s    ,c         C   så   t  d I| IJ| r( |  j d | É n d  } | sE |  j d É d  S|  j r_ |  j d É d  S| |  _ t  d I|  j IJ|  j d É d  S(   Ns	   ===> MAILs   FROM:s   501 Syntax: MAIL FROM:<address>s   503 Error: nested MAIL commands   sender:s   250 Ok(   R+   t   _SMTPChannel__getaddrR   R-   R   (   R   RH   RT   (    (    s   /usr/lib/python2.7/smtpd.pyt	   smtp_MAIL„   s    		c         C   sì   t  d I| IJ|  j s* |  j d É d  S| rB |  j d | É n d  } | s_ |  j d É d  S|  j j | É t  d I|  j IJ|  j d É d  S(   Ns	   ===> RCPTs   503 Error: need MAIL commands   TO:s   501 Syntax: RCPT TO: <address>s   recips:s   250 Ok(   R+   R   R-   RW   R   R    R4   (   R   RH   RT   (    (    s   /usr/lib/python2.7/smtpd.pyt	   smtp_RCPT   s    	c         C   sO   | r |  j  d É d  Sd  |  _ g  |  _ d |  _ |  j |  _ |  j  d É d  S(   Ns   501 Syntax: RSETR   s   250 Ok(   R-   R   R   R    R!   R   R   (   R   RH   (    (    s   /usr/lib/python2.7/smtpd.pyt	   smtp_RSET˝   s    			c         C   s[   |  j  s |  j d É d  S| r1 |  j d É d  S|  j |  _ |  j d É |  j d É d  S(   Ns   503 Error: need RCPT commands   501 Syntax: DATAs   
.
s#   354 End data with <CR><LF>.<CR><LF>(   R    R-   R@   R   R/   (   R   RH   (    (    s   /usr/lib/python2.7/smtpd.pyt	   smtp_DATA  s    	(   R	   R
   R   R@   R   R-   R6   RK   RL   RM   RO   RW   RX   RY   RZ   R[   (    (    (    s   /usr/lib/python2.7/smtpd.pyR   i   s   				1	
						c           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s™   | |  _  | |  _ t j j |  É y> |  j t j t j É |  j	 É  |  j
 | É |  j d É Wn |  j É  Ç  n0 Xt d |  j j t j t j É  É | | f IJd  S(   Ni   s0   %s started at %s
	Local addr: %s
	Remote addr:%s(   t
   _localaddrt   _remoteaddrt   asyncoret
   dispatcherR   t   create_socketR"   t   AF_INETt   SOCK_STREAMt   set_reuse_addrt   bindt   listenR(   R+   t	   __class__R	   t   timet   ctime(   R   t	   localaddrt
   remoteaddr(    (    s   /usr/lib/python2.7/smtpd.pyR     s    		

c         C   sQ   |  j  É  } | d  k	 rM | \ } } t d t | É IJt |  | | É } n  d  S(   Ns   Incoming connection from %s(   t   acceptR   R+   R,   R   (   R   t   pairR1   R2   t   channel(    (    s   /usr/lib/python2.7/smtpd.pyt   handle_accept)  s
    c         C   s
   t  Ç d S(   sI  Override this abstract method to handle messages from the client.

        peer is a tuple containing (ipaddr, port) of the client that made the
        socket connection to our smtp port.

        mailfrom is the raw address the client claims the message is coming
        from.

        rcpttos is a list of raw addresses the client wishes to deliver the
        message to.

        data is a string containing the entire full text of the message,
        headers (if supplied) and all.  It has been `de-transparencied'
        according to RFC 821, Section 4.5.2.  In other words, a line
        containing a `.' followed by other text has had the leading dot
        removed.

        This function should return None, for a normal `250 Ok' response;
        otherwise it returns the desired response string in RFC 821 format.

        N(   t   NotImplementedError(   R   t   peert   mailfromt   rcpttosR5   (    (    s   /usr/lib/python2.7/smtpd.pyRC   1  s    (   R	   R
   R   Rn   RC   (    (    (    s   /usr/lib/python2.7/smtpd.pyR      s   		c           B   s   e  Z d  Ñ  Z RS(   c         C   s\   d } | j  d É } d GHx6 | D]. } | rJ | rJ d G| d GHd } n  | GHq! Wd GHd  S(   Ni   s   
s%   ---------- MESSAGE FOLLOWS ----------s   X-Peer:i    s%   ------------ END MESSAGE ------------(   RA   (   R   Rp   Rq   Rr   R5   t	   inheaderst   linesRD   (    (    s   /usr/lib/python2.7/smtpd.pyRC   L  s    		(   R	   R
   RC   (    (    (    s   /usr/lib/python2.7/smtpd.pyR   J  s   c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c   	      C   sä   | j  d É } d } x" | D] } | s, Pn  | d 7} q W| j | d | d É t j | É } |  j | | | É } t d I| IJd  S(   Ns   
i    i   s
   X-Peer: %ss   we got some refusals:(   RA   t   insertRB   R;   t   _deliverR+   (	   R   Rp   Rq   Rr   R5   Rt   RF   RD   t   refused(    (    s   /usr/lib/python2.7/smtpd.pyRC   Z  s    c         C   s  d d  l  } i  } yU | j É  } | j |  j d |  j d É z | j | | | É } Wd  | j É  XWnü | j k
 rí } t d IJ| j } nw t	 j
 | j f k
 r} t d I| j IJt | d d É } t | d d É }	 x" | D] }
 | |	 f | |
 <qÎ Wn X| S(	   Niˇˇˇˇi    i   s   got SMTPRecipientsRefusedt   gott	   smtp_codet
   smtp_errort   ignore(   t   smtplibt   SMTPt   connectR]   t   sendmailt   quitt   SMTPRecipientsRefusedR+   t
   recipientsR"   R'   t   SMTPExceptionRf   R?   (   R   Rq   Rr   R5   R|   Rw   t   st   et   errcodet   errmsgt   r(    (    s   /usr/lib/python2.7/smtpd.pyRv   h  s$    
(   R	   R
   RC   Rv   (    (    (    s   /usr/lib/python2.7/smtpd.pyR   Y  s   	c           B   s   e  Z d  Ñ  Z RS(   c         C   s  d d l  m } d d l m } d d l m } d d l m } g  }	 xµ | D]≠ }
 |
 j É  j d É d } | j d É } t | É d	 k rì qM n  | d } t | É d	 k rº | d
 } n d } | j	 | É sM | d! k r‰ qM n  |	 j
 |
 | | f É qM Wx$ |	 D] \ }
 } } | j |
 É qWt d Id j | É IJ| rl|  j | | | É } t d I| IJn  i  } | | É } | j | É } | j d É s©| | d <n  | j d É s‘t j t j É  É | d <n  x+|	 D]#\ }
 } } t d I|
 IJ| j | É } | s1| j | d d É} | | | <n  | d k rS| j | d d
 Éq€| d k ru| j | d d
 Éq€| d k ró| j | d d
 Éq€| d k rπ| j | d d
 Éq€| d" k r€| d k rﬁd | d <n
 d  | d <| j | d d
 Éq€q€Wd  S(#   Niˇˇˇˇ(   t   StringIO(   t   Utils(   t   Message(   t   MailListt   @i    t   -i   i   R   t   admint   ownert   requestR;   t   leaves   forwarding recips:R7   s   we got refusals:t   fromt   Fromt   datet   Dates   sending message tot   lockt   tolistt   toadmint   toownert	   torequestt	   subscribet   Subjectt   unsubscribe(   R   Rè   Rê   Rë   R;   Rí   (   R;   Rí   (   t	   cStringIORâ   t   MailmanRä   Rã   Rå   t   lowerRA   RR   t   list_existsR4   t   removeR+   R;   Rv   t	   getheaderRg   Rh   t   gett   Enqueue(   R   Rp   Rq   Rr   R5   Râ   Rä   Rã   Rå   t	   listnamest   rcptt   localt   partst   listnameRG   Rw   t   mlistsRÑ   R   t   mlist(    (    s   /usr/lib/python2.7/smtpd.pyRC   Ç  sd    
	
(   R	   R
   RC   (    (    (    s   /usr/lib/python2.7/smtpd.pyR   Å  s   t   Optionsc           B   s   e  Z d  Z d Z RS(   i   R   (   R	   R
   t   setuidt	   classname(    (    (    s   /usr/lib/python2.7/smtpd.pyRÆ   œ  s   c    	      C   sä  y5 t  j  t j d d d d d d d g É \ }  } Wn# t  j k
 rZ } t d | É n Xt É  } xû |  D]ñ \ } } | d k rê t d
 É qk | d k rπ t j t IJt j d
 É qk | d k r— d
 | _	 qk | d  k rÈ | | _
 qk | d! k rk t j a qk qk Wt | É d k  r&d } d } nh t | É d k  rK| d
 } d } nC t | É d k  rt| d
 } | d } n t d d t j | É É | j d É } | d
 k  rΩt d d | É n  | |  | _ y t | | d É | _ Wn" t k
 r	t d d | É n X| j d É } | d
 k  r9t d d | É n  | |  | _ y t | | d É | _ Wn" t k
 rÖt d d | É n X| S("   Ni   s   nVhc:ds   class=t   nosetuidt   versiont   helpt   debugs   -hs   --helpi    s   -Vs	   --versions   -ns
   --nosetuids   -cs   --classs   -ds   --debugs   localhost:8025s   localhost:25i   i   s   Invalid arguments: %st   :s   Bad local spec: %ss   Bad local port: %ss   Bad remote spec: %ss   Bad remote port: %s(   s   -hs   --help(   s   -Vs	   --version(   s   -ns
   --nosetuid(   s   -cs   --class(   s   -ds   --debug(   t   getoptR   t   argvR'   R   RÆ   R   R.   R   RØ   R∞   R+   RR   t
   COMMASPACER;   R<   t	   localhostt   intt	   localportt
   ValueErrort
   remotehostt
   remoteport(	   t   optst   argsRÖ   t   optionst   optRH   t	   localspect
   remotespecRF   (    (    s   /usr/lib/python2.7/smtpd.pyt	   parseargs‘  s\    "		
	
t   __main__R9   i   s7   Cannot import module "pwd"; try running with -n option.t   nobodyi   s3   Cannot setuid "nobody"; try running with -n option.(    (    (9   R   R   t   osR)   R∂   Rg   R"   R^   R   t   __all__R∑   t   programR.   R   R+   RB   R:   R∏   R   R   R   R_   R    R   R   R   RÆ   R≈   R	   R¡   R∞   t   rfindt   lastdott
   __import__R   t   localst   modR∆   R?   t   class_Rπ   Rª   RΩ   Ræ   t   proxyRØ   t   pwdt   ImportErrorR   R   t   getpwnamR«   t   OSErrorRÖ   t   EPERMt   loopt   KeyboardInterrupt(    (    (    s   /usr/lib/python2.7/smtpd.pyt   <module>$   sn   $	´6(N	8		"	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #! /usr/bin/python2.7

'''SMTP/ESMTP client class.

This should follow RFC 821 (SMTP), RFC 1869 (ESMTP), RFC 2554 (SMTP
Authentication) and RFC 2487 (Secure SMTP over TLS).

Notes:

Please remember, when doing ESMTP, that the names of the SMTP service
extensions are NOT the same thing as the option keywords for the RCPT
and MAIL commands!

Example:

  >>> import smtplib
  >>> s=smtplib.SMTP("localhost")
  >>> print s.help()
  This is Sendmail version 8.8.4
  Topics:
      HELO    EHLO    MAIL    RCPT    DATA
      RSET    NOOP    QUIT    HELP    VRFY
      EXPN    VERB    ETRN    DSN
  For more info use "HELP <topic>".
  To report bugs in the implementation send email to
      sendmail-bugs@sendmail.org.
  For local information send email to Postmaster at your site.
  End of HELP info
  >>> s.putcmd("vrfy","someone@here")
  >>> s.getreply()
  (250, "Somebody OverHere <somebody@here.my.org>")
  >>> s.quit()
'''

# Author: The Dragon De Monsyne <dragondm@integral.org>
# ESMTP support, test code and doc fixes added by
#     Eric S. Raymond <esr@thyrsus.com>
# Better RFC 821 compliance (MAIL and RCPT, and CRLF in data)
#     by Carey Evans <c.evans@clear.net.nz>, for picky mail servers.
# RFC 2554 (authentication) support by Gerhard Haering <gerhard@bigfoot.de>.
#
# This was modified from the Python 1.5 library HTTP lib.

import socket
import re
import email.utils
import base64
import hmac
from email.base64mime import encode as encode_base64
from sys import stderr

__all__ = ["SMTPException", "SMTPServerDisconnected", "SMTPResponseException",
           "SMTPSenderRefused", "SMTPRecipientsRefused", "SMTPDataError",
           "SMTPConnectError", "SMTPHeloError", "SMTPAuthenticationError",
           "quoteaddr", "quotedata", "SMTP"]

SMTP_PORT = 25
SMTP_SSL_PORT = 465
CRLF = "\r\n"
_MAXLINE = 8192 # more than 8 times larger than RFC 821, 4.5.3

OLDSTYLE_AUTH = re.compile(r"auth=(.*)", re.I)


# Exception classes used by this module.
class SMTPException(Exception):
    """Base class for all exceptions raised by this module."""

class SMTPServerDisconnected(SMTPException):
    """Not connected to any SMTP server.

    This exception is raised when the server unexpectedly disconnects,
    or when an attempt is made to use the SMTP instance before
    connecting it to a server.
    """

class SMTPResponseException(SMTPException):
    """Base class for all exceptions that include an SMTP error code.

    These exceptions are generated in some instances when the SMTP
    server returns an error code.  The error code is stored in the
    `smtp_code' attribute of the error, and the `smtp_error' attribute
    is set to the error message.
    """

    def __init__(self, code, msg):
        self.smtp_code = code
        self.smtp_error = msg
        self.args = (code, msg)

class SMTPSenderRefused(SMTPResponseException):
    """Sender address refused.

    In addition to the attributes set by on all SMTPResponseException
    exceptions, this sets `sender' to the string that the SMTP refused.
    """

    def __init__(self, code, msg, sender):
        self.smtp_code = code
        self.smtp_error = msg
        self.sender = sender
        self.args = (code, msg, sender)

class SMTPRecipientsRefused(SMTPException):
    """All recipient addresses refused.

    The errors for each recipient are accessible through the attribute
    'recipients', which is a dictionary of exactly the same sort as
    SMTP.sendmail() returns.
    """

    def __init__(self, recipients):
        self.recipients = recipients
        self.args = (recipients,)


class SMTPDataError(SMTPResponseException):
    """The SMTP server didn't accept the data."""

class SMTPConnectError(SMTPResponseException):
    """Error during connection establishment."""

class SMTPHeloError(SMTPResponseException):
    """The server refused our HELO reply."""

class SMTPAuthenticationError(SMTPResponseException):
    """Authentication error.

    Most probably the server didn't accept the username/password
    combination provided.
    """


def quoteaddr(addr):
    """Quote a subset of the email addresses defined by RFC 821.

    Should be able to handle anything rfc822.parseaddr can handle.
    """
    m = (None, None)
    try:
        m = email.utils.parseaddr(addr)[1]
    except AttributeError:
        pass
    if m == (None, None):  # Indicates parse failure or AttributeError
        # something weird here.. punt -ddm
        return "<%s>" % addr
    elif m is None:
        # the sender wants an empty return address
        return "<>"
    else:
        return "<%s>" % m

def _addr_only(addrstring):
    displayname, addr = email.utils.parseaddr(addrstring)
    if (displayname, addr) == ('', ''):
        # parseaddr couldn't parse it, so use it as is.
        return addrstring
    return addr

def quotedata(data):
    """Quote data for email.

    Double leading '.', and change Unix newline '\\n', or Mac '\\r' into
    Internet CRLF end-of-line.
    """
    return re.sub(r'(?m)^\.', '..',
        re.sub(r'(?:\r\n|\n|\r(?!\n))', CRLF, data))


try:
    import ssl
except ImportError:
    _have_ssl = False
else:
    class SSLFakeFile:
        """A fake file like object that really wraps a SSLObject.

        It only supports what is needed in smtplib.
        """
        def __init__(self, sslobj):
            self.sslobj = sslobj

        def readline(self, size=-1):
            if size < 0:
                size = None
            str = ""
            chr = None
            while chr != "\n":
                if size is not None and len(str) >= size:
                    break
                chr = self.sslobj.read(1)
                if not chr:
                    break
                str += chr
            return str

        def close(self):
            pass

    _have_ssl = True

class SMTP:
    """This class manages a connection to an SMTP or ESMTP server.
    SMTP Objects:
        SMTP objects have the following attributes:
            helo_resp
                This is the message given by the server in response to the
                most recent HELO command.

            ehlo_resp
                This is the message given by the server in response to the
                most recent EHLO command. This is usually multiline.

            does_esmtp
                This is a True value _after you do an EHLO command_, if the
                server supports ESMTP.

            esmtp_features
                This is a dictionary, which, if the server supports ESMTP,
                will _after you do an EHLO command_, contain the names of the
                SMTP service extensions this server supports, and their
                parameters (if any).

                Note, all extension names are mapped to lower case in the
                dictionary.

        See each method's docstrings for details.  In general, there is a
        method of the same name to perform each SMTP command.  There is also a
        method called 'sendmail' that will do an entire mail transaction.
        """
    debuglevel = 0
    file = None
    helo_resp = None
    ehlo_msg = "ehlo"
    ehlo_resp = None
    does_esmtp = 0
    default_port = SMTP_PORT

    def __init__(self, host='', port=0, local_hostname=None,
                 timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
        """Initialize a new instance.

        If specified, `host' is the name of the remote host to which to
        connect.  If specified, `port' specifies the port to which to connect.
        By default, smtplib.SMTP_PORT is used.  If a host is specified the
        connect method is called, and if it returns anything other than a
        success code an SMTPConnectError is raised.  If specified,
        `local_hostname` is used as the FQDN of the local host for the
        HELO/EHLO command.  Otherwise, the local hostname is found using
        socket.getfqdn().

        """
        self.timeout = timeout
        self.esmtp_features = {}
        if host:
            (code, msg) = self.connect(host, port)
            if code != 220:
                raise SMTPConnectError(code, msg)
        if local_hostname is not None:
            self.local_hostname = local_hostname
        else:
            # RFC 2821 says we should use the fqdn in the EHLO/HELO verb, and
            # if that can't be calculated, that we should use a domain literal
            # instead (essentially an encoded IP address like [A.B.C.D]).
            fqdn = socket.getfqdn()
            if '.' in fqdn:
                self.local_hostname = fqdn
            else:
                # We can't find an fqdn hostname, so use a domain literal
                addr = '127.0.0.1'
                try:
                    addr = socket.gethostbyname(socket.gethostname())
                except socket.gaierror:
                    pass
                self.local_hostname = '[%s]' % addr

    def set_debuglevel(self, debuglevel):
        """Set the debug output level.

        A non-false value results in debug messages for connection and for all
        messages sent to and received from the server.

        """
        self.debuglevel = debuglevel

    def _get_socket(self, host, port, timeout):
        # This makes it simpler for SMTP_SSL to use the SMTP connect code
        # and just alter the socket connection bit.
        if self.debuglevel > 0:
            print>>stderr, 'connect:', (host, port)
        return socket.create_connection((host, port), timeout)

    def connect(self, host='localhost', port=0):
        """Connect to a host on a given port.

        If the hostname ends with a colon (`:') followed by a number, and
        there is no port specified, that suffix will be stripped off and the
        number interpreted as the port number to use.

        Note: This method is automatically invoked by __init__, if a host is
        specified during instantiation.

        """
        if not port and (host.find(':') == host.rfind(':')):
            i = host.rfind(':')
            if i >= 0:
                host, port = host[:i], host[i + 1:]
                try:
                    port = int(port)
                except ValueError:
                    raise socket.error, "nonnumeric port"
        if not port:
            port = self.default_port
        if self.debuglevel > 0:
            print>>stderr, 'connect:', (host, port)
        self.sock = self._get_socket(host, port, self.timeout)
        (code, msg) = self.getreply()
        if self.debuglevel > 0:
            print>>stderr, "connect:", msg
        return (code, msg)

    def send(self, str):
        """Send `str' to the server."""
        if self.debuglevel > 0:
            print>>stderr, 'send:', repr(str)
        if hasattr(self, 'sock') and self.sock:
            try:
                self.sock.sendall(str)
            except socket.error:
                self.close()
                raise SMTPServerDisconnected('Server not connected')
        else:
            raise SMTPServerDisconnected('please run connect() first')

    def putcmd(self, cmd, args=""):
        """Send a command to the server."""
        if args == "":
            str = '%s%s' % (cmd, CRLF)
        else:
            str = '%s %s%s' % (cmd, args, CRLF)
        self.send(str)

    def getreply(self):
        """Get a reply from the server.

        Returns a tuple consisting of:

          - server response code (e.g. '250', or such, if all goes well)
            Note: returns -1 if it can't read response code.

          - server response string corresponding to response code (multiline
            responses are converted to a single, multiline string).

        Raises SMTPServerDisconnected if end-of-file is reached.
        """
        resp = []
        if self.file is None:
            self.file = self.sock.makefile('rb')
        while 1:
            try:
                line = self.file.readline(_MAXLINE + 1)
            except socket.error as e:
                self.close()
                raise SMTPServerDisconnected("Connection unexpectedly closed: "
                                             + str(e))
            if line == '':
                self.close()
                raise SMTPServerDisconnected("Connection unexpectedly closed")
            if self.debuglevel > 0:
                print>>stderr, 'reply:', repr(line)
            if len(line) > _MAXLINE:
                raise SMTPResponseException(500, "Line too long.")
            resp.append(line[4:].strip())
            code = line[:3]
            # Check that the error code is syntactically correct.
            # Don't attempt to read a continuation line if it is broken.
            try:
                errcode = int(code)
            except ValueError:
                errcode = -1
                break
            # Check if multiline response.
            if line[3:4] != "-":
                break

        errmsg = "\n".join(resp)
        if self.debuglevel > 0:
            print>>stderr, 'reply: retcode (%s); Msg: %s' % (errcode, errmsg)
        return errcode, errmsg

    def docmd(self, cmd, args=""):
        """Send a command, and return its response code."""
        self.putcmd(cmd, args)
        return self.getreply()

    # std smtp commands
    def helo(self, name=''):
        """SMTP 'helo' command.
        Hostname to send for this command defaults to the FQDN of the local
        host.
        """
        self.putcmd("helo", name or self.local_hostname)
        (code, msg) = self.getreply()
        self.helo_resp = msg
        return (code, msg)

    def ehlo(self, name=''):
        """ SMTP 'ehlo' command.
        Hostname to send for this command defaults to the FQDN of the local
        host.
        """
        self.esmtp_features = {}
        self.putcmd(self.ehlo_msg, name or self.local_hostname)
        (code, msg) = self.getreply()
        # According to RFC1869 some (badly written)
        # MTA's will disconnect on an ehlo. Toss an exception if
        # that happens -ddm
        if code == -1 and len(msg) == 0:
            self.close()
            raise SMTPServerDisconnected("Server not connected")
        self.ehlo_resp = msg
        if code != 250:
            return (code, msg)
        self.does_esmtp = 1
        #parse the ehlo response -ddm
        resp = self.ehlo_resp.split('\n')
        del resp[0]
        for each in resp:
            # To be able to communicate with as many SMTP servers as possible,
            # we have to take the old-style auth advertisement into account,
            # because:
            # 1) Else our SMTP feature parser gets confused.
            # 2) There are some servers that only advertise the auth methods we
            #    support using the old style.
            auth_match = OLDSTYLE_AUTH.match(each)
            if auth_match:
                # This doesn't remove duplicates, but that's no problem
                self.esmtp_features["auth"] = self.esmtp_features.get("auth", "") \
                        + " " + auth_match.groups(0)[0]
                continue

            # RFC 1869 requires a space between ehlo keyword and parameters.
            # It's actually stricter, in that only spaces are allowed between
            # parameters, but were not going to check for that here.  Note
            # that the space isn't present if there are no parameters.
            m = re.match(r'(?P<feature>[A-Za-z0-9][A-Za-z0-9\-]*) ?', each)
            if m:
                feature = m.group("feature").lower()
                params = m.string[m.end("feature"):].strip()
                if feature == "auth":
                    self.esmtp_features[feature] = self.esmtp_features.get(feature, "") \
                            + " " + params
                else:
                    self.esmtp_features[feature] = params
        return (code, msg)

    def has_extn(self, opt):
        """Does the server support a given SMTP service extension?"""
        return opt.lower() in self.esmtp_features

    def help(self, args=''):
        """SMTP 'help' command.
        Returns help text from server."""
        self.putcmd("help", args)
        return self.getreply()[1]

    def rset(self):
        """SMTP 'rset' command -- resets session."""
        return self.docmd("rset")

    def noop(self):
        """SMTP 'noop' command -- doesn't do anything :>"""
        return self.docmd("noop")

    def mail(self, sender, options=[]):
        """SMTP 'mail' command -- begins mail xfer session."""
        optionlist = ''
        if options and self.does_esmtp:
            optionlist = ' ' + ' '.join(options)
        self.putcmd("mail", "FROM:%s%s" % (quoteaddr(sender), optionlist))
        return self.getreply()

    def rcpt(self, recip, options=[]):
        """SMTP 'rcpt' command -- indicates 1 recipient for this mail."""
        optionlist = ''
        if options and self.does_esmtp:
            optionlist = ' ' + ' '.join(options)
        self.putcmd("rcpt", "TO:%s%s" % (quoteaddr(recip), optionlist))
        return self.getreply()

    def data(self, msg):
        """SMTP 'DATA' command -- sends message data to server.

        Automatically quotes lines beginning with a period per rfc821.
        Raises SMTPDataError if there is an unexpected reply to the
        DATA command; the return value from this method is the final
        response code received when the all data is sent.
        """
        self.putcmd("data")
        (code, repl) = self.getreply()
        if self.debuglevel > 0:
            print>>stderr, "data:", (code, repl)
        if code != 354:
            raise SMTPDataError(code, repl)
        else:
            q = quotedata(msg)
            if q[-2:] != CRLF:
                q = q + CRLF
            q = q + "." + CRLF
            self.send(q)
            (code, msg) = self.getreply()
            if self.debuglevel > 0:
                print>>stderr, "data:", (code, msg)
            return (code, msg)

    def verify(self, address):
        """SMTP 'verify' command -- checks for address validity."""
        self.putcmd("vrfy", _addr_only(address))
        return self.getreply()
    # a.k.a.
    vrfy = verify

    def expn(self, address):
        """SMTP 'expn' command -- expands a mailing list."""
        self.putcmd("expn", _addr_only(address))
        return self.getreply()

    # some useful methods

    def ehlo_or_helo_if_needed(self):
        """Call self.ehlo() and/or self.helo() if needed.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
        """
        if self.helo_resp is None and self.ehlo_resp is None:
            if not (200 <= self.ehlo()[0] <= 299):
                (code, resp) = self.helo()
                if not (200 <= code <= 299):
                    raise SMTPHeloError(code, resp)

    def login(self, user, password):
        """Log in on an SMTP server that requires authentication.

        The arguments are:
            - user:     The user name to authenticate with.
            - password: The password for the authentication.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        This method will return normally if the authentication was successful.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
         SMTPAuthenticationError  The server didn't accept the username/
                                  password combination.
         SMTPException            No suitable authentication method was
                                  found.
        """

        def encode_cram_md5(challenge, user, password):
            challenge = base64.decodestring(challenge)
            response = user + " " + hmac.HMAC(password, challenge).hexdigest()
            return encode_base64(response, eol="")

        def encode_plain(user, password):
            return encode_base64("\0%s\0%s" % (user, password), eol="")


        AUTH_PLAIN = "PLAIN"
        AUTH_CRAM_MD5 = "CRAM-MD5"
        AUTH_LOGIN = "LOGIN"

        self.ehlo_or_helo_if_needed()

        if not self.has_extn("auth"):
            raise SMTPException("SMTP AUTH extension not supported by server.")

        # Authentication methods the server supports:
        authlist = self.esmtp_features["auth"].split()

        # List of authentication methods we support: from preferred to
        # less preferred methods. Except for the purpose of testing the weaker
        # ones, we prefer stronger methods like CRAM-MD5:
        preferred_auths = [AUTH_CRAM_MD5, AUTH_PLAIN, AUTH_LOGIN]

        # Determine the authentication method we'll use
        authmethod = None
        for method in preferred_auths:
            if method in authlist:
                authmethod = method
                break

        if authmethod == AUTH_CRAM_MD5:
            (code, resp) = self.docmd("AUTH", AUTH_CRAM_MD5)
            if code == 503:
                # 503 == 'Error: already authenticated'
                return (code, resp)
            (code, resp) = self.docmd(encode_cram_md5(resp, user, password))
        elif authmethod == AUTH_PLAIN:
            (code, resp) = self.docmd("AUTH",
                AUTH_PLAIN + " " + encode_plain(user, password))
        elif authmethod == AUTH_LOGIN:
            (code, resp) = self.docmd("AUTH",
                "%s %s" % (AUTH_LOGIN, encode_base64(user, eol="")))
            if code != 334:
                raise SMTPAuthenticationError(code, resp)
            (code, resp) = self.docmd(encode_base64(password, eol=""))
        elif authmethod is None:
            raise SMTPException("No suitable authentication method found.")
        if code not in (235, 503):
            # 235 == 'Authentication successful'
            # 503 == 'Error: already authenticated'
            raise SMTPAuthenticationError(code, resp)
        return (code, resp)

    def starttls(self, keyfile=None, certfile=None):
        """Puts the connection to the SMTP server into TLS mode.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        If the server supports TLS, this will encrypt the rest of the SMTP
        session. If you provide the keyfile and certfile parameters,
        the identity of the SMTP server and client can be checked. This,
        however, depends on whether the socket module really checks the
        certificates.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
        """
        self.ehlo_or_helo_if_needed()
        if not self.has_extn("starttls"):
            raise SMTPException("STARTTLS extension not supported by server.")
        (resp, reply) = self.docmd("STARTTLS")
        if resp == 220:
            if not _have_ssl:
                raise RuntimeError("No SSL support included in this Python")
            self.sock = ssl.wrap_socket(self.sock, keyfile, certfile)
            self.file = SSLFakeFile(self.sock)
            # RFC 3207:
            # The client MUST discard any knowledge obtained from
            # the server, such as the list of SMTP service extensions,
            # which was not obtained from the TLS negotiation itself.
            self.helo_resp = None
            self.ehlo_resp = None
            self.esmtp_features = {}
            self.does_esmtp = 0
        else:
            # RFC 3207:
            # 501 Syntax error (no parameters allowed)
            # 454 TLS not available due to temporary reason
            raise SMTPResponseException(resp, reply)
        return (resp, reply)

    def sendmail(self, from_addr, to_addrs, msg, mail_options=[],
                 rcpt_options=[]):
        """This command performs an entire mail transaction.

        The arguments are:
            - from_addr    : The address sending this mail.
            - to_addrs     : A list of addresses to send this mail to.  A bare
                             string will be treated as a list with 1 address.
            - msg          : The message to send.
            - mail_options : List of ESMTP options (such as 8bitmime) for the
                             mail command.
            - rcpt_options : List of ESMTP options (such as DSN commands) for
                             all the rcpt commands.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.  If the server does ESMTP, message size
        and each of the specified options will be passed to it.  If EHLO
        fails, HELO will be tried and ESMTP options suppressed.

        This method will return normally if the mail is accepted for at least
        one recipient.  It returns a dictionary, with one entry for each
        recipient that was refused.  Each entry contains a tuple of the SMTP
        error code and the accompanying error message sent by the server.

        This method may raise the following exceptions:

         SMTPHeloError          The server didn't reply properly to
                                the helo greeting.
         SMTPRecipientsRefused  The server rejected ALL recipients
                                (no mail was sent).
         SMTPSenderRefused      The server didn't accept the from_addr.
         SMTPDataError          The server replied with an unexpected
                                error code (other than a refusal of
                                a recipient).

        Note: the connection will be open even after an exception is raised.

        Example:

         >>> import smtplib
         >>> s=smtplib.SMTP("localhost")
         >>> tolist=["one@one.org","two@two.org","three@three.org","four@four.org"]
         >>> msg = '''\\
         ... From: Me@my.org
         ... Subject: testin'...
         ...
         ... This is a test '''
         >>> s.sendmail("me@my.org",tolist,msg)
         { "three@three.org" : ( 550 ,"User unknown" ) }
         >>> s.quit()

        In the above example, the message was accepted for delivery to three
        of the four addresses, and one was rejected, with the error code
        550.  If all addresses are accepted, then the method will return an
        empty dictionary.

        """
        self.ehlo_or_helo_if_needed()
        esmtp_opts = []
        if self.does_esmtp:
            # Hmmm? what's this? -ddm
            # self.esmtp_features['7bit']=""
            if self.has_extn('size'):
                esmtp_opts.append("size=%d" % len(msg))
            for option in mail_options:
                esmtp_opts.append(option)

        (code, resp) = self.mail(from_addr, esmtp_opts)
        if code != 250:
            self.rset()
            raise SMTPSenderRefused(code, resp, from_addr)
        senderrs = {}
        if isinstance(to_addrs, basestring):
            to_addrs = [to_addrs]
        for each in to_addrs:
            (code, resp) = self.rcpt(each, rcpt_options)
            if (code != 250) and (code != 251):
                senderrs[each] = (code, resp)
        if len(senderrs) == len(to_addrs):
            # the server refused all our recipients
            self.rset()
            raise SMTPRecipientsRefused(senderrs)
        (code, resp) = self.data(msg)
        if code != 250:
            self.rset()
            raise SMTPDataError(code, resp)
        #if we got here then somebody got our mail
        return senderrs


    def close(self):
        """Close the connection to the SMTP server."""
        try:
            file = self.file
            self.file = None
            if file:
                file.close()
        finally:
            sock = self.sock
            self.sock = None
            if sock:
                sock.close()


    def quit(self):
        """Terminate the SMTP session."""
        res = self.docmd("quit")
        # A new EHLO is required after reconnecting with connect()
        self.ehlo_resp = self.helo_resp = None
        self.esmtp_features = {}
        self.does_esmtp = False
        self.close()
        return res

if _have_ssl:

    class SMTP_SSL(SMTP):
        """ This is a subclass derived from SMTP that connects over an SSL
        encrypted socket (to use this class you need a socket module that was
        compiled with SSL support). If host is not specified, '' (the local
        host) is used. If port is omitted, the standard SMTP-over-SSL port
        (465) is used.  local_hostname has the same meaning as it does in the
        SMTP class.  keyfile and certfile are also optional - they can contain
        a PEM formatted private key and certificate chain file for the SSL
        connection.

        """

        default_port = SMTP_SSL_PORT

        def __init__(self, host='', port=0, local_hostname=None,
                     keyfile=None, certfile=None,
                     timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
            self.keyfile = keyfile
            self.certfile = certfile
            SMTP.__init__(self, host, port, local_hostname, timeout)

        def _get_socket(self, host, port, timeout):
            if self.debuglevel > 0:
                print>>stderr, 'connect:', (host, port)
            new_socket = socket.create_connection((host, port), timeout)
            new_socket = ssl.wrap_socket(new_socket, self.keyfile, self.certfile)
            self.file = SSLFakeFile(new_socket)
            return new_socket

    __all__.append("SMTP_SSL")

#
# LMTP extension
#
LMTP_PORT = 2003

class LMTP(SMTP):
    """LMTP - Local Mail Transfer Protocol

    The LMTP protocol, which is very similar to ESMTP, is heavily based
    on the standard SMTP client. It's common to use Unix sockets for
    LMTP, so our connect() method must support that as well as a regular
    host:port server.  local_hostname has the same meaning as it does in
    the SMTP class.  To specify a Unix socket, you must use an absolute
    path as the host, starting with a '/'.

    Authentication is supported, using the regular SMTP mechanism. When
    using a Unix socket, LMTP generally don't support or require any
    authentication, but your mileage might vary."""

    ehlo_msg = "lhlo"

    def __init__(self, host='', port=LMTP_PORT, local_hostname=None):
        """Initialize a new instance."""
        SMTP.__init__(self, host, port, local_hostname)

    def connect(self, host='localhost', port=0):
        """Connect to the LMTP daemon, on either a Unix or a TCP socket."""
        if host[0] != '/':
            return SMTP.connect(self, host, port)

        # Handle Unix-domain sockets.
        try:
            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.sock.connect(host)
        except socket.error:
            if self.debuglevel > 0:
                print>>stderr, 'connect fail:', host
            if self.sock:
                self.sock.close()
            self.sock = None
            raise
        (code, msg) = self.getreply()
        if self.debuglevel > 0:
            print>>stderr, "connect:", msg
        return (code, msg)


# Test the sendmail method, which tests most of the others.
# Note: This always sends to localhost.
if __name__ == '__main__':
    import sys

    def prompt(prompt):
        sys.stdout.write(prompt + ": ")
        return sys.stdin.readline().strip()

    fromaddr = prompt("From")
    toaddrs = prompt("To").split(',')
    print "Enter message, end with ^D:"
    msg = ''
    while 1:
        line = sys.stdin.readline()
        if not line:
            break
        msg = msg + line
    print "Message length is %d" % len(msg)

    server = SMTP('localhost')
    server.set_debuglevel(1)
    server.sendmail(fromaddr, toaddrs, msg)
    server.quit()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   s¸  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z	 d d l
 m Z d d d d d	 d
 d d d d d d g Z d Z d Z d Z d Z e j d e j É Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d	 e f d Ñ  É  YZ d
 e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d Ñ  Z d  Ñ  Z d! Ñ  Z  y d d l! Z! Wn e" k
 r√e# Z$ n Xd" f  d# Ñ  É  YZ% e& Z$ d f  d$ Ñ  É  YZ' e$ rd% e' f d& Ñ  É  YZ( e j) d% É n  d' Z* d( e' f d) Ñ  É  YZ+ e, d* k r¯d d l
 Z
 d+ Ñ  Z- e- d, É Z. e- d- É j/ d. É Z0 d/ GHd0 Z1 x( e
 j2 j3 É  Z4 e4 r¢Pn  e1 e4 Z1 qàWd1 e5 e1 É GHe' d2 É Z6 e6 j7 d3 É e6 j8 e. e0 e1 É e6 j9 É  n  d S(4   s~  SMTP/ESMTP client class.

This should follow RFC 821 (SMTP), RFC 1869 (ESMTP), RFC 2554 (SMTP
Authentication) and RFC 2487 (Secure SMTP over TLS).

Notes:

Please remember, when doing ESMTP, that the names of the SMTP service
extensions are NOT the same thing as the option keywords for the RCPT
and MAIL commands!

Example:

  >>> import smtplib
  >>> s=smtplib.SMTP("localhost")
  >>> print s.help()
  This is Sendmail version 8.8.4
  Topics:
      HELO    EHLO    MAIL    RCPT    DATA
      RSET    NOOP    QUIT    HELP    VRFY
      EXPN    VERB    ETRN    DSN
  For more info use "HELP <topic>".
  To report bugs in the implementation send email to
      sendmail-bugs@sendmail.org.
  For local information send email to Postmaster at your site.
  End of HELP info
  >>> s.putcmd("vrfy","someone@here")
  >>> s.getreply()
  (250, "Somebody OverHere <somebody@here.my.org>")
  >>> s.quit()
iˇˇˇˇN(   t   encode(   t   stderrt   SMTPExceptiont   SMTPServerDisconnectedt   SMTPResponseExceptiont   SMTPSenderRefusedt   SMTPRecipientsRefusedt   SMTPDataErrort   SMTPConnectErrort   SMTPHeloErrort   SMTPAuthenticationErrort	   quoteaddrt	   quotedatat   SMTPi   i—  s   
i    s	   auth=(.*)c           B   s   e  Z d  Z RS(   s4   Base class for all exceptions raised by this module.(   t   __name__t
   __module__t   __doc__(    (    (    s   /usr/lib/python2.7/smtplib.pyR   B   s   c           B   s   e  Z d  Z RS(   sÃ   Not connected to any SMTP server.

    This exception is raised when the server unexpectedly disconnects,
    or when an attempt is made to use the SMTP instance before
    connecting it to a server.
    (   R   R   R   (    (    (    s   /usr/lib/python2.7/smtplib.pyR   E   s   c           B   s   e  Z d  Z d Ñ  Z RS(   s2  Base class for all exceptions that include an SMTP error code.

    These exceptions are generated in some instances when the SMTP
    server returns an error code.  The error code is stored in the
    `smtp_code' attribute of the error, and the `smtp_error' attribute
    is set to the error message.
    c         C   s%   | |  _  | |  _ | | f |  _ d  S(   N(   t	   smtp_codet
   smtp_errort   args(   t   selft   codet   msg(    (    s   /usr/lib/python2.7/smtplib.pyt   __init__V   s    		(   R   R   R   R   (    (    (    s   /usr/lib/python2.7/smtplib.pyR   M   s   c           B   s   e  Z d  Z d Ñ  Z RS(   s´   Sender address refused.

    In addition to the attributes set by on all SMTPResponseException
    exceptions, this sets `sender' to the string that the SMTP refused.
    c         C   s1   | |  _  | |  _ | |  _ | | | f |  _ d  S(   N(   R   R   t   senderR   (   R   R   R   R   (    (    s   /usr/lib/python2.7/smtplib.pyR   b   s    			(   R   R   R   R   (    (    (    s   /usr/lib/python2.7/smtplib.pyR   [   s   c           B   s   e  Z d  Z d Ñ  Z RS(   sŒ   All recipient addresses refused.

    The errors for each recipient are accessible through the attribute
    'recipients', which is a dictionary of exactly the same sort as
    SMTP.sendmail() returns.
    c         C   s   | |  _  | f |  _ d  S(   N(   t
   recipientsR   (   R   R   (    (    s   /usr/lib/python2.7/smtplib.pyR   p   s    	(   R   R   R   R   (    (    (    s   /usr/lib/python2.7/smtplib.pyR   h   s   c           B   s   e  Z d  Z RS(   s'   The SMTP server didn't accept the data.(   R   R   R   (    (    (    s   /usr/lib/python2.7/smtplib.pyR   u   s   c           B   s   e  Z d  Z RS(   s&   Error during connection establishment.(   R   R   R   (    (    (    s   /usr/lib/python2.7/smtplib.pyR   x   s   c           B   s   e  Z d  Z RS(   s"   The server refused our HELO reply.(   R   R   R   (    (    (    s   /usr/lib/python2.7/smtplib.pyR	   {   s   c           B   s   e  Z d  Z RS(   sv   Authentication error.

    Most probably the server didn't accept the username/password
    combination provided.
    (   R   R   R   (    (    (    s   /usr/lib/python2.7/smtplib.pyR
   ~   s   c         C   sd   d } y t j j |  É d } Wn t k
 r3 n X| d k rH d |  S| d k rX d Sd | Sd S(   sÇ   Quote a subset of the email addresses defined by RFC 821.

    Should be able to handle anything rfc822.parseaddr can handle.
    i   s   <%s>s   <>N(   NN(   NN(   t   Nonet   emailt   utilst	   parseaddrt   AttributeError(   t   addrt   m(    (    s   /usr/lib/python2.7/smtplib.pyR   Ü   s    c         C   s2   t  j j |  É \ } } | | f d k r. |  S| S(   Nt    (   R!   R!   (   R   R   R   (   t
   addrstringt   displaynameR   (    (    s   /usr/lib/python2.7/smtplib.pyt
   _addr_onlyô   s    c         C   s"   t  j d d t  j d t |  É É S(   sÅ   Quote data for email.

    Double leading '.', and change Unix newline '\n', or Mac '\r' into
    Internet CRLF end-of-line.
    s   (?m)^\.s   ..s   (?:\r\n|\n|\r(?!\n))(   t   ret   subt   CRLF(   t   data(    (    s   /usr/lib/python2.7/smtplib.pyR   †   s    t   SSLFakeFilec           B   s,   e  Z d  Z d Ñ  Z d d Ñ Z d Ñ  Z RS(   st   A fake file like object that really wraps a SSLObject.

        It only supports what is needed in smtplib.
        c         C   s   | |  _  d  S(   N(   t   sslobj(   R   R*   (    (    s   /usr/lib/python2.7/smtplib.pyR   ¥   s    iˇˇˇˇc         C   sÄ   | d k  r d  } n  d } d  } xX | d k r{ | d  k	 rR t | É | k rR Pn  |  j j d É } | sn Pn  | | 7} q$ W| S(   Ni    R!   s   
i   (   R   t   lenR*   t   read(   R   t   sizet   strt   chr(    (    s   /usr/lib/python2.7/smtplib.pyt   readline∑   s    	c         C   s   d  S(   N(    (   R   (    (    s   /usr/lib/python2.7/smtplib.pyt   close≈   s    (   R   R   R   R   R0   R1   (    (    (    s   /usr/lib/python2.7/smtplib.pyR)   Ø   s   	c           B   sU  e  Z d  Z d Z d Z d Z d Z d Z d Z	 e
 Z d d d e j d Ñ Z d Ñ  Z d Ñ  Z d d d Ñ Z d	 Ñ  Z d d
 Ñ Z d Ñ  Z d d Ñ Z d d Ñ Z d d Ñ Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z g  d Ñ Z g  d Ñ Z d Ñ  Z d Ñ  Z e Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d d d Ñ Z$ g  g  d Ñ Z% d Ñ  Z& d Ñ  Z' RS(   s¥  This class manages a connection to an SMTP or ESMTP server.
    SMTP Objects:
        SMTP objects have the following attributes:
            helo_resp
                This is the message given by the server in response to the
                most recent HELO command.

            ehlo_resp
                This is the message given by the server in response to the
                most recent EHLO command. This is usually multiline.

            does_esmtp
                This is a True value _after you do an EHLO command_, if the
                server supports ESMTP.

            esmtp_features
                This is a dictionary, which, if the server supports ESMTP,
                will _after you do an EHLO command_, contain the names of the
                SMTP service extensions this server supports, and their
                parameters (if any).

                Note, all extension names are mapped to lower case in the
                dictionary.

        See each method's docstrings for details.  In general, there is a
        method of the same name to perform each SMTP command.  There is also a
        method called 'sendmail' that will do an entire mail transaction.
        i    t   ehloR!   c   	      C   s‘   | |  _  i  |  _ | rQ |  j | | É \ } } | d k rQ t | | É Ç qQ n  | d k	 ri | |  _ ng t j É  } d | k rç | |  _ nC d } y t j t j	 É  É } Wn t j
 k
 r¬ n Xd | |  _ d S(   s>  Initialize a new instance.

        If specified, `host' is the name of the remote host to which to
        connect.  If specified, `port' specifies the port to which to connect.
        By default, smtplib.SMTP_PORT is used.  If a host is specified the
        connect method is called, and if it returns anything other than a
        success code an SMTPConnectError is raised.  If specified,
        `local_hostname` is used as the FQDN of the local host for the
        HELO/EHLO command.  Otherwise, the local hostname is found using
        socket.getfqdn().

        i‹   t   .s	   127.0.0.1s   [%s]N(   t   timeoutt   esmtp_featurest   connectR   R   t   local_hostnamet   sockett   getfqdnt   gethostbynamet   gethostnamet   gaierror(	   R   t   hostt   portR7   R4   R   R   t   fqdnR   (    (    s   /usr/lib/python2.7/smtplib.pyR   Ô   s"    		c         C   s   | |  _  d S(   s¨   Set the debug output level.

        A non-false value results in debug messages for connection and for all
        messages sent to and received from the server.

        N(   t
   debuglevel(   R   R@   (    (    s   /usr/lib/python2.7/smtplib.pyt   set_debuglevel  s    c         C   s>   |  j  d k r( t d I| | f IJn  t j | | f | É S(   Ni    s   connect:(   R@   R   R8   t   create_connection(   R   R=   R>   R4   (    (    s   /usr/lib/python2.7/smtplib.pyt   _get_socket  s    t	   localhostc         C   s"  | rè | j  d É | j d É k rè | j d É } | d k rè | |  | | d } } y t | É } Wqå t k
 rà t j d Ç qå Xqè n  | s° |  j } n  |  j d k r… t d I| | f IJn  |  j	 | | |  j
 É |  _ |  j É  \ } } |  j d k rt d I| IJn  | | f S(   sp  Connect to a host on a given port.

        If the hostname ends with a colon (`:') followed by a number, and
        there is no port specified, that suffix will be stripped off and the
        number interpreted as the port number to use.

        Note: This method is automatically invoked by __init__, if a host is
        specified during instantiation.

        t   :i    i   s   nonnumeric ports   connect:(   t   findt   rfindt   intt
   ValueErrorR8   t   errort   default_portR@   R   RC   R4   t   sockt   getreply(   R   R=   R>   t   iR   R   (    (    s   /usr/lib/python2.7/smtplib.pyR6   %  s"    %c         C   sî   |  j  d k r( t d It | É IJn  t |  d É rÑ |  j rÑ y |  j j | É Wqê t j k
 rÄ |  j É  t	 d É Ç qê Xn t	 d É Ç d S(   s   Send `str' to the server.i    s   send:RL   s   Server not connecteds   please run connect() firstN(
   R@   R   t   reprt   hasattrRL   t   sendallR8   RJ   R1   R   (   R   R.   (    (    s   /usr/lib/python2.7/smtplib.pyt   sendB  s    
c         C   sC   | d k r d | t  f } n d | | t  f } |  j | É d S(   s   Send a command to the server.R!   s   %s%ss   %s %s%sN(   R'   RR   (   R   t   cmdR   R.   (    (    s   /usr/lib/python2.7/smtplib.pyt   putcmdO  s    c         C   sö  g  } |  j  d k r- |  j j d É |  _  n  x+y |  j  j t d É } Wn6 t j k
 rÇ } |  j É  t	 d t
 | É É Ç n X| d k r® |  j É  t	 d É Ç n  |  j d k r– t d It | É IJn  t | É t k rÙ t d d	 É Ç n  | j | d
 j É  É | d  } y t | É } Wn t k
 r?d } Pn X| d d
 !d k r0 Pq0 q0 Wd j | É } |  j d k rêt d | | f IJn  | | f S(   s®  Get a reply from the server.

        Returns a tuple consisting of:

          - server response code (e.g. '250', or such, if all goes well)
            Note: returns -1 if it can't read response code.

          - server response string corresponding to response code (multiline
            responses are converted to a single, multiline string).

        Raises SMTPServerDisconnected if end-of-file is reached.
        t   rbi   s    Connection unexpectedly closed: R!   s   Connection unexpectedly closedi    s   reply:iÙ  s   Line too long.i   i   iˇˇˇˇt   -s   
s   reply: retcode (%s); Msg: %sN(   t   fileR   RL   t   makefileR0   t   _MAXLINER8   RJ   R1   R   R.   R@   R   RO   R+   R   t   appendt   stripRH   RI   t   join(   R   t   respt   linet   eR   t   errcodet   errmsg(    (    s   /usr/lib/python2.7/smtplib.pyRM   W  s<    


c         C   s   |  j  | | É |  j É  S(   s-   Send a command, and return its response code.(   RT   RM   (   R   RS   R   (    (    s   /usr/lib/python2.7/smtplib.pyt   docmdá  s    c         C   s>   |  j  d | p |  j É |  j É  \ } } | |  _ | | f S(   sw   SMTP 'helo' command.
        Hostname to send for this command defaults to the FQDN of the local
        host.
        t   helo(   RT   R7   RM   t	   helo_resp(   R   t   nameR   R   (    (    s   /usr/lib/python2.7/smtplib.pyRc   ç  s    	c   
      C   s¢  i  |  _  |  j |  j | p! |  j É |  j É  \ } } | d k rn t | É d k rn |  j É  t d É Ç n  | |  _ | d k rç | | f Sd |  _	 |  j j
 d É } | d =xÊ | D]ﬁ } t j | É } | r|  j  j d d É d	 | j d É d |  j  d <q∂ n  t j d
 | É } | r∂ | j d É j É  } | j | j d É j É  }	 | d k rÑ|  j  j | d É d	 |	 |  j  | <qî|	 |  j  | <q∂ q∂ W| | f S(   sx    SMTP 'ehlo' command.
        Hostname to send for this command defaults to the FQDN of the local
        host.
        iˇˇˇˇi    s   Server not connectedi˙   i   s   
t   authR!   t    s(   (?P<feature>[A-Za-z0-9][A-Za-z0-9\-]*) ?t   feature(   R5   RT   t   ehlo_msgR7   RM   R+   R1   R   t	   ehlo_respt
   does_esmtpt   splitt   OLDSTYLE_AUTHt   matcht   gett   groupsR%   t   groupt   lowert   stringt   endR[   (
   R   Re   R   R   R]   t   eacht
   auth_matchR    Rh   t   params(    (    s   /usr/lib/python2.7/smtplib.pyR2   ó  s2    	
	
	1'c         C   s   | j  É  |  j k S(   s7   Does the server support a given SMTP service extension?(   Rr   R5   (   R   t   opt(    (    s   /usr/lib/python2.7/smtplib.pyt   has_extn…  s    c         C   s   |  j  d | É |  j É  d S(   s;   SMTP 'help' command.
        Returns help text from server.t   helpi   (   RT   RM   (   R   R   (    (    s   /usr/lib/python2.7/smtplib.pyRz   Õ  s    c         C   s   |  j  d É S(   s&   SMTP 'rset' command -- resets session.t   rset(   Rb   (   R   (    (    s   /usr/lib/python2.7/smtplib.pyR{   ”  s    c         C   s   |  j  d É S(   s-   SMTP 'noop' command -- doesn't do anything :>t   noop(   Rb   (   R   (    (    s   /usr/lib/python2.7/smtplib.pyR|   ◊  s    c         C   sU   d } | r+ |  j  r+ d d j | É } n  |  j d d t | É | f É |  j É  S(   s0   SMTP 'mail' command -- begins mail xfer session.R!   Rg   t   mails	   FROM:%s%s(   Rk   R\   RT   R   RM   (   R   R   t   optionst
   optionlist(    (    s   /usr/lib/python2.7/smtplib.pyR}   €  s
     c         C   sU   d } | r+ |  j  r+ d d j | É } n  |  j d d t | É | f É |  j É  S(   s;   SMTP 'rcpt' command -- indicates 1 recipient for this mail.R!   Rg   t   rcpts   TO:%s%s(   Rk   R\   RT   R   RM   (   R   t   recipR~   R   (    (    s   /usr/lib/python2.7/smtplib.pyRÄ   „  s
     c         C   sÒ   |  j  d É |  j É  \ } } |  j d k rG t d I| | f IJn  | d k re t | | É Ç nà t | É } | d t k ré | t } n  | d t } |  j | É |  j É  \ } } |  j d k r„ t d I| | f IJn  | | f Sd S(   sH  SMTP 'DATA' command -- sends message data to server.

        Automatically quotes lines beginning with a period per rfc821.
        Raises SMTPDataError if there is an unexpected reply to the
        DATA command; the return value from this method is the final
        response code received when the all data is sent.
        R(   i    s   data:ib  i˛ˇˇˇR3   N(   RT   RM   R@   R   R   R   R'   RR   (   R   R   R   t   replt   q(    (    s   /usr/lib/python2.7/smtplib.pyR(   Î  s    c         C   s    |  j  d t | É É |  j É  S(   s5   SMTP 'verify' command -- checks for address validity.t   vrfy(   RT   R$   RM   (   R   t   address(    (    s   /usr/lib/python2.7/smtplib.pyt   verify  s    c         C   s    |  j  d t | É É |  j É  S(   s.   SMTP 'expn' command -- expands a mailing list.t   expn(   RT   R$   RM   (   R   RÖ   (    (    s   /usr/lib/python2.7/smtplib.pyRá     s    c         C   sé   |  j  d k rä |  j d k rä d |  j É  d k o? d k n sä |  j É  \ } } d | k om d k n sá t | | É Ç qá qä n  d S(   sb  Call self.ehlo() and/or self.helo() if needed.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
        i»   i    i+  N(   Rd   R   Rj   R2   Rc   R	   (   R   R   R]   (    (    s   /usr/lib/python2.7/smtplib.pyt   ehlo_or_helo_if_needed  s
    &c         C   s  d Ñ  } d Ñ  } d } d } d } |  j  É  |  j d É sL t d É Ç n  |  j d j É  } | | | g }	 d }
 x$ |	 D] } | | k r{ | }
 Pq{ q{ W|
 | k r˘ |  j d | É \ } } | d	 k r’ | | f S|  j | | | | É É \ } } nœ |
 | k r1|  j d | d
 | | | É É \ } } nó |
 | k r≠|  j d d | t | d d Éf É \ } } | d k rât | | É Ç n  |  j t | d d ÉÉ \ } } n |
 d k r»t d É Ç n  | d k rÊt | | É Ç n  | | f S(   sA  Log in on an SMTP server that requires authentication.

        The arguments are:
            - user:     The user name to authenticate with.
            - password: The password for the authentication.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        This method will return normally if the authentication was successful.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
         SMTPAuthenticationError  The server didn't accept the username/
                                  password combination.
         SMTPException            No suitable authentication method was
                                  found.
        c         S   s?   t  j |  É }  | d t j | |  É j É  } t | d d ÉS(   NRg   t   eolR!   (   t   base64t   decodestringt   hmact   HMACt	   hexdigestt   encode_base64(   t	   challenget   usert   passwordt   response(    (    s   /usr/lib/python2.7/smtplib.pyt   encode_cram_md59  s     c         S   s   t  d |  | f d d ÉS(   Ns    %s %sRâ   R!   (   Rè   (   Rë   Rí   (    (    s   /usr/lib/python2.7/smtplib.pyt   encode_plain>  s    t   PLAINs   CRAM-MD5t   LOGINRf   s,   SMTP AUTH extension not supported by server.t   AUTHi˜  Rg   s   %s %sRâ   R!   iN  s(   No suitable authentication method found.iÎ   N(   iÎ   i˜  (	   Rà   Ry   R   R5   Rl   R   Rb   Rè   R
   (   R   Rë   Rí   Rî   Rï   t
   AUTH_PLAINt   AUTH_CRAM_MD5t
   AUTH_LOGINt   authlistt   preferred_authst
   authmethodt   methodR   R]   (    (    s   /usr/lib/python2.7/smtplib.pyt   login#  sD    		

$	#	%$c         C   sÀ   |  j  É  |  j d É s( t d É Ç n  |  j d É \ } } | d k r≤ t s^ t d É Ç n  t j |  j | | É |  _ t	 |  j É |  _
 d |  _ d |  _ i  |  _ d |  _ n t | | É Ç | | f S(   s°  Puts the connection to the SMTP server into TLS mode.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        If the server supports TLS, this will encrypt the rest of the SMTP
        session. If you provide the keyfile and certfile parameters,
        the identity of the SMTP server and client can be checked. This,
        however, depends on whether the socket module really checks the
        certificates.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
        t   starttlss+   STARTTLS extension not supported by server.t   STARTTLSi‹   s&   No SSL support included in this Pythoni    N(   Rà   Ry   R   Rb   t	   _have_sslt   RuntimeErrort   sslt   wrap_socketRL   R)   RW   R   Rd   Rj   R5   Rk   R   (   R   t   keyfilet   certfileR]   t   reply(    (    s   /usr/lib/python2.7/smtplib.pyR°   q  s    
			c         C   sç  |  j  É  g  } |  j rc |  j d É rB | j d t | É É n  x | D] } | j | É qI Wn  |  j | | É \ } }	 | d k r¶ |  j É  t | |	 | É Ç n  i  }
 t | t	 É r« | g } n  xQ | D]I } |  j
 | | É \ } }	 | d k rŒ | d k rŒ | |	 f |
 | <qŒ qŒ Wt |
 É t | É k rL|  j É  t |
 É Ç n  |  j | É \ } }	 | d k râ|  j É  t | |	 É Ç n  |
 S(   s‘	  This command performs an entire mail transaction.

        The arguments are:
            - from_addr    : The address sending this mail.
            - to_addrs     : A list of addresses to send this mail to.  A bare
                             string will be treated as a list with 1 address.
            - msg          : The message to send.
            - mail_options : List of ESMTP options (such as 8bitmime) for the
                             mail command.
            - rcpt_options : List of ESMTP options (such as DSN commands) for
                             all the rcpt commands.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.  If the server does ESMTP, message size
        and each of the specified options will be passed to it.  If EHLO
        fails, HELO will be tried and ESMTP options suppressed.

        This method will return normally if the mail is accepted for at least
        one recipient.  It returns a dictionary, with one entry for each
        recipient that was refused.  Each entry contains a tuple of the SMTP
        error code and the accompanying error message sent by the server.

        This method may raise the following exceptions:

         SMTPHeloError          The server didn't reply properly to
                                the helo greeting.
         SMTPRecipientsRefused  The server rejected ALL recipients
                                (no mail was sent).
         SMTPSenderRefused      The server didn't accept the from_addr.
         SMTPDataError          The server replied with an unexpected
                                error code (other than a refusal of
                                a recipient).

        Note: the connection will be open even after an exception is raised.

        Example:

         >>> import smtplib
         >>> s=smtplib.SMTP("localhost")
         >>> tolist=["one@one.org","two@two.org","three@three.org","four@four.org"]
         >>> msg = '''\
         ... From: Me@my.org
         ... Subject: testin'...
         ...
         ... This is a test '''
         >>> s.sendmail("me@my.org",tolist,msg)
         { "three@three.org" : ( 550 ,"User unknown" ) }
         >>> s.quit()

        In the above example, the message was accepted for delivery to three
        of the four addresses, and one was rejected, with the error code
        550.  If all addresses are accepted, then the method will return an
        empty dictionary.

        R-   s   size=%di˙   i˚   (   Rà   Rk   Ry   RZ   R+   R}   R{   R   t
   isinstancet
   basestringRÄ   R   R(   R   (   R   t	   from_addrt   to_addrsR   t   mail_optionst   rcpt_optionst
   esmtp_optst   optionR   R]   t   senderrsRu   (    (    s   /usr/lib/python2.7/smtplib.pyt   sendmailö  s4    9
	


c         C   sV   z) |  j  } d |  _  | r( | j É  n  Wd |  j } d |  _ | rQ | j É  n  Xd S(   s(   Close the connection to the SMTP server.N(   RW   R   R1   RL   (   R   RW   RL   (    (    s   /usr/lib/python2.7/smtplib.pyR1   Ù  s    				c         C   s?   |  j  d É } d |  _ |  _ i  |  _ t |  _ |  j É  | S(   s   Terminate the SMTP session.t   quitN(   Rb   R   Rj   Rd   R5   t   FalseRk   R1   (   R   t   res(    (    s   /usr/lib/python2.7/smtplib.pyR¥     s    		
N((   R   R   R   R@   R   RW   Rd   Ri   Rj   Rk   t	   SMTP_PORTRK   R8   t   _GLOBAL_DEFAULT_TIMEOUTR   RA   RC   R6   RR   RT   RM   Rb   Rc   R2   Ry   Rz   R{   R|   R}   RÄ   R(   RÜ   RÑ   Rá   Rà   R†   R°   R≥   R1   R¥   (    (    (    s   /usr/lib/python2.7/smtplib.pyR       sH   	%					0
2								N)Y	t   SMTP_SSLc           B   s;   e  Z d  Z e Z d d d d d e j d Ñ Z d Ñ  Z	 RS(   s*   This is a subclass derived from SMTP that connects over an SSL
        encrypted socket (to use this class you need a socket module that was
        compiled with SSL support). If host is not specified, '' (the local
        host) is used. If port is omitted, the standard SMTP-over-SSL port
        (465) is used.  local_hostname has the same meaning as it does in the
        SMTP class.  keyfile and certfile are also optional - they can contain
        a PEM formatted private key and certificate chain file for the SSL
        connection.

        R!   i    c         C   s/   | |  _  | |  _ t j |  | | | | É d  S(   N(   Rß   R®   R   R   (   R   R=   R>   R7   Rß   R®   R4   (    (    s   /usr/lib/python2.7/smtplib.pyR     s    		c         C   sn   |  j  d k r( t d I| | f IJn  t j | | f | É } t j | |  j |  j É } t | É |  _	 | S(   Ni    s   connect:(
   R@   R   R8   RB   R•   R¶   Rß   R®   R)   RW   (   R   R=   R>   R4   t
   new_socket(    (    s   /usr/lib/python2.7/smtplib.pyRC   #  s    N(
   R   R   R   t   SMTP_SSL_PORTRK   R   R8   R∏   R   RC   (    (    (    s   /usr/lib/python2.7/smtplib.pyRπ     s   
	i”  t   LMTPc           B   s5   e  Z d  Z d Z d e d d Ñ Z d d d Ñ Z RS(   su  LMTP - Local Mail Transfer Protocol

    The LMTP protocol, which is very similar to ESMTP, is heavily based
    on the standard SMTP client. It's common to use Unix sockets for
    LMTP, so our connect() method must support that as well as a regular
    host:port server.  local_hostname has the same meaning as it does in
    the SMTP class.  To specify a Unix socket, you must use an absolute
    path as the host, starting with a '/'.

    Authentication is supported, using the regular SMTP mechanism. When
    using a Unix socket, LMTP generally don't support or require any
    authentication, but your mileage might vary.t   lhloR!   c         C   s   t  j |  | | | É d S(   s   Initialize a new instance.N(   R   R   (   R   R=   R>   R7   (    (    s   /usr/lib/python2.7/smtplib.pyR   B  s    RD   i    c         C   sÓ   | d d k r# t  j |  | | É Sy/ t j t j t j É |  _ |  j j | É Wn[ t j k
 rØ |  j d k rá t d I| IJn  |  j r† |  j j	 É  n  d |  _ Ç  n X|  j É  \ } } |  j d k r‰ t d I| IJn  | | f S(   s=   Connect to the LMTP daemon, on either a Unix or a TCP socket.i    t   /s   connect fail:s   connect:N(   R   R6   R8   t   AF_UNIXt   SOCK_STREAMRL   RJ   R@   R   R1   R   RM   (   R   R=   R>   R   R   (    (    s   /usr/lib/python2.7/smtplib.pyR6   F  s     		N(   R   R   R   Ri   t	   LMTP_PORTR   R   R6   (    (    (    s   /usr/lib/python2.7/smtplib.pyRº   2  s   t   __main__c         C   s'   t  j j |  d É t  j j É  j É  S(   Ns   : (   t   syst   stdoutt   writet   stdinR0   R[   (   t   prompt(    (    s   /usr/lib/python2.7/smtplib.pyR«   a  s    t   Fromt   Tot   ,s   Enter message, end with ^D:R!   s   Message length is %dRD   i   (:   R   R8   R%   t   email.utilsR   Rä   Rå   t   email.base64mimeR    Rè   R√   R   t   __all__R∑   Rª   R'   RY   t   compilet   IRm   t	   ExceptionR   R   R   R   R   R   R   R	   R
   R   R$   R   R•   t   ImportErrorRµ   R£   R)   t   TrueR   Rπ   RZ   R¡   Rº   R   R«   t   fromaddrRl   t   toaddrsR   R∆   R0   R^   R+   t   serverRA   R≥   R¥   (    (    (    s   /usr/lib/python2.7/smtplib.pyt   <module>!   sv   						

ˇ ˇ D,	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   s*  d  Z  d d g Z d Ñ  Z d Ñ  Z g  Z d Ñ  Z e j e É d Ñ  Z e j e É d Ñ  Z e j e É d Ñ  Z	 e j e	 É d	 Ñ  Z
 e j e
 É d
 Ñ  Z e j e É d Ñ  Z e j e É d Ñ  Z e j e É d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d k r&e É  n  d S(   s∂  Routines to help recognizing sound files.

Function whathdr() recognizes various types of sound file headers.
It understands almost all headers that SOX can decode.

The return tuple contains the following items, in this order:
- file type (as SOX understands it)
- sampling rate (0 if unknown or hard to decode)
- number of channels (0 if unknown or hard to decode)
- number of frames in the file (-1 if unknown or hard to decode)
- number of bits/sample, or 'U' for U-LAW, or 'A' for A-LAW

If the file doesn't have a recognizable type, it returns None.
If the file can't be opened, IOError is raised.

To compute the total time, divide the number of frames by the
sampling rate (a frame contains a sample for each channel).

Function what() calls whathdr().  (It used to also use some
heuristics for raw data, but this doesn't work very well.)

Finally, the function test() is a simple main program that calls
what() for all files mentioned on the argument list.  For directory
arguments it calls what() for all files in that directory.  Default
argument is "." (testing all files in the current directory).  The
option -r tells it to recurse down directories found inside
explicitly given directories.
t   whatt   whathdrc         C   s   t  |  É } | S(   s   Guess the type of a sound file(   R   (   t   filenamet   res(    (    s   /usr/lib/python2.7/sndhdr.pyR    #   s    c         C   sL   t  |  d É } | j d É } x' t D] } | | | É } | r% | Sq% Wd S(   s   Recognize sound headerst   rbi   N(   t   opent   readt   testst   None(   R   t   ft   ht   tfR   (    (    s   /usr/lib/python2.7/sndhdr.pyR   )   s    c         C   sÃ   d d  l  } |  d  d k r  d  S|  d d !d k r< d } n  |  d d !d k rX d	 } n d  S| j d
 É y | j | d É } Wn t | j f k
 rú d  SX| | j É  | j É  | j É  d | j	 É  f S(   Niˇˇˇˇi   t   FORMi   i   t   AIFCt   aifct   AIFFt   aiffi    t   r(
   R   R   t   seekt   openfpt   EOFErrort   Errort   getframeratet   getnchannelst
   getnframest   getsampwidth(   R
   R	   R   t   fmtt   a(    (    s   /usr/lib/python2.7/sndhdr.pyt	   test_aifc:   s    		c         C   s  |  d  d k r t  } n |  d  d k r2 t } n d  Sd } | |  d d !É } | |  d d !É } | |  d d !É } | |  d d	 !É } | |  d	 d
 !É } d } | d k r∂ d }	 n6 | d k rÀ d }	 n! | d k rÊ d }	 d } n d }	 | | }
 | | | | |
 |	 f S(   Ni   s   .snds    ds.s   dns.t   aui   i   i   i   i   i   t   Ui   i   t   ?(   s    ds.s   dns.(   t   get_long_bet   get_long_leR   (   R
   R	   t   typet   hdr_sizet	   data_sizet   encodingt   ratet	   nchannelst   sample_sizet   sample_bitst
   frame_size(    (    s   /usr/lib/python2.7/sndhdr.pyt   test_auO   s,    					
c         C   sT   |  d d !d k s& |  d d !d k r* d  St |  d d !É } d	 d
 | d d d f S(   NiA   iE   t   FSSDiÄ   iÑ   t   HCOMi   i   t   hcomi"V  i   iˇˇˇˇi   iê   iî   (   R   R    (   R
   R	   t   divisor(    (    s   /usr/lib/python2.7/sndhdr.pyt	   test_hcoml   s    &c         C   só   |  d  d k r d  St |  d d !É } d } d | k oD d k  n rÑ |  | d k rÑ t |  | d É } t d d	 | É } n  d
 | d d d f S(   Ni   s   Creative Voice Filei   i    iÙ  s   i   g    ÄÑ.Ai   t   voci   iˇˇˇˇi   (   R   t   get_short_let   ordt   int(   R
   R	   t   sbseekR&   t   ratecode(    (    s   /usr/lib/python2.7/sndhdr.pyt   test_vocu   s    ,c         C   sô   |  d  d k s6 |  d d !d k s6 |  d d !d k r: d  St |  d d	 !É } t |  d	 d
 !É } t |  d
 d !É } t |  d d !É } d | | d | f S(   Ni   t   RIFFi   i   t   WAVEi   s   fmt i   i   i   i   i"   i$   t   waviˇˇˇˇ(   R   R2   R!   (   R
   R	   t   styleR'   R&   R)   (    (    s   /usr/lib/python2.7/sndhdr.pyt   test_wavÇ   s    6c         C   s+   |  d  d k s# |  d d !d k r' d  Sd	 S(
   Ni   R   i   i   t   8SVXt   8svxi    i   (   R>   i    i   i    i   (   R   (   R
   R	   (    (    s   /usr/lib/python2.7/sndhdr.pyt	   test_8svxè   s    #c         C   sM   |  d  d k rI t  |  d d !É } t |  d d !É } d | d | d f Sd  S(	   Ni   t   SOUNDi   i   i   i   t   sndti   (   R!   R2   (   R
   R	   t   nsamplesR&   (    (    s   /usr/lib/python2.7/sndhdr.pyt	   test_sndtò   s    c         C   sY   |  d  d k rU t  |  d d !É } d | k o: d k n rU d | d d d	 f Sn  d  S(
   Ni   s     i   i†  i®a  t   sndri   iˇˇˇˇi   (   R2   (   R
   R	   R&   (    (    s   /usr/lib/python2.7/sndhdr.pyt	   test_sndr°   s    c         C   sD   t  |  d É d >t  |  d É d >Bt  |  d É d >Bt  |  d É BS(   Ni    i   i   i   i   i   i   (   R3   (   t   s(    (    s   /usr/lib/python2.7/sndhdr.pyR    Æ   s    c         C   sD   t  |  d É d >t  |  d É d >Bt  |  d É d >Bt  |  d É BS(   Ni   i   i   i   i   i   i    (   R3   (   RF   (    (    s   /usr/lib/python2.7/sndhdr.pyR!   ±   s    c         C   s    t  |  d É d >t  |  d É BS(   Ni    i   i   (   R3   (   RF   (    (    s   /usr/lib/python2.7/sndhdr.pyt   get_short_be¥   s    c         C   s    t  |  d É d >t  |  d É BS(   Ni   i   i    (   R3   (   RF   (    (    s   /usr/lib/python2.7/sndhdr.pyR2   ∑   s    c          C   sª   d d  l  }  d } |  j d rH |  j d d k rH |  j d d 5d } n  y> |  j d rr t |  j d | d É n t d g | d É Wn. t k
 r∂ |  j j d É |  j d É n Xd  S(   Niˇˇˇˇi    i   s   -ri   t   .s   
[Interrupted]
(   t   syst   argvt   testallt   KeyboardInterruptt   stderrt   writet   exit(   RI   t	   recursive(    (    s   /usr/lib/python2.7/sndhdr.pyt   testø   s     	c         C   s⁄   d d  l  } d d  l } xª |  D]≥ } | j j | É rï | d G| sK | rç d GHd d  l } | j | j j | d É É } t | | d É q“ d GHq | d G| j j É  y t	 | É GHWq t
 k
 r— d GHq Xq Wd  S(	   Niˇˇˇˇs   /:s   recursing down:t   *i    s   *** directory (use -r) ***t   :s   *** not found ***(   RI   t   ost   patht   isdirt   globt   joinRK   t   stdoutt   flushR    t   IOError(   t   listRP   t   toplevelRI   RT   R   RW   t   names(    (    s   /usr/lib/python2.7/sndhdr.pyRK   Œ   s"    t   __main__N(   t   __doc__t   __all__R    R   R   R   t   appendR+   R0   R7   R<   R?   RC   RE   R    R!   RG   R2   RQ   RK   t   __name__(    (    (    s   /usr/lib/python2.7/sndhdr.pyt   <module>   s8   						
	
									                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Wrapper module for _socket, providing some additional facilities
# implemented in Python.

"""\
This module provides socket operations and some related functions.
On Unix, it supports IP (Internet Protocol) and Unix domain sockets.
On other systems, it only supports IP. Functions specific for a
socket are available as methods of the socket object.

Functions:

socket() -- create a new socket object
socketpair() -- create a pair of new socket objects [*]
fromfd() -- create a socket object from an open file descriptor [*]
gethostname() -- return the current hostname
gethostbyname() -- map a hostname to its IP number
gethostbyaddr() -- map an IP number or hostname to DNS info
getservbyname() -- map a service name and a protocol name to a port number
getprotobyname() -- map a protocol name (e.g. 'tcp') to a number
ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order
htons(), htonl() -- convert 16, 32 bit int from host to network byte order
inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format
inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)
ssl() -- secure socket layer support (only available if configured)
socket.getdefaulttimeout() -- get the default timeout value
socket.setdefaulttimeout() -- set the default timeout value
create_connection() -- connects to an address, with an optional timeout and
                       optional source address.

 [*] not available on all platforms!

Special objects:

SocketType -- type object for socket objects
error -- exception raised for I/O errors
has_ipv6 -- boolean value indicating if IPv6 is supported

Integer constants:

AF_INET, AF_UNIX -- socket domains (first argument to socket() call)
SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)

Many other constants may be defined; these may be used in calls to
the setsockopt() and getsockopt() methods.
"""

import _socket
from _socket import *
from functools import partial
from types import MethodType

try:
    import _ssl
except ImportError:
    # no SSL support
    pass
else:
    def ssl(sock, keyfile=None, certfile=None):
        # we do an internal import here because the ssl
        # module imports the socket module
        import ssl as _realssl
        warnings.warn("socket.ssl() is deprecated.  Use ssl.wrap_socket() instead.",
                      DeprecationWarning, stacklevel=2)
        return _realssl.sslwrap_simple(sock, keyfile, certfile)

    # we need to import the same constants we used to...
    from _ssl import SSLError as sslerror
    from _ssl import \
         RAND_add, \
         RAND_status, \
         SSL_ERROR_ZERO_RETURN, \
         SSL_ERROR_WANT_READ, \
         SSL_ERROR_WANT_WRITE, \
         SSL_ERROR_WANT_X509_LOOKUP, \
         SSL_ERROR_SYSCALL, \
         SSL_ERROR_SSL, \
         SSL_ERROR_WANT_CONNECT, \
         SSL_ERROR_EOF, \
         SSL_ERROR_INVALID_ERROR_CODE
    try:
        from _ssl import RAND_egd
    except ImportError:
        # LibreSSL does not provide RAND_egd
        pass

import os, sys, warnings

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

try:
    import errno
except ImportError:
    errno = None
EBADF = getattr(errno, 'EBADF', 9)
EINTR = getattr(errno, 'EINTR', 4)

__all__ = ["getfqdn", "create_connection"]
__all__.extend(os._get_exports_list(_socket))


_realsocket = socket

# WSA error codes
if sys.platform.lower().startswith("win"):
    errorTab = {}
    errorTab[10004] = "The operation was interrupted."
    errorTab[10009] = "A bad file handle was passed."
    errorTab[10013] = "Permission denied."
    errorTab[10014] = "A fault occurred on the network??" # WSAEFAULT
    errorTab[10022] = "An invalid operation was attempted."
    errorTab[10035] = "The socket operation would block"
    errorTab[10036] = "A blocking operation is already in progress."
    errorTab[10048] = "The network address is in use."
    errorTab[10054] = "The connection has been reset."
    errorTab[10058] = "The network has been shut down."
    errorTab[10060] = "The operation timed out."
    errorTab[10061] = "Connection refused."
    errorTab[10063] = "The name is too long."
    errorTab[10064] = "The host is down."
    errorTab[10065] = "The host is unreachable."
    __all__.append("errorTab")



def getfqdn(name=''):
    """Get fully qualified domain name from name.

    An empty argument is interpreted as meaning the local host.

    First the hostname returned by gethostbyaddr() is checked, then
    possibly existing aliases. In case no FQDN is available, hostname
    from gethostname() is returned.
    """
    name = name.strip()
    if not name or name == '0.0.0.0':
        name = gethostname()
    try:
        hostname, aliases, ipaddrs = gethostbyaddr(name)
    except error:
        pass
    else:
        aliases.insert(0, hostname)
        for name in aliases:
            if '.' in name:
                break
        else:
            name = hostname
    return name


_socketmethods = (
    'bind', 'connect', 'connect_ex', 'fileno', 'listen',
    'getpeername', 'getsockname', 'getsockopt', 'setsockopt',
    'sendall', 'setblocking',
    'settimeout', 'gettimeout', 'shutdown')

if os.name == "nt":
    _socketmethods = _socketmethods + ('ioctl',)

if sys.platform == "riscos":
    _socketmethods = _socketmethods + ('sleeptaskw',)

# All the method names that must be delegated to either the real socket
# object or the _closedsocket object.
_delegate_methods = ("recv", "recvfrom", "recv_into", "recvfrom_into",
                     "send", "sendto")

class _closedsocket(object):
    __slots__ = []
    def _dummy(*args):
        raise error(EBADF, 'Bad file descriptor')
    # All _delegate_methods must also be initialized here.
    send = recv = recv_into = sendto = recvfrom = recvfrom_into = _dummy
    __getattr__ = _dummy

# Wrapper around platform socket objects. This implements
# a platform-independent dup() functionality. The
# implementation currently relies on reference counting
# to close the underlying socket object.
class _socketobject(object):

    __doc__ = _realsocket.__doc__

    __slots__ = ["_sock", "__weakref__"] + list(_delegate_methods)

    def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, _sock=None):
        if _sock is None:
            _sock = _realsocket(family, type, proto)
        self._sock = _sock
        for method in _delegate_methods:
            setattr(self, method, getattr(_sock, method))

    def close(self, _closedsocket=_closedsocket,
              _delegate_methods=_delegate_methods, setattr=setattr):
        # This function should not reference any globals. See issue #808164.
        self._sock = _closedsocket()
        dummy = self._sock._dummy
        for method in _delegate_methods:
            setattr(self, method, dummy)
    close.__doc__ = _realsocket.close.__doc__

    def accept(self):
        sock, addr = self._sock.accept()
        return _socketobject(_sock=sock), addr
    accept.__doc__ = _realsocket.accept.__doc__

    def dup(self):
        """dup() -> socket object

        Return a new socket object connected to the same system resource."""
        return _socketobject(_sock=self._sock)

    def makefile(self, mode='r', bufsize=-1):
        """makefile([mode[, bufsize]]) -> file object

        Return a regular file object corresponding to the socket.  The mode
        and bufsize arguments are as for the built-in open() function."""
        return _fileobject(self._sock, mode, bufsize)

    family = property(lambda self: self._sock.family, doc="the socket family")
    type = property(lambda self: self._sock.type, doc="the socket type")
    proto = property(lambda self: self._sock.proto, doc="the socket protocol")

def meth(name,self,*args):
    return getattr(self._sock,name)(*args)

for _m in _socketmethods:
    p = partial(meth,_m)
    p.__name__ = _m
    p.__doc__ = getattr(_realsocket,_m).__doc__
    m = MethodType(p,None,_socketobject)
    setattr(_socketobject,_m,m)

socket = SocketType = _socketobject

class _fileobject(object):
    """Faux file object attached to a socket object."""

    default_bufsize = 8192
    name = "<socket>"

    __slots__ = ["mode", "bufsize", "softspace",
                 # "closed" is a property, see below
                 "_sock", "_rbufsize", "_wbufsize", "_rbuf", "_wbuf", "_wbuf_len",
                 "_close"]

    def __init__(self, sock, mode='rb', bufsize=-1, close=False):
        self._sock = sock
        self.mode = mode # Not actually used in this version
        if bufsize < 0:
            bufsize = self.default_bufsize
        self.bufsize = bufsize
        self.softspace = False
        # _rbufsize is the suggested recv buffer size.  It is *strictly*
        # obeyed within readline() for recv calls.  If it is larger than
        # default_bufsize it will be used for recv calls within read().
        if bufsize == 0:
            self._rbufsize = 1
        elif bufsize == 1:
            self._rbufsize = self.default_bufsize
        else:
            self._rbufsize = bufsize
        self._wbufsize = bufsize
        # We use StringIO for the read buffer to avoid holding a list
        # of variously sized string objects which have been known to
        # fragment the heap due to how they are malloc()ed and often
        # realloc()ed down much smaller than their original allocation.
        self._rbuf = StringIO()
        self._wbuf = [] # A list of strings
        self._wbuf_len = 0
        self._close = close

    def _getclosed(self):
        return self._sock is None
    closed = property(_getclosed, doc="True if the file is closed")

    def close(self):
        try:
            if self._sock:
                self.flush()
        finally:
            if self._close:
                self._sock.close()
            self._sock = None

    def __del__(self):
        try:
            self.close()
        except:
            # close() may fail if __init__ didn't complete
            pass

    def flush(self):
        if self._wbuf:
            data = "".join(self._wbuf)
            self._wbuf = []
            self._wbuf_len = 0
            buffer_size = max(self._rbufsize, self.default_bufsize)
            data_size = len(data)
            write_offset = 0
            view = memoryview(data)
            try:
                while write_offset < data_size:
                    self._sock.sendall(view[write_offset:write_offset+buffer_size])
                    write_offset += buffer_size
            finally:
                if write_offset < data_size:
                    remainder = data[write_offset:]
                    del view, data  # explicit free
                    self._wbuf.append(remainder)
                    self._wbuf_len = len(remainder)

    def fileno(self):
        return self._sock.fileno()

    def write(self, data):
        data = str(data) # XXX Should really reject non-string non-buffers
        if not data:
            return
        self._wbuf.append(data)
        self._wbuf_len += len(data)
        if (self._wbufsize == 0 or
            (self._wbufsize == 1 and '\n' in data) or
            (self._wbufsize > 1 and self._wbuf_len >= self._wbufsize)):
            self.flush()

    def writelines(self, list):
        # XXX We could do better here for very long lists
        # XXX Should really reject non-string non-buffers
        lines = filter(None, map(str, list))
        self._wbuf_len += sum(map(len, lines))
        self._wbuf.extend(lines)
        if (self._wbufsize <= 1 or
            self._wbuf_len >= self._wbufsize):
            self.flush()

    def read(self, size=-1):
        # Use max, disallow tiny reads in a loop as they are very inefficient.
        # We never leave read() with any leftover data from a new recv() call
        # in our internal buffer.
        rbufsize = max(self._rbufsize, self.default_bufsize)
        # Our use of StringIO rather than lists of string objects returned by
        # recv() minimizes memory usage and fragmentation that occurs when
        # rbufsize is large compared to the typical return value of recv().
        buf = self._rbuf
        buf.seek(0, 2)  # seek end
        if size < 0:
            # Read until EOF
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                try:
                    data = self._sock.recv(rbufsize)
                except error, e:
                    if e.args[0] == EINTR:
                        continue
                    raise
                if not data:
                    break
                buf.write(data)
            return buf.getvalue()
        else:
            # Read until size bytes or EOF seen, whichever comes first
            buf_len = buf.tell()
            if buf_len >= size:
                # Already have size bytes in our buffer?  Extract and return.
                buf.seek(0)
                rv = buf.read(size)
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return rv

            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                left = size - buf_len
                # recv() will malloc the amount of memory given as its
                # parameter even though it often returns much less data
                # than that.  The returned data string is short lived
                # as we copy it into a StringIO and free it.  This avoids
                # fragmentation issues on many platforms.
                try:
                    data = self._sock.recv(left)
                except error, e:
                    if e.args[0] == EINTR:
                        continue
                    raise
                if not data:
                    break
                n = len(data)
                if n == size and not buf_len:
                    # Shortcut.  Avoid buffer data copies when:
                    # - We have no data in our buffer.
                    # AND
                    # - Our call to recv returned exactly the
                    #   number of bytes we were asked to read.
                    return data
                if n == left:
                    buf.write(data)
                    del data  # explicit free
                    break
                assert n <= left, "recv(%d) returned %d bytes" % (left, n)
                buf.write(data)
                buf_len += n
                del data  # explicit free
                #assert buf_len == buf.tell()
            return buf.getvalue()

    def readline(self, size=-1):
        buf = self._rbuf
        buf.seek(0, 2)  # seek end
        if buf.tell() > 0:
            # check if we already have it in our buffer
            buf.seek(0)
            bline = buf.readline(size)
            if bline.endswith('\n') or len(bline) == size:
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return bline
            del bline
        if size < 0:
            # Read until \n or EOF, whichever comes first
            if self._rbufsize <= 1:
                # Speed up unbuffered case
                buf.seek(0)
                buffers = [buf.read()]
                self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
                data = None
                recv = self._sock.recv
                while True:
                    try:
                        while data != "\n":
                            data = recv(1)
                            if not data:
                                break
                            buffers.append(data)
                    except error, e:
                        # The try..except to catch EINTR was moved outside the
                        # recv loop to avoid the per byte overhead.
                        if e.args[0] == EINTR:
                            continue
                        raise
                    break
                return "".join(buffers)

            buf.seek(0, 2)  # seek end
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                try:
                    data = self._sock.recv(self._rbufsize)
                except error, e:
                    if e.args[0] == EINTR:
                        continue
                    raise
                if not data:
                    break
                nl = data.find('\n')
                if nl >= 0:
                    nl += 1
                    buf.write(data[:nl])
                    self._rbuf.write(data[nl:])
                    del data
                    break
                buf.write(data)
            return buf.getvalue()
        else:
            # Read until size bytes or \n or EOF seen, whichever comes first
            buf.seek(0, 2)  # seek end
            buf_len = buf.tell()
            if buf_len >= size:
                buf.seek(0)
                rv = buf.read(size)
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return rv
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                try:
                    data = self._sock.recv(self._rbufsize)
                except error, e:
                    if e.args[0] == EINTR:
                        continue
                    raise
                if not data:
                    break
                left = size - buf_len
                # did we just receive a newline?
                nl = data.find('\n', 0, left)
                if nl >= 0:
                    nl += 1
                    # save the excess data to _rbuf
                    self._rbuf.write(data[nl:])
                    if buf_len:
                        buf.write(data[:nl])
                        break
                    else:
                        # Shortcut.  Avoid data copy through buf when returning
                        # a substring of our first recv().
                        return data[:nl]
                n = len(data)
                if n == size and not buf_len:
                    # Shortcut.  Avoid data copy through buf when
                    # returning exactly all of our first recv().
                    return data
                if n >= left:
                    buf.write(data[:left])
                    self._rbuf.write(data[left:])
                    break
                buf.write(data)
                buf_len += n
                #assert buf_len == buf.tell()
            return buf.getvalue()

    def readlines(self, sizehint=0):
        total = 0
        list = []
        while True:
            line = self.readline()
            if not line:
                break
            list.append(line)
            total += len(line)
            if sizehint and total >= sizehint:
                break
        return list

    # Iterator protocols

    def __iter__(self):
        return self

    def next(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

_GLOBAL_DEFAULT_TIMEOUT = object()

def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                      source_address=None):
    """Connect to *address* and return the socket object.

    Convenience function.  Connect to *address* (a 2-tuple ``(host,
    port)``) and return the socket object.  Passing the optional
    *timeout* parameter will set the timeout on the socket instance
    before attempting to connect.  If no *timeout* is supplied, the
    global default timeout setting returned by :func:`getdefaulttimeout`
    is used.  If *source_address* is set it must be a tuple of (host, port)
    for the socket to bind as a source address before making the connection.
    A host of '' or port 0 tells the OS to use the default.
    """

    host, port = address
    err = None
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        sock = None
        try:
            sock = socket(af, socktype, proto)
            if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                sock.settimeout(timeout)
            if source_address:
                sock.bind(source_address)
            sock.connect(sa)
            return sock

        except error as _:
            err = _
            if sock is not None:
                sock.close()

    if err is not None:
        raise err
    else:
        raise error("getaddrinfo returns an empty list")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   sÏ  d  Z  d d l Z d d l Td d l m Z d d l m Z y d d l Z Wn e k
 r_ nî Xe e d Ñ Z	 d d l m
 Z d d l m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z y d d	 l m Z Wn e k
 rÚ n Xd d l Z d d l Z d d l Z y d d
 l m Z Wn! e k
 rNd d
 l m Z n Xy d d l Z Wn e k
 rxe Z n Xe e d d É Z e e d d É Z  d d g Z! e! j" e j# e É É e$ Z% e j& j' É  j( d É râi  Z) d e) d <d e) d <d e) d <d e) d <d e) d <d e) d <d e) d <d  e) d! <d" e) d# <d$ e) d% <d& e) d' <d( e) d) <d* e) d+ <d, e) d- <d. e) d/ <e! j* d0 É n  d1 d2 Ñ Z+ d3 d4 d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ f Z, e j- dA k r‰e, dB f Z, n  e j& dC k re, dD f Z, n  dE dF dG dH dI dJ f Z. dK e/ f dL Ñ  É  YZ0 dM e/ f dN Ñ  É  YZ1 dO Ñ  Z2 x] e, D]U Z3 e e2 e3 É Z4 e3 e4 _5 e e% e3 É j  e4 _  e e4 e e1 É Z6 e7 e1 e3 e6 É qWWe1 Z$ Z8 dP e/ f dQ Ñ  É  YZ9 e/ É  Z: e: e dR Ñ Z; d S(S   s  This module provides socket operations and some related functions.
On Unix, it supports IP (Internet Protocol) and Unix domain sockets.
On other systems, it only supports IP. Functions specific for a
socket are available as methods of the socket object.

Functions:

socket() -- create a new socket object
socketpair() -- create a pair of new socket objects [*]
fromfd() -- create a socket object from an open file descriptor [*]
gethostname() -- return the current hostname
gethostbyname() -- map a hostname to its IP number
gethostbyaddr() -- map an IP number or hostname to DNS info
getservbyname() -- map a service name and a protocol name to a port number
getprotobyname() -- map a protocol name (e.g. 'tcp') to a number
ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order
htons(), htonl() -- convert 16, 32 bit int from host to network byte order
inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format
inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)
ssl() -- secure socket layer support (only available if configured)
socket.getdefaulttimeout() -- get the default timeout value
socket.setdefaulttimeout() -- set the default timeout value
create_connection() -- connects to an address, with an optional timeout and
                       optional source address.

 [*] not available on all platforms!

Special objects:

SocketType -- type object for socket objects
error -- exception raised for I/O errors
has_ipv6 -- boolean value indicating if IPv6 is supported

Integer constants:

AF_INET, AF_UNIX -- socket domains (first argument to socket() call)
SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)

Many other constants may be defined; these may be used in calls to
the setsockopt() and getsockopt() methods.
iˇˇˇˇN(   t   *(   t   partial(   t
   MethodTypec         C   s5   d d  l  } t j d t d d É| j |  | | É S(   Niˇˇˇˇs;   socket.ssl() is deprecated.  Use ssl.wrap_socket() instead.t
   stackleveli   (   t   sslt   warningst   warnt   DeprecationWarningt   sslwrap_simple(   t   sockt   keyfilet   certfilet   _realssl(    (    s   /usr/lib/python2.7/socket.pyR   :   s    	(   t   SSLError(   t   RAND_addt   RAND_statust   SSL_ERROR_ZERO_RETURNt   SSL_ERROR_WANT_READt   SSL_ERROR_WANT_WRITEt   SSL_ERROR_WANT_X509_LOOKUPt   SSL_ERROR_SYSCALLt   SSL_ERROR_SSLt   SSL_ERROR_WANT_CONNECTt   SSL_ERROR_EOFt   SSL_ERROR_INVALID_ERROR_CODE(   t   RAND_egd(   t   StringIOt   EBADFi	   t   EINTRi   t   getfqdnt   create_connectiont   wins   The operation was interrupted.i'  s   A bad file handle was passed.i'  s   Permission denied.i'  s!   A fault occurred on the network??i'  s#   An invalid operation was attempted.i&'  s    The socket operation would blocki3'  s,   A blocking operation is already in progress.i4'  s   The network address is in use.i@'  s   The connection has been reset.iF'  s   The network has been shut down.iJ'  s   The operation timed out.iL'  s   Connection refused.iM'  s   The name is too long.iO'  s   The host is down.iP'  s   The host is unreachable.iQ'  t   errorTabt    c         C   sì   |  j  É  }  |  s |  d k r+ t É  }  n  y t |  É \ } } } Wn t k
 rW n8 X| j d | É x$ | D] }  d |  k ro Pqo qo W| }  |  S(   s  Get fully qualified domain name from name.

    An empty argument is interpreted as meaning the local host.

    First the hostname returned by gethostbyaddr() is checked, then
    possibly existing aliases. In case no FQDN is available, hostname
    from gethostname() is returned.
    s   0.0.0.0i    t   .(   t   stript   gethostnamet   gethostbyaddrt   errort   insert(   t   namet   hostnamet   aliasest   ipaddrs(    (    s   /usr/lib/python2.7/socket.pyR   Ä   s    	t   bindt   connectt
   connect_ext   filenot   listent   getpeernamet   getsocknamet
   getsockoptt
   setsockoptt   sendallt   setblockingt
   settimeoutt
   gettimeoutt   shutdownt   ntt   ioctlt   riscost
   sleeptaskwt   recvt   recvfromt	   recv_intot   recvfrom_intot   sendt   sendtot   _closedsocketc           B   s7   e  Z g  Z d  Ñ  Z e Z Z Z Z Z Z	 e Z
 RS(   c          G   s   t  t d É Ç d  S(   Ns   Bad file descriptor(   R&   R   (   t   args(    (    s   /usr/lib/python2.7/socket.pyt   _dummy≠   s    (   t   __name__t
   __module__t	   __slots__RF   RB   R>   R@   RC   R?   RA   t   __getattr__(    (    (    s   /usr/lib/python2.7/socket.pyRD   ´   s   	t   _socketobjectc           B   sÃ   e  Z e j Z d  d g e e É Z e e d d d Ñ Z
 e e e d Ñ Z e j j e _ d Ñ  Z e j j e _ d Ñ  Z d d d	 Ñ Z e d
 Ñ  d d ÉZ e d Ñ  d d ÉZ e d Ñ  d d ÉZ RS(   t   _sockt   __weakref__i    c         C   sX   | d  k r! t | | | É } n  | |  _ x' t D] } t |  | t | | É É q1 Wd  S(   N(   t   Nonet   _realsocketRL   t   _delegate_methodst   setattrt   getattr(   t   selft   familyt   typet   protoRL   t   method(    (    s   /usr/lib/python2.7/socket.pyt   __init__Ω   s
    	c         C   s=   | É  |  _  |  j  j } x | D] } | |  | | É q Wd  S(   N(   RL   RF   (   RS   RD   RP   RQ   t   dummyRW   (    (    s   /usr/lib/python2.7/socket.pyt   closeƒ   s    c         C   s(   |  j  j É  \ } } t d | É | f S(   NRL   (   RL   t   acceptRK   (   RS   R	   t   addr(    (    s   /usr/lib/python2.7/socket.pyR[   Õ   s    c         C   s   t  d |  j É S(   sa   dup() -> socket object

        Return a new socket object connected to the same system resource.RL   (   RK   RL   (   RS   (    (    s   /usr/lib/python2.7/socket.pyt   dup“   s    t   riˇˇˇˇc         C   s   t  |  j | | É S(   sæ   makefile([mode[, bufsize]]) -> file object

        Return a regular file object corresponding to the socket.  The mode
        and bufsize arguments are as for the built-in open() function.(   t   _fileobjectRL   (   RS   t   modet   bufsize(    (    s   /usr/lib/python2.7/socket.pyt   makefileÿ   s    c         C   s
   |  j  j S(   N(   RL   RT   (   RS   (    (    s   /usr/lib/python2.7/socket.pyt   <lambda>ﬂ   s    t   docs   the socket familyc         C   s
   |  j  j S(   N(   RL   RU   (   RS   (    (    s   /usr/lib/python2.7/socket.pyRc   ‡   s    s   the socket typec         C   s
   |  j  j S(   N(   RL   RV   (   RS   (    (    s   /usr/lib/python2.7/socket.pyRc   ·   s    s   the socket protocolN(   RG   RH   RO   t   __doc__t   listRP   RI   t   AF_INETt   SOCK_STREAMRN   RX   RD   RQ   RZ   R[   R]   Rb   t   propertyRT   RU   RV   (    (    (    s   /usr/lib/python2.7/socket.pyRK   ∑   s   			c         G   s   t  | j |  É | å  S(   N(   RR   RL   (   R(   RS   RE   (    (    s   /usr/lib/python2.7/socket.pyt   meth„   s    R_   c        
   B   s◊   e  Z d  Z d Z d Z d d d d d d d	 d
 d d g
 Z d d e d Ñ Z d Ñ  Z e	 e d d ÉZ
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z RS(   s-   Faux file object attached to a socket object.i    s   <socket>R`   Ra   t	   softspaceRL   t	   _rbufsizet	   _wbufsizet   _rbuft   _wbuft	   _wbuf_lent   _closet   rbiˇˇˇˇc         C   s¨   | |  _  | |  _ | d k  r* |  j } n  | |  _ t |  _ | d k rT d |  _ n$ | d k ro |  j |  _ n	 | |  _ | |  _ t É  |  _	 g  |  _
 d |  _ | |  _ d  S(   Ni    i   (   RL   R`   t   default_bufsizeRa   t   FalseRk   Rl   Rm   R   Rn   Ro   Rp   Rq   (   RS   R	   R`   Ra   RZ   (    (    s   /usr/lib/python2.7/socket.pyRX   ˙   s     								c         C   s   |  j  d  k S(   N(   RL   RN   (   RS   (    (    s   /usr/lib/python2.7/socket.pyt
   _getclosed  s    Rd   s   True if the file is closedc         C   sD   z |  j  r |  j É  n  Wd  |  j r6 |  j  j É  n  d  |  _  Xd  S(   N(   RL   t   flushRq   RZ   RN   (   RS   (    (    s   /usr/lib/python2.7/socket.pyRZ     s    		c         C   s   y |  j  É  Wn n Xd  S(   N(   RZ   (   RS   (    (    s   /usr/lib/python2.7/socket.pyt   __del__!  s    c         C   sÂ   |  j  r· d j |  j  É } g  |  _  d |  _ t |  j |  j É } t | É } d } t | É } z< x5 | | k  rö |  j j	 | | | | !É | | 7} qf WWd  | | k  r› | | } ~ ~ |  j  j
 | É t | É |  _ n  Xn  d  S(   NR!   i    (   Ro   t   joinRp   t   maxRl   Rs   t   lent
   memoryviewRL   R5   t   append(   RS   t   datat   buffer_sizet	   data_sizet   write_offsett   viewt	   remainder(    (    s   /usr/lib/python2.7/socket.pyRv   (  s"    			
c         C   s   |  j  j É  S(   N(   RL   R/   (   RS   (    (    s   /usr/lib/python2.7/socket.pyR/   <  s    c         C   só   t  | É } | s d  S|  j j | É |  j t | É 7_ |  j d k sÜ |  j d k re d | k sÜ |  j d k rì |  j |  j k rì |  j É  n  d  S(   Ni    i   s   
(   t   strRo   R|   Rp   Rz   Rm   Rv   (   RS   R}   (    (    s   /usr/lib/python2.7/socket.pyt   write?  s    !c         C   sx   t  d  t t | É É } |  j t t t | É É 7_ |  j j | É |  j	 d k sg |  j |  j	 k rt |  j
 É  n  d  S(   Ni   (   t   filterRN   t   mapRÉ   Rp   t   sumRz   Ro   t   extendRm   Rv   (   RS   Rf   t   lines(    (    s   /usr/lib/python2.7/socket.pyt
   writelinesJ  s    c   
      C   s  t  |  j |  j É } |  j } | j d d É | d k  rº t É  |  _ xi t r± y |  j j | É } Wn/ t	 k
 rñ } | j
 d t k rê qI n  Ç  n X| s° Pn  | j | É qI W| j É  S| j É  } | | k r| j d É | j | É } t É  |  _ |  j j | j É  É | St É  |  _ xÂ t r	| | } y |  j j | É } Wn/ t	 k
 r|} | j
 d t k rvq%n  Ç  n X| sáPn  t | É }	 |	 | k r™| r™| S|	 | k r | j | É ~ Pn  |	 | k sÏt d | |	 f É Ç | j | É | |	 7} ~ q%W| j É  Sd  S(   Ni    i   s   recv(%d) returned %d bytes(   Ry   Rl   Rs   Rn   t   seekR   t   TrueRL   R>   R&   RE   R   RÑ   t   getvaluet   tellt   readRz   t   AssertionError(
   RS   t   sizet   rbufsizet   bufR}   t   et   buf_lent   rvt   leftt   n(    (    s   /usr/lib/python2.7/socket.pyRè   T  s\    		
	
"
c         C   s  |  j  } | j d d É | j É  d k rî | j d É | j | É } | j d É sh t | É | k ré t É  |  _  |  j  j | j É  É | S~ n  | d k  rV|  j	 d k rp| j d É | j É  g } t É  |  _  d  } |  j j } xw t rby: x3 | d k r*| d É } | sPn  | j | É q¯ WWn/ t k
 r]} | j d t k rWqÏ n  Ç  n XPqÏ Wd j | É S| j d d É t É  |  _  xΩ t rKy |  j j |  j	 É } Wn/ t k
 rﬂ} | j d t k rŸqèn  Ç  n X| sÍPn  | j d É } | d k r;| d 7} | j | |  É |  j  j | | É ~ Pn  | j | É qèW| j É  S| j d d É | j É  }	 |	 | k r¿| j d É | j | É }
 t É  |  _  |  j  j | j É  É |
 St É  |  _  x=t ry |  j j |  j	 É } Wn/ t k
 r} | j d t k rqœn  Ç  n X| s*Pn  | |	 } | j d d | É } | d k rô| d 7} |  j  j | | É |	 ré| j | |  É Pqô| |  Sn  t | É } | | k rº|	 rº| S| | k rÒ| j | |  É |  j  j | | É Pn  | j | É |	 | 7}	 qœW| j É  Sd  S(   Ni    i   s   
i   R!   (   Rn   Rã   Ré   t   readlinet   endswithRz   R   RÑ   Rè   Rl   RN   RL   R>   Rå   R|   R&   RE   R   Rx   t   findRç   (   RS   Rë   Rì   t   blinet   buffersR}   R>   Rî   t   nlRï   Rñ   Ró   Rò   (    (    s   /usr/lib/python2.7/socket.pyRô   ö  sÆ    	!		

	

i    c         C   sf   d } g  } xS t  ra |  j É  } | s+ Pn  | j | É | t | É 7} | r | | k r Pq q W| S(   Ni    (   Rå   Rô   R|   Rz   (   RS   t   sizehintt   totalRf   t   line(    (    s   /usr/lib/python2.7/socket.pyt	   readlines  s    	c         C   s   |  S(   N(    (   RS   (    (    s   /usr/lib/python2.7/socket.pyt   __iter__  s    c         C   s   |  j  É  } | s t Ç n  | S(   N(   Rô   t   StopIteration(   RS   R°   (    (    s   /usr/lib/python2.7/socket.pyt   next  s    	(   RG   RH   Re   Rs   R(   RI   Rt   RX   Ru   Ri   t   closedRZ   Rw   Rv   R/   RÑ   Rä   Rè   Rô   R¢   R£   R•   (    (    (    s   /usr/lib/python2.7/socket.pyR_   Ô   s(   										
Fi	c         C   s   |  \ } } d } x∆ t | | d t É D]Ø } | \ } } }	 }
 } d } yY t | | |	 É } | t k	 rz | j | É n  | rê | j | É n  | j | É | SWq( t k
 r÷ } | } | d k	 r◊ | j	 É  q◊ q( Xq( W| d k	 r | Ç n t d É Ç d S(   sc  Connect to *address* and return the socket object.

    Convenience function.  Connect to *address* (a 2-tuple ``(host,
    port)``) and return the socket object.  Passing the optional
    *timeout* parameter will set the timeout on the socket instance
    before attempting to connect.  If no *timeout* is supplied, the
    global default timeout setting returned by :func:`getdefaulttimeout`
    is used.  If *source_address* is set it must be a tuple of (host, port)
    for the socket to bind as a source address before making the connection.
    A host of '' or port 0 tells the OS to use the default.
    i    s!   getaddrinfo returns an empty listN(
   RN   t   getaddrinfoRh   t   sockett   _GLOBAL_DEFAULT_TIMEOUTR7   R,   R-   R&   RZ   (   t   addresst   timeoutt   source_addresst   hostt   portt   errt   rest   aft   socktypeRV   t	   canonnamet   saR	   t   _(    (    s   /usr/lib/python2.7/socket.pyR     s(    	(<   Re   t   _sockett	   functoolsR   t   typesR   t   _sslt   ImportErrorRN   R   R   t   sslerrorR   R   R   R   R   R   R   R   R   R   R   R   t   ost   sysR   t	   cStringIOR   t   errnoRR   R   R   t   __all__Rà   t   _get_exports_listR®   RO   t   platformt   lowert
   startswithR    R|   R   t   _socketmethodsR(   RP   t   objectRD   RK   Rj   t   _mt   pRG   t   mRQ   t
   SocketTypeR_   R©   R   (    (    (    s   /usr/lib/python2.7/socket.pyt   <module>-   sí   
	L$















,		
ˇ -	                                                                                                                                                                                                                                                                                                    # -*- coding: utf-8 -*-
#
# Secret Labs' Regular Expression Engine
#
# convert template to internal format
#
# Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.
#
# See the sre.py file for information on usage and redistribution.
#

"""Internal support module for sre"""

import _sre, sys
import sre_parse
from sre_constants import *

assert _sre.MAGIC == MAGIC, "SRE module mismatch"

if _sre.CODESIZE == 2:
    MAXCODE = 65535
else:
    MAXCODE = 0xFFFFFFFFL

_LITERAL_CODES = set([LITERAL, NOT_LITERAL])
_REPEATING_CODES = set([REPEAT, MIN_REPEAT, MAX_REPEAT])
_SUCCESS_CODES = set([SUCCESS, FAILURE])
_ASSERT_CODES = set([ASSERT, ASSERT_NOT])

# Sets of lowercase characters which have the same uppercase.
_equivalences = (
    # LATIN SMALL LETTER I, LATIN SMALL LETTER DOTLESS I
    (0x69, 0x131), # iƒ±
    # LATIN SMALL LETTER S, LATIN SMALL LETTER LONG S
    (0x73, 0x17f), # s≈ø
    # MICRO SIGN, GREEK SMALL LETTER MU
    (0xb5, 0x3bc), # ¬µŒº
    # COMBINING GREEK YPOGEGRAMMENI, GREEK SMALL LETTER IOTA, GREEK PROSGEGRAMMENI
    (0x345, 0x3b9, 0x1fbe), # \u0345Œπ·ææ
    # GREEK SMALL LETTER BETA, GREEK BETA SYMBOL
    (0x3b2, 0x3d0), # Œ≤œê
    # GREEK SMALL LETTER EPSILON, GREEK LUNATE EPSILON SYMBOL
    (0x3b5, 0x3f5), # Œµœµ
    # GREEK SMALL LETTER THETA, GREEK THETA SYMBOL
    (0x3b8, 0x3d1), # Œ∏œë
    # GREEK SMALL LETTER KAPPA, GREEK KAPPA SYMBOL
    (0x3ba, 0x3f0), # Œ∫œ∞
    # GREEK SMALL LETTER PI, GREEK PI SYMBOL
    (0x3c0, 0x3d6), # œÄœñ
    # GREEK SMALL LETTER RHO, GREEK RHO SYMBOL
    (0x3c1, 0x3f1), # œÅœ±
    # GREEK SMALL LETTER FINAL SIGMA, GREEK SMALL LETTER SIGMA
    (0x3c2, 0x3c3), # œÇœÉ
    # GREEK SMALL LETTER PHI, GREEK PHI SYMBOL
    (0x3c6, 0x3d5), # œÜœï
    # LATIN SMALL LETTER S WITH DOT ABOVE, LATIN SMALL LETTER LONG S WITH DOT ABOVE
    (0x1e61, 0x1e9b), # ·π°·∫õ
)

# Maps the lowercase code to lowercase codes which have the same uppercase.
_ignorecase_fixes = {i: tuple(j for j in t if i != j)
                     for t in _equivalences for i in t}

def _compile(code, pattern, flags):
    # internal: compile a (sub)pattern
    emit = code.append
    _len = len
    LITERAL_CODES = _LITERAL_CODES
    REPEATING_CODES = _REPEATING_CODES
    SUCCESS_CODES = _SUCCESS_CODES
    ASSERT_CODES = _ASSERT_CODES
    if (flags & SRE_FLAG_IGNORECASE and
            not (flags & SRE_FLAG_LOCALE) and
            flags & SRE_FLAG_UNICODE):
        fixes = _ignorecase_fixes
    else:
        fixes = None
    for op, av in pattern:
        if op in LITERAL_CODES:
            if flags & SRE_FLAG_IGNORECASE:
                lo = _sre.getlower(av, flags)
                if fixes and lo in fixes:
                    emit(OPCODES[IN_IGNORE])
                    skip = _len(code); emit(0)
                    if op is NOT_LITERAL:
                        emit(OPCODES[NEGATE])
                    for k in (lo,) + fixes[lo]:
                        emit(OPCODES[LITERAL])
                        emit(k)
                    emit(OPCODES[FAILURE])
                    code[skip] = _len(code) - skip
                else:
                    emit(OPCODES[OP_IGNORE[op]])
                    emit(lo)
            else:
                emit(OPCODES[op])
                emit(av)
        elif op is IN:
            if flags & SRE_FLAG_IGNORECASE:
                emit(OPCODES[OP_IGNORE[op]])
                def fixup(literal, flags=flags):
                    return _sre.getlower(literal, flags)
            else:
                emit(OPCODES[op])
                fixup = None
            skip = _len(code); emit(0)
            _compile_charset(av, flags, code, fixup, fixes)
            code[skip] = _len(code) - skip
        elif op is ANY:
            if flags & SRE_FLAG_DOTALL:
                emit(OPCODES[ANY_ALL])
            else:
                emit(OPCODES[ANY])
        elif op in REPEATING_CODES:
            if flags & SRE_FLAG_TEMPLATE:
                raise error, "internal: unsupported template operator"
                emit(OPCODES[REPEAT])
                skip = _len(code); emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                emit(OPCODES[SUCCESS])
                code[skip] = _len(code) - skip
            elif _simple(av) and op is not REPEAT:
                if op is MAX_REPEAT:
                    emit(OPCODES[REPEAT_ONE])
                else:
                    emit(OPCODES[MIN_REPEAT_ONE])
                skip = _len(code); emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                emit(OPCODES[SUCCESS])
                code[skip] = _len(code) - skip
            else:
                emit(OPCODES[REPEAT])
                skip = _len(code); emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                code[skip] = _len(code) - skip
                if op is MAX_REPEAT:
                    emit(OPCODES[MAX_UNTIL])
                else:
                    emit(OPCODES[MIN_UNTIL])
        elif op is SUBPATTERN:
            if av[0]:
                emit(OPCODES[MARK])
                emit((av[0]-1)*2)
            # _compile_info(code, av[1], flags)
            _compile(code, av[1], flags)
            if av[0]:
                emit(OPCODES[MARK])
                emit((av[0]-1)*2+1)
        elif op in SUCCESS_CODES:
            emit(OPCODES[op])
        elif op in ASSERT_CODES:
            emit(OPCODES[op])
            skip = _len(code); emit(0)
            if av[0] >= 0:
                emit(0) # look ahead
            else:
                lo, hi = av[1].getwidth()
                if lo != hi:
                    raise error, "look-behind requires fixed-width pattern"
                emit(lo) # look behind
            _compile(code, av[1], flags)
            emit(OPCODES[SUCCESS])
            code[skip] = _len(code) - skip
        elif op is CALL:
            emit(OPCODES[op])
            skip = _len(code); emit(0)
            _compile(code, av, flags)
            emit(OPCODES[SUCCESS])
            code[skip] = _len(code) - skip
        elif op is AT:
            emit(OPCODES[op])
            if flags & SRE_FLAG_MULTILINE:
                av = AT_MULTILINE.get(av, av)
            if flags & SRE_FLAG_LOCALE:
                av = AT_LOCALE.get(av, av)
            elif flags & SRE_FLAG_UNICODE:
                av = AT_UNICODE.get(av, av)
            emit(ATCODES[av])
        elif op is BRANCH:
            emit(OPCODES[op])
            tail = []
            tailappend = tail.append
            for av in av[1]:
                skip = _len(code); emit(0)
                # _compile_info(code, av, flags)
                _compile(code, av, flags)
                emit(OPCODES[JUMP])
                tailappend(_len(code)); emit(0)
                code[skip] = _len(code) - skip
            emit(0) # end of branch
            for tail in tail:
                code[tail] = _len(code) - tail
        elif op is CATEGORY:
            emit(OPCODES[op])
            if flags & SRE_FLAG_LOCALE:
                av = CH_LOCALE[av]
            elif flags & SRE_FLAG_UNICODE:
                av = CH_UNICODE[av]
            emit(CHCODES[av])
        elif op is GROUPREF:
            if flags & SRE_FLAG_IGNORECASE:
                emit(OPCODES[OP_IGNORE[op]])
            else:
                emit(OPCODES[op])
            emit(av-1)
        elif op is GROUPREF_EXISTS:
            emit(OPCODES[op])
            emit(av[0]-1)
            skipyes = _len(code); emit(0)
            _compile(code, av[1], flags)
            if av[2]:
                emit(OPCODES[JUMP])
                skipno = _len(code); emit(0)
                code[skipyes] = _len(code) - skipyes + 1
                _compile(code, av[2], flags)
                code[skipno] = _len(code) - skipno
            else:
                code[skipyes] = _len(code) - skipyes + 1
        else:
            raise ValueError, ("unsupported operand type", op)

def _compile_charset(charset, flags, code, fixup=None, fixes=None):
    # compile charset subprogram
    emit = code.append
    for op, av in _optimize_charset(charset, fixup, fixes,
                                    flags & SRE_FLAG_UNICODE):
        emit(OPCODES[op])
        if op is NEGATE:
            pass
        elif op is LITERAL:
            emit(av)
        elif op is RANGE:
            emit(av[0])
            emit(av[1])
        elif op is CHARSET:
            code.extend(av)
        elif op is BIGCHARSET:
            code.extend(av)
        elif op is CATEGORY:
            if flags & SRE_FLAG_LOCALE:
                emit(CHCODES[CH_LOCALE[av]])
            elif flags & SRE_FLAG_UNICODE:
                emit(CHCODES[CH_UNICODE[av]])
            else:
                emit(CHCODES[av])
        else:
            raise error, "internal: unsupported set operator"
    emit(OPCODES[FAILURE])

def _optimize_charset(charset, fixup, fixes, isunicode):
    # internal: optimize character set
    out = []
    tail = []
    charmap = bytearray(256)
    for op, av in charset:
        while True:
            try:
                if op is LITERAL:
                    if fixup:
                        i = fixup(av)
                        charmap[i] = 1
                        if fixes and i in fixes:
                            for k in fixes[i]:
                                charmap[k] = 1
                    else:
                        charmap[av] = 1
                elif op is RANGE:
                    r = range(av[0], av[1]+1)
                    if fixup:
                        r = map(fixup, r)
                    if fixup and fixes:
                        for i in r:
                            charmap[i] = 1
                            if i in fixes:
                                for k in fixes[i]:
                                    charmap[k] = 1
                    else:
                        for i in r:
                            charmap[i] = 1
                elif op is NEGATE:
                    out.append((op, av))
                else:
                    tail.append((op, av))
            except IndexError:
                if len(charmap) == 256:
                    # character set contains non-UCS1 character codes
                    charmap += b'\0' * 0xff00
                    continue
                # character set contains non-BMP character codes
                if fixup and isunicode and op is RANGE:
                    lo, hi = av
                    ranges = [av]
                    # There are only two ranges of cased astral characters:
                    # 10400-1044F (Deseret) and 118A0-118DF (Warang Citi).
                    _fixup_range(max(0x10000, lo), min(0x11fff, hi),
                                 ranges, fixup)
                    for lo, hi in ranges:
                        if lo == hi:
                            tail.append((LITERAL, hi))
                        else:
                            tail.append((RANGE, (lo, hi)))
                else:
                    tail.append((op, av))
            break

    # compress character map
    runs = []
    q = 0
    while True:
        p = charmap.find(b'\1', q)
        if p < 0:
            break
        if len(runs) >= 2:
            runs = None
            break
        q = charmap.find(b'\0', p)
        if q < 0:
            runs.append((p, len(charmap)))
            break
        runs.append((p, q))
    if runs is not None:
        # use literal/range
        for p, q in runs:
            if q - p == 1:
                out.append((LITERAL, p))
            else:
                out.append((RANGE, (p, q - 1)))
        out += tail
        # if the case was changed or new representation is more compact
        if fixup or len(out) < len(charset):
            return out
        # else original character set is good enough
        return charset

    # use bitmap
    if len(charmap) == 256:
        data = _mk_bitmap(charmap)
        out.append((CHARSET, data))
        out += tail
        return out

    # To represent a big charset, first a bitmap of all characters in the
    # set is constructed. Then, this bitmap is sliced into chunks of 256
    # characters, duplicate chunks are eliminated, and each chunk is
    # given a number. In the compiled expression, the charset is
    # represented by a 32-bit word sequence, consisting of one word for
    # the number of different chunks, a sequence of 256 bytes (64 words)
    # of chunk numbers indexed by their original chunk position, and a
    # sequence of 256-bit chunks (8 words each).

    # Compression is normally good: in a typical charset, large ranges of
    # Unicode will be either completely excluded (e.g. if only cyrillic
    # letters are to be matched), or completely included (e.g. if large
    # subranges of Kanji match). These ranges will be represented by
    # chunks of all one-bits or all zero-bits.

    # Matching can be also done efficiently: the more significant byte of
    # the Unicode character is an index into the chunk number, and the
    # less significant byte is a bit index in the chunk (just like the
    # CHARSET matching).

    # In UCS-4 mode, the BIGCHARSET opcode still supports only subsets
    # of the basic multilingual plane; an efficient representation
    # for all of Unicode has not yet been developed.

    charmap = bytes(charmap) # should be hashable
    comps = {}
    mapping = bytearray(256)
    block = 0
    data = bytearray()
    for i in range(0, 65536, 256):
        chunk = charmap[i: i + 256]
        if chunk in comps:
            mapping[i // 256] = comps[chunk]
        else:
            mapping[i // 256] = comps[chunk] = block
            block += 1
            data += chunk
    data = _mk_bitmap(data)
    data[0:0] = [block] + _bytes_to_codes(mapping)
    out.append((BIGCHARSET, data))
    out += tail
    return out

def _fixup_range(lo, hi, ranges, fixup):
    for i in map(fixup, range(lo, hi+1)):
        for k, (lo, hi) in enumerate(ranges):
            if i < lo:
                if l == lo - 1:
                    ranges[k] = (i, hi)
                else:
                    ranges.insert(k, (i, i))
                break
            elif i > hi:
                if i == hi + 1:
                    ranges[k] = (lo, i)
                    break
            else:
                break
        else:
            ranges.append((i, i))

_CODEBITS = _sre.CODESIZE * 8
_BITS_TRANS = b'0' + b'1' * 255
def _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):
    s = bytes(bits).translate(_BITS_TRANS)[::-1]
    return [_int(s[i - _CODEBITS: i], 2)
            for i in range(len(s), 0, -_CODEBITS)]

def _bytes_to_codes(b):
    # Convert block indices to word array
    import array
    if _sre.CODESIZE == 2:
        code = 'H'
    else:
        code = 'I'
    a = array.array(code, bytes(b))
    assert a.itemsize == _sre.CODESIZE
    assert len(a) * a.itemsize == len(b)
    return a.tolist()

def _simple(av):
    # check if av is a "simple" operator
    lo, hi = av[2].getwidth()
    return lo == hi == 1 and av[2][0][0] != SUBPATTERN

def _compile_info(code, pattern, flags):
    # internal: compile an info block.  in the current version,
    # this contains min/max pattern width, and an optional literal
    # prefix or a character map
    lo, hi = pattern.getwidth()
    if lo == 0:
        return # not worth it
    # look for a literal prefix
    prefix = []
    prefixappend = prefix.append
    prefix_skip = 0
    charset = [] # not used
    charsetappend = charset.append
    if not (flags & SRE_FLAG_IGNORECASE):
        # look for literal prefix
        for op, av in pattern.data:
            if op is LITERAL:
                if len(prefix) == prefix_skip:
                    prefix_skip = prefix_skip + 1
                prefixappend(av)
            elif op is SUBPATTERN and len(av[1]) == 1:
                op, av = av[1][0]
                if op is LITERAL:
                    prefixappend(av)
                else:
                    break
            else:
                break
        # if no prefix, look for charset prefix
        if not prefix and pattern.data:
            op, av = pattern.data[0]
            if op is SUBPATTERN and av[1]:
                op, av = av[1][0]
                if op is LITERAL:
                    charsetappend((op, av))
                elif op is BRANCH:
                    c = []
                    cappend = c.append
                    for p in av[1]:
                        if not p:
                            break
                        op, av = p[0]
                        if op is LITERAL:
                            cappend((op, av))
                        else:
                            break
                    else:
                        charset = c
            elif op is BRANCH:
                c = []
                cappend = c.append
                for p in av[1]:
                    if not p:
                        break
                    op, av = p[0]
                    if op is LITERAL:
                        cappend((op, av))
                    else:
                        break
                else:
                    charset = c
            elif op is IN:
                charset = av
##     if prefix:
##         print "*** PREFIX", prefix, prefix_skip
##     if charset:
##         print "*** CHARSET", charset
    # add an info block
    emit = code.append
    emit(OPCODES[INFO])
    skip = len(code); emit(0)
    # literal flag
    mask = 0
    if prefix:
        mask = SRE_INFO_PREFIX
        if len(prefix) == prefix_skip == len(pattern.data):
            mask = mask + SRE_INFO_LITERAL
    elif charset:
        mask = mask + SRE_INFO_CHARSET
    emit(mask)
    # pattern length
    if lo < MAXCODE:
        emit(lo)
    else:
        emit(MAXCODE)
        prefix = prefix[:MAXCODE]
    if hi < MAXCODE:
        emit(hi)
    else:
        emit(0)
    # add literal prefix
    if prefix:
        emit(len(prefix)) # length
        emit(prefix_skip) # skip
        code.extend(prefix)
        # generate overlap table
        table = [-1] + ([0]*len(prefix))
        for i in xrange(len(prefix)):
            table[i+1] = table[i]+1
            while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
                table[i+1] = table[table[i+1]-1]+1
        code.extend(table[1:]) # don't store first entry
    elif charset:
        _compile_charset(charset, flags, code)
    code[skip] = len(code) - skip

try:
    unicode
except NameError:
    STRING_TYPES = (type(""),)
else:
    STRING_TYPES = (type(""), type(unicode("")))

def isstring(obj):
    for tp in STRING_TYPES:
        if isinstance(obj, tp):
            return 1
    return 0

def _code(p, flags):

    flags = p.pattern.flags | flags
    code = []

    # compile info block
    _compile_info(code, p, flags)

    # compile the pattern
    _compile(code, p.data, flags)

    code.append(OPCODES[SUCCESS])

    return code

def compile(p, flags=0):
    # internal: convert pattern list to internal format

    if isstring(p):
        pattern = p
        p = sre_parse.parse(p, flags)
    else:
        pattern = None

    code = _code(p, flags)

    # print code

    # XXX: <fl> get rid of this limitation!
    if p.pattern.groups > 100:
        raise AssertionError(
            "sorry, but this version only supports 100 named groups"
            )

    # map in either direction
    groupindex = p.pattern.groupdict
    indexgroup = [None] * p.pattern.groups
    for k, i in groupindex.items():
        indexgroup[i] = k

    return _sre.compile(
        pattern, flags | p.pattern.flags, code,
        p.pattern.groups-1,
        groupindex, indexgroup
        )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from _struct import *
from _struct import _clearcache
from _struct import __doc__
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #
# Secret Labs' Regular Expression Engine
#
# various symbols used by the regular expression engine.
# run this script to update the _sre include files!
#
# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
#
# See the sre.py file for information on usage and redistribution.
#

"""Internal support module for sre"""

# update when constants are added or removed

MAGIC = 20031017

try:
    from _sre import MAXREPEAT
except ImportError:
    import _sre
    MAXREPEAT = _sre.MAXREPEAT = 65535

# SRE standard exception (access as sre.error)
# should this really be here?

class error(Exception):
    pass

# operators

FAILURE = "failure"
SUCCESS = "success"

ANY = "any"
ANY_ALL = "any_all"
ASSERT = "assert"
ASSERT_NOT = "assert_not"
AT = "at"
BIGCHARSET = "bigcharset"
BRANCH = "branch"
CALL = "call"
CATEGORY = "category"
CHARSET = "charset"
GROUPREF = "groupref"
GROUPREF_IGNORE = "groupref_ignore"
GROUPREF_EXISTS = "groupref_exists"
IN = "in"
IN_IGNORE = "in_ignore"
INFO = "info"
JUMP = "jump"
LITERAL = "literal"
LITERAL_IGNORE = "literal_ignore"
MARK = "mark"
MAX_REPEAT = "max_repeat"
MAX_UNTIL = "max_until"
MIN_REPEAT = "min_repeat"
MIN_UNTIL = "min_until"
NEGATE = "negate"
NOT_LITERAL = "not_literal"
NOT_LITERAL_IGNORE = "not_literal_ignore"
RANGE = "range"
REPEAT = "repeat"
REPEAT_ONE = "repeat_one"
SUBPATTERN = "subpattern"
MIN_REPEAT_ONE = "min_repeat_one"

# positions
AT_BEGINNING = "at_beginning"
AT_BEGINNING_LINE = "at_beginning_line"
AT_BEGINNING_STRING = "at_beginning_string"
AT_BOUNDARY = "at_boundary"
AT_NON_BOUNDARY = "at_non_boundary"
AT_END = "at_end"
AT_END_LINE = "at_end_line"
AT_END_STRING = "at_end_string"
AT_LOC_BOUNDARY = "at_loc_boundary"
AT_LOC_NON_BOUNDARY = "at_loc_non_boundary"
AT_UNI_BOUNDARY = "at_uni_boundary"
AT_UNI_NON_BOUNDARY = "at_uni_non_boundary"

# categories
CATEGORY_DIGIT = "category_digit"
CATEGORY_NOT_DIGIT = "category_not_digit"
CATEGORY_SPACE = "category_space"
CATEGORY_NOT_SPACE = "category_not_space"
CATEGORY_WORD = "category_word"
CATEGORY_NOT_WORD = "category_not_word"
CATEGORY_LINEBREAK = "category_linebreak"
CATEGORY_NOT_LINEBREAK = "category_not_linebreak"
CATEGORY_LOC_WORD = "category_loc_word"
CATEGORY_LOC_NOT_WORD = "category_loc_not_word"
CATEGORY_UNI_DIGIT = "category_uni_digit"
CATEGORY_UNI_NOT_DIGIT = "category_uni_not_digit"
CATEGORY_UNI_SPACE = "category_uni_space"
CATEGORY_UNI_NOT_SPACE = "category_uni_not_space"
CATEGORY_UNI_WORD = "category_uni_word"
CATEGORY_UNI_NOT_WORD = "category_uni_not_word"
CATEGORY_UNI_LINEBREAK = "category_uni_linebreak"
CATEGORY_UNI_NOT_LINEBREAK = "category_uni_not_linebreak"

OPCODES = [

    # failure=0 success=1 (just because it looks better that way :-)
    FAILURE, SUCCESS,

    ANY, ANY_ALL,
    ASSERT, ASSERT_NOT,
    AT,
    BRANCH,
    CALL,
    CATEGORY,
    CHARSET, BIGCHARSET,
    GROUPREF, GROUPREF_EXISTS, GROUPREF_IGNORE,
    IN, IN_IGNORE,
    INFO,
    JUMP,
    LITERAL, LITERAL_IGNORE,
    MARK,
    MAX_UNTIL,
    MIN_UNTIL,
    NOT_LITERAL, NOT_LITERAL_IGNORE,
    NEGATE,
    RANGE,
    REPEAT,
    REPEAT_ONE,
    SUBPATTERN,
    MIN_REPEAT_ONE

]

ATCODES = [
    AT_BEGINNING, AT_BEGINNING_LINE, AT_BEGINNING_STRING, AT_BOUNDARY,
    AT_NON_BOUNDARY, AT_END, AT_END_LINE, AT_END_STRING,
    AT_LOC_BOUNDARY, AT_LOC_NON_BOUNDARY, AT_UNI_BOUNDARY,
    AT_UNI_NON_BOUNDARY
]

CHCODES = [
    CATEGORY_DIGIT, CATEGORY_NOT_DIGIT, CATEGORY_SPACE,
    CATEGORY_NOT_SPACE, CATEGORY_WORD, CATEGORY_NOT_WORD,
    CATEGORY_LINEBREAK, CATEGORY_NOT_LINEBREAK, CATEGORY_LOC_WORD,
    CATEGORY_LOC_NOT_WORD, CATEGORY_UNI_DIGIT, CATEGORY_UNI_NOT_DIGIT,
    CATEGORY_UNI_SPACE, CATEGORY_UNI_NOT_SPACE, CATEGORY_UNI_WORD,
    CATEGORY_UNI_NOT_WORD, CATEGORY_UNI_LINEBREAK,
    CATEGORY_UNI_NOT_LINEBREAK
]

def makedict(list):
    d = {}
    i = 0
    for item in list:
        d[item] = i
        i = i + 1
    return d

OPCODES = makedict(OPCODES)
ATCODES = makedict(ATCODES)
CHCODES = makedict(CHCODES)

# replacement operations for "ignore case" mode
OP_IGNORE = {
    GROUPREF: GROUPREF_IGNORE,
    IN: IN_IGNORE,
    LITERAL: LITERAL_IGNORE,
    NOT_LITERAL: NOT_LITERAL_IGNORE
}

AT_MULTILINE = {
    AT_BEGINNING: AT_BEGINNING_LINE,
    AT_END: AT_END_LINE
}

AT_LOCALE = {
    AT_BOUNDARY: AT_LOC_BOUNDARY,
    AT_NON_BOUNDARY: AT_LOC_NON_BOUNDARY
}

AT_UNICODE = {
    AT_BOUNDARY: AT_UNI_BOUNDARY,
    AT_NON_BOUNDARY: AT_UNI_NON_BOUNDARY
}

CH_LOCALE = {
    CATEGORY_DIGIT: CATEGORY_DIGIT,
    CATEGORY_NOT_DIGIT: CATEGORY_NOT_DIGIT,
    CATEGORY_SPACE: CATEGORY_SPACE,
    CATEGORY_NOT_SPACE: CATEGORY_NOT_SPACE,
    CATEGORY_WORD: CATEGORY_LOC_WORD,
    CATEGORY_NOT_WORD: CATEGORY_LOC_NOT_WORD,
    CATEGORY_LINEBREAK: CATEGORY_LINEBREAK,
    CATEGORY_NOT_LINEBREAK: CATEGORY_NOT_LINEBREAK
}

CH_UNICODE = {
    CATEGORY_DIGIT: CATEGORY_UNI_DIGIT,
    CATEGORY_NOT_DIGIT: CATEGORY_UNI_NOT_DIGIT,
    CATEGORY_SPACE: CATEGORY_UNI_SPACE,
    CATEGORY_NOT_SPACE: CATEGORY_UNI_NOT_SPACE,
    CATEGORY_WORD: CATEGORY_UNI_WORD,
    CATEGORY_NOT_WORD: CATEGORY_UNI_NOT_WORD,
    CATEGORY_LINEBREAK: CATEGORY_UNI_LINEBREAK,
    CATEGORY_NOT_LINEBREAK: CATEGORY_UNI_NOT_LINEBREAK
}

# flags
SRE_FLAG_TEMPLATE = 1 # template mode (disable backtracking)
SRE_FLAG_IGNORECASE = 2 # case insensitive
SRE_FLAG_LOCALE = 4 # honour system locale
SRE_FLAG_MULTILINE = 8 # treat target as multiline string
SRE_FLAG_DOTALL = 16 # treat target as a single string
SRE_FLAG_UNICODE = 32 # use unicode locale
SRE_FLAG_VERBOSE = 64 # ignore whitespace and comments
SRE_FLAG_DEBUG = 128 # debugging

# flags for INFO primitive
SRE_INFO_PREFIX = 1 # has prefix
SRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)
SRE_INFO_CHARSET = 4 # pattern starts with character from given set

if __name__ == "__main__":
    def dump(f, d, prefix):
        items = d.items()
        items.sort(key=lambda a: a[1])
        for k, v in items:
            f.write("#define %s_%s %s\n" % (prefix, k.upper(), v))
    f = open("sre_constants.h", "w")
    f.write("""\
/*
 * Secret Labs' Regular Expression Engine
 *
 * regular expression matching engine
 *
 * NOTE: This file is generated by sre_constants.py.  If you need
 * to change anything in here, edit sre_constants.py and run it.
 *
 * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.
 *
 * See the _sre.c file for information on usage and redistribution.
 */

""")

    f.write("#define SRE_MAGIC %d\n" % MAGIC)

    dump(f, OPCODES, "SRE_OP")
    dump(f, ATCODES, "SRE")
    dump(f, CHCODES, "SRE")

    f.write("#define SRE_FLAG_TEMPLATE %d\n" % SRE_FLAG_TEMPLATE)
    f.write("#define SRE_FLAG_IGNORECASE %d\n" % SRE_FLAG_IGNORECASE)
    f.write("#define SRE_FLAG_LOCALE %d\n" % SRE_FLAG_LOCALE)
    f.write("#define SRE_FLAG_MULTILINE %d\n" % SRE_FLAG_MULTILINE)
    f.write("#define SRE_FLAG_DOTALL %d\n" % SRE_FLAG_DOTALL)
    f.write("#define SRE_FLAG_UNICODE %d\n" % SRE_FLAG_UNICODE)
    f.write("#define SRE_FLAG_VERBOSE %d\n" % SRE_FLAG_VERBOSE)

    f.write("#define SRE_INFO_PREFIX %d\n" % SRE_INFO_PREFIX)
    f.write("#define SRE_INFO_LITERAL %d\n" % SRE_INFO_LITERAL)
    f.write("#define SRE_INFO_CHARSET %d\n" % SRE_INFO_CHARSET)

    f.close()
    print "done"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   sœ  d  Z  d d l Z d d l Z d d l Z d d l Te j e k sO t d É Ç e j d k rg d Z n d Z e	 e
 e g É Z e	 e e e g É Z e	 e e g É Z e	 e e g É Z d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA f Z d# Ñ  e DÉ Z d$ Ñ  Z d d d% Ñ Z d& Ñ  Z d' Ñ  Z e j d( Z d) d* d+ Z e e  d, Ñ Z! d- Ñ  Z" d. Ñ  Z# d/ Ñ  Z$ y e% Wn  e& k
 rée' d0 É f Z( n Xe' d0 É e' e% d0 É É f Z( d1 Ñ  Z) d2 Ñ  Z* d3 d4 Ñ Z+ d S(B   s   Internal support module for sreiˇˇˇˇN(   t   *s   SRE module mismatchi   iˇˇ  l   ˇˇ ii   i1  is   i  iµ   iº  iE  iπ  iæ  i≤  i–  iµ  iı  i∏  i—  i∫  i  i¿  i÷  i¡  iÒ  i¬  i√  i∆  i’  ia  iõ  c            s<   i  |  ]2 } | D]% â  t  á  f d  Ü  | DÉ É à  ì q q S(   c         3   s!   |  ] } à  | k r | Vq d  S(   N(    (   t   .0t   j(   t   i(    s!   /usr/lib/python2.7/sre_compile.pys	   <genexpr>=   s    (   t   tuple(   R   t   t(    (   R   s!   /usr/lib/python2.7/sre_compile.pys
   <dictcomp>=   s   	c         C   s◊  |  j  } t } t } t } t } t } | t @rO | t @rO | t @rO t	 }	 n d  }	 x{| D]s\ }
 } |
 | k rv| t @r[t j | | É } |	 r<| |	 k r<| t t É | |  É } | d É |
 t k r„ | t t É n  x1 | f |	 | D] } | t t É | | É qı W| t t É | |  É | |  | <qs| t t |
 É | | É qœ| t |
 É | | É q\ |
 t k r| t @r≠| t t |
 É | d Ñ } n | t |
 É d  } | |  É } | d É t | | |  | |	 É | |  É | |  | <q\ |
 t k r<| t @r+| t t É qœ| t t É q\ |
 | k r| t @r‘t d Ç | t t É | |  É } | d É | | d É | | d É t |  | d | É | t t É | |  É | |  | <qœt | É rÇ|
 t k	 rÇ|
 t k r	| t t  É n | t t! É | |  É } | d É | | d É | | d É t |  | d | É | t t É | |  É | |  | <qœ| t t É | |  É } | d É | | d É | | d É t |  | d | É | |  É | |  | <|
 t k r| t t" É qœ| t t# É q\ |
 t$ k r°| d rU| t t% É | | d d d É n  t |  | d | É | d rœ| t t% É | | d d d d É qœq\ |
 | k ræ| t |
 É q\ |
 | k r|| t |
 É | |  É } | d É | d d k r| d É n8 | d j& É  \ } } | | k r9t d Ç n  | | É t |  | d | É | t t É | |  É | |  | <q\ |
 t' k r·| t |
 É | |  É } | d É t |  | | É | t t É | |  É | |  | <q\ |
 t( k ri| t |
 É | t) @rt* j+ | | É } n  | t @r9t, j+ | | É } n | t @rXt- j+ | | É } n  | t. | É q\ |
 t/ k r;| t |
 É g  } | j  } xt | d D]h } | |  É } | d É t |  | | É | t t0 É | | |  É É | d É | |  É | |  | <qùW| d É xπ| D] } | |  É | |  | <qWq\ |
 t1 k rî| t |
 É | t @rlt2 | } n | t @rÉt3 | } n  | t4 | É q\ |
 t5 k rﬁ| t @rø| t t |
 É n | t |
 É | | d É q\ |
 t6 k r¿| t |
 É | | d d É | |  É } | d É t |  | d | É | d r•| t t0 É | |  É } | d É | |  É | d |  | <t |  | d | É | |  É | |  | <qœ| |  É | d |  | <q\ t7 d |
 f Ç q\ Wd  S(   Ni    c         S   s   t  j |  | É S(   N(   t   _sret   getlower(   t   literalt   flags(    (    s!   /usr/lib/python2.7/sre_compile.pyt   fixupe   s    s'   internal: unsupported template operatori   i   s(   look-behind requires fixed-width patterns   unsupported operand type(8   t   appendt   lent   _LITERAL_CODESt   _REPEATING_CODESt   _SUCCESS_CODESt   _ASSERT_CODESt   SRE_FLAG_IGNORECASEt   SRE_FLAG_LOCALEt   SRE_FLAG_UNICODEt   _ignorecase_fixest   NoneR   R   t   OPCODESt	   IN_IGNOREt   NOT_LITERALt   NEGATEt   LITERALt   FAILUREt	   OP_IGNOREt   INt   _compile_charsett   ANYt   SRE_FLAG_DOTALLt   ANY_ALLt   SRE_FLAG_TEMPLATEt   errort   REPEATt   _compilet   SUCCESSt   _simplet
   MAX_REPEATt
   REPEAT_ONEt   MIN_REPEAT_ONEt	   MAX_UNTILt	   MIN_UNTILt
   SUBPATTERNt   MARKt   getwidtht   CALLt   ATt   SRE_FLAG_MULTILINEt   AT_MULTILINEt   gett	   AT_LOCALEt
   AT_UNICODEt   ATCODESt   BRANCHt   JUMPt   CATEGORYt	   CH_LOCALEt
   CH_UNICODEt   CHCODESt   GROUPREFt   GROUPREF_EXISTSt
   ValueError(   t   codet   patternR	   t   emitt   _lent   LITERAL_CODESt   REPEATING_CODESt   SUCCESS_CODESt   ASSERT_CODESt   fixest   opt   avt   lot   skipt   kR
   t   hit   tailt
   tailappendt   skipyest   skipno(    (    s!   /usr/lib/python2.7/sre_compile.pyR%   @   s:   	

	
 

 


	 
 
 


  

 



	 
 




 

 
c         C   sB  | j  } x$t |  | | | t @É D]	\ } } | t | É | t k rL q# | t k re | | É q# | t k rê | | d É | | d É q# | t k r¨ | j | É q# | t	 k r» | j | É q# | t
 k r#| t @rÛ | t t | É q,| t @r| t t | É q,| t | É q# t d Ç q# W| t t É d  S(   Ni    i   s"   internal: unsupported set operator(   R   t   _optimize_charsetR   R   R   R   t   RANGEt   CHARSETt   extendt
   BIGCHARSETR:   R   R=   R;   R<   R#   R   (   t   charsetR	   RA   R
   RI   RC   RJ   RK   (    (    s!   /usr/lib/python2.7/sre_compile.pyR   ‰   s.    	

c         C   sÚ  g  } g  } t  d É } xp|  D]h\ } } xYt rÜyZ| t k r£ | rñ | | É }	 d | |	 <| r† |	 | k r† x | |	 D] }
 d | |
 <q| Wq† qçd | | <nÍ | t k rXt | d | d d É } | r‚ t | | É } n  | r:| r:xd | D]> }	 d | |	 <|	 | k rı x | |	 D] }
 d | |
 <qWqı qı WqçxP | D] }	 d | |	 <qAWn5 | t k rz| j | | f É n | j | | f É WnÒ t k
 rÅt	 | É d k rƒ| d d 7} q. n  | rk| rk| t k rk| \ } } | g } t
 t d | É t d | É | | É xe | D]G \ } } | | k rK| j t | f É q| j t | | f f É qWqÇ| j | | f É n XPq. Wq Wg  } d } xñ t r/| j d | É } | d k  r¬Pn  t	 | É d	 k rﬁd  } Pn  | j d | É } | d k  r| j | t	 | É f É Pn  | j | | f É qöW| d  k	 r∆xW | D]O \ } } | | d k ru| j t | f É qC| j t | | d f f É qCW| | 7} | sæt	 | É t	 |  É k  r¬| S|  St	 | É d k rt | É } | j t | f É | | 7} | St | É } i  } t  d É } d } t  É  } xv t d d d É D]b }	 | |	 |	 d !} | | k r}| | | |	 d <qE| | |	 d <| | <| d 7} | | 7} qEWt | É } | g t | É | d d +| j t | f É | | 7} | S(
   Ni   i   i    s    i ˇ  i   iˇ s   i   (   t	   bytearrayt   TrueR   RU   t   ranget   mapR   R   t
   IndexErrorR   t   _fixup_ranget   maxt   mint   findR   t
   _mk_bitmapRV   t   bytest   _bytes_to_codesRX   (   RY   R
   RI   t	   isunicodet   outRP   t   charmapRJ   RK   R   RN   t   rRL   RO   t   rangest   runst   qt   pt   datat   compst   mappingt   blockt   chunk(    (    s!   /usr/lib/python2.7/sre_compile.pyRT      s≤    	

	
 		!

	

c         C   sﬁ   x◊ t  | t |  | d É É D]π } x∞ t | É D]è \ } \ }  } | |  k  rã t |  d k rq | | f | | <n | j | | | f É Pq0 | | k ræ | | d k rø |  | f | | <Pqø q0 Pq0 W| j | | f É q Wd  S(   Ni   (   R]   R\   t	   enumeratet   lt   insertR   (   RL   RO   Rj   R
   R   RN   (    (    s!   /usr/lib/python2.7/sre_compile.pyR_   á  s    #i   t   0t   1iˇ   c         C   s`   t  |  É j t É d  d  d Ö } g  t t | É d | É D]  } | | | | | !d É ^ q< S(   Niˇˇˇˇi    i   (   Rd   t	   translatet   _BITS_TRANSR\   R   (   t   bitst	   _CODEBITSt   _intt   sR   (    (    s!   /usr/lib/python2.7/sre_compile.pyRc   õ  s    "c         C   sâ   d d  l  } t j d k r$ d } n d } | j  | t |  É É } | j t j k sZ t Ç t | É | j t |  É k s t Ç | j É  S(   Niˇˇˇˇi   t   Ht   I(   t   arrayR   t   CODESIZERd   t   itemsizet   AssertionErrorR   t   tolist(   t   bRÄ   RA   t   a(    (    s!   /usr/lib/python2.7/sre_compile.pyRe   †  s    	%c         C   sH   |  d j  É  \ } } | | k o- d k n oG |  d d d t k S(   Ni   i   i    (   R/   R-   (   RK   RL   RO   (    (    s!   /usr/lib/python2.7/sre_compile.pyR'   ¨  s    c         C   si  | j  É  \ } } | d k r" d  Sg  } | j } d } g  } | j }	 | t @sfx£ | j D]ò \ }
 } |
 t k rû t | É | k rë | d } n  | | É qZ |
 t k rÒ t | d É d k rÒ | d d \ }
 } |
 t k rÌ | | É qÚ PqZ PqZ W| rf| j rf| j d \ }
 } |
 t k rÿ| d rÿ| d d \ }
 } |
 t k rb|	 |
 | f É q`|
 t k r`g  } | j } xU | d D]@ } | sòPn  | d \ }
 } |
 t k r«| |
 | f É qàPqàW| } q`qc|
 t k rKg  } | j } xj | d D]@ } | sPn  | d \ }
 } |
 t k r=| |
 | f É q˛Pq˛W| } qc|
 t k rc| } qcqfn  |  j } | t	 t
 É t |  É } | d É d } | r‡t } t | É | k oÀt | j É k n rÛ| t } qÛn | rÛ| t } n  | | É | t k  r| | É n | t É | t  } | t k  rC| | É n
 | d É | r8| t | É É | | É |  j | É d g d g t | É } xç t t | É É D]y } | | d | | d <xZ | | d d k r| | | | | d d k r| | | d d d | | d <q∆WqßW|  j | d É n | rQt | | |  É n  t |  É | |  | <d  S(   Ni    i   iˇˇˇˇ(   R/   R   R   Rn   R   R   R-   R8   R   R   t   INFOt   SRE_INFO_PREFIXt   SRE_INFO_LITERALt   SRE_INFO_CHARSETt   MAXCODERW   t   xrangeR   (   RA   RB   R	   RL   RO   t   prefixt   prefixappendt   prefix_skipRY   t   charsetappendRJ   RK   t   ct   cappendRm   RC   RM   t   maskt   tableR   (    (    s!   /usr/lib/python2.7/sre_compile.pyt   _compile_info±  s§    		
"				 
+




7*t    c         C   s(   x! t  D] } t |  | É r d Sq Wd S(   Ni   i    (   t   STRING_TYPESt
   isinstance(   t   objt   tp(    (    s!   /usr/lib/python2.7/sre_compile.pyt   isstring"  s    c         C   sN   |  j  j | B} g  } t | |  | É t | |  j | É | j t t É | S(   N(   RB   R	   Rï   R%   Rn   R   R   R&   (   Rm   R	   RA   (    (    s!   /usr/lib/python2.7/sre_compile.pyt   _code(  s    i    c         C   s”   t  |  É r' |  } t j |  | É }  n d  } t |  | É } |  j j d k r] t d É Ç n  |  j j } d  g |  j j } x$ | j	 É  D] \ } } | | | <qâ Wt
 j | | |  j j B| |  j j d | | É S(   Nid   s6   sorry, but this version only supports 100 named groupsi   (   Rõ   t	   sre_parset   parseR   Rú   RB   t   groupsRÉ   t	   groupdictt   itemsR   t   compileR	   (   Rm   R	   RB   RA   t
   groupindext
   indexgroupRN   R   (    (    s!   /usr/lib/python2.7/sre_compile.pyR¢   7  s     (   ii   i1  (   is   i  (   iµ   iº  (   iE  iπ  iæ  (   i≤  i–  (   iµ  iı  (   i∏  i—  (   i∫  i  (   i¿  i÷  (   i¡  iÒ  (   i¬  i√  (   i∆  i’  (   ia  iõ  (,   t   __doc__R   t   sysRù   t   sre_constantst   MAGICRÉ   RÅ   Rã   t   setR   R   R   R$   t
   MIN_REPEATR(   R   R&   R   R   t   ASSERTt
   ASSERT_NOTR   t   _equivalencesR   R%   R   R   RT   R_   R{   Ry   t   intRc   Re   R'   Rï   t   unicodet	   NameErrort   typeRó   Rõ   Rú   R¢   (    (    (    s!   /usr/lib/python2.7/sre_compile.pyt   <module>   sX   
		
	§	á				j		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               