berrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 15:19:22 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 15:19:22 raspberrypi dhcpcd[354]: eth0: leased 131.174.12.254 for 49397 seconds
Jun 12 15:19:22 raspberrypi dhcpcd[354]: eth0: adding route to 131.174.12.0/24
Jun 12 15:19:22 raspberrypi dhcpcd[354]: eth0: adding default route via 131.174.12.1
Jun 12 15:19:22 raspberrypi avahi-daemon[346]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.12.254.
Jun 12 15:19:22 raspberrypi avahi-daemon[346]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 15:19:22 raspberrypi avahi-daemon[346]: Registering new address record for 131.174.12.254 on eth0.IPv4.
Jun 12 15:19:22 raspberrypi bluetoothd[482]: Bluetooth daemon 5.43
Jun 12 15:19:22 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 15:19:22 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 15:19:22 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 15:19:22 raspberrypi bluetoothd[482]: Starting SDP server
Jun 12 15:19:22 raspberrypi dbus[327]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 15:19:22 raspberrypi bluetoothd[482]: Bluetooth management interface 1.14 initialized
Jun 12 15:19:22 raspberrypi bluetoothd[482]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 15:19:22 raspberrypi bluetoothd[482]: Sap driver initialization failed.
Jun 12 15:19:22 raspberrypi bluetoothd[482]: sap-server: Operation not permitted (1)
Jun 12 15:19:22 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 15:19:22 raspberrypi dhcpcd[354]: Too few arguments.
Jun 12 15:19:22 raspberrypi bluetoothd[482]: Failed to set privacy: Rejected (0x0b)
Jun 12 15:19:23 raspberrypi dhcpcd[354]: Too few arguments.
Jun 12 15:19:23 raspberrypi dhcpcd[354]: Failed to get unit file state for ntp.service: No such file or directory
Jun 12 15:19:23 raspberrypi dhcpcd[354]: forked to background, child pid 549
Jun 12 15:19:23 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 15:19:23 raspberrypi systemd[1]: Reached target Network.
Jun 12 15:19:23 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 15:19:23 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 15:19:23 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 15:19:23 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 15:19:23 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 15:19:23 raspberrypi dbus[327]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 15:19:23 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 15:19:23 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 15:19:23 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 15:19:24 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 15:19:24 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 15:19:24 raspberrypi systemd[1]: smbd.service: Supervising process 596 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:19:25 raspberrypi dhcpcd[549]: wlan0: leased 192.168.1.231 for 86400 seconds
Jun 12 15:19:25 raspberrypi avahi-daemon[346]: Joining mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.231.
Jun 12 15:19:25 raspberrypi avahi-daemon[346]: New relevant interface wlan0.IPv4 for mDNS.
Jun 12 15:19:25 raspberrypi avahi-daemon[346]: Registering new address record for 192.168.1.231 on wlan0.IPv4.
Jun 12 15:19:25 raspberrypi dhcpcd[549]: wlan0: adding route to 192.168.1.0/24
Jun 12 15:19:25 raspberrypi dhcpcd[549]: wlan0: adding default route via 192.168.1.1
Jun 12 15:19:25 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 15:19:29 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 15:19:29 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 15:19:29 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 15:19:29 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 210 (plymouthd).
Jun 12 15:19:29 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 15:19:29 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 15:19:29 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 15:19:29 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 15:19:29 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 15:19:29 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 15:19:29 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 15:19:29 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 15:19:29 raspberrypi systemd[1]: Startup finished in 2.075s (kernel) + 17.627s (userspace) = 19.702s.
Jun 12 15:19:29 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 15:19:29 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 15:19:29 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 15:19:29 raspberrypi systemd[692]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 15:19:29 raspberrypi systemd[692]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 15:19:29 raspberrypi systemd[692]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 15:19:29 raspberrypi systemd[692]: Reached target Paths.
Jun 12 15:19:29 raspberrypi systemd[692]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 15:19:29 raspberrypi systemd[692]: Reached target Sockets.
Jun 12 15:19:29 raspberrypi systemd[692]: Reached target Timers.
Jun 12 15:19:29 raspberrypi systemd[692]: Reached target Basic System.
Jun 12 15:19:29 raspberrypi systemd[692]: Reached target Default.
Jun 12 15:19:29 raspberrypi systemd[692]: Startup finished in 105ms.
Jun 12 15:19:29 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 15:19:30 raspberrypi dhcpcd[549]: eth0: no IPv6 Routers available
Jun 12 15:19:33 raspberrypi dhcpcd[549]: wlan0: no IPv6 Routers available
Jun 12 15:19:53 raspberrypi systemd[692]: Time has been changed
Jun 12 15:19:53 raspberrypi systemd[1]: Time has been changed
Jun 12 15:19:53 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 16min 23.182809s random time.
Jun 12 15:19:53 raspberrypi systemd[1]: apt-daily.timer: Adding 7h 49min 49.320647s random time.
Jun 12 15:20:25 raspberrypi systemd[1]: Started Session c2 of user root.
Jun 12 15:20:27 raspberrypi systemd[1]: Stopped target Graphical Interface.
Jun 12 15:20:27 raspberrypi systemd[1]: Stopped target Sound Card.
Jun 12 15:20:27 raspberrypi systemd[1]: Closed Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 15:20:27 raspberrypi systemd[1]: Stopped target Bluetooth.
Jun 12 15:20:27 raspberrypi bluetoothd[482]: Terminating
Jun 12 15:20:27 raspberrypi systemd[1]: Stopping Bluetooth service...
Jun 12 15:20:27 raspberrypi systemd[1]: Stopped target Multi-User System.
Jun 12 15:20:27 raspberrypi bluetoothd[482]: Stopping SDP server
Jun 12 15:20:27 raspberrypi bluetoothd[482]: Exit
Jun 12 15:20:31 raspberrypi fake-hwclock[129]: Wed 12 Jun 13:20:29 UTC 2019
Jun 12 15:20:31 raspberrypi systemd[1]: Started Create list of required static device nodes for the current kernel.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Load Kernel Modules.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Restore / save the current clock.
Jun 12 15:20:31 raspberrypi systemd[1]: Time has been changed
Jun 12 15:20:31 raspberrypi systemd[1]: Starting File System Check on Root Device...
Jun 12 15:20:31 raspberrypi systemd[1]: Mounting Configuration File System...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Apply Kernel Variables...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Create Static Device Nodes in /dev...
Jun 12 15:20:31 raspberrypi systemd[1]: Mounted Configuration File System.
Jun 12 15:20:31 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 15:20:31 raspberrypi systemd-fsck[139]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 15:20:31 raspberrypi systemd-fsck[139]: rootfs: clean, 53734/451232 files, 412595/1904384 blocks
Jun 12 15:20:31 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 15:20:31 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 15:20:31 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 15:20:31 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 15:20:31 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 15:20:31 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 207 (plymouthd).
Jun 12 15:20:31 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Paths.
Jun 12 15:20:31 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 15:20:31 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 15:20:31 raspberrypi systemd-fsck[236]: fsck.fat 4.1 (2017-01-24)
Jun 12 15:20:31 raspberrypi systemd-fsck[236]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 15:20:31 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 15:20:31 raspberrypi systemd[1]: Mounting /boot...
Jun 12 15:20:31 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 15:20:31 raspberrypi systemd[1]: Mounted /boot.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 15:20:31 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 15:20:31 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 15:20:31 raspberrypi systemd[1]: apt-daily.timer: Adding 1h 24min 27.842000s random time.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 15:20:31 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 1min 51.057873s random time.
Jun 12 15:20:31 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 15:20:31 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 15:20:31 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 15:20:31 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 15:20:31 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Login Service...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 15:20:31 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 15:20:31 raspberrypi thd[346]: Found socket passed from systemd
Jun 12 15:20:31 raspberrypi rngd[372]: rngd 2-unofficial-mt.14 starting up...
Jun 12 15:20:31 raspberrypi rng-tools[354]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 15:20:31 raspberrypi rngd[372]: entropy feed to the kernel ready
Jun 12 15:20:31 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 15:20:31 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 15:20:31 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 15:20:31 raspberrypi systemd[1]: Reached target Timers.
Jun 12 15:20:31 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 15:20:31 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 15:20:31 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 15:20:32 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 15:20:32 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 15:20:32 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 15:20:32 raspberrypi avahi-daemon[384]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 15:20:32 raspberrypi avahi-daemon[384]: Successfully dropped root privileges.
Jun 12 15:20:32 raspberrypi avahi-daemon[384]: avahi-daemon 0.6.32 starting up.
Jun 12 15:20:32 raspberrypi dhcpcd[386]: dev: loaded udev
Jun 12 15:20:32 raspberrypi avahi-daemon[384]: Successfully called chroot().
Jun 12 15:20:32 raspberrypi avahi-daemon[384]: Successfully dropped remaining capabilities.
Jun 12 15:20:32 raspberrypi wpa_supplicant[382]: Successfully initialized wpa_supplicant
Jun 12 15:20:32 raspberrypi avahi-daemon[384]: No service file found in /etc/avahi/services.
Jun 12 15:20:32 raspberrypi avahi-daemon[384]: Network interface enumeration completed.
Jun 12 15:20:32 raspberrypi avahi-daemon[384]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 2512111573.
Jun 12 15:20:32 raspberrypi dphys-swapfile[344]: Starting dphys-swapfile swapfile setup ...
Jun 12 15:20:32 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 15:20:32 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 15:20:32 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 15:20:32 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 15:20:32 raspberrypi raspi-config[389]: Checking if shift key is held down:Error opening '/dev/input/event*': No such file or directory
Jun 12 15:20:32 raspberrypi systemd[1]: Started Login Service.
Jun 12 15:20:32 raspberrypi raspi-config[389]:  No. Switching to ondemand scaling governor.
Jun 12 15:20:32 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 15:20:32 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 15:20:32 raspberrypi dhcpcd[386]: wlan0: starting wpa_supplicant
Jun 12 15:20:32 raspberrypi dhcpcd-run-hooks[437]: wlan0: starting wpa_supplicant
Jun 12 15:20:32 raspberrypi dphys-swapfile[344]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 15:20:32 raspberrypi gpm[343]: Starting mouse interface server: gpm.
Jun 12 15:20:32 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 15:20:32 raspberrypi dphys-swapfile[344]: done.
Jun 12 15:20:32 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 15:20:32 raspberrypi dhcpcd[386]: eth0: waiting for carrier
Jun 12 15:20:32 raspberrypi dhcpcd[386]: wlan0: waiting for carrier
Jun 12 15:20:32 raspberrypi dhcpcd[386]: wlan0: carrier acquired
Jun 12 15:20:32 raspberrypi dhcpcd[386]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 15:20:32 raspberrypi dhcpcd[386]: wlan0: IAID eb:de:05:30
Jun 12 15:20:32 raspberrypi dhcpcd[386]: wlan0: adding address fe80::690e:a875:9ced:b218
Jun 12 15:20:32 raspberrypi dhcpcd[386]: wlan0: carrier lost
Jun 12 15:20:32 raspberrypi dhcpcd[386]: wlan0: deleting address fe80::690e:a875:9ced:b218
Jun 12 15:20:32 raspberrypi dhcpcd[386]: eth0: carrier acquired
Jun 12 15:20:33 raspberrypi dhcpcd[386]: eth0: IAID eb:8b:50:65
Jun 12 15:20:33 raspberrypi dhcpcd[386]: eth0: adding address fe80::99bd:84fe:733:8d76
Jun 12 15:20:33 raspberrypi dhcpcd[386]: eth0: soliciting an IPv6 router
Jun 12 15:20:33 raspberrypi dhcpcd[386]: eth0: rebinding lease of 131.174.12.254
Jun 12 15:20:33 raspberrypi dhcpcd[386]: eth0: probing address 131.174.12.254/24
Jun 12 15:20:34 raspberrypi avahi-daemon[384]: Joining mDNS multicast group on interface eth0.IPv6 with address fe80::99bd:84fe:733:8d76.
Jun 12 15:20:34 raspberrypi avahi-daemon[384]: New relevant interface eth0.IPv6 for mDNS.
Jun 12 15:20:34 raspberrypi avahi-daemon[384]: Registering new address record for fe80::99bd:84fe:733:8d76 on eth0.*.
Jun 12 15:20:35 raspberrypi dhcpcd[386]: wlan0: carrier acquired
Jun 12 15:20:35 raspberrypi dhcpcd[386]: wlan0: IAID eb:de:05:30
Jun 12 15:20:35 raspberrypi dhcpcd[386]: wlan0: adding address fe80::6992:1a45:7092:72a6
Jun 12 15:20:36 raspberrypi dhcpcd[386]: wlan0: rebinding lease of 192.168.1.231
Jun 12 15:20:36 raspberrypi dhcpcd[386]: wlan0: probing address 192.168.1.231/24
Jun 12 15:20:36 raspberrypi dhcpcd[386]: wlan0: soliciting an IPv6 router
Jun 12 15:20:37 raspberrypi avahi-daemon[384]: Joining mDNS multicast group on interface wlan0.IPv6 with address fe80::6992:1a45:7092:72a6.
Jun 12 15:20:37 raspberrypi avahi-daemon[384]: New relevant interface wlan0.IPv6 for mDNS.
Jun 12 15:20:37 raspberrypi avahi-daemon[384]: Registering new address record for fe80::6992:1a45:7092:72a6 on wlan0.*.
Jun 12 15:20:38 raspberrypi btuart[348]: bcm43xx_init
Jun 12 15:20:38 raspberrypi btuart[348]: Flash firmware /lib/firmware/brcm/BCM4345C0.hcd
Jun 12 15:20:38 raspberrypi btuart[348]: Set BDADDR UART: b8:27:eb:21:fa:cf
Jun 12 15:20:38 raspberrypi btuart[348]: Set Controller UART speed to 3000000 bit/s
Jun 12 15:20:38 raspberrypi btuart[348]: Device setup complete
Jun 12 15:20:38 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 15:20:38 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 15:20:38 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 15:20:38 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 15:20:38 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 15:20:38 raspberrypi bluetoothd[482]: Bluetooth daemon 5.43
Jun 12 15:20:38 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 15:20:38 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 15:20:38 raspberrypi bluetoothd[482]: Starting SDP server
Jun 12 15:20:38 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 15:20:38 raspberrypi dbus[356]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 15:20:38 raspberrypi bluetoothd[482]: Bluetooth management interface 1.14 initialized
Jun 12 15:20:38 raspberrypi bluetoothd[482]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 15:20:38 raspberrypi bluetoothd[482]: Sap driver initialization failed.
Jun 12 15:20:38 raspberrypi bluetoothd[482]: sap-server: Operation not permitted (1)
Jun 12 15:20:38 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 15:20:38 raspberrypi dhcpcd[386]: eth0: leased 131.174.12.254 for 49923 seconds
Jun 12 15:20:38 raspberrypi avahi-daemon[384]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.12.254.
Jun 12 15:20:38 raspberrypi avahi-daemon[384]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 15:20:38 raspberrypi dhcpcd[386]: eth0: adding route to 131.174.12.0/24
Jun 12 15:20:38 raspberrypi avahi-daemon[384]: Registering new address record for 131.174.12.254 on eth0.IPv4.
Jun 12 15:20:38 raspberrypi dhcpcd[386]: eth0: adding default route via 131.174.12.1
Jun 12 15:20:38 raspberrypi bluetoothd[482]: Failed to set privacy: Rejected (0x0b)
Jun 12 15:20:38 raspberrypi dbus[356]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 15:20:38 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 15:20:38 raspberrypi dhcpcd[386]: Too few arguments.
Jun 12 15:20:38 raspberrypi dhcpcd[386]: Too few arguments.
Jun 12 15:20:38 raspberrypi dhcpcd[386]: Failed to get unit file state for ntp.service: No such file or directory
Jun 12 15:20:38 raspberrypi dhcpcd[386]: forked to background, child pid 549
Jun 12 15:20:38 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 15:20:38 raspberrypi systemd[1]: Reached target Network.
Jun 12 15:20:39 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 15:20:39 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 15:20:39 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 15:20:39 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 15:20:39 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 15:20:39 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 15:20:39 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 15:20:40 raspberrypi systemd[1]: nmbd.service: Supervising process 590 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:20:40 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 15:20:40 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 15:20:40 raspberrypi systemd[1]: smbd.service: Supervising process 592 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:20:41 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 15:20:41 raspberrypi dhcpcd[549]: wlan0: leased 192.168.1.231 for 86400 seconds
Jun 12 15:20:41 raspberrypi avahi-daemon[384]: Joining mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.231.
Jun 12 15:20:41 raspberrypi avahi-daemon[384]: New relevant interface wlan0.IPv4 for mDNS.
Jun 12 15:20:41 raspberrypi avahi-daemon[384]: Registering new address record for 192.168.1.231 on wlan0.IPv4.
Jun 12 15:20:41 raspberrypi dhcpcd[549]: wlan0: adding route to 192.168.1.0/24
Jun 12 15:20:41 raspberrypi dhcpcd[549]: wlan0: adding default route via 192.168.1.1
Jun 12 15:20:44 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 15:20:44 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 15:20:44 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 15:20:44 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 207 (plymouthd).
Jun 12 15:20:44 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 15:20:44 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 15:20:44 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 15:20:44 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 15:20:44 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 15:20:44 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 15:20:44 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 15:20:45 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 15:20:45 raspberrypi systemd[1]: Startup finished in 2.090s (kernel) + 17.492s (userspace) = 19.583s.
Jun 12 15:20:45 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 15:20:45 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 15:20:45 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 15:20:45 raspberrypi systemd[688]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 15:20:45 raspberrypi systemd[688]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 15:20:45 raspberrypi systemd[688]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 15:20:45 raspberrypi systemd[688]: Reached target Paths.
Jun 12 15:20:45 raspberrypi systemd[688]: Reached target Timers.
Jun 12 15:20:45 raspberrypi systemd[688]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 15:20:45 raspberrypi systemd[688]: Reached target Sockets.
Jun 12 15:20:45 raspberrypi systemd[688]: Reached target Basic System.
Jun 12 15:20:45 raspberrypi systemd[688]: Reached target Default.
Jun 12 15:20:45 raspberrypi systemd[688]: Startup finished in 110ms.
Jun 12 15:20:45 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 15:20:46 raspberrypi dhcpcd[549]: eth0: no IPv6 Routers available
Jun 12 15:20:49 raspberrypi dhcpcd[549]: wlan0: no IPv6 Routers available
Jun 12 15:21:10 raspberrypi systemd[1]: Time has been changed
Jun 12 15:21:10 raspberrypi systemd[688]: Time has been changed
Jun 12 15:21:10 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 50min 46.574260s random time.
Jun 12 15:21:10 raspberrypi systemd[1]: apt-daily.timer: Adding 10h 30min 10.303394s random time.
Jun 12 15:21:10 raspberrypi fake-hwclock[115]: Wed 12 Jun 13:20:29 UTC 2019
Jun 12 15:21:10 raspberrypi systemd[1]: Time has been changed
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Apply Kernel Variables...
Jun 12 15:21:10 raspberrypi systemd[1]: Mounting Configuration File System...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting File System Check on Root Device...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Create Static Device Nodes in /dev...
Jun 12 15:21:10 raspberrypi systemd[1]: Mounted Configuration File System.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 15:21:10 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 15:21:10 raspberrypi systemd-fsck[142]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 15:21:10 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 15:21:10 raspberrypi systemd-fsck[142]: rootfs: clean, 53743/451232 files, 412626/1904384 blocks
Jun 12 15:21:10 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 15:21:10 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 15:21:10 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 15:21:10 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 15:21:10 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 15:21:10 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 204 (plymouthd).
Jun 12 15:21:10 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Paths.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 15:21:10 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 15:21:10 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 15:21:10 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 15:21:10 raspberrypi systemd-fsck[246]: fsck.fat 4.1 (2017-01-24)
Jun 12 15:21:10 raspberrypi systemd-fsck[246]: 0x41: Dirty bit is set. Fs was not properly unmounted and some data may be corrupt.
Jun 12 15:21:10 raspberrypi systemd-fsck[246]:  Automatically removing dirty bit.
Jun 12 15:21:10 raspberrypi systemd-fsck[246]: Performing changes.
Jun 12 15:21:10 raspberrypi systemd-fsck[246]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 15:21:10 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 15:21:10 raspberrypi systemd[1]: Mounting /boot...
Jun 12 15:21:10 raspberrypi systemd[1]: Mounted /boot.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 15:21:10 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 15:21:10 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 15:21:10 raspberrypi systemd[1]: Time has been changed
Jun 12 15:21:10 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 15:21:10 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 15:21:10 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 15:21:10 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Login Service...
Jun 12 15:21:10 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 15:21:10 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 15:21:10 raspberrypi thd[355]: Found socket passed from systemd
Jun 12 15:21:10 raspberrypi rng-tools[365]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 15:21:10 raspberrypi rngd[386]: rngd 2-unofficial-mt.14 starting up...
Jun 12 15:21:10 raspberrypi avahi-daemon[350]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 15:21:10 raspberrypi avahi-daemon[350]: Successfully dropped root privileges.
Jun 12 15:21:10 raspberrypi avahi-daemon[350]: avahi-daemon 0.6.32 starting up.
Jun 12 15:21:10 raspberrypi rngd[386]: entropy feed to the kernel ready
Jun 12 15:21:10 raspberrypi avahi-daemon[350]: Successfully called chroot().
Jun 12 15:21:10 raspberrypi avahi-daemon[350]: Successfully dropped remaining capabilities.
Jun 12 15:21:10 raspberrypi avahi-daemon[350]: No service file found in /etc/avahi/services.
Jun 12 15:21:10 raspberrypi dbus[378]: [system] Successfully activated service 'org.freedesktop.systemd1'
Jun 12 15:21:10 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 15:21:10 raspberrypi avahi-daemon[350]: Network interface enumeration completed.
Jun 12 15:21:10 raspberrypi avahi-daemon[350]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 1265983346.
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 15:21:10 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 15:21:10 raspberrypi systemd[1]: apt-daily.timer: Adding 2h 25min 55.246389s random time.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 15:21:10 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 49min 28.339025s random time.
Jun 12 15:21:10 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 15:21:10 raspberrypi systemd[1]: Reached target Timers.
Jun 12 15:21:11 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 15:21:11 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 15:21:11 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 15:21:11 raspberrypi dhcpcd[402]: dev: loaded udev
Jun 12 15:21:11 raspberrypi wpa_supplicant[395]: Successfully initialized wpa_supplicant
Jun 12 15:21:11 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 15:21:11 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 15:21:11 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 15:21:11 raspberrypi dhcpcd[402]: wlan0: starting wpa_supplicant
Jun 12 15:21:11 raspberrypi dhcpcd-run-hooks[427]: wlan0: starting wpa_supplicant
Jun 12 15:21:11 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 15:21:11 raspberrypi systemd[1]: Started Login Service.
Jun 12 15:21:11 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 15:21:11 raspberrypi dphys-swapfile[397]: Starting dphys-swapfile swapfile setup ...
Jun 12 15:21:11 raspberrypi raspi-config[375]: Checking if shift key is held down:Error opening '/dev/input/event*': No such file or directory
Jun 12 15:21:11 raspberrypi raspi-config[375]:  No. Switching to ondemand scaling governor.
Jun 12 15:21:11 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 15:21:11 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 15:21:11 raspberrypi gpm[364]: Starting mouse interface server: gpm.
Jun 12 15:21:11 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 15:21:11 raspberrypi dphys-swapfile[397]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 15:21:11 raspberrypi dphys-swapfile[397]: done.
Jun 12 15:21:11 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 15:21:12 raspberrypi dhcpcd[402]: eth0: waiting for carrier
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: waiting for carrier
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: carrier acquired
Jun 12 15:21:12 raspberrypi dhcpcd[402]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: IAID eb:18:c0:5e
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: adding address fe80::3015:f637:ecbd:e86f
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: carrier lost
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: deleting address fe80::3015:f637:ecbd:e86f
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: carrier acquired
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: IAID eb:18:c0:5e
Jun 12 15:21:12 raspberrypi dhcpcd[402]: wlan0: adding address fe80::c28b:58ca:4056:3df1
Jun 12 15:21:13 raspberrypi dhcpcd[402]: wlan0: rebinding lease of 192.168.1.231
Jun 12 15:21:13 raspberrypi dhcpcd[402]: wlan0: NAK: address in use from 192.168.1.1
Jun 12 15:21:13 raspberrypi dhcpcd[402]: wlan0: message: address in use
Jun 12 15:21:13 raspberrypi dhcpcd[402]: wlan0: soliciting a DHCP lease
Jun 12 15:21:13 raspberrypi dhcpcd[402]: wlan0: soliciting an IPv6 router
Jun 12 15:21:14 raspberrypi avahi-daemon[350]: Joining mDNS multicast group on interface wlan0.IPv6 with address fe80::c28b:58ca:4056:3df1.
Jun 12 15:21:14 raspberrypi avahi-daemon[350]: New relevant interface wlan0.IPv6 for mDNS.
Jun 12 15:21:14 raspberrypi avahi-daemon[350]: Registering new address record for fe80::c28b:58ca:4056:3df1 on wlan0.*.
Jun 12 15:21:15 raspberrypi btuart[353]: bcm43xx_init
Jun 12 15:21:15 raspberrypi btuart[353]: Flash firmware /lib/firmware/brcm/BCM43430A1.hcd
Jun 12 15:21:15 raspberrypi btuart[353]: Set BDADDR UART: b8:27:eb:e7:3f:a1
Jun 12 15:21:15 raspberrypi btuart[353]: Set Controller UART speed to 921600 bit/s
Jun 12 15:21:15 raspberrypi btuart[353]: Device setup complete
Jun 12 15:21:15 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 15:21:15 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 15:21:15 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 15:21:15 raspberrypi bluetoothd[494]: Bluetooth daemon 5.43
Jun 12 15:21:15 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 15:21:15 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 15:21:15 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 15:21:15 raspberrypi bluetoothd[494]: Starting SDP server
Jun 12 15:21:15 raspberrypi dbus[378]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 15:21:15 raspberrypi bluetoothd[494]: Bluetooth management interface 1.14 initialized
Jun 12 15:21:15 raspberrypi bluetoothd[494]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 15:21:15 raspberrypi bluetoothd[494]: Sap driver initialization failed.
Jun 12 15:21:15 raspberrypi bluetoothd[494]: sap-server: Operation not permitted (1)
Jun 12 15:21:15 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 15:21:15 raspberrypi bluetoothd[494]: Failed to set privacy: Rejected (0x0b)
Jun 12 15:21:15 raspberrypi dbus[378]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 15:21:15 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 15:21:16 raspberrypi dhcpcd[402]: wlan0: offered 192.168.1.233 from 192.168.1.1
Jun 12 15:21:16 raspberrypi dhcpcd[402]: wlan0: ignoring offer of 192.168.1.233 from 192.168.1.1
Jun 12 15:21:16 raspberrypi dhcpcd[402]: wlan0: probing address 192.168.1.233/24
Jun 12 15:21:21 raspberrypi dhcpcd[402]: wlan0: leased 192.168.1.233 for 86400 seconds
Jun 12 15:21:21 raspberrypi avahi-daemon[350]: Joining mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.233.
Jun 12 15:21:21 raspberrypi avahi-daemon[350]: New relevant interface wlan0.IPv4 for mDNS.
Jun 12 15:21:21 raspberrypi dhcpcd[402]: wlan0: adding route to 192.168.1.0/24
Jun 12 15:21:21 raspberrypi avahi-daemon[350]: Registering new address record for 192.168.1.233 on wlan0.IPv4.
Jun 12 15:21:21 raspberrypi dhcpcd[402]: wlan0: adding default route via 192.168.1.1
Jun 12 15:21:22 raspberrypi dhcpcd[402]: Too few arguments.
Jun 12 15:21:22 raspberrypi dhcpcd[402]: Too few arguments.
Jun 12 15:21:22 raspberrypi dhcpcd[402]: forked to background, child pid 555
Jun 12 15:21:22 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 15:21:22 raspberrypi systemd[1]: Reached target Network.
Jun 12 15:21:22 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 15:21:22 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 15:21:22 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 15:21:22 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 15:21:22 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 15:21:22 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 15:21:22 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 15:21:23 raspberrypi systemd[1]: nmbd.service: Supervising process 598 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:21:23 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 15:21:23 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 15:21:23 raspberrypi systemd[1]: smbd.service: Supervising process 600 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:21:24 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 15:21:26 raspberrypi dhcpcd[555]: wlan0: no IPv6 Routers available
Jun 12 15:21:29 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 15:21:29 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 15:21:29 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 15:21:29 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 204 (plymouthd).
Jun 12 15:21:29 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 15:21:29 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 15:21:29 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 15:21:29 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 15:21:29 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 15:21:29 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 15:21:29 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 15:21:29 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 15:21:29 raspberrypi systemd[1]: Startup finished in 3.648s (kernel) + 23.147s (userspace) = 26.795s.
Jun 12 15:21:29 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 15:21:30 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 15:21:30 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 15:21:30 raspberrypi systemd[640]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 15:21:30 raspberrypi systemd[640]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 15:21:30 raspberrypi systemd[640]: Reached target Timers.
Jun 12 15:21:30 raspberrypi systemd[640]: Reached target Paths.
Jun 12 15:21:30 raspberrypi systemd[640]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 15:21:30 raspberrypi systemd[640]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 15:21:30 raspberrypi systemd[640]: Reached target Sockets.
Jun 12 15:21:30 raspberrypi systemd[640]: Reached target Basic System.
Jun 12 15:21:30 raspberrypi systemd[640]: Reached target Default.
Jun 12 15:21:30 raspberrypi systemd[640]: Startup finished in 106ms.
Jun 12 15:21:30 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 15:36:30 raspberrypi systemd[640]: Time has been changed
Jun 12 15:36:30 raspberrypi systemd[1]: Time has been changed
Jun 12 15:36:30 raspberrypi systemd[1]: apt-daily.timer: Adding 7h 22min 40.575143s random time.
Jun 12 15:36:30 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 23min 7.926457s random time.
Jun 12 15:36:43 raspberrypi dhcpcd[555]: eth0: carrier acquired
Jun 12 15:36:43 raspberrypi dhcpcd[555]: eth0: IAID eb:4d:95:0b
Jun 12 15:36:43 raspberrypi dhcpcd[555]: eth0: adding address fe80::5f52:4d15:e8db:e389
Jun 12 15:36:44 raspberrypi dhcpcd[555]: eth0: soliciting an IPv6 router
Jun 12 15:36:44 raspberrypi dhcpcd[555]: eth0: rebinding lease of 131.174.12.254
Jun 12 15:36:44 raspberrypi dhcpcd[555]: eth0: NAK: requested address not available from 131.174.16.130
Jun 12 15:36:44 raspberrypi dhcpcd[555]: eth0: message: requested address not available
Jun 12 15:36:44 raspberrypi dhcpcd[555]: eth0: soliciting a DHCP lease
Jun 12 15:36:44 raspberrypi avahi-daemon[350]: Joining mDNS multicast group on interface eth0.IPv6 with address fe80::5f52:4d15:e8db:e389.
Jun 12 15:36:44 raspberrypi avahi-daemon[350]: New relevant interface eth0.IPv6 for mDNS.
Jun 12 15:36:44 raspberrypi avahi-daemon[350]: Registering new address record for fe80::5f52:4d15:e8db:e389 on eth0.*.
Jun 12 15:36:45 raspberrypi dhcpcd[555]: eth0: offered 131.174.142.242 from 131.174.30.59
Jun 12 15:36:45 raspberrypi dhcpcd[555]: eth0: probing address 131.174.142.242/24
Jun 12 15:36:51 raspberrypi dhcpcd[555]: eth0: leased 131.174.142.242 for 3600 seconds
Jun 12 15:36:51 raspberrypi avahi-daemon[350]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.142.242.
Jun 12 15:36:51 raspberrypi avahi-daemon[350]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 15:36:51 raspberrypi avahi-daemon[350]: Registering new address record for 131.174.142.242 on eth0.IPv4.
Jun 12 15:36:51 raspberrypi dhcpcd[555]: eth0: adding route to 131.174.142.0/24
Jun 12 15:36:51 raspberrypi dhcpcd[555]: eth0: adding default route via 131.174.142.1
Jun 12 15:36:56 raspberrypi dhcpcd[555]: eth0: no IPv6 Routers available
Jun 12 15:36:58 raspberrypi systemd-udevd[738]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:36:59 raspberrypi systemd-udevd[742]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:37:00 raspberrypi systemd-udevd[750]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:37:04 raspberrypi systemd[1]: Stopped target Graphical Interface.
Jun 12 15:37:04 raspberrypi systemd[1]: Closed Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 15:37:04 raspberrypi systemd[1]: Stopped target Timers.
Jun 12 15:37:04 raspberrypi systemd[1]: Stopped Daily Cleanup of Temporary Directories.
Jun 12 15:37:04 raspberrypi systemd[1]: Stopped target Sound Card.
Jun 12 15:37:04 raspberrypi systemd[1]: Removed slice system-bthelper.slice.
Jun 12 15:37:04 raspberrypi systemd[1]: Stopped target Multi-User System.
Jun 12 15:37:08 raspberrypi fake-hwclock[126]: Wed 12 Jun 13:37:06 UTC 2019
Jun 12 15:37:08 raspberrypi systemd[1]: Started Load Kernel Modules.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Create list of required static device nodes for the current kernel.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Restore / save the current clock.
Jun 12 15:37:08 raspberrypi systemd[1]: Time has been changed
Jun 12 15:37:08 raspberrypi systemd[1]: Starting File System Check on Root Device...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Create Static Device Nodes in /dev...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Apply Kernel Variables...
Jun 12 15:37:08 raspberrypi systemd[1]: Mounting Configuration File System...
Jun 12 15:37:08 raspberrypi systemd[1]: Mounted Configuration File System.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 15:37:08 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 15:37:08 raspberrypi systemd-fsck[140]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 15:37:08 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 15:37:08 raspberrypi systemd-fsck[140]: rootfs: clean, 53741/451232 files, 412656/1904384 blocks
Jun 12 15:37:08 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 15:37:08 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 15:37:08 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 15:37:08 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 15:37:08 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 15:37:08 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 213 (plymouthd).
Jun 12 15:37:08 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Paths.
Jun 12 15:37:08 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 15:37:08 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 15:37:08 raspberrypi systemd-fsck[244]: fsck.fat 4.1 (2017-01-24)
Jun 12 15:37:08 raspberrypi systemd-fsck[244]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 15:37:08 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 15:37:08 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 15:37:08 raspberrypi systemd[1]: Mounting /boot...
Jun 12 15:37:08 raspberrypi systemd[1]: Mounted /boot.
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 15:37:08 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 15:37:08 raspberrypi systemd-udevd[212]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 15:37:08 raspberrypi systemd-udevd[209]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:37:08 raspberrypi systemd-udevd[210]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 15:37:08 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 15:37:08 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 15:37:08 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 15:37:08 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 15:37:08 raspberrypi rng-tools[359]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 15:37:08 raspberrypi rngd[370]: rngd 2-unofficial-mt.14 starting up...
Jun 12 15:37:08 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 15:37:08 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 15:37:08 raspberrypi rngd[370]: entropy feed to the kernel ready
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 15:37:08 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 15:37:08 raspberrypi thd[372]: Found socket passed from systemd
Jun 12 15:37:08 raspberrypi systemd[1]: Starting Login Service...
Jun 12 15:37:08 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 15:37:08 raspberrypi avahi-daemon[367]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 15:37:08 raspberrypi avahi-daemon[367]: Successfully dropped root privileges.
Jun 12 15:37:08 raspberrypi avahi-daemon[367]: avahi-daemon 0.6.32 starting up.
Jun 12 15:37:08 raspberrypi dhcpcd[381]: dev: loaded udev
Jun 12 15:37:09 raspberrypi avahi-daemon[367]: Successfully called chroot().
Jun 12 15:37:09 raspberrypi avahi-daemon[367]: Successfully dropped remaining capabilities.
Jun 12 15:37:09 raspberrypi avahi-daemon[367]: No service file found in /etc/avahi/services.
Jun 12 15:37:09 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 15:37:09 raspberrypi avahi-daemon[367]: Network interface enumeration completed.
Jun 12 15:37:09 raspberrypi avahi-daemon[367]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 335597321.
Jun 12 15:37:09 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 15:37:09 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 15:37:09 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 15:37:09 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 15:37:09 raspberrypi systemd[1]: apt-daily.timer: Adding 10h 55min 49.994657s random time.
Jun 12 15:37:09 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 15:37:09 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 48min 50.744075s random time.
Jun 12 15:37:09 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 15:37:09 raspberrypi systemd[1]: Reached target Timers.
Jun 12 15:37:09 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 15:37:09 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 15:37:09 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 15:37:09 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 15:37:09 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 15:37:09 raspberrypi wpa_supplicant[416]: Successfully initialized wpa_supplicant
Jun 12 15:37:09 raspberrypi dhcpcd[381]: wlan0: starting wpa_supplicant
Jun 12 15:37:09 raspberrypi dhcpcd-run-hooks[431]: wlan0: starting wpa_supplicant
Jun 12 15:37:09 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 15:37:09 raspberrypi dphys-swapfile[421]: Starting dphys-swapfile swapfile setup ...
Jun 12 15:37:09 raspberrypi systemd[1]: Started Login Service.
Jun 12 15:37:09 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 15:37:09 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 15:37:09 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 15:37:09 raspberrypi dphys-swapfile[421]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 15:37:09 raspberrypi gpm[418]: Starting mouse interface server: gpm.
Jun 12 15:37:09 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 15:37:09 raspberrypi dphys-swapfile[421]: done.
Jun 12 15:37:09 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 15:37:10 raspberrypi dhcpcd[381]: eth0: waiting for carrier
Jun 12 15:37:10 raspberrypi dhcpcd[381]: wlan0: waiting for carrier
Jun 12 15:37:10 raspberrypi dhcpcd[381]: wlan0: carrier acquired
Jun 12 15:37:10 raspberrypi dhcpcd[381]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 15:37:10 raspberrypi dhcpcd[381]: wlan0: IAID eb:18:c0:5e
Jun 12 15:37:10 raspberrypi dhcpcd[381]: wlan0: adding address fe80::3015:f637:ecbd:e86f
Jun 12 15:37:10 raspberrypi dhcpcd[381]: wlan0: carrier lost
Jun 12 15:37:10 raspberrypi dhcpcd[381]: wlan0: deleting address fe80::3015:f637:ecbd:e86f
Jun 12 15:37:10 raspberrypi dhcpcd[381]: eth0: carrier acquired
Jun 12 15:37:10 raspberrypi dhcpcd[381]: eth0: IAID eb:4d:95:0b
Jun 12 15:37:10 raspberrypi dhcpcd[381]: eth0: adding address fe80::5f52:4d15:e8db:e389
Jun 12 15:37:10 raspberrypi dhcpcd[381]: eth0: soliciting an IPv6 router
Jun 12 15:37:10 raspberrypi raspi-config[365]: Checking if shift key is held down: No. Switching to ondemand scaling governor.
Jun 12 15:37:10 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 15:37:10 raspberrypi dhcpcd[381]: eth0: rebinding lease of 131.174.142.242
Jun 12 15:37:11 raspberrypi dhcpcd[381]: eth0: carrier lost
Jun 12 15:37:11 raspberrypi dhcpcd[381]: eth0: deleting address fe80::5f52:4d15:e8db:e389
Jun 12 15:37:11 raspberrypi dhcpcd[381]: eth0: carrier acquired
Jun 12 15:37:11 raspberrypi dhcpcd[381]: eth0: IAID eb:4d:95:0b
Jun 12 15:37:11 raspberrypi dhcpcd[381]: eth0: adding address fe80::5f52:4d15:e8db:e389
Jun 12 15:37:11 raspberrypi dhcpcd[381]: eth0: soliciting an IPv6 router
Jun 12 15:37:12 raspberrypi dhcpcd[381]: eth0: rebinding lease of 131.174.142.242
Jun 12 15:37:12 raspberrypi dhcpcd[381]: eth0: probing address 131.174.142.242/24
Jun 12 15:37:12 raspberrypi avahi-daemon[367]: Joining mDNS multicast group on interface eth0.IPv6 with address fe80::5f52:4d15:e8db:e389.
Jun 12 15:37:12 raspberrypi avahi-daemon[367]: New relevant interface eth0.IPv6 for mDNS.
Jun 12 15:37:12 raspberrypi avahi-daemon[367]: Registering new address record for fe80::5f52:4d15:e8db:e389 on eth0.*.
Jun 12 15:37:13 raspberrypi btuart[379]: bcm43xx_init
Jun 12 15:37:13 raspberrypi btuart[379]: Flash firmware /lib/firmware/brcm/BCM43430A1.hcd
Jun 12 15:37:13 raspberrypi btuart[379]: Set BDADDR UART: b8:27:eb:e7:3f:a1
Jun 12 15:37:13 raspberrypi btuart[379]: Set Controller UART speed to 921600 bit/s
Jun 12 15:37:13 raspberrypi btuart[379]: Device setup complete
Jun 12 15:37:13 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 15:37:13 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 15:37:13 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 15:37:13 raspberrypi bluetoothd[513]: Bluetooth daemon 5.43
Jun 12 15:37:13 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 15:37:13 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 15:37:13 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 15:37:13 raspberrypi bluetoothd[513]: Starting SDP server
Jun 12 15:37:13 raspberrypi bluetoothd[513]: Bluetooth management interface 1.14 initialized
Jun 12 15:37:13 raspberrypi dbus[394]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 15:37:13 raspberrypi bluetoothd[513]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 15:37:13 raspberrypi bluetoothd[513]: Sap driver initialization failed.
Jun 12 15:37:13 raspberrypi bluetoothd[513]: sap-server: Operation not permitted (1)
Jun 12 15:37:13 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 15:37:13 raspberrypi bluetoothd[513]: Failed to set privacy: Rejected (0x0b)
Jun 12 15:37:14 raspberrypi dbus[394]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 15:37:14 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 15:37:16 raspberrypi dhcpcd[381]: wlan0: carrier acquired
Jun 12 15:37:16 raspberrypi dhcpcd[381]: wlan0: IAID eb:18:c0:5e
Jun 12 15:37:16 raspberrypi dhcpcd[381]: wlan0: adding address fe80::c28b:58ca:4056:3df1
Jun 12 15:37:17 raspberrypi dhcpcd[381]: wlan0: rebinding lease of 192.168.1.233
Jun 12 15:37:17 raspberrypi dhcpcd[381]: wlan0: soliciting an IPv6 router
Jun 12 15:37:17 raspberrypi dhcpcd[381]: wlan0: probing address 192.168.1.233/24
Jun 12 15:37:17 raspberrypi dhcpcd[381]: eth0: leased 131.174.142.242 for 3564 seconds
Jun 12 15:37:17 raspberrypi avahi-daemon[367]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.142.242.
Jun 12 15:37:17 raspberrypi dhcpcd[381]: eth0: adding route to 131.174.142.0/24
Jun 12 15:37:17 raspberrypi dhcpcd[381]: eth0: adding default route via 131.174.142.1
Jun 12 15:37:17 raspberrypi avahi-daemon[367]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 15:37:17 raspberrypi avahi-daemon[367]: Registering new address record for 131.174.142.242 on eth0.IPv4.
Jun 12 15:37:18 raspberrypi dhcpcd[381]: Too few arguments.
Jun 12 15:37:18 raspberrypi dhcpcd[381]: Too few arguments.
Jun 12 15:37:18 raspberrypi dhcpcd[381]: Failed to get unit file state for ntp.service: No such file or directory
Jun 12 15:37:18 raspberrypi dhcpcd[381]: forked to background, child pid 581
Jun 12 15:37:18 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 15:37:18 raspberrypi systemd[1]: Reached target Network.
Jun 12 15:37:18 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 15:37:18 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 15:37:18 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 15:37:18 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 15:37:18 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 15:37:18 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 15:37:18 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 15:37:18 raspberrypi avahi-daemon[367]: Joining mDNS multicast group on interface wlan0.IPv6 with address fe80::c28b:58ca:4056:3df1.
Jun 12 15:37:18 raspberrypi avahi-daemon[367]: New relevant interface wlan0.IPv6 for mDNS.
Jun 12 15:37:18 raspberrypi avahi-daemon[367]: Registering new address record for fe80::c28b:58ca:4056:3df1 on wlan0.*.
Jun 12 15:37:19 raspberrypi systemd[1]: nmbd.service: Supervising process 628 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:37:19 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 15:37:19 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 15:37:20 raspberrypi systemd[1]: smbd.service: Supervising process 630 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:37:20 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 15:37:22 raspberrypi dhcpcd[581]: wlan0: leased 192.168.1.233 for 86400 seconds
Jun 12 15:37:22 raspberrypi avahi-daemon[367]: Joining mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.233.
Jun 12 15:37:22 raspberrypi dhcpcd[581]: wlan0: adding route to 192.168.1.0/24
Jun 12 15:37:22 raspberrypi avahi-daemon[367]: New relevant interface wlan0.IPv4 for mDNS.
Jun 12 15:37:22 raspberrypi avahi-daemon[367]: Registering new address record for 192.168.1.233 on wlan0.IPv4.
Jun 12 15:37:22 raspberrypi dhcpcd[581]: wlan0: adding default route via 192.168.1.1
Jun 12 15:37:24 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 15:37:24 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 15:37:24 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 15:37:24 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 213 (plymouthd).
Jun 12 15:37:24 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 15:37:24 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 15:37:24 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 15:37:24 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 15:37:24 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 15:37:24 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 15:37:24 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 15:37:24 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 15:37:24 raspberrypi systemd[1]: Startup finished in 2.033s (kernel) + 19.636s (userspace) = 21.669s.
Jun 12 15:37:24 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 15:37:24 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 15:37:24 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 15:37:24 raspberrypi dhcpcd[581]: eth0: no IPv6 Routers available
Jun 12 15:37:24 raspberrypi systemd[726]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 15:37:24 raspberrypi systemd[726]: Reached target Timers.
Jun 12 15:37:24 raspberrypi systemd[726]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 15:37:24 raspberrypi systemd[726]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 15:37:24 raspberrypi systemd[726]: Reached target Paths.
Jun 12 15:37:24 raspberrypi systemd[726]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 15:37:24 raspberrypi systemd[726]: Reached target Sockets.
Jun 12 15:37:24 raspberrypi systemd[726]: Reached target Basic System.
Jun 12 15:37:24 raspberrypi systemd[726]: Reached target Default.
Jun 12 15:37:24 raspberrypi systemd[726]: Startup finished in 105ms.
Jun 12 15:37:24 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 15:37:30 raspberrypi dhcpcd[581]: wlan0: no IPv6 Routers available
Jun 12 15:37:47 raspberrypi systemd[726]: Time has been changed
Jun 12 15:37:47 raspberrypi systemd[1]: Time has been changed
Jun 12 15:37:47 raspberrypi systemd[1]: apt-daily.timer: Adding 1h 7min 15.799924s random time.
Jun 12 15:37:47 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 44min 23.177403s random time.
Jun 12 15:38:09 raspberrypi systemd[1]: Removed slice system-bthelper.slice.
Jun 12 15:38:09 raspberrypi systemd[1]: Stopping User Manager for UID 0...
Jun 12 15:38:09 raspberrypi systemd[1]: Closed Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 15:38:09 raspberrypi bluetoothd[513]: Terminating
Jun 12 15:38:09 raspberrypi systemd[1]: Stopped target Bluetooth.
Jun 12 15:38:09 raspberrypi systemd[1]: Stopping Bluetooth service...
Jun 12 15:38:09 raspberrypi systemd[1]: Stopping Session c1 of user root.
Jun 12 15:38:13 raspberrypi fake-hwclock[126]: Wed 12 Jun 13:38:11 UTC 2019
Jun 12 15:38:13 raspberrypi systemd[1]: Time has been changed
Jun 12 15:38:13 raspberrypi systemd[1]: Starting File System Check on Root Device...
Jun 12 15:38:13 raspberrypi systemd[1]: Mounting Configuration File System...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Apply Kernel Variables...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Create Static Device Nodes in /dev...
Jun 12 15:38:13 raspberrypi systemd[1]: Mounted Configuration File System.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 15:38:13 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 15:38:13 raspberrypi systemd-fsck[140]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 15:38:13 raspberrypi systemd-fsck[140]: rootfs: clean, 53745/451232 files, 412688/1904384 blocks
Jun 12 15:38:13 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 15:38:13 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 15:38:13 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 15:38:13 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 15:38:13 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 15:38:13 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 15:38:13 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 205 (plymouthd).
Jun 12 15:38:13 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Paths.
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 15:38:13 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 15:38:13 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 15:38:13 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 15:38:13 raspberrypi systemd-fsck[238]: fsck.fat 4.1 (2017-01-24)
Jun 12 15:38:13 raspberrypi systemd-fsck[238]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 15:38:13 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 15:38:13 raspberrypi systemd[1]: Mounting /boot...
Jun 12 15:38:13 raspberrypi systemd-udevd[187]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:38:13 raspberrypi systemd[1]: Mounted /boot.
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 15:38:13 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 15:38:13 raspberrypi systemd-udevd[188]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 15:38:13 raspberrypi systemd-udevd[199]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 15:38:13 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 15:38:13 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 15:38:13 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 15:38:13 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 15:38:13 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 15:38:13 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Login Service...
Jun 12 15:38:13 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 15:38:13 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 15:38:13 raspberrypi rng-tools[356]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 15:38:13 raspberrypi rngd[374]: rngd 2-unofficial-mt.14 starting up...
Jun 12 15:38:13 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 15:38:13 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 15:38:13 raspberrypi dhcpcd[353]: dev: loaded udev
Jun 12 15:38:13 raspberrypi rngd[374]: entropy feed to the kernel ready
Jun 12 15:38:14 raspberrypi thd[371]: Found socket passed from systemd
Jun 12 15:38:14 raspberrypi avahi-daemon[373]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 15:38:14 raspberrypi avahi-daemon[373]: Successfully dropped root privileges.
Jun 12 15:38:14 raspberrypi avahi-daemon[373]: avahi-daemon 0.6.32 starting up.
Jun 12 15:38:14 raspberrypi avahi-daemon[373]: Successfully called chroot().
Jun 12 15:38:14 raspberrypi avahi-daemon[373]: Successfully dropped remaining capabilities.
Jun 12 15:38:14 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 15:38:14 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 15:38:14 raspberrypi avahi-daemon[373]: No service file found in /etc/avahi/services.
Jun 12 15:38:14 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 15:38:14 raspberrypi avahi-daemon[373]: Network interface enumeration completed.
Jun 12 15:38:14 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 15:38:14 raspberrypi avahi-daemon[373]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 3543698440.
Jun 12 15:38:14 raspberrypi systemd[1]: apt-daily.timer: Adding 2h 6min 25.991589s random time.
Jun 12 15:38:14 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 15:38:14 raspberrypi dhcpcd[353]: wlan0: starting wpa_supplicant
Jun 12 15:38:14 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 5min 12.324554s random time.
Jun 12 15:38:14 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 15:38:14 raspberrypi systemd[1]: Reached target Timers.
Jun 12 15:38:14 raspberrypi dhcpcd-run-hooks[416]: wlan0: starting wpa_supplicant
Jun 12 15:38:14 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 15:38:14 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 15:38:14 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 15:38:14 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 15:38:14 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 15:38:14 raspberrypi wpa_supplicant[414]: Successfully initialized wpa_supplicant
Jun 12 15:38:14 raspberrypi dphys-swapfile[349]: Starting dphys-swapfile swapfile setup ...
Jun 12 15:38:14 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 15:38:14 raspberrypi systemd[1]: Started Login Service.
Jun 12 15:38:14 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 15:38:14 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 15:38:14 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 15:38:14 raspberrypi dphys-swapfile[349]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 15:38:14 raspberrypi gpm[340]: Starting mouse interface server: gpm.
Jun 12 15:38:14 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 15:38:14 raspberrypi dphys-swapfile[349]: done.
Jun 12 15:38:14 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 15:38:14 raspberrypi dhcpcd[353]: eth0: waiting for carrier
Jun 12 15:38:14 raspberrypi dhcpcd[353]: wlan0: waiting for carrier
Jun 12 15:38:14 raspberrypi dhcpcd[353]: wlan0: carrier acquired
Jun 12 15:38:14 raspberrypi dhcpcd[353]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 15:38:14 raspberrypi dhcpcd[353]: wlan0: IAID eb:de:05:30
Jun 12 15:38:14 raspberrypi dhcpcd[353]: wlan0: adding address fe80::690e:a875:9ced:b218
Jun 12 15:38:14 raspberrypi dhcpcd[353]: wlan0: carrier lost
Jun 12 15:38:14 raspberrypi dhcpcd[353]: wlan0: deleting address fe80::690e:a875:9ced:b218
Jun 12 15:38:15 raspberrypi raspi-config[364]: Checking if shift key is held down: No. Switching to ondemand scaling governor.
Jun 12 15:38:15 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 15:38:20 raspberrypi btuart[360]: bcm43xx_init
Jun 12 15:38:20 raspberrypi btuart[360]: Flash firmware /lib/firmware/brcm/BCM4345C0.hcd
Jun 12 15:38:20 raspberrypi btuart[360]: Set BDADDR UART: b8:27:eb:21:fa:cf
Jun 12 15:38:20 raspberrypi btuart[360]: Set Controller UART speed to 3000000 bit/s
Jun 12 15:38:20 raspberrypi btuart[360]: Device setup complete
Jun 12 15:38:20 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 15:38:20 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 15:38:20 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 15:38:20 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 15:38:20 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 15:38:20 raspberrypi bluetoothd[489]: Bluetooth daemon 5.43
Jun 12 15:38:20 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 15:38:20 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 15:38:20 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 15:38:20 raspberrypi bluetoothd[489]: Starting SDP server
Jun 12 15:38:20 raspberrypi dbus[375]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 15:38:20 raspberrypi bluetoothd[489]: Bluetooth management interface 1.14 initialized
Jun 12 15:38:20 raspberrypi bluetoothd[489]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 15:38:20 raspberrypi bluetoothd[489]: Sap driver initialization failed.
Jun 12 15:38:20 raspberrypi bluetoothd[489]: sap-server: Operation not permitted (1)
Jun 12 15:38:20 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 15:38:20 raspberrypi bluetoothd[489]: Failed to set privacy: Rejected (0x0b)
Jun 12 15:38:21 raspberrypi dbus[375]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 15:38:21 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 15:38:30 raspberrypi dhcpcd[353]: eth0: carrier acquired
Jun 12 15:38:30 raspberrypi dhcpcd[353]: eth0: IAID eb:8b:50:65
Jun 12 15:38:30 raspberrypi dhcpcd[353]: eth0: adding address fe80::99bd:84fe:733:8d76
Jun 12 15:38:31 raspberrypi dhcpcd[353]: eth0: rebinding lease of 131.174.142.242
Jun 12 15:38:31 raspberrypi dhcpcd[353]: eth0: NAK: requested address not available from 131.174.16.130
Jun 12 15:38:31 raspberrypi dhcpcd[353]: eth0: message: requested address not available
Jun 12 15:38:31 raspberrypi dhcpcd[353]: eth0: soliciting a DHCP lease
Jun 12 15:38:31 raspberrypi dhcpcd[353]: eth0: soliciting an IPv6 router
Jun 12 15:38:31 raspberrypi avahi-daemon[373]: Joining mDNS multicast group on interface eth0.IPv6 with address fe80::99bd:84fe:733:8d76.
Jun 12 15:38:31 raspberrypi avahi-daemon[373]: New relevant interface eth0.IPv6 for mDNS.
Jun 12 15:38:31 raspberrypi avahi-daemon[373]: Registering new address record for fe80::99bd:84fe:733:8d76 on eth0.*.
Jun 12 15:38:32 raspberrypi dhcpcd[353]: eth0: offered 131.174.142.142 from 131.174.30.59
Jun 12 15:38:32 raspberrypi dhcpcd[353]: eth0: probing address 131.174.142.142/24
Jun 12 15:38:37 raspberrypi dhcpcd[353]: eth0: leased 131.174.142.142 for 3600 seconds
Jun 12 15:38:37 raspberrypi avahi-daemon[373]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.142.142.
Jun 12 15:38:37 raspberrypi avahi-daemon[373]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 15:38:37 raspberrypi dhcpcd[353]: eth0: adding route to 131.174.142.0/24
Jun 12 15:38:37 raspberrypi avahi-daemon[373]: Registering new address record for 131.174.142.142 on eth0.IPv4.
Jun 12 15:38:37 raspberrypi dhcpcd[353]: eth0: adding default route via 131.174.142.1
Jun 12 15:38:37 raspberrypi dhcpcd[353]: Too few arguments.
Jun 12 15:38:38 raspberrypi dhcpcd[353]: Too few arguments.
Jun 12 15:38:38 raspberrypi dhcpcd[353]: Failed to get unit file state for ntp.service: No such file or directory
Jun 12 15:38:38 raspberrypi dhcpcd[353]: forked to background, child pid 564
Jun 12 15:38:38 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 15:38:38 raspberrypi systemd[1]: Reached target Network.
Jun 12 15:38:38 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 15:38:38 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 15:38:38 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 15:38:38 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 15:38:38 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 15:38:38 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 15:38:38 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 15:38:39 raspberrypi systemd[1]: nmbd.service: Supervising process 602 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:38:39 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 15:38:39 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 15:38:39 raspberrypi systemd[1]: smbd.service: Supervising process 604 which is not our child. We'll most likely not notice when it exits.
Jun 12 15:38:40 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 15:38:43 raspberrypi dhcpcd[564]: eth0: no IPv6 Routers available
Jun 12 15:38:43 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 15:38:43 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 15:38:43 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 15:38:44 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 205 (plymouthd).
Jun 12 15:38:44 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 15:38:44 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 15:38:44 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 15:38:44 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 15:38:44 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 15:38:44 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 15:38:44 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 15:39:47 raspberrypi systemd[1]: Time has been changed
Jun 12 15:39:47 raspberrypi systemd[1]: apt-daily.timer: Adding 2h 54min 2.632346s random time.
Jun 12 15:39:47 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 38min 51.200317s random time.
Jun 12 15:39:47 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 15:39:47 raspberrypi systemd[1]: Startup finished in 2.003s (kernel) + 34.626s (userspace) = 36.630s.
Jun 12 15:39:47 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 15:39:47 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 15:39:47 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 15:39:47 raspberrypi systemd[645]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 15:39:47 raspberrypi systemd[645]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 15:39:47 raspberrypi systemd[645]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 15:39:47 raspberrypi systemd[645]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 15:39:47 raspberrypi systemd[645]: Reached target Sockets.
Jun 12 15:39:47 raspberrypi systemd[645]: Reached target Timers.
Jun 12 15:39:47 raspberrypi systemd[645]: Reached target Paths.
Jun 12 15:39:47 raspberrypi systemd[645]: Reached target Basic System.
Jun 12 15:39:47 raspberrypi systemd[645]: Reached target Default.
Jun 12 15:39:47 raspberrypi systemd[645]: Startup finished in 111ms.
Jun 12 15:39:47 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 15:41:43 raspberrypi systemd[1]: Started Session c2 of user root.
Jun 12 15:54:18 raspberrypi systemd[1]: Starting Cleanup of Temporary Directories...
Jun 12 15:54:18 raspberrypi systemd[1]: Started Cleanup of Temporary Directories.
Jun 12 16:11:05 raspberrypi systemd[1]: Stopping Raise network interfaces...
Jun 12 16:11:06 raspberrypi systemd[1]: Stopped Raise network interfaces.
Jun 12 16:11:06 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 16:11:06 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 16:15:19 raspberrypi dhclient[921]: Internet Systems Consortium DHCP Client 4.3.5
Jun 12 16:15:19 raspberrypi dhclient[921]: Copyright 2004-2016 Internet Systems Consortium.
Jun 12 16:15:19 raspberrypi dhclient[921]: All rights reserved.
Jun 12 16:15:19 raspberrypi dhclient[921]: For info, please visit https://www.isc.org/software/dhcp/
Jun 12 16:15:19 raspberrypi dhclient[921]: 
Jun 12 16:15:19 raspberrypi dhclient[921]: Listening on LPF/wlan0/b8:27:eb:de:05:30
Jun 12 16:15:19 raspberrypi dhclient[921]: Sending on   LPF/wlan0/b8:27:eb:de:05:30
Jun 12 16:15:19 raspberrypi dhclient[921]: Sending on   Socket/fallback
Jun 12 16:15:19 raspberrypi dhclient[921]: DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 4
Jun 12 16:15:23 raspberrypi dhclient[921]: DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
Jun 12 16:15:29 raspberrypi dhclient[921]: DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 11
Jun 12 16:15:40 raspberrypi dhclient[921]: DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 8
Jun 12 16:20:12 raspberrypi systemd[1]: Stopping WPA supplicant...
Jun 12 16:20:12 raspberrypi systemd[1]: Stopped WPA supplicant.
Jun 12 16:20:12 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 16:20:12 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 16:20:12 raspberrypi wpa_supplicant[964]: Successfully initialized wpa_supplicant
Jun 12 16:27:46 raspberrypi systemd[1]: Stopped target Timers.
Jun 12 16:27:46 raspberrypi systemd[1]: Stopped Daily Cleanup of Temporary Directories.
Jun 12 16:27:46 raspberrypi bluetoothd[489]: Terminating
Jun 12 16:27:46 raspberrypi systemd[1]: Stopping Session c2 of user root.
Jun 12 16:27:46 raspberrypi systemd[1]: Stopped target Bluetooth.
Jun 12 16:27:46 raspberrypi systemd[1]: Stopping Bluetooth service...
Jun 12 16:27:50 raspberrypi fake-hwclock[132]: Wed 12 Jun 14:27:48 UTC 2019
Jun 12 16:27:50 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 16:27:50 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 16:27:50 raspberrypi systemd-fsck[141]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 16:27:50 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 16:27:50 raspberrypi systemd-fsck[141]: rootfs: clean, 53746/451232 files, 412722/1904384 blocks
Jun 12 16:27:50 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 16:27:50 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 16:27:50 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 16:27:50 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 16:27:50 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 194 (plymouthd).
Jun 12 16:27:50 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Paths.
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 16:27:50 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 16:27:50 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 16:27:50 raspberrypi systemd-fsck[223]: fsck.fat 4.1 (2017-01-24)
Jun 12 16:27:50 raspberrypi systemd-fsck[223]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 16:27:50 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:27:50 raspberrypi systemd[1]: Mounting /boot...
Jun 12 16:27:50 raspberrypi systemd[1]: Mounted /boot.
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 16:27:50 raspberrypi systemd-udevd[163]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 16:27:50 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 16:27:50 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 16:27:50 raspberrypi systemd-udevd[188]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:27:50 raspberrypi systemd-udevd[189]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:27:50 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 16:27:50 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 16:27:50 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 16:27:50 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 16:27:50 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Login Service...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 16:27:50 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 16:27:50 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 16:27:50 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 16:27:50 raspberrypi thd[344]: Found socket passed from systemd
Jun 12 16:27:50 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 16:27:50 raspberrypi rng-tools[357]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 16:27:50 raspberrypi rngd[374]: rngd 2-unofficial-mt.14 starting up...
Jun 12 16:27:50 raspberrypi avahi-daemon[349]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 16:27:50 raspberrypi avahi-daemon[349]: Successfully dropped root privileges.
Jun 12 16:27:50 raspberrypi avahi-daemon[349]: avahi-daemon 0.6.32 starting up.
Jun 12 16:27:50 raspberrypi rngd[374]: entropy feed to the kernel ready
Jun 12 16:27:50 raspberrypi avahi-daemon[349]: Successfully called chroot().
Jun 12 16:27:51 raspberrypi avahi-daemon[349]: Successfully dropped remaining capabilities.
Jun 12 16:27:51 raspberrypi avahi-daemon[349]: No service file found in /etc/avahi/services.
Jun 12 16:27:51 raspberrypi avahi-daemon[349]: Network interface enumeration completed.
Jun 12 16:27:51 raspberrypi avahi-daemon[349]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 4191531448.
Jun 12 16:27:51 raspberrypi dbus[358]: [system] Successfully activated service 'org.freedesktop.systemd1'
Jun 12 16:27:51 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 16:27:51 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 16:27:51 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 16:27:51 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 16:27:51 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 16:27:51 raspberrypi systemd[1]: apt-daily.timer: Adding 46min 44.349242s random time.
Jun 12 16:27:51 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 16:27:51 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 54min 26.923490s random time.
Jun 12 16:27:51 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 16:27:51 raspberrypi systemd[1]: Reached target Timers.
Jun 12 16:27:51 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 16:27:51 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 16:27:51 raspberrypi dhcpcd[388]: dev: loaded udev
Jun 12 16:27:51 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 16:27:51 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 16:27:51 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 16:27:51 raspberrypi wpa_supplicant[387]: Successfully initialized wpa_supplicant
Jun 12 16:27:51 raspberrypi dhcpcd[388]: wlan0: starting wpa_supplicant
Jun 12 16:27:51 raspberrypi dphys-swapfile[343]: Starting dphys-swapfile swapfile setup ...
Jun 12 16:27:51 raspberrypi dhcpcd-run-hooks[411]: wlan0: starting wpa_supplicant
Jun 12 16:27:51 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 16:27:51 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 16:27:51 raspberrypi systemd[1]: Started Login Service.
Jun 12 16:27:51 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:27:51 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:27:51 raspberrypi gpm[335]: Starting mouse interface server: gpm.
Jun 12 16:27:51 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 16:27:51 raspberrypi dphys-swapfile[343]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 16:27:51 raspberrypi dphys-swapfile[343]: done.
Jun 12 16:27:51 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 16:27:51 raspberrypi dhcpcd[388]: eth0: waiting for carrier
Jun 12 16:27:51 raspberrypi dhcpcd[388]: wlan0: waiting for carrier
Jun 12 16:27:51 raspberrypi dhcpcd[388]: wlan0: carrier acquired
Jun 12 16:27:52 raspberrypi dhcpcd[388]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 16:27:52 raspberrypi dhcpcd[388]: wlan0: IAID eb:de:05:30
Jun 12 16:27:52 raspberrypi dhcpcd[388]: wlan0: adding address fe80::690e:a875:9ced:b218
Jun 12 16:27:52 raspberrypi dhcpcd[388]: wlan0: carrier lost
Jun 12 16:27:52 raspberrypi dhcpcd[388]: wlan0: deleting address fe80::690e:a875:9ced:b218
Jun 12 16:27:52 raspberrypi dhcpcd[388]: eth0: carrier acquired
Jun 12 16:27:52 raspberrypi dhcpcd[388]: eth0: IAID eb:8b:50:65
Jun 12 16:27:52 raspberrypi dhcpcd[388]: eth0: adding address fe80::99bd:84fe:733:8d76
Jun 12 16:27:52 raspberrypi dhcpcd[388]: eth0: rebinding lease of 131.174.142.142
Jun 12 16:27:52 raspberrypi dhcpcd[388]: eth0: probing address 131.174.142.142/24
Jun 12 16:27:52 raspberrypi raspi-config[341]: Checking if shift key is held down: No. Switching to ondemand scaling governor.
Jun 12 16:27:52 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 16:27:52 raspberrypi dhcpcd[388]: eth0: soliciting an IPv6 router
Jun 12 16:27:53 raspberrypi avahi-daemon[349]: Joining mDNS multicast group on interface eth0.IPv6 with address fe80::99bd:84fe:733:8d76.
Jun 12 16:27:53 raspberrypi avahi-daemon[349]: New relevant interface eth0.IPv6 for mDNS.
Jun 12 16:27:53 raspberrypi avahi-daemon[349]: Registering new address record for fe80::99bd:84fe:733:8d76 on eth0.*.
Jun 12 16:27:57 raspberrypi btuart[347]: bcm43xx_init
Jun 12 16:27:57 raspberrypi btuart[347]: Flash firmware /lib/firmware/brcm/BCM4345C0.hcd
Jun 12 16:27:57 raspberrypi btuart[347]: Set BDADDR UART: b8:27:eb:21:fa:cf
Jun 12 16:27:57 raspberrypi btuart[347]: Set Controller UART speed to 3000000 bit/s
Jun 12 16:27:57 raspberrypi btuart[347]: Device setup complete
Jun 12 16:27:57 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:27:57 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 16:27:57 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:27:57 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 16:27:57 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 16:27:57 raspberrypi bluetoothd[476]: Bluetooth daemon 5.43
Jun 12 16:27:57 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 16:27:57 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 16:27:57 raspberrypi bluetoothd[476]: Starting SDP server
Jun 12 16:27:57 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 16:27:57 raspberrypi dbus[358]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 16:27:57 raspberrypi bluetoothd[476]: Bluetooth management interface 1.14 initialized
Jun 12 16:27:57 raspberrypi bluetoothd[476]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 16:27:57 raspberrypi bluetoothd[476]: Sap driver initialization failed.
Jun 12 16:27:57 raspberrypi bluetoothd[476]: sap-server: Operation not permitted (1)
Jun 12 16:27:57 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 16:27:57 raspberrypi bluetoothd[476]: Failed to set privacy: Rejected (0x0b)
Jun 12 16:27:57 raspberrypi dhcpcd[388]: eth0: leased 131.174.142.142 for 48900 seconds
Jun 12 16:27:57 raspberrypi avahi-daemon[349]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.142.142.
Jun 12 16:27:57 raspberrypi dhcpcd[388]: eth0: adding route to 131.174.142.0/24
Jun 12 16:27:57 raspberrypi avahi-daemon[349]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 16:27:57 raspberrypi avahi-daemon[349]: Registering new address record for 131.174.142.142 on eth0.IPv4.
Jun 12 16:27:57 raspberrypi dhcpcd[388]: eth0: adding default route via 131.174.142.1
Jun 12 16:27:58 raspberrypi dbus[358]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 16:27:58 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 16:27:58 raspberrypi dhcpcd[388]: Failed to get unit file state for ntp.service: No such file or directory
Jun 12 16:27:58 raspberrypi dhcpcd[388]: forked to background, child pid 540
Jun 12 16:27:58 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 16:27:58 raspberrypi systemd[1]: Reached target Network.
Jun 12 16:27:58 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 16:27:58 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 16:27:58 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 16:27:58 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 16:27:58 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 16:27:58 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 16:27:58 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 16:27:59 raspberrypi systemd[1]: nmbd.service: Supervising process 581 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:27:59 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 16:27:59 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 16:28:00 raspberrypi systemd[1]: smbd.service: Supervising process 583 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:28:00 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 16:28:01 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 16:28:01 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 16:28:01 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 16:28:01 raspberrypi systemd[593]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 16:28:01 raspberrypi systemd[593]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 16:28:01 raspberrypi systemd[593]: Reached target Paths.
Jun 12 16:28:01 raspberrypi systemd[593]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 16:28:01 raspberrypi systemd[593]: Reached target Timers.
Jun 12 16:28:01 raspberrypi systemd[593]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 16:28:01 raspberrypi systemd[593]: Reached target Sockets.
Jun 12 16:28:01 raspberrypi systemd[593]: Reached target Basic System.
Jun 12 16:28:01 raspberrypi systemd[593]: Reached target Default.
Jun 12 16:28:01 raspberrypi systemd[593]: Startup finished in 105ms.
Jun 12 16:28:01 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 16:28:04 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 16:28:04 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 16:28:04 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 16:28:04 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 194 (plymouthd).
Jun 12 16:28:04 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 16:28:04 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 16:28:04 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 16:28:04 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 16:28:04 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 16:28:04 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 16:28:04 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 16:28:04 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 16:28:04 raspberrypi systemd[1]: Startup finished in 2.014s (kernel) + 17.777s (userspace) = 19.792s.
Jun 12 16:28:04 raspberrypi systemd[1]: Started Session c2 of user root.
Jun 12 16:28:05 raspberrypi dhcpcd[540]: eth0: no IPv6 Routers available
Jun 12 16:28:28 raspberrypi systemd[593]: Time has been changed
Jun 12 16:28:28 raspberrypi systemd[1]: Time has been changed
Jun 12 16:28:28 raspberrypi systemd[1]: apt-daily.timer: Adding 6h 50min 32.748327s random time.
Jun 12 16:28:28 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 4min 11.349575s random time.
Jun 12 16:29:00 raspberrypi dhcpcd[540]: eth0: carrier lost
Jun 12 16:29:00 raspberrypi dhcpcd[540]: eth0: deleting address fe80::99bd:84fe:733:8d76
Jun 12 16:29:00 raspberrypi avahi-daemon[349]: Withdrawing address record for fe80::99bd:84fe:733:8d76 on eth0.
Jun 12 16:29:00 raspberrypi avahi-daemon[349]: Leaving mDNS multicast group on interface eth0.IPv6 with address fe80::99bd:84fe:733:8d76.
Jun 12 16:29:00 raspberrypi avahi-daemon[349]: Interface eth0.IPv6 no longer relevant for mDNS.
Jun 12 16:29:00 raspberrypi dhcpcd[540]: eth0: deleting default route via 131.174.142.1
Jun 12 16:29:00 raspberrypi dhcpcd[540]: eth0: deleting route to 131.174.142.0/24
Jun 12 16:29:00 raspberrypi avahi-daemon[349]: Withdrawing address record for 131.174.142.142 on eth0.
Jun 12 16:29:00 raspberrypi avahi-daemon[349]: Leaving mDNS multicast group on interface eth0.IPv4 with address 131.174.142.142.
Jun 12 16:29:00 raspberrypi avahi-daemon[349]: Interface eth0.IPv4 no longer relevant for mDNS.
Jun 12 16:29:03 raspberrypi systemd[1]: Stopped target Bluetooth.
Jun 12 16:29:03 raspberrypi systemd[1]: Stopped target Sound Card.
Jun 12 16:29:03 raspberrypi bluetoothd[476]: Terminating
Jun 12 16:29:03 raspberrypi systemd[1]: Stopping Bluetooth service...
Jun 12 16:29:03 raspberrypi systemd[1]: Closed Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 16:29:03 raspberrypi systemd[1]: Stopping Session c1 of user root.
Jun 12 16:29:03 raspberrypi systemd[1]: Stopping Save/Restore Sound Card State...
Jun 12 16:29:03 raspberrypi bluetoothd[476]: Stopping SDP server
Jun 12 16:29:03 raspberrypi systemd[1]: Stopped target Timers.
Jun 12 16:29:07 raspberrypi fake-hwclock[119]: Wed 12 Jun 14:29:04 UTC 2019
Jun 12 16:29:07 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 16:29:07 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 16:29:07 raspberrypi systemd-fsck[142]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 16:29:07 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 16:29:07 raspberrypi systemd-fsck[142]: rootfs: clean, 53745/451232 files, 412753/1904384 blocks
Jun 12 16:29:07 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 16:29:07 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 16:29:07 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 16:29:07 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 16:29:07 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 16:29:07 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 205 (plymouthd).
Jun 12 16:29:07 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Paths.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 16:29:07 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 16:29:07 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 16:29:07 raspberrypi systemd-fsck[236]: fsck.fat 4.1 (2017-01-24)
Jun 12 16:29:07 raspberrypi systemd-fsck[236]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 16:29:07 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 16:29:07 raspberrypi systemd[1]: Mounting /boot...
Jun 12 16:29:07 raspberrypi systemd[1]: Mounted /boot.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 16:29:07 raspberrypi systemd-udevd[203]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 16:29:07 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 16:29:07 raspberrypi systemd-udevd[190]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:29:07 raspberrypi systemd-udevd[198]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 16:29:07 raspberrypi systemd[1]: apt-daily.timer: Adding 2h 31min 51.649331s random time.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 16:29:07 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 18min 32.145078s random time.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 16:29:07 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 16:29:07 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 16:29:07 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 16:29:07 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 16:29:07 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Login Service...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 16:29:07 raspberrypi rngd[361]: rngd 2-unofficial-mt.14 starting up...
Jun 12 16:29:07 raspberrypi rng-tools[351]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 16:29:07 raspberrypi thd[356]: Found socket passed from systemd
Jun 12 16:29:07 raspberrypi systemd[1]: Reached target Timers.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 16:29:07 raspberrypi rngd[361]: entropy feed to the kernel ready
Jun 12 16:29:07 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 16:29:07 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 16:29:07 raspberrypi avahi-daemon[362]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 16:29:07 raspberrypi avahi-daemon[362]: Successfully dropped root privileges.
Jun 12 16:29:07 raspberrypi avahi-daemon[362]: avahi-daemon 0.6.32 starting up.
Jun 12 16:29:07 raspberrypi avahi-daemon[362]: Successfully called chroot().
Jun 12 16:29:07 raspberrypi avahi-daemon[362]: Successfully dropped remaining capabilities.
Jun 12 16:29:07 raspberrypi avahi-daemon[362]: No service file found in /etc/avahi/services.
Jun 12 16:29:07 raspberrypi avahi-daemon[362]: Network interface enumeration completed.
Jun 12 16:29:07 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 16:29:07 raspberrypi avahi-daemon[362]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 2735388288.
Jun 12 16:29:07 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 16:29:07 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 16:29:07 raspberrypi dhcpcd[378]: dev: loaded udev
Jun 12 16:29:07 raspberrypi wpa_supplicant[369]: Successfully initialized wpa_supplicant
Jun 12 16:29:07 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 16:29:07 raspberrypi dphys-swapfile[385]: Starting dphys-swapfile swapfile setup ...
Jun 12 16:29:07 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 16:29:07 raspberrypi systemd[1]: Started Login Service.
Jun 12 16:29:07 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:29:07 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:29:07 raspberrypi dhcpcd[378]: wlan0: starting wpa_supplicant
Jun 12 16:29:07 raspberrypi dphys-swapfile[385]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 16:29:07 raspberrypi dhcpcd-run-hooks[443]: wlan0: starting wpa_supplicant
Jun 12 16:29:07 raspberrypi gpm[371]: Starting mouse interface server: gpm.
Jun 12 16:29:07 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 16:29:07 raspberrypi dphys-swapfile[385]: done.
Jun 12 16:29:07 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 16:29:08 raspberrypi dhcpcd[378]: eth0: waiting for carrier
Jun 12 16:29:08 raspberrypi dhcpcd[378]: wlan0: waiting for carrier
Jun 12 16:29:08 raspberrypi dhcpcd[378]: wlan0: carrier acquired
Jun 12 16:29:08 raspberrypi dhcpcd[378]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 16:29:08 raspberrypi dhcpcd[378]: wlan0: IAID eb:de:05:30
Jun 12 16:29:08 raspberrypi dhcpcd[378]: wlan0: adding address fe80::690e:a875:9ced:b218
Jun 12 16:29:08 raspberrypi dhcpcd[378]: wlan0: carrier lost
Jun 12 16:29:08 raspberrypi dhcpcd[378]: wlan0: deleting address fe80::690e:a875:9ced:b218
Jun 12 16:29:08 raspberrypi raspi-config[350]: Checking if shift key is held down: No. Switching to ondemand scaling governor.
Jun 12 16:29:08 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 16:29:13 raspberrypi btuart[360]: bcm43xx_init
Jun 12 16:29:13 raspberrypi btuart[360]: Flash firmware /lib/firmware/brcm/BCM4345C0.hcd
Jun 12 16:29:13 raspberrypi btuart[360]: Set BDADDR UART: b8:27:eb:21:fa:cf
Jun 12 16:29:13 raspberrypi btuart[360]: Set Controller UART speed to 3000000 bit/s
Jun 12 16:29:13 raspberrypi btuart[360]: Device setup complete
Jun 12 16:29:13 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:29:13 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 16:29:13 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:29:13 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 16:29:13 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 16:29:13 raspberrypi bluetoothd[485]: Bluetooth daemon 5.43
Jun 12 16:29:14 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 16:29:14 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 16:29:14 raspberrypi bluetoothd[485]: Starting SDP server
Jun 12 16:29:14 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 16:29:14 raspberrypi bluetoothd[485]: Bluetooth management interface 1.14 initialized
Jun 12 16:29:14 raspberrypi dbus[346]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 16:29:14 raspberrypi bluetoothd[485]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 16:29:14 raspberrypi bluetoothd[485]: Sap driver initialization failed.
Jun 12 16:29:14 raspberrypi bluetoothd[485]: sap-server: Operation not permitted (1)
Jun 12 16:29:14 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 16:29:14 raspberrypi bluetoothd[485]: Failed to set privacy: Rejected (0x0b)
Jun 12 16:29:14 raspberrypi dbus[346]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 16:29:14 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 16:29:38 raspberrypi dhcpcd[378]: timed out
Jun 12 16:29:38 raspberrypi dhcpcd[378]: forked to background, child pid 499
Jun 12 16:29:38 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 16:29:38 raspberrypi systemd[1]: Reached target Network.
Jun 12 16:29:38 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 16:29:38 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 16:29:38 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 16:29:38 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 16:29:38 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 16:29:38 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 16:29:38 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 16:29:39 raspberrypi systemd[1]: nmbd.service: Supervising process 539 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:29:44 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 16:29:44 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 16:29:44 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 16:29:44 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 205 (plymouthd).
Jun 12 16:29:44 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 16:29:44 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 16:29:44 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 16:29:44 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 16:29:49 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 16:29:49 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 16:29:49 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 16:29:49 raspberrypi systemd[577]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 16:29:49 raspberrypi systemd[577]: Reached target Paths.
Jun 12 16:29:49 raspberrypi systemd[577]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 16:29:49 raspberrypi systemd[577]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 16:29:49 raspberrypi systemd[577]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 16:29:49 raspberrypi systemd[577]: Reached target Sockets.
Jun 12 16:29:49 raspberrypi systemd[577]: Reached target Timers.
Jun 12 16:29:49 raspberrypi systemd[577]: Reached target Basic System.
Jun 12 16:29:49 raspberrypi systemd[577]: Reached target Default.
Jun 12 16:29:49 raspberrypi systemd[577]: Startup finished in 113ms.
Jun 12 16:29:49 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 16:31:08 raspberrypi systemd[1]: nmbd.service: Start operation timed out. Terminating.
Jun 12 16:31:08 raspberrypi systemd[1]: nmbd.service: Killing process 539 (nmbd) with signal SIGKILL.
Jun 12 16:31:08 raspberrypi systemd[1]: Failed to start Samba NMB Daemon.
Jun 12 16:31:08 raspberrypi systemd[1]: nmbd.service: Unit entered failed state.
Jun 12 16:31:08 raspberrypi systemd[1]: nmbd.service: Failed with result 'timeout'.
Jun 12 16:31:08 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 16:31:09 raspberrypi systemd[1]: smbd.service: Supervising process 606 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:31:09 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 16:31:09 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 16:31:09 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 16:31:09 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 16:31:09 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 16:31:09 raspberrypi systemd[1]: Startup finished in 2.039s (kernel) + 2min 6.648s (userspace) = 2min 8.688s.
Jun 12 16:33:01 raspberrypi systemd[1]: Stopping Raise network interfaces...
Jun 12 16:33:01 raspberrypi systemd[1]: Stopped Raise network interfaces.
Jun 12 16:33:01 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 16:33:01 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 16:29:06 raspberrypi fake-hwclock[122]: Wed 12 Jun 14:29:04 UTC 2019
Jun 12 16:29:06 raspberrypi systemd[1]: Time has been changed
Jun 12 16:29:06 raspberrypi systemd[1]: Starting File System Check on Root Device...
Jun 12 16:29:06 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 16:29:06 raspberrypi systemd-fsck[147]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 16:29:06 raspberrypi systemd-fsck[147]: rootfs: clean, 53753/451232 files, 412784/1904384 blocks
Jun 12 16:29:06 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 16:29:06 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 16:29:06 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 16:29:06 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 16:29:06 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 16:29:06 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 210 (plymouthd).
Jun 12 16:29:06 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Paths.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 16:29:06 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 16:29:06 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 16:29:06 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 16:29:06 raspberrypi systemd-fsck[240]: fsck.fat 4.1 (2017-01-24)
Jun 12 16:29:06 raspberrypi systemd-fsck[240]: 0x41: Dirty bit is set. Fs was not properly unmounted and some data may be corrupt.
Jun 12 16:29:06 raspberrypi systemd-fsck[240]:  Automatically removing dirty bit.
Jun 12 16:29:06 raspberrypi systemd-fsck[240]: Performing changes.
Jun 12 16:29:06 raspberrypi systemd-fsck[240]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 16:29:06 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:29:06 raspberrypi systemd[1]: Mounting /boot...
Jun 12 16:29:06 raspberrypi systemd[1]: Mounted /boot.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 16:29:06 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 16:29:06 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 16:29:06 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 16:29:06 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 16:29:06 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 16:29:06 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 16:29:06 raspberrypi rng-tools[330]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 16:29:06 raspberrypi rngd[340]: rngd 2-unofficial-mt.14 starting up...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 16:29:06 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 16:29:06 raspberrypi rngd[340]: entropy feed to the kernel ready
Jun 12 16:29:06 raspberrypi thd[345]: Found socket passed from systemd
Jun 12 16:29:06 raspberrypi avahi-daemon[331]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 16:29:06 raspberrypi avahi-daemon[331]: Successfully dropped root privileges.
Jun 12 16:29:06 raspberrypi avahi-daemon[331]: avahi-daemon 0.6.32 starting up.
Jun 12 16:29:06 raspberrypi avahi-daemon[331]: Successfully called chroot().
Jun 12 16:29:06 raspberrypi avahi-daemon[331]: Successfully dropped remaining capabilities.
Jun 12 16:29:06 raspberrypi avahi-daemon[331]: No service file found in /etc/avahi/services.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 16:29:06 raspberrypi avahi-daemon[331]: Network interface enumeration completed.
Jun 12 16:29:06 raspberrypi avahi-daemon[331]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 11650188.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Login Service...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 16:29:06 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 16:29:06 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 16:29:06 raspberrypi systemd[1]: apt-daily.timer: Adding 8h 16min 6.387226s random time.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 16:29:06 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 17min 42.439244s random time.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 16:29:06 raspberrypi systemd[1]: Reached target Timers.
Jun 12 16:29:06 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 16:29:06 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 16:29:06 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 16:29:06 raspberrypi dhcpcd[370]: dev: loaded udev
Jun 12 16:29:06 raspberrypi wpa_supplicant[373]: Successfully initialized wpa_supplicant
Jun 12 16:29:06 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 16:29:06 raspberrypi systemd[1]: Started Login Service.
Jun 12 16:29:06 raspberrypi dphys-swapfile[375]: Starting dphys-swapfile swapfile setup ...
Jun 12 16:29:06 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:29:06 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 16:29:06 raspberrypi raspi-config[341]: Checking if shift key is held down:Error opening '/dev/input/event*': No such file or directory
Jun 12 16:29:07 raspberrypi raspi-config[341]:  No. Switching to ondemand scaling governor.
Jun 12 16:29:07 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 16:29:07 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:29:07 raspberrypi gpm[346]: Starting mouse interface server: gpm.
Jun 12 16:29:07 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 16:29:07 raspberrypi dhcpcd[370]: wlan0: starting wpa_supplicant
Jun 12 16:29:07 raspberrypi dhcpcd-run-hooks[439]: wlan0: starting wpa_supplicant
Jun 12 16:29:07 raspberrypi dphys-swapfile[375]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 16:29:07 raspberrypi dphys-swapfile[375]: done.
Jun 12 16:29:07 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 16:29:07 raspberrypi dhcpcd[370]: eth0: waiting for carrier
Jun 12 16:29:07 raspberrypi dhcpcd[370]: wlan0: waiting for carrier
Jun 12 16:29:07 raspberrypi dhcpcd[370]: wlan0: carrier acquired
Jun 12 16:29:07 raspberrypi dhcpcd[370]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 16:29:07 raspberrypi dhcpcd[370]: wlan0: IAID eb:de:05:30
Jun 12 16:29:07 raspberrypi dhcpcd[370]: wlan0: adding address fe80::690e:a875:9ced:b218
Jun 12 16:29:07 raspberrypi dhcpcd[370]: wlan0: carrier lost
Jun 12 16:29:07 raspberrypi dhcpcd[370]: wlan0: deleting address fe80::690e:a875:9ced:b218
Jun 12 16:29:07 raspberrypi dhcpcd[370]: eth0: carrier acquired
Jun 12 16:29:07 raspberrypi dhcpcd[370]: eth0: IAID eb:8b:50:65
Jun 12 16:29:07 raspberrypi dhcpcd[370]: eth0: adding address fe80::99bd:84fe:733:8d76
Jun 12 16:29:07 raspberrypi dhcpcd[370]: eth0: rebinding lease of 131.174.142.142
Jun 12 16:29:08 raspberrypi dhcpcd[370]: eth0: NAK: requested address not available from 131.174.16.130
Jun 12 16:29:08 raspberrypi dhcpcd[370]: eth0: message: requested address not available
Jun 12 16:29:08 raspberrypi dhcpcd[370]: eth0: soliciting a DHCP lease
Jun 12 16:29:08 raspberrypi dhcpcd[370]: eth0: soliciting an IPv6 router
Jun 12 16:29:09 raspberrypi dhcpcd[370]: eth0: offered 131.174.12.235 from 131.174.30.59
Jun 12 16:29:09 raspberrypi dhcpcd[370]: eth0: probing address 131.174.12.235/24
Jun 12 16:29:09 raspberrypi avahi-daemon[331]: Joining mDNS multicast group on interface eth0.IPv6 with address fe80::99bd:84fe:733:8d76.
Jun 12 16:29:09 raspberrypi avahi-daemon[331]: New relevant interface eth0.IPv6 for mDNS.
Jun 12 16:29:09 raspberrypi avahi-daemon[331]: Registering new address record for fe80::99bd:84fe:733:8d76 on eth0.*.
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: carrier acquired
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: IAID eb:de:05:30
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: adding address fe80::6992:1a45:7092:72a6
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: rebinding lease of 192.168.1.233
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: NAK: wrong address from 192.168.1.1
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: message: wrong address
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: soliciting a DHCP lease
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: offered 192.168.1.231 from 192.168.1.1
Jun 12 16:29:10 raspberrypi dhcpcd[370]: wlan0: probing address 192.168.1.231/24
Jun 12 16:29:11 raspberrypi dhcpcd[370]: wlan0: soliciting an IPv6 router
Jun 12 16:29:12 raspberrypi avahi-daemon[331]: Joining mDNS multicast group on interface wlan0.IPv6 with address fe80::6992:1a45:7092:72a6.
Jun 12 16:29:12 raspberrypi avahi-daemon[331]: New relevant interface wlan0.IPv6 for mDNS.
Jun 12 16:29:12 raspberrypi avahi-daemon[331]: Registering new address record for fe80::6992:1a45:7092:72a6 on wlan0.*.
Jun 12 16:29:13 raspberrypi btuart[374]: bcm43xx_init
Jun 12 16:29:13 raspberrypi btuart[374]: Flash firmware /lib/firmware/brcm/BCM4345C0.hcd
Jun 12 16:29:13 raspberrypi btuart[374]: Set BDADDR UART: b8:27:eb:21:fa:cf
Jun 12 16:29:13 raspberrypi btuart[374]: Set Controller UART speed to 3000000 bit/s
Jun 12 16:29:13 raspberrypi btuart[374]: Device setup complete
Jun 12 16:29:13 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:29:13 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 16:29:13 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:29:13 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 16:29:13 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 16:29:13 raspberrypi bluetoothd[495]: Bluetooth daemon 5.43
Jun 12 16:29:13 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 16:29:13 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 16:29:13 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 16:29:13 raspberrypi bluetoothd[495]: Starting SDP server
Jun 12 16:29:13 raspberrypi dbus[348]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 16:29:13 raspberrypi bluetoothd[495]: Bluetooth management interface 1.14 initialized
Jun 12 16:29:13 raspberrypi bluetoothd[495]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 16:29:13 raspberrypi bluetoothd[495]: Sap driver initialization failed.
Jun 12 16:29:13 raspberrypi bluetoothd[495]: sap-server: Operation not permitted (1)
Jun 12 16:29:13 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 16:29:13 raspberrypi bluetoothd[495]: Failed to set privacy: Rejected (0x0b)
Jun 12 16:29:13 raspberrypi dbus[348]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 16:29:13 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 16:29:14 raspberrypi dhcpcd[370]: eth0: leased 131.174.12.235 for 3600 seconds
Jun 12 16:29:14 raspberrypi avahi-daemon[331]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.12.235.
Jun 12 16:29:14 raspberrypi avahi-daemon[331]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 16:29:14 raspberrypi avahi-daemon[331]: Registering new address record for 131.174.12.235 on eth0.IPv4.
Jun 12 16:29:14 raspberrypi dhcpcd[370]: eth0: adding route to 131.174.12.0/24
Jun 12 16:29:14 raspberrypi dhcpcd[370]: eth0: adding default route via 131.174.12.1
Jun 12 16:29:14 raspberrypi dhcpcd[370]: Too few arguments.
Jun 12 16:29:14 raspberrypi dhcpcd[370]: Too few arguments.
Jun 12 16:29:14 raspberrypi dhcpcd[370]: Failed to get unit file state for ntp.service: No such file or directory
Jun 12 16:29:14 raspberrypi dhcpcd[370]: forked to background, child pid 564
Jun 12 16:29:14 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 16:29:14 raspberrypi systemd[1]: Reached target Network.
Jun 12 16:29:14 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 16:29:14 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 16:29:14 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 16:29:14 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 16:29:14 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 16:29:14 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 16:29:15 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 16:29:15 raspberrypi systemd[1]: nmbd.service: Supervising process 608 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:29:15 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 16:29:15 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 16:29:16 raspberrypi systemd[1]: smbd.service: Supervising process 610 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:29:16 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 16:29:16 raspberrypi dhcpcd[564]: wlan0: leased 192.168.1.231 for 86400 seconds
Jun 12 16:29:16 raspberrypi avahi-daemon[331]: Joining mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.231.
Jun 12 16:29:16 raspberrypi avahi-daemon[331]: New relevant interface wlan0.IPv4 for mDNS.
Jun 12 16:29:16 raspberrypi avahi-daemon[331]: Registering new address record for 192.168.1.231 on wlan0.IPv4.
Jun 12 16:29:16 raspberrypi dhcpcd[564]: wlan0: adding route to 192.168.1.0/24
Jun 12 16:29:16 raspberrypi dhcpcd[564]: wlan0: adding default route via 192.168.1.1
Jun 12 16:29:20 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 16:29:20 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 16:29:20 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 16:29:20 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 210 (plymouthd).
Jun 12 16:29:20 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 16:29:20 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 16:29:20 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 16:29:20 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 16:29:20 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 16:29:20 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 16:29:20 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 16:29:20 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 16:29:20 raspberrypi systemd[1]: Startup finished in 3.087s (kernel) + 17.537s (userspace) = 20.625s.
Jun 12 16:29:20 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 16:29:20 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 16:29:20 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 16:29:20 raspberrypi systemd[707]: Reached target Timers.
Jun 12 16:29:20 raspberrypi systemd[707]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 16:29:20 raspberrypi systemd[707]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 16:29:20 raspberrypi systemd[707]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 16:29:20 raspberrypi systemd[707]: Reached target Paths.
Jun 12 16:29:20 raspberrypi systemd[707]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 16:29:20 raspberrypi systemd[707]: Reached target Sockets.
Jun 12 16:29:20 raspberrypi systemd[707]: Reached target Basic System.
Jun 12 16:29:20 raspberrypi systemd[707]: Reached target Default.
Jun 12 16:29:20 raspberrypi systemd[707]: Startup finished in 102ms.
Jun 12 16:29:20 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 16:29:21 raspberrypi dhcpcd[564]: eth0: no IPv6 Routers available
Jun 12 16:29:24 raspberrypi dhcpcd[564]: wlan0: no IPv6 Routers available
Jun 12 16:35:19 raspberrypi systemd[1]: Time has been changed
Jun 12 16:35:19 raspberrypi systemd[707]: Time has been changed
Jun 12 16:35:19 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 49min 27.799217s random time.
Jun 12 16:35:19 raspberrypi systemd[1]: apt-daily.timer: Adding 6h 29min 55.871669s random time.
Jun 12 16:35:46 raspberrypi systemd[1]: Started Session c2 of user root.
Jun 12 16:36:37 raspberrypi systemd[1]: Started Session c3 of user root.
Jun 12 16:36:54 raspberrypi systemd[1]: Stopping Session c2 of user root.
Jun 12 16:36:54 raspberrypi systemd[1]: Stopping Save/Restore Sound Card State...
Jun 12 16:36:54 raspberrypi systemd[1]: Closed Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 16:36:54 raspberrypi systemd[1]: Stopped target Timers.
Jun 12 16:36:54 raspberrypi systemd[1]: Stopped Daily Cleanup of Temporary Directories.
Jun 12 16:36:54 raspberrypi systemd[1]: Unmounting RPC Pipe File System...
Jun 12 16:36:54 raspberrypi bluetoothd[495]: Terminating
Jun 12 16:36:54 raspberrypi systemd[1]: Stopped target Sound Card.
Jun 12 16:36:54 raspberrypi avahi-daJun 12 16:35:52 raspberrypi fake-hwclock[120]: Wed 12 Jun 14:29:04 UTC 2019
Jun 12 16:35:52 raspberrypi systemd[1]: Started Restore / save the current clock.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 16:35:52 raspberrypi systemd[1]: Time has been changed
Jun 12 16:35:52 raspberrypi systemd[1]: Starting File System Check on Root Device...
Jun 12 16:35:52 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 16:35:52 raspberrypi systemd-fsck[146]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 16:35:52 raspberrypi systemd-fsck[146]: rootfs: clean, 53759/451232 files, 412816/1904384 blocks
Jun 12 16:35:52 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 16:35:52 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 16:35:52 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 16:35:52 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 16:35:52 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 16:35:52 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 210 (plymouthd).
Jun 12 16:35:52 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Paths.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 16:35:52 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 16:35:52 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 16:35:52 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 16:35:52 raspberrypi systemd-fsck[240]: fsck.fat 4.1 (2017-01-24)
Jun 12 16:35:52 raspberrypi systemd-fsck[240]: 0x41: Dirty bit is set. Fs was not properly unmounted and some data may be corrupt.
Jun 12 16:35:52 raspberrypi systemd-fsck[240]:  Automatically removing dirty bit.
Jun 12 16:35:52 raspberrypi systemd-fsck[240]: Performing changes.
Jun 12 16:35:52 raspberrypi systemd-fsck[240]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 16:35:52 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:35:52 raspberrypi systemd[1]: Mounting /boot...
Jun 12 16:35:52 raspberrypi systemd[1]: Mounted /boot.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 16:35:52 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 16:35:52 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 16:35:52 raspberrypi systemd[1]: Time has been changed
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 16:35:52 raspberrypi systemd[1]: apt-daily.timer: Adding 10h 21min 15.220369s random time.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 16:35:52 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 16:35:52 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 16:35:52 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 8min 29.993661s random time.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Timers.
Jun 12 16:35:52 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 16:35:52 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 16:35:52 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 16:35:52 raspberrypi rng-tools[353]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 16:35:52 raspberrypi rngd[370]: rngd 2-unofficial-mt.14 starting up...
Jun 12 16:35:52 raspberrypi thd[358]: Found socket passed from systemd
Jun 12 16:35:52 raspberrypi rngd[370]: entropy feed to the kernel ready
Jun 12 16:35:52 raspberrypi avahi-daemon[361]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 16:35:52 raspberrypi avahi-daemon[361]: Successfully dropped root privileges.
Jun 12 16:35:52 raspberrypi avahi-daemon[361]: avahi-daemon 0.6.32 starting up.
Jun 12 16:35:52 raspberrypi avahi-daemon[361]: Successfully called chroot().
Jun 12 16:35:52 raspberrypi avahi-daemon[361]: Successfully dropped remaining capabilities.
Jun 12 16:35:52 raspberrypi avahi-daemon[361]: No service file found in /etc/avahi/services.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 16:35:52 raspberrypi avahi-daemon[361]: Network interface enumeration completed.
Jun 12 16:35:52 raspberrypi avahi-daemon[361]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 2205741488.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Login Service...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 16:35:52 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 16:35:52 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 16:35:52 raspberrypi dhcpcd[399]: dev: loaded udev
Jun 12 16:35:52 raspberrypi wpa_supplicant[395]: Successfully initialized wpa_supplicant
Jun 12 16:35:52 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Login Service.
Jun 12 16:35:52 raspberrypi dphys-swapfile[396]: Starting dphys-swapfile swapfile setup ...
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:35:52 raspberrypi raspi-config[348]: Checking if shift key is held down:Error opening '/dev/input/event*': No such file or directory
Jun 12 16:35:52 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 16:35:52 raspberrypi raspi-config[348]:  No. Switching to ondemand scaling governor.
Jun 12 16:35:52 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 16:35:52 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:35:52 raspberrypi dphys-swapfile[396]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 16:35:52 raspberrypi gpm[392]: Starting mouse interface server: gpm.
Jun 12 16:35:52 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 16:35:52 raspberrypi dhcpcd[399]: wlan0: starting wpa_supplicant
Jun 12 16:35:52 raspberrypi dhcpcd-run-hooks[446]: wlan0: starting wpa_supplicant
Jun 12 16:35:52 raspberrypi dphys-swapfile[396]: done.
Jun 12 16:35:52 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 16:35:52 raspberrypi dhcpcd[399]: eth0: waiting for carrier
Jun 12 16:35:52 raspberrypi dhcpcd[399]: wlan0: waiting for carrier
Jun 12 16:35:52 raspberrypi dhcpcd[399]: wlan0: carrier acquired
Jun 12 16:35:52 raspberrypi dhcpcd[399]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 16:35:53 raspberrypi dhcpcd[399]: wlan0: IAID eb:de:05:30
Jun 12 16:35:53 raspberrypi dhcpcd[399]: wlan0: adding address fe80::690e:a875:9ced:b218
Jun 12 16:35:53 raspberrypi dhcpcd[399]: wlan0: carrier lost
Jun 12 16:35:53 raspberrypi dhcpcd[399]: wlan0: deleting address fe80::690e:a875:9ced:b218
Jun 12 16:35:53 raspberrypi dhcpcd[399]: eth0: carrier acquired
Jun 12 16:35:53 raspberrypi dhcpcd[399]: eth0: IAID eb:8b:50:65
Jun 12 16:35:53 raspberrypi dhcpcd[399]: eth0: adding address fe80::99bd:84fe:733:8d76
Jun 12 16:35:53 raspberrypi dhcpcd[399]: eth0: rebinding lease of 131.174.12.235
Jun 12 16:35:53 raspberrypi dhcpcd[399]: eth0: NAK: requested address not available from 131.174.16.130
Jun 12 16:35:53 raspberrypi dhcpcd[399]: eth0: message: requested address not available
Jun 12 16:35:53 raspberrypi dhcpcd[399]: eth0: soliciting a DHCP lease
Jun 12 16:35:53 raspberrypi dhcpcd[399]: eth0: soliciting an IPv6 router
Jun 12 16:35:54 raspberrypi dhcpcd[399]: eth0: offered 131.174.142.142 from 131.174.30.59
Jun 12 16:35:54 raspberrypi dhcpcd[399]: eth0: probing address 131.174.142.142/24
Jun 12 16:35:54 raspberrypi avahi-daemon[361]: Joining mDNS multicast group on interface eth0.IPv6 with address fe80::99bd:84fe:733:8d76.
Jun 12 16:35:54 raspberrypi avahi-daemon[361]: New relevant interface eth0.IPv6 for mDNS.
Jun 12 16:35:54 raspberrypi avahi-daemon[361]: Registering new address record for fe80::99bd:84fe:733:8d76 on eth0.*.
Jun 12 16:35:55 raspberrypi dhcpcd[399]: wlan0: carrier acquired
Jun 12 16:35:55 raspberrypi dhcpcd[399]: wlan0: IAID eb:de:05:30
Jun 12 16:35:55 raspberrypi dhcpcd[399]: wlan0: adding address fe80::6992:1a45:7092:72a6
Jun 12 16:35:55 raspberrypi dhcpcd[399]: wlan0: soliciting an IPv6 router
Jun 12 16:35:55 raspberrypi dhcpcd[399]: wlan0: rebinding lease of 192.168.1.231
Jun 12 16:35:55 raspberrypi dhcpcd[399]: wlan0: probing address 192.168.1.231/24
Jun 12 16:35:57 raspberrypi avahi-daemon[361]: Joining mDNS multicast group on interface wlan0.IPv6 with address fe80::6992:1a45:7092:72a6.
Jun 12 16:35:57 raspberrypi avahi-daemon[361]: New relevant interface wlan0.IPv6 for mDNS.
Jun 12 16:35:57 raspberrypi avahi-daemon[361]: Registering new address record for fe80::6992:1a45:7092:72a6 on wlan0.*.
Jun 12 16:35:58 raspberrypi btuart[349]: bcm43xx_init
Jun 12 16:35:58 raspberrypi btuart[349]: Flash firmware /lib/firmware/brcm/BCM4345C0.hcd
Jun 12 16:35:58 raspberrypi btuart[349]: Set BDADDR UART: b8:27:eb:21:fa:cf
Jun 12 16:35:58 raspberrypi btuart[349]: Set Controller UART speed to 3000000 bit/s
Jun 12 16:35:58 raspberrypi btuart[349]: Device setup complete
Jun 12 16:35:58 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:35:58 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 16:35:58 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:35:58 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 16:35:58 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 16:35:58 raspberrypi bluetoothd[494]: Bluetooth daemon 5.43
Jun 12 16:35:58 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 16:35:58 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 16:35:58 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 16:35:58 raspberrypi bluetoothd[494]: Starting SDP server
Jun 12 16:35:58 raspberrypi bluetoothd[494]: Bluetooth management interface 1.14 initialized
Jun 12 16:35:58 raspberrypi dbus[362]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 16:35:58 raspberrypi bluetoothd[494]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 16:35:58 raspberrypi bluetoothd[494]: Sap driver initialization failed.
Jun 12 16:35:58 raspberrypi bluetoothd[494]: sap-server: Operation not permitted (1)
Jun 12 16:35:58 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 16:35:58 raspberrypi bluetoothd[494]: Failed to set privacy: Rejected (0x0b)
Jun 12 16:35:58 raspberrypi dbus[362]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 16:35:58 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 16:35:59 raspberrypi dhcpcd[399]: eth0: leased 131.174.142.142 for 3600 seconds
Jun 12 16:35:59 raspberrypi avahi-daemon[361]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.142.142.
Jun 12 16:35:59 raspberrypi avahi-daemon[361]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 16:35:59 raspberrypi avahi-daemon[361]: Registering new address record for 131.174.142.142 on eth0.IPv4.
Jun 12 16:35:59 raspberrypi dhcpcd[399]: eth0: adding route to 131.174.142.0/24
Jun 12 16:35:59 raspberrypi dhcpcd[399]: eth0: adding default route via 131.174.142.1
Jun 12 16:35:59 raspberrypi dhcpcd[399]: Too few arguments.
Jun 12 16:35:59 raspberrypi dhcpcd[399]: Too few arguments.
Jun 12 16:35:59 raspberrypi dhcpcd[399]: Failed to get unit file state for ntp.service: No such file or directory
Jun 12 16:35:59 raspberrypi dhcpcd[399]: forked to background, child pid 561
Jun 12 16:35:59 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 16:35:59 raspberrypi systemd[1]: Reached target Network.
Jun 12 16:35:59 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 16:35:59 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 16:35:59 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 16:35:59 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 16:35:59 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 16:35:59 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 16:35:59 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 16:36:00 raspberrypi systemd[1]: nmbd.service: Supervising process 600 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:36:00 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 16:36:00 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 16:36:01 raspberrypi systemd[1]: smbd.service: Supervising process 602 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:36:01 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 16:36:01 raspberrypi dhcpcd[561]: wlan0: leased 192.168.1.231 for 86400 seconds
Jun 12 16:36:01 raspberrypi avahi-daemon[361]: Joining mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.231.
Jun 12 16:36:01 raspberrypi avahi-daemon[361]: New relevant interface wlan0.IPv4 for mDNS.
Jun 12 16:36:01 raspberrypi avahi-daemon[361]: Registering new address record for 192.168.1.231 on wlan0.IPv4.
Jun 12 16:36:01 raspberrypi dhcpcd[561]: wlan0: adding route to 192.168.1.0/24
Jun 12 16:36:01 raspberrypi dhcpcd[561]: wlan0: adding default route via 192.168.1.1
Jun 12 16:36:05 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 16:36:05 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 16:36:05 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 16:36:05 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 210 (plymouthd).
Jun 12 16:36:05 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 16:36:05 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 16:36:05 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 16:36:05 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 16:36:05 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 16:36:05 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 16:36:05 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 16:36:05 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 16:36:05 raspberrypi systemd[1]: Startup finished in 3.677s (kernel) + 17.303s (userspace) = 20.980s.
Jun 12 16:36:05 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 16:36:05 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 16:36:05 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 16:36:05 raspberrypi systemd[698]: Reached target Timers.
Jun 12 16:36:05 raspberrypi systemd[698]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 16:36:05 raspberrypi systemd[698]: Reached target Paths.
Jun 12 16:36:05 raspberrypi systemd[698]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 16:36:05 raspberrypi systemd[698]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 16:36:05 raspberrypi systemd[698]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 16:36:05 raspberrypi systemd[698]: Reached target Sockets.
Jun 12 16:36:05 raspberrypi systemd[698]: Reached target Basic System.
Jun 12 16:36:05 raspberrypi systemd[698]: Reached target Default.
Jun 12 16:36:05 raspberrypi systemd[698]: Startup finished in 106ms.
Jun 12 16:36:05 raspberrypi systemd[1]: Started User Manager for UID 0.
                                                                                                                                                   Jun 12 16:35:51 raspberrypi fake-hwclock[116]: Wed 12 Jun 14:29:04 UTC 2019
Jun 12 16:35:51 raspberrypi systemd[1]: Time has been changed
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Create Static Device Nodes in /dev...
Jun 12 16:35:51 raspberrypi systemd[1]: Mounting Configuration File System...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Apply Kernel Variables...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting File System Check on Root Device...
Jun 12 16:35:51 raspberrypi systemd[1]: Mounted Configuration File System.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 16:35:51 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 16:35:51 raspberrypi systemd-fsck[144]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 16:35:51 raspberrypi systemd-fsck[144]: rootfs: clean, 53767/451232 files, 412852/1904384 blocks
Jun 12 16:35:51 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 16:35:51 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 16:35:51 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 16:35:51 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 16:35:51 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 16:35:51 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 210 (plymouthd).
Jun 12 16:35:51 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Paths.
Jun 12 16:35:51 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 16:35:51 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01...
Jun 12 16:35:51 raspberrypi systemd-fsck[233]: fsck.fat 4.1 (2017-01-24)
Jun 12 16:35:51 raspberrypi systemd-fsck[233]: 0x41: Dirty bit is set. Fs was not properly unmounted and some data may be corrupt.
Jun 12 16:35:51 raspberrypi systemd-fsck[233]:  Automatically removing dirty bit.
Jun 12 16:35:51 raspberrypi systemd-fsck[233]: Performing changes.
Jun 12 16:35:51 raspberrypi systemd-fsck[233]: /dev/mmcblk0p1: 310 files, 63163/86467 clusters
Jun 12 16:35:51 raspberrypi systemd[1]: Started File System Check on /dev/disk/by-partuuid/b93bee23-01.
Jun 12 16:35:51 raspberrypi systemd[1]: Mounting /boot...
Jun 12 16:35:51 raspberrypi systemd[1]: Mounted /boot.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Local File Systems.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Set console font and keymap...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Preprocess NFS configuration...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Create Volatile Files and Directories...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Tell Plymouth To Write Out Runtime Data...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Raise network interfaces...
Jun 12 16:35:51 raspberrypi systemd[1]: Started Set console font and keymap.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Preprocess NFS configuration.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Tell Plymouth To Write Out Runtime Data.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Create Volatile Files and Directories.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Sound Card.
Jun 12 16:35:51 raspberrypi systemd[1]: Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Update UTMP about System Boot/Shutdown...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Network Time Synchronization...
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target NFS client services.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Remote File Systems (Pre).
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Remote File Systems.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Update UTMP about System Boot/Shutdown.
Jun 12 16:35:51 raspberrypi systemd[1]: Time has been changed
Jun 12 16:35:51 raspberrypi systemd[1]: Started Network Time Synchronization.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target System Time Synchronized.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target System Initialization.
Jun 12 16:35:51 raspberrypi systemd[1]: Listening on Avahi mDNS/DNS-SD Stack Activation Socket.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Daily Cleanup of Temporary Directories.
Jun 12 16:35:51 raspberrypi systemd[1]: apt-daily.timer: Adding 1h 54min 50.037980s random time.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Daily apt download activities.
Jun 12 16:35:51 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 48min 34.050043s random time.
Jun 12 16:35:51 raspberrypi systemd[1]: Started Daily apt upgrade and clean activities.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Timers.
Jun 12 16:35:51 raspberrypi systemd[1]: Listening on D-Bus System Message Bus Socket.
Jun 12 16:35:51 raspberrypi systemd[1]: Listening on triggerhappy.socket.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Sockets.
Jun 12 16:35:51 raspberrypi systemd[1]: Reached target Basic System.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting System Logging Service...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting LSB: gpm sysv init script...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting rng-tools.service...
Jun 12 16:35:51 raspberrypi systemd[1]: Started Regular background program processing daemon.
Jun 12 16:35:51 raspberrypi systemd[1]: Starting LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Disable WiFi if country not set...
Jun 12 16:35:51 raspberrypi rng-tools[332]: Starting Hardware RNG entropy gatherer daemon: rngd.
Jun 12 16:35:51 raspberrypi rngd[347]: rngd 2-unofficial-mt.14 starting up...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting dhcpcd on all interfaces...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Save/Restore Sound Card State...
Jun 12 16:35:51 raspberrypi rngd[347]: entropy feed to the kernel ready
Jun 12 16:35:51 raspberrypi systemd[1]: Starting LSB: Autogenerate and use a swap file...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Configure Bluetooth Modems connected by UART...
Jun 12 16:35:51 raspberrypi systemd[1]: Starting Avahi mDNS/DNS-SD Stack...
Jun 12 16:35:51 raspberrypi systemd[1]: Started D-Bus System Message Bus.
Jun 12 16:35:51 raspberrypi dhcpcd[352]: dev: loaded udev
Jun 12 16:35:51 raspberrypi avahi-daemon[362]: Found user 'avahi' (UID 108) and group 'avahi' (GID 112).
Jun 12 16:35:51 raspberrypi avahi-daemon[362]: Successfully dropped root privileges.
Jun 12 16:35:51 raspberrypi avahi-daemon[362]: avahi-daemon 0.6.32 starting up.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Avahi mDNS/DNS-SD Stack.
Jun 12 16:35:52 raspberrypi avahi-daemon[362]: Successfully called chroot().
Jun 12 16:35:52 raspberrypi avahi-daemon[362]: Successfully dropped remaining capabilities.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting WPA supplicant...
Jun 12 16:35:52 raspberrypi avahi-daemon[362]: No service file found in /etc/avahi/services.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting triggerhappy global hotkey daemon...
Jun 12 16:35:52 raspberrypi dhcpcd[352]: wlan0: starting wpa_supplicant
Jun 12 16:35:52 raspberrypi avahi-daemon[362]: Network interface enumeration completed.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Login Service...
Jun 12 16:35:52 raspberrypi avahi-daemon[362]: Server startup complete. Host name is raspberrypi.local. Local service cookie is 1478261184.
Jun 12 16:35:52 raspberrypi systemd[1]: Started System Logging Service.
Jun 12 16:35:52 raspberrypi systemd[1]: Started rng-tools.service.
Jun 12 16:35:52 raspberrypi dhcpcd-run-hooks[411]: wlan0: starting wpa_supplicant
Jun 12 16:35:52 raspberrypi thd[410]: Found socket passed from systemd
Jun 12 16:35:52 raspberrypi systemd[1]: Started Disable WiFi if country not set.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Save/Restore Sound Card State.
Jun 12 16:35:52 raspberrypi systemd[1]: Started triggerhappy global hotkey daemon.
Jun 12 16:35:52 raspberrypi wpa_supplicant[409]: Successfully initialized wpa_supplicant
Jun 12 16:35:52 raspberrypi dphys-swapfile[359]: Starting dphys-swapfile swapfile setup ...
Jun 12 16:35:52 raspberrypi raspi-config[340]: Checking if shift key is held down:Error opening '/dev/input/event*': No such file or directory
Jun 12 16:35:52 raspberrypi raspi-config[340]:  No. Switching to ondemand scaling governor.
Jun 12 16:35:52 raspberrypi systemd[1]: Started WPA supplicant.
Jun 12 16:35:52 raspberrypi systemd[1]: Started Raise network interfaces.
Jun 12 16:35:52 raspberrypi systemd[1]: Started LSB: Switch to ondemand cpu governor (unless shift key is pressed).
Jun 12 16:35:52 raspberrypi systemd[1]: Started Login Service.
Jun 12 16:35:52 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:35:52 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:35:52 raspberrypi gpm[331]: Starting mouse interface server: gpm.
Jun 12 16:35:52 raspberrypi systemd[1]: Started LSB: gpm sysv init script.
Jun 12 16:35:52 raspberrypi dphys-swapfile[359]: want /var/swap=100MByte, checking existing: keeping it
Jun 12 16:35:52 raspberrypi dphys-swapfile[359]: done.
Jun 12 16:35:52 raspberrypi systemd[1]: Started LSB: Autogenerate and use a swap file.
Jun 12 16:35:52 raspberrypi dhcpcd[352]: eth0: waiting for carrier
Jun 12 16:35:52 raspberrypi dhcpcd[352]: wlan0: waiting for carrier
Jun 12 16:35:52 raspberrypi dhcpcd[352]: wlan0: carrier acquired
Jun 12 16:35:53 raspberrypi dhcpcd[352]: DUID 00:01:00:01:24:3d:de:29:b8:27:eb:de:05:30
Jun 12 16:35:53 raspberrypi dhcpcd[352]: wlan0: IAID eb:de:05:30
Jun 12 16:35:53 raspberrypi dhcpcd[352]: wlan0: adding address fe80::690e:a875:9ced:b218
Jun 12 16:35:53 raspberrypi dhcpcd[352]: wlan0: carrier lost
Jun 12 16:35:53 raspberrypi dhcpcd[352]: wlan0: deleting address fe80::690e:a875:9ced:b218
Jun 12 16:35:53 raspberrypi dhcpcd[352]: eth0: carrier acquired
Jun 12 16:35:53 raspberrypi dhcpcd[352]: eth0: IAID eb:8b:50:65
Jun 12 16:35:53 raspberrypi dhcpcd[352]: eth0: adding address fe80::99bd:84fe:733:8d76
Jun 12 16:35:53 raspberrypi dhcpcd[352]: eth0: soliciting an IPv6 router
Jun 12 16:35:53 raspberrypi systemd-udevd[475]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:35:53 raspberrypi dhcpcd[352]: eth0: rebinding lease of 131.174.142.142
Jun 12 16:35:53 raspberrypi dhcpcd[352]: eth0: probing address 131.174.142.142/24
Jun 12 16:35:54 raspberrypi avahi-daemon[362]: Joining mDNS multicast group on interface eth0.IPv6 with address fe80::99bd:84fe:733:8d76.
Jun 12 16:35:54 raspberrypi avahi-daemon[362]: New relevant interface eth0.IPv6 for mDNS.
Jun 12 16:35:54 raspberrypi avahi-daemon[362]: Registering new address record for fe80::99bd:84fe:733:8d76 on eth0.*.
Jun 12 16:35:55 raspberrypi systemd-udevd[479]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:35:55 raspberrypi systemd-udevd[477]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 16:35:58 raspberrypi btuart[360]: bcm43xx_init
Jun 12 16:35:58 raspberrypi btuart[360]: Flash firmware /lib/firmware/brcm/BCM4345C0.hcd
Jun 12 16:35:58 raspberrypi btuart[360]: Set BDADDR UART: b8:27:eb:21:fa:cf
Jun 12 16:35:58 raspberrypi btuart[360]: Set Controller UART speed to 3000000 bit/s
Jun 12 16:35:58 raspberrypi btuart[360]: Device setup complete
Jun 12 16:35:58 raspberrypi systemd[1]: Starting Load/Save RF Kill Switch Status...
Jun 12 16:35:58 raspberrypi systemd[1]: Started Configure Bluetooth Modems connected by UART.
Jun 12 16:35:58 raspberrypi systemd[1]: Started Load/Save RF Kill Switch Status.
Jun 12 16:35:58 raspberrypi systemd[1]: Created slice system-bthelper.slice.
Jun 12 16:35:58 raspberrypi systemd[1]: Starting Bluetooth service...
Jun 12 16:35:58 raspberrypi bluetoothd[497]: Bluetooth daemon 5.43
Jun 12 16:35:58 raspberrypi systemd[1]: Started Bluetooth service.
Jun 12 16:35:58 raspberrypi systemd[1]: Reached target Bluetooth.
Jun 12 16:35:58 raspberrypi bluetoothd[497]: Starting SDP server
Jun 12 16:35:58 raspberrypi systemd[1]: Started Raspberry Pi bluetooth helper.
Jun 12 16:35:58 raspberrypi dbus[368]: [system] Activating via systemd: service name='org.freedesktop.hostname1' unit='dbus-org.freedesktop.hostname1.service'
Jun 12 16:35:58 raspberrypi bluetoothd[497]: Bluetooth management interface 1.14 initialized
Jun 12 16:35:58 raspberrypi bluetoothd[497]: Failed to obtain handles for "Service Changed" characteristic
Jun 12 16:35:58 raspberrypi bluetoothd[497]: Sap driver initialization failed.
Jun 12 16:35:58 raspberrypi bluetoothd[497]: sap-server: Operation not permitted (1)
Jun 12 16:35:58 raspberrypi systemd[1]: Starting Hostname Service...
Jun 12 16:35:58 raspberrypi dhcpcd[352]: eth0: leased 131.174.142.142 for 3552 seconds
Jun 12 16:35:58 raspberrypi dhcpcd[352]: eth0: adding route to 131.174.142.0/24
Jun 12 16:35:58 raspberrypi dhcpcd[352]: eth0: adding default route via 131.174.142.1
Jun 12 16:35:58 raspberrypi avahi-daemon[362]: Joining mDNS multicast group on interface eth0.IPv4 with address 131.174.142.142.
Jun 12 16:35:58 raspberrypi avahi-daemon[362]: New relevant interface eth0.IPv4 for mDNS.
Jun 12 16:35:59 raspberrypi avahi-daemon[362]: Registering new address record for 131.174.142.142 on eth0.IPv4.
Jun 12 16:35:59 raspberrypi dbus[368]: [system] Successfully activated service 'org.freedesktop.hostname1'
Jun 12 16:35:59 raspberrypi systemd[1]: Started Hostname Service.
Jun 12 16:35:59 raspberrypi dhcpcd[352]: Too few arguments.
Jun 12 16:35:59 raspberrypi dhcpcd[352]: Too few arguments.
Jun 12 16:35:59 raspberrypi dhcpcd[352]: Failed to get unit file state for ntp.service: No such file or directory
Jun 12 16:35:59 raspberrypi dhcpcd[352]: forked to background, child pid 570
Jun 12 16:35:59 raspberrypi systemd[1]: Started dhcpcd on all interfaces.
Jun 12 16:35:59 raspberrypi systemd[1]: Reached target Network.
Jun 12 16:35:59 raspberrypi systemd[1]: Starting OpenBSD Secure Shell server...
Jun 12 16:35:59 raspberrypi systemd[1]: Reached target Network is Online.
Jun 12 16:35:59 raspberrypi systemd[1]: Starting Samba NMB Daemon...
Jun 12 16:35:59 raspberrypi systemd[1]: Starting /etc/rc.local Compatibility...
Jun 12 16:35:59 raspberrypi systemd[1]: Starting Permit User Sessions...
Jun 12 16:35:59 raspberrypi systemd[1]: Started Permit User Sessions.
Jun 12 16:35:59 raspberrypi systemd[1]: Started OpenBSD Secure Shell server.
Jun 12 16:36:00 raspberrypi systemd[1]: nmbd.service: Supervising process 611 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:36:00 raspberrypi systemd[1]: Started Samba NMB Daemon.
Jun 12 16:36:00 raspberrypi systemd[1]: Starting Samba SMB Daemon...
Jun 12 16:36:01 raspberrypi systemd[1]: smbd.service: Supervising process 613 which is not our child. We'll most likely not notice when it exits.
Jun 12 16:36:01 raspberrypi systemd[1]: Started Samba SMB Daemon.
Jun 12 16:36:05 raspberrypi systemd[1]: Started /etc/rc.local Compatibility.
Jun 12 16:36:05 raspberrypi systemd[1]: Starting Hold until boot process finishes up...
Jun 12 16:36:05 raspberrypi systemd[1]: Starting Terminate Plymouth Boot Screen...
Jun 12 16:36:05 raspberrypi systemd[1]: Received SIGRTMIN+21 from PID 210 (plymouthd).
Jun 12 16:36:05 raspberrypi systemd[1]: Started Hold until boot process finishes up.
Jun 12 16:36:05 raspberrypi systemd[1]: Started Terminate Plymouth Boot Screen.
Jun 12 16:36:05 raspberrypi systemd[1]: Started Getty on tty1.
Jun 12 16:36:05 raspberrypi systemd[1]: Reached target Login Prompts.
Jun 12 16:36:05 raspberrypi systemd[1]: Reached target Multi-User System.
Jun 12 16:36:05 raspberrypi systemd[1]: Reached target Graphical Interface.
Jun 12 16:36:05 raspberrypi systemd[1]: Starting Update UTMP about System Runlevel Changes...
Jun 12 16:36:05 raspberrypi systemd[1]: Started Update UTMP about System Runlevel Changes.
Jun 12 16:36:05 raspberrypi systemd[1]: Startup finished in 3.427s (kernel) + 17.621s (userspace) = 21.048s.
Jun 12 16:36:05 raspberrypi systemd[1]: Created slice User Slice of root.
Jun 12 16:36:05 raspberrypi systemd[1]: Starting User Manager for UID 0...
Jun 12 16:36:05 raspberrypi systemd[1]: Started Session c1 of user root.
Jun 12 16:36:05 raspberrypi systemd[654]: Reached target Timers.
Jun 12 16:36:05 raspberrypi systemd[654]: Listening on GnuPG cryptographic agent and passphrase cache.
Jun 12 16:36:05 raspberrypi systemd[654]: Listening on GnuPG cryptographic agent (access for web browsers).
Jun 12 16:36:05 raspberrypi systemd[654]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 16:36:05 raspberrypi systemd[654]: Reached target Paths.
Jun 12 16:36:05 raspberrypi systemd[654]: Listening on GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 16:36:05 raspberrypi systemd[654]: Reached target Sockets.
Jun 12 16:36:05 raspberrypi systemd[654]: Reached target Basic System.
Jun 12 16:36:05 raspberrypi systemd[654]: Reached target Default.
Jun 12 16:36:05 raspberrypi systemd[654]: Startup finished in 103ms.
Jun 12 16:36:05 raspberrypi systemd[1]: Started User Manager for UID 0.
Jun 12 16:36:07 raspberrypi dhcpcd[570]: eth0: no IPv6 Routers available
Jun 12 16:39:39 raspberrypi systemd[1]: Time has been changed
Jun 12 16:39:39 raspberrypi systemd[654]: Time has been changed
Jun 12 16:39:39 raspberrypi systemd[1]: apt-daily.timer: Adding 2h 41min 39.379441s random time.
Jun 12 16:39:39 raspberrypi systemd[1]: apt-daily-upgrade.timer: Adding 23min 47.297279s random time.
Jun 12 16:54:34 raspberrypi systemd[1]: Starting Cleanup of Temporary Directories...
Jun 12 16:54:34 raspberrypi systemd[1]: Started Cleanup of Temporary Directories.
Jun 12 17:26:39 raspberrypi systemd[1]: Started Session c2 of user root.
Jun 12 17:39:09 raspberrypi rngd[347]: stats: bits received from HRNG source: 80064
Jun 12 17:39:09 raspberrypi rngd[347]: stats: bits sent to kernel pool: 35360
Jun 12 17:39:09 raspberrypi rngd[347]: stats: entropy added to kernel pool: 35360
Jun 12 17:39:09 raspberrypi rngd[347]: stats: FIPS 140-2 successes: 4
Jun 12 17:39:09 raspberrypi rngd[347]: stats: FIPS 140-2 failures: 0
Jun 12 17:39:09 raspberrypi rngd[347]: stats: FIPS 140-2(2001-10-10) Monobit: 0
Jun 12 17:39:09 raspberrypi rngd[347]: stats: FIPS 140-2(2001-10-10) Poker: 0
Jun 12 17:39:09 raspberrypi rngd[347]: stats: FIPS 140-2(2001-10-10) Runs: 0
Jun 12 17:39:09 raspberrypi rngd[347]: stats: FIPS 140-2(2001-10-10) Long run: 0
Jun 12 17:39:09 raspberrypi rngd[347]: stats: FIPS 140-2(2001-10-10) Continuous run: 0
Jun 12 17:39:09 raspberrypi rngd[347]: stats: HRNG source speed: (min=256.198; avg=373.781; max=856.972)Kibits/s
Jun 12 17:39:09 raspberrypi rngd[347]: stats: FIPS tests speed: (min=4.926; avg=6.278; max=7.104)Mibits/s
Jun 12 17:39:09 raspberrypi rngd[347]: stats: Lowest ready-buffers level: 2
Jun 12 17:39:10 raspberrypi rngd[347]: stats: Entropy starvations: 0
Jun 12 17:39:10 raspberrypi rngd[347]: stats: Time spent starving for entropy: (min=0; avg=0.000; max=0)us
Jun 12 17:39:10 raspberrypi systemd[1]: Closed Load/Save RF Kill Switch Status /dev/rfkill Watch.
Jun 12 17:39:10 raspberrypi systemd[1]: Stopping Session c1 of user root.
Jun 12 17:39:10 raspberrypi systemd[1]: Stopping User Manager for UID 0...
Jun 12 17:39:10 raspberrypi systemd[1]: Stopped target Graphical Interface.
Jun 12 17:39:10 raspberrypi systemd[1]: Stopped target Multi-User System.
Jun 12 17:39:10 raspberrypi systemd[1]: Stopping LSB: Autogenerate and use a swap file...
Jun 12 17:39:10 raspberrypi systemd[1]: Stopping Regular background program processing daemon...
Jun 12 17:39:10 raspberrypi systemd[1]: Stopping Samba SMB Daemon...
Jun 12 17:39:10 raspberrypi avahi-daemon[362]: Got SIGTERM, quitting.
Jun 12 17:39:10 raspberrypi systemd[1]: Stopping LSB: Switch to ondemand cpu governor (unless shift key is pressed)...
Jun 12 17:39:10 raspberrypi avahi-daemon[362]: Leaving mDNS multicast group on interface eth0.IPv6 with address fe80::99bd:84fe:733:8d76.
Jun 12 17:39:10 raspberrypi systemd[1]: Stopped target Sound Card.
Jun 12 17:39:10 raspberrypi avahi-daemon[362]: Leaving mDNS multicast group on interface eth0.IPv4 with address 131.174.142.142.
Jun 12 17:39:10 raspberrypi systemd[654]: Stopped target Default.
Jun 12 17:39:10 raspberrypi avahi-daemon[362]: avahi-daemon 0.6.32 exiting.
Jun 12 17:39:10 raspberrypi systemd[654]: Stopped target Basic System.
Jun 12 17:39:10 raspberrypi systemd[654]: Stopped target Paths.
Jun 12 17:39:10 raspberrypi systemd[654]: Stopped target Sockets.
Jun 12 17:39:10 raspberrypi systemd[654]: Closed GnuPG cryptographic agent and passphrase cache.
Jun 12 17:39:10 raspberrypi systemd[654]: Closed GnuPG cryptographic agent (ssh-agent emulation).
Jun 12 17:39:10 raspberrypi systemd[654]: Closed GnuPG cryptographic agent and passphrase cache (restricted).
Jun 12 17:39:10 raspberrypi systemd[654]: Closed GnuPG cryptographic agent (access for web browsers).
Jun 12 17:39:10 raspberrypi systemd[654]: Reached target Shutdown.
Jun 12 17:39:10 raspberrypi systemd[654]: Starting Exit the Session...
Jun 12 17:39:10 raspberrypi systemd[654]: Stopped target Timers.
Jun 12 17:39:10 raspberrypi systemd[1]: Stopping Avahi mDNS/DNS-SD Stack...
Jun 12 17:39:10 raspberrypi systemd[1]: Stopping Configure Bluetooth Modems connected by UART...
Jun 12 17:39:15 raspberrypi fake-hwclock[123]: Wed 12 Jun 15:39:12 UTC 2019
Jun 12 17:39:15 raspberrypi systemd[1]: Started Apply Kernel Variables.
Jun 12 17:39:15 raspberrypi systemd[1]: Started File System Check Daemon to report status.
Jun 12 17:39:15 raspberrypi systemd-fsck[141]: e2fsck 1.43.4 (31-Jan-2017)
Jun 12 17:39:15 raspberrypi systemd-fsck[141]: rootfs: clean, 52216/99424 files, 357834/395520 blocks
Jun 12 17:39:15 raspberrypi systemd[1]: Started Create Static Device Nodes in /dev.
Jun 12 17:39:15 raspberrypi systemd[1]: Started File System Check on Root Device.
Jun 12 17:39:15 raspberrypi systemd[1]: Starting Remount Root and Kernel File Systems...
Jun 12 17:39:15 raspberrypi systemd[1]: Starting udev Kernel Device Manager...
Jun 12 17:39:15 raspberrypi systemd[1]: Started Set the console keyboard layout.
Jun 12 17:39:15 raspberrypi systemd[1]: Started Remount Root and Kernel File Systems.
Jun 12 17:39:15 raspberrypi systemd[1]: Starting Load/Save Random Seed...
Jun 12 17:39:15 raspberrypi systemd[1]: Starting udev Coldplug all Devices...
Jun 12 17:39:15 raspberrypi systemd[1]: Starting Flush Journal to Persistent Storage...
Jun 12 17:39:15 raspberrypi systemd[1]: Reached target Local File Systems (Pre).
Jun 12 17:39:15 raspberrypi systemd[1]: Started udev Kernel Device Manager.
Jun 12 17:39:15 raspberrypi systemd[1]: Started Load/Save Random Seed.
Jun 12 17:39:15 raspberrypi systemd[1]: Started Flush Journal to Persistent Storage.
Jun 12 17:39:15 raspberrypi systemd[1]: Started udev Coldplug all Devices.
Jun 12 17:39:15 raspberrypi systemd[1]: Starting Show Plymouth Boot Screen...
Jun 12 17:39:15 raspberrypi systemd[1]: Received SIGRTMIN+20 from PID 200 (plymouthd).
Jun 12 17:39:15 raspberrypi systemd[1]: Started Show Plymouth Boot Screen.
Jun 12 17:39:15 raspberrypi systemd[1]: Reached target Encrypted Volumes.
Jun 12 17:39:15 raspberrypi systemd[1]: Reached target Paths.
Jun 12 17:39:15 raspberrypi systemd[1]: Started Forward Password Requests to Plymouth Directory Watch.
Jun 12 17:39:15 raspberrypi systemd-udevd[166]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 17:39:15 raspberrypi systemd-udevd[162]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 17:39:15 raspberrypi systemd-udevd[168]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 17:39:15 raspberrypi systemd-udevd[167]: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
Jun 12 17:39:15 raspberrypi systemd[1]: Found device /dev/serial1.
Jun 12 17:39:15 raspberrypi systemd[1]: Found device /dev/disk/by-partuuid/b93bee23-01.
Jun 12 17:39:15 raspberrypi systemd[1]: Starting File System Check on /dev/disk/by-partuuid/b93bee23-01..."     call Decho("edit-a-file: handle optional Funcrefs",'~'.expand("<slnum>"))
     if type(g:Netrw_funcref) == 2
"      call Decho("edit-a-file: handling a g:Netrw_funcref",'~'.expand("<slnum>"))
      NetrwKeepj call g:Netrw_funcref()
     elseif type(g:Netrw_funcref) == 3
"      call Decho("edit-a-file: handling a list of g:Netrw_funcrefs",'~'.expand("<slnum>"))
      for Fncref in g:Netrw_funcref
       if type(FncRef) == 2
        NetrwKeepj call FncRef()
       endif
      endfor
     endif
    endif
   endif

  elseif newdir =~ '^/'
   " ----------------------------------------------------
   " NetrwBrowseChgDir: just go to the new directory spec {{{3
   " ----------------------------------------------------
"   call Decho('goto-newdir: case "just go to new directory spec": newdir<'.newdir.'>','~'.expand("<slnum>"))
   let dirname = newdir
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
   NetrwKeepj call s:NetrwOptionRestore("s:")
   norm! m`

  elseif newdir == './'
   " ---------------------------------------------
   " NetrwBrowseChgDir: refresh the directory list {{{3
   " ---------------------------------------------
"   call Decho('refresh-dirlist: case "refresh directory listing": newdir == "./"','~'.expand("<slnum>"))
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
   norm! m`

  elseif newdir == '../'
   " --------------------------------------
   " NetrwBrowseChgDir: go up one directory {{{3
   " --------------------------------------
"   call Decho('go-up: case "go up one directory": newdir == "../"','~'.expand("<slnum>"))

   if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
    " force a refresh
"    call Decho("go-up: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
"    call Decho("go-up: setl noro ma",'~'.expand("<slnum>"))
    setl noro ma
    NetrwKeepj %d _
   endif

   if has("amiga")
    " amiga
"    call Decho('go-up: case "go up one directory": newdir == "../" and amiga','~'.expand("<slnum>"))
    if a:islocal
     let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
     let dirname= substitute(dirname,'/$','','')
    else
     let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
    endif
"    call Decho("go-up: amiga: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))

   elseif !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    " windows
    if a:islocal
     let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
     if dirname == ""
      let dirname= '/'
     endif
    else
     let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
    endif
    if dirname =~ '^\a:$'
     let dirname= dirname.'/'
    endif
"    call Decho("go-up: windows: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))

   else
    " unix or cygwin
"    call Decho('go-up: case "go up one directory": newdir == "../" and unix or cygwin','~'.expand("<slnum>"))
    if a:islocal
     let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
     if dirname == ""
      let dirname= '/'
     endif
    else
     let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
    endif
"    call Decho("go-up: unix: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
   endif
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
   norm m`

  elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " --------------------------------------
   " NetrwBrowseChgDir: Handle Tree Listing {{{3
   " --------------------------------------
"   call Decho('tree-list: case liststyle is TREELIST and w:netrw_treedict exists','~'.expand("<slnum>"))
   " force a refresh (for TREELIST, NetrwTreeDir() will force the refresh)
"   call Decho("tree-list: setl noro ma",'~'.expand("<slnum>"))
   setl noro ma
   if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
"    call Decho("tree-list: clear buffer<".expand("%")."> with :%d  (force refresh)",'~'.expand("<slnum>"))
    NetrwKeepj %d _
   endif
   let treedir      = s:NetrwTreeDir(a:islocal)
"   call Decho("tree-list: treedir<".treedir.">",'~'.expand("<slnum>"))
   let s:treecurpos = nbcd_curpos
   let haskey       = 0
"   call Decho("tree-list: w:netrw_treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))

   " search treedict for tree dir as-is
"   call Decho("tree-list: search treedict for tree dir as-is",'~'.expand("<slnum>"))
   if has_key(w:netrw_treedict,treedir)
"    call Decho('tree-list: ....searched for treedir<'.treedir.'> : found it!','~'.expand("<slnum>"))
    let haskey= 1
   else
"    call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
   endif

   " search treedict for treedir with a [/@] appended
"   call Decho("tree-list: search treedict for treedir with a [/@] appended",'~'.expand("<slnum>"))
   if !haskey && treedir !~ '[/@]$'
    if has_key(w:netrw_treedict,treedir."/")
     let treedir= treedir."/"
"     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
     let haskey = 1
    else
"     call Decho('tree-list: ....searched for treedir<'.treedir.'/> : not found','~'.expand("<slnum>"))
    endif
   endif

   " search treedict for treedir with any trailing / elided
"   call Decho("tree-list: search treedict for treedir with any trailing / elided",'~'.expand("<slnum>"))
   if !haskey && treedir =~ '/$'
    let treedir= substitute(treedir,'/$','','')
    if has_key(w:netrw_treedict,treedir)
"     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
     let haskey = 1
    else
"     call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
    endif
   endif

"   call Decho("haskey=".haskey,'~'.expand("<slnum>"))
   if haskey
    " close tree listing for selected subdirectory
"    call Decho("tree-list: closing selected subdirectory<".dirname.">",'~'.expand("<slnum>"))
    call remove(w:netrw_treedict,treedir)
"    call Decho("tree-list: removed     entry<".treedir."> from treedict",'~'.expand("<slnum>"))
"    call Decho("tree-list: yielding treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))
    let dirname= w:netrw_treetop
   else
    " go down one directory
    let dirname= substitute(treedir,'/*$','/','')
"    call Decho("tree-list: go down one dir: treedir<".treedir.">",'~'.expand("<slnum>"))
"    call Decho("tree-list: ...            : dirname<".dirname.">",'~'.expand("<slnum>"))
   endif
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
"   call Decho("setting s:treeforceredraw to true",'~'.expand("<slnum>"))
   let s:treeforceredraw = 1

  else
   " ----------------------------------------
   " NetrwBrowseChgDir: Go down one directory {{{3
   " ----------------------------------------
   let dirname    = s:ComposePath(dirname,newdir)
"   call Decho("go down one dir: dirname<".dirname."> newdir<".newdir.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
   norm m`
  endif

 " --------------------------------------
 " NetrwBrowseChgDir: Restore and Cleanup {{{3
 " --------------------------------------
  if dorestore
   " dorestore is zero'd when a local file was hidden or bufhidden;
   " in such a case, we want to keep whatever settings it may have.
"   call Decho("doing option restore (dorestore=".dorestore.")",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwOptionRestore("s:")
"  else " Decho
"   call Decho("skipping option restore (dorestore==0): hidden=".&hidden." bufhidden=".&bufhidden." mod=".&mod,'~'.expand("<slnum>"))
  endif
  if dolockout && dorestore
"   call Decho("restore: filewritable(dirname<".dirname.">)=".filewritable(dirname),'~'.expand("<slnum>"))
   if filewritable(dirname)
"    call Decho("restore: doing modification lockout settings: ma nomod noro",'~'.expand("<slnum>"))
"    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
    setl ma noro nomod
"    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   else
"    call Decho("restore: doing modification lockout settings: ma nomod ro",'~'.expand("<slnum>"))
"    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
    setl ma ro nomod
"    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   endif
  endif
  let @@= ykeep

"  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
  return dirname
endfun

" ---------------------------------------------------------------------
" s:NetrwBrowseUpDir: implements the "-" mappings {{{2
"    for thin, long, and wide: cursor placed just after banner
"    for tree, keeps cursor on current filename
fun! s:NetrwBrowseUpDir(islocal)
"  call Dfunc("s:NetrwBrowseUpDir(islocal=".a:islocal.")")
  if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt-1
   " this test needed because occasionally this function seems to be incorrectly called
   " when multiple leftmouse clicks are taken when atop the one line help in the banner.
   " I'm allowing the very bottom line to permit a "-" exit so that one may escape empty
   " directories.
"   call Dret("s:NetrwBrowseUpDir : cursor not in file area")
   return
  endif

  norm! 0
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
"   call Decho("case: treestyle",'~'.expand("<slnum>"))
   let curline= getline(".")
   let swwline= winline() - 1
   if exists("w:netrw_treetop")
    let b:netrw_curdir= w:netrw_treetop
   endif
   let curdir= b:netrw_curdir
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
   else
    call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
   endif
   if !search('\c^'.s:treedepthstring.curline,'cw')
    if !search('\c^'.curline,'cw')
     sil! NetrwKeepj 1
    endif
   endif
   exe "sil! NetrwKeepj norm! z\<cr>"
   while winline() < swwline
    let curwinline= winline()
    exe "sil! NetrwKeepj norm! \<c-y>"
    if curwinline == winline()
     break
    endif
   endwhile
  else
"   call Decho("case: not treestyle",'~'.expand("<slnum>"))
   if exists("b:netrw_curdir")
    let curdir= b:netrw_curdir
   else
    let curdir= expand(getcwd())
   endif
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
   else
    call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
   endif
   if exists("w:netrw_bannercnt")
"    call Decho("moving to line#".w:netrw_bannercnt,'~'.expand("<slnum>"))
    exe w:netrw_bannercnt
   else
    1
   endif
  endif
  let curdir= substitute(curdir,'^.*[\/]','','')
  call search('\<'.curdir.'\>','wc')
"  call Dret("s:NetrwBrowseUpDir")
endfun

" ---------------------------------------------------------------------
" netrw#BrowseX:  (implements "x") executes a special "viewer" script or program for the {{{2
"              given filename; typically this means given their extension.
"              0=local, 1=remote
fun! netrw#BrowseX(fname,remote)
"  call Dfunc("netrw#BrowseX(fname<".a:fname."> remote=".a:remote.")")

  " if its really just a directory, then do a "gf" instead
  if (a:remote == 0 && isdirectory(a:fname)) || (a:remote == 1 && fname =~ '/$' && fname !~ '^https\=:')
   norm! gf
"   call Dret("netrw#BrowseX : did gf instead")
  endif


  let ykeep      = @@
  let screenposn = winsaveview()
"  call Decho("saving posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))

  " need to save and restore aw setting as gx can invoke this function from non-netrw buffers
  let awkeep     = &aw
  set noaw

  " special core dump handler
  if a:fname =~ '/core\(\.\d\+\)\=$'
   if exists("g:Netrw_corehandler")
    if type(g:Netrw_corehandler) == 2
     " g:Netrw_corehandler is a function reference (see :help Funcref)
"     call Decho("g:Netrw_corehandler is a funcref",'~'.expand("<slnum>"))
     call g:Netrw_corehandler(s:NetrwFile(a:fname))
    elseif type(g:Netrw_corehandler) == 3
     " g:Netrw_corehandler is a List of function references (see :help Funcref)
"     call Decho("g:Netrw_corehandler is a List",'~'.expand("<slnum>"))
     for Fncref in g:Netrw_corehandler
      if type(FncRef) == 2
       call FncRef(a:fname)
      endif
     endfor
    endif
"    call Decho("restoring posn to screenposn<".string(screenposn).">,'~'.expand("<slnum>"))"
    call winrestview(screenposn)
    let @@= ykeep
    let &aw= awkeep
"    call Dret("netrw#BrowseX : coredump handler invoked")
    return
   endif
  endif

  " set up the filename
  " (lower case the extension, make a local copy of a remote file)
  let exten= substitute(a:fname,'.*\.\(.\{-}\)','\1','e')
  if has("win32") || has("win95") || has("win64") || has("win16")
   let exten= substitute(exten,'^.*$','\L&\E','')
  endif
"  call Decho("exten<".exten.">",'~'.expand("<slnum>"))

  if a:remote == 1
   " create a local copy
"   call Decho("remote: a:remote=".a:remote.": create a local copy of <".a:fname.">",'~'.expand("<slnum>"))
   setl bh=delete
   call netrw#NetRead(3,a:fname)
   " attempt to rename tempfile
   let basename= substitute(a:fname,'^\(.*\)/\(.*\)\.\([^.]*\)$','\2','')
   let newname = substitute(s:netrw_tmpfile,'^\(.*\)/\(.*\)\.\([^.]*\)$','\1/'.basename.'.\3','')
"   call Decho("basename<".basename.">",'~'.expand("<slnum>"))
"   call Decho("newname <".newname.">",'~'.expand("<slnum>"))
   if rename(s:netrw_tmpfile,newname) == 0
    " renaming succeeded
    let fname= newname
   else
    " renaming failed
    let fname= s:netrw_tmpfile
   endif
  else
"   call Decho("local: a:remote=".a:remote.": handling local copy of <".a:fname.">",'~'.expand("<slnum>"))
   let fname= a:fname
   " special ~ handler for local
   if fname =~ '^\~' && expand("$HOME") != ""
"    call Decho('invoking special ~ handler','~'.expand("<slnum>"))
    let fname= s:NetrwFile(substitute(fname,'^\~',expand("$HOME"),''))
   endif
  endif
"  call Decho("fname<".fname.">",'~'.expand("<slnum>"))
"  call Decho("exten<".exten."> "."netrwFileHandlers#NFH_".exten."():exists=".exists("*netrwFileHandlers#NFH_".exten),'~'.expand("<slnum>"))

  " set up redirection
  if &srr =~ "%s"
   if (has("win32") || has("win95") || has("win64") || has("win16"))
    let redir= substitute(&srr,"%s","nul","")
   else
    let redir= substitute(&srr,"%s","/dev/null","")
   endif
  elseif (has("win32") || has("win95") || has("win64") || has("win16"))
   let redir= &srr . "nul"
  else
   let redir= &srr . "/dev/null"
  endif
"  call Decho("set up redirection: redir{".redir."} srr{".&srr."}",'~'.expand("<slnum>"))

  " extract any viewing options.  Assumes that they're set apart by quotes.
"  call Decho("extract any viewing options",'~'.expand("<slnum>"))
  if exists("g:netrw_browsex_viewer")
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
   if g:netrw_browsex_viewer =~ '\s'
    let viewer  = substitute(g:netrw_browsex_viewer,'\s.*$','','')
    let viewopt = substitute(g:netrw_browsex_viewer,'^\S\+\s*','','')." "
    let oviewer = ''
    let cnt     = 1
    while !executable(viewer) && viewer != oviewer
     let viewer  = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\1','')
     let viewopt = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\3','')." "
     let cnt     = cnt + 1
     let oviewer = viewer
"     call Decho("!exe: viewer<".viewer.">  viewopt<".viewopt.">",'~'.expand("<slnum>"))
    endwhile
   else
    let viewer  = g:netrw_browsex_viewer
    let viewopt = ""
   endif
"   call Decho("viewer<".viewer.">  viewopt<".viewopt.">",'~'.expand("<slnum>"))
  endif

  " execute the file handler
"  call Decho("execute the file handler (if any)",'~'.expand("<slnum>"))
  if exists("g:netrw_browsex_viewer") && g:netrw_browsex_viewer == '-'
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
   let ret= netrwFileHandlers#Invoke(exten,fname)

  elseif exists("g:netrw_browsex_viewer") && executable(viewer)
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !".viewer." ".viewopt.s:ShellEscape(fname,1).redir)
   let ret= v:shell_error

  elseif has("win32") || has("win64")
"   call Decho("windows",'~'.expand("<slnum>"))
   if executable("start")
    call s:NetrwExe('sil! !start rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(fname,1))
   elseif executable("rundll32")
    call s:NetrwExe('sil! !rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(fname,1))
   else
    call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
   endif
   call inputsave()|call input("Press <cr> to continue")|call inputrestore()
   let ret= v:shell_error

  elseif has("win32unix")
   let winfname= 'c:\cygwin'.substitute(fname,'/','\\','g')
"   call Decho("cygwin: winfname<".s:ShellEscape(winfname,1).">",'~'.expand("<slnum>"))
   if executable("start")
    call s:NetrwExe('sil !start rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(winfname,1))
   elseif executable("rundll32")
    call s:NetrwExe('sil !rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(winfname,1))
   elseif executable("cygstart")
    call s:NetrwExe('sil !cygstart '.s:ShellEscape(fname,1))
   else
    call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
   endif
   call inputsave()|call input("Press <cr> to continue")|call inputrestore()
   let ret= v:shell_error

  elseif has("unix") && executable("kfmclient") && s:CheckIfKde()
"   call Decho("unix and kfmclient",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !kfmclient exec ".s:ShellEscape(fname,1)." ".redir)
   let ret= v:shell_error

  elseif has("unix") && executable("exo-open") && executable("xdg-open") && executable("setsid")
"   call Decho("unix, exo-open, xdg-open",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !setsid xdg-open ".s:ShellEscape(fname,1).redir)
   let ret= v:shell_error

  elseif has("unix") && executable("xdg-open")
"   call Decho("unix and xdg-open",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !xdg-open ".s:ShellEscape(fname,1).redir)
   let ret= v:shell_error

  elseif has("macunix") && executable("open")
"   call Decho("macunix and open",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !open ".s:ShellEscape(fname,1)." ".redir)
   let ret= v:shell_error

  else
   " netrwFileHandlers#Invoke() always returns 0
   let ret= netrwFileHandlers#Invoke(exten,fname)
  endif

  " if unsuccessful, attempt netrwFileHandlers#Invoke()
  if ret
   let ret= netrwFileHandlers#Invoke(exten,fname)
  endif

  " restoring redraw! after external file handlers
  redraw!

  " cleanup: remove temporary file,
  "          delete current buffer if success with handler,
  "          return to prior buffer (directory listing)
  "          Feb 12, 2008: had to de-activiate removal of
  "          temporary file because it wasn't getting seen.
"  if a:remote == 1 && fname != a:fname
""   call Decho("deleting temporary file<".fname.">",'~'.expand("<slnum>"))
"   call s:NetrwDelete(fname)
"  endif

  if a:remote == 1
   setl bh=delete bt=nofile
   if g:netrw_use_noswf
    setl noswf
   endif
   exe "sil! NetrwKeepj norm! \<c-o>"
"   redraw!
  endif
"  call Decho("restoring posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
  call winrestview(screenposn)
  let @@ = ykeep
  let &aw= awkeep

"  call Dret("netrw#BrowseX")
endfun

" ---------------------------------------------------------------------
" netrw#BrowseXVis: used by gx in visual mode to select a file for browsing {{{2
fun! netrw#BrowseXVis()
"  call Dfunc("netrw#BrowseXVis()")
  let atkeep = @@
  norm! gvy
"  call Decho("@@<".@@.">",'~'.expand("<slnum>"))
  call netrw#BrowseX(@@,netrw#CheckIfRemote())
  let @@     = atkeep
"  call Dret("netrw#BrowseXVis")
endfun

" ---------------------------------------------------------------------
" netrw#CheckIfRemote: returns 1 if current file looks like an url, 0 else {{{2
fun! netrw#CheckIfRemote()
"  call Dfunc("netrw#CheckIfRemote()")
  if expand("%") =~ '^\a\{3,}://'
"   call Dret("netrw#CheckIfRemote 1")
   return 1
  else
"   call Dret("netrw#CheckIfRemote 0")
   return 0
  endif
endfun

" ---------------------------------------------------------------------
" s:NetrwChgPerm: (implements "gp") change file permission {{{2
fun! s:NetrwChgPerm(islocal,curdir)
"  call Dfunc("s:NetrwChgPerm(islocal=".a:islocal." curdir<".a:curdir.">)")
  let ykeep  = @@
  call inputsave()
  let newperm= input("Enter new permission: ")
  call inputrestore()
  let chgperm= substitute(g:netrw_chgperm,'\<FILENAME\>',s:ShellEscape(expand("<cfile>")),'')
  let chgperm= substitute(chgperm,'\<PERM\>',s:ShellEscape(newperm),'')
"  call Decho("chgperm<".chgperm.">",'~'.expand("<slnum>"))
  call system(chgperm)
  if v:shell_error != 0
   NetrwKeepj call netrw#ErrorMsg(1,"changing permission on file<".expand("<cfile>")."> seems to have failed",75)
  endif
  if a:islocal
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  endif
  let @@= ykeep
"  call Dret("s:NetrwChgPerm")
endfun

" ---------------------------------------------------------------------
" s:CheckIfKde: checks if kdeinit is running {{{2
"    Returns 0: kdeinit not running
"            1: kdeinit is  running
fun! s:CheckIfKde()
"  call Dfunc("s:CheckIfKde()")
  " seems kde systems often have gnome-open due to dependencies, even though
  " gnome-open's subsidiary display tools are largely absent.  Kde systems
  " usually have "kdeinit" running, though...  (tnx Mikolaj Machowski)
  if !exists("s:haskdeinit")
   if has("unix") && executable("ps") && !has("win32unix")
    let s:haskdeinit= system("ps -e") =~ '\<kdeinit'
    if v:shell_error
     let s:haskdeinit = 0
    endif
   else
    let s:haskdeinit= 0
   endif
"   call Decho("setting s:haskdeinit=".s:haskdeinit,'~'.expand("<slnum>"))
  endif

"  call Dret("s:CheckIfKde ".s:haskdeinit)
  return s:haskdeinit
endfun

" ---------------------------------------------------------------------
" s:NetrwClearExplore: clear explore variables (if any) {{{2
fun! s:NetrwClearExplore()
"  call Dfunc("s:NetrwClearExplore()")
  2match none
  if exists("s:explore_match")        |unlet s:explore_match        |endif
  if exists("s:explore_indx")         |unlet s:explore_indx         |endif
  if exists("s:netrw_explore_prvdir") |unlet s:netrw_explore_prvdir |endif
  if exists("s:dirstarstar")          |unlet s:dirstarstar          |endif
  if exists("s:explore_prvdir")       |unlet s:explore_prvdir       |endif
  if exists("w:netrw_explore_indx")   |unlet w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_listlen")|unlet w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_list")   |unlet w:netrw_explore_list   |endif
  if exists("w:netrw_explore_bufnr")  |unlet w:netrw_explore_bufnr  |endif
"   redraw!
  echo " "
  echo " "
"  call Dret("s:NetrwClearExplore")
endfun

" ---------------------------------------------------------------------
" s:NetrwExploreListUniq: {{{2
fun! s:NetrwExploreListUniq(explist)
"  call Dfunc("s:NetrwExploreListUniq(explist<".string(a:explist).">)")

  " this assumes that the list is already sorted
  let newexplist= []
  for member in a:explist
   if !exists("uniqmember") || member != uniqmember
    let uniqmember = member
    let newexplist = newexplist + [ member ]
   endif
  endfor

"  call Dret("s:NetrwExploreListUniq newexplist<".string(newexplist).">")
  return newexplist
endfun

" ---------------------------------------------------------------------
" s:NetrwForceChgDir: (gd support) Force treatment as a directory {{{2
fun! s:NetrwForceChgDir(islocal,newdir)
"  call Dfunc("s:NetrwForceChgDir(islocal=".a:islocal." newdir<".a:newdir.">)")
  let ykeep= @@
  if a:newdir !~ '/$'
   " ok, looks like force is needed to get directory-style treatment
   if a:newdir =~ '@$'
    let newdir= substitute(a:newdir,'@$','/','')
   elseif a:newdir =~ '[*=|\\]$'
    let newdir= substitute(a:newdir,'.$','/','')
   else
    let newdir= a:newdir.'/'
   endif
"   call Decho("adjusting newdir<".newdir."> due to gd",'~'.expand("<slnum>"))
  else
   " should already be getting treatment as a directory
   let newdir= a:newdir
  endif
  let newdir= s:NetrwBrowseChgDir(a:islocal,newdir)
  call s:NetrwBrowse(a:islocal,newdir)
  let @@= ykeep
"  call Dret("s:NetrwForceChgDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwGlob: does glob() if local, remote listing otherwise {{{2
fun! s:NetrwGlob(direntry,expr)
"  call Dfunc("s:NetrwGlob(direntry<".a:direntry."> expr<".a:expr.">)")
  if netrw#CheckIfRemote()
   keepalt 1sp
   keepalt enew
   let keep_liststyle    = w:netrw_liststyle
   let w:netrw_liststyle = s:THINLIST
   if s:NetrwRemoteListing() == 0
    keepj keepalt %s@/@@
    let filelist= getline(1,$)
    q!
   else
    " remote listing error -- leave treedict unchanged
    let filelist= w:netrw_treedict[a:direntry]
   endif
   let w:netrw_liststyle= keep_liststyle
  else
   let filelist= glob(s:ComposePath(a:direntry,a:expr),0,1,1)
   let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
  endif
"  call Dret("s:NetrwGlob ".string(filelist))
  return filelist
endfun

" ---------------------------------------------------------------------
" s:NetrwForceFile: (gf support) Force treatment as a file {{{2
fun! s:NetrwForceFile(islocal,newfile)
"  call Dfunc("s:NetrwForceFile(islocal=".a:islocal." newdir<".a:newfile.">)")
  if a:newfile =~ '[/@*=|\\]$'
   let newfile= substitute(a:newfile,'.$','','')
  else
   let newfile= a:newfile
  endif
  if a:islocal
   call s:NetrwBrowseChgDir(a:islocal,newfile)
  else
   call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,newfile))
  endif
"  call Dret("s:NetrwForceFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwHide: this function is invoked by the "a" map for browsing {{{2
"          and switches the hiding mode.  The actual hiding is done by
"          s:NetrwListHide().
"             g:netrw_hide= 0: show all
"                           1: show not-hidden files
"                           2: show hidden files only
fun! s:NetrwHide(islocal)
"  call Dfunc("NetrwHide(islocal=".a:islocal.") g:netrw_hide=".g:netrw_hide)
  let ykeep= @@
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{bufnr('%')}")
"   call Decho("((g:netrw_hide == 1)? "unhide" : "hide")." files in markfilelist<".string(s:netrwmarkfilelist_{bufnr("%")}).">",'~'.expand("<slnum>"))
"   call Decho("g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))

   " hide the files in the markfile list
   for fname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("match(g:netrw_list_hide<".g:netrw_list_hide.'> fname<\<'.fname.'\>>)='.match(g:netrw_list_hide,'\<'.fname.'\>')." l:isk=".&l:isk,'~'.expand("<slnum>"))
    if match(g:netrw_list_hide,'\<'.fname.'\>') != -1
     " remove fname from hiding list
     let g:netrw_list_hide= substitute(g:netrw_list_hide,'..\<'.escape(fname,g:netrw_fname_escape).'\>..','','')
     let g:netrw_list_hide= substitute(g:netrw_list_hide,',,',',','g')
     let g:netrw_list_hide= substitute(g:netrw_list_hide,'^,\|,$','','')
"     call Decho("unhide: g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
    else
     " append fname to hiding list
     if exists("g:netrw_list_hide") && g:netrw_list_hide != ""
      let g:netrw_list_hide= g:netrw_list_hide.',\<'.escape(fname,g:netrw_fname_escape).'\>'
     else
      let g:netrw_list_hide= '\<'.escape(fname,g:netrw_fname_escape).'\>'
     endif
"     call Decho("hide: g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
    endif
   endfor
   NetrwKeepj call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
   let g:netrw_hide= 1

  else

   " switch between show-all/show-not-hidden/show-hidden
   let g:netrw_hide=(g:netrw_hide+1)%3
   exe "NetrwKeepj norm! 0"
   if g:netrw_hide && g:netrw_list_hide == ""
    NetrwKeepj call netrw#ErrorMsg(s:WARNING,"your hiding list is empty!",49)
    let @@= ykeep
"    call Dret("NetrwHide")
    return
   endif
  endif

  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep
"  call Dret("NetrwHide")
endfun

" ---------------------------------------------------------------------
" s:NetrwHideEdit: allows user to edit the file/directory hiding list {{{2
fun! s:NetrwHideEdit(islocal)
"  call Dfunc("NetrwHideEdit(islocal=".a:islocal.")")

  let ykeep= @@
  " save current cursor position
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  " get new hiding list from user
  call inputsave()
  let newhide= input("Edit Hiding List: ",g:netrw_list_hide)
  call inputrestore()
  let g:netrw_list_hide= newhide
"  call Decho("new g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))

  " refresh the listing
  sil NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,"./"))

  " restore cursor position
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)
  let @@= ykeep

"  call Dret("NetrwHideEdit")
endfun

" ---------------------------------------------------------------------
" s:NetrwHidden: invoked by "gh" {{{2
fun! s:NetrwHidden(islocal)
"  call Dfunc("s:NetrwHidden()")
  let ykeep= @@
  "  save current position
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  if g:netrw_list_hide =~ '\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+'
   " remove pattern from hiding list
   let g:netrw_list_hide= substitute(g:netrw_list_hide,'\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+','','')
  elseif s:Strlen(g:netrw_list_hide) >= 1
   let g:netrw_list_hide= g:netrw_list_hide . ',\(^\|\s\s\)\zs\.\S\+'
  else
   let g:netrw_list_hide= '\(^\|\s\s\)\zs\.\S\+'
  endif

  " refresh screen and return to saved position
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep
"  call Dret("s:NetrwHidden")
endfun

" ---------------------------------------------------------------------
"  s:NetrwHome: this function determines a "home" for saving bookmarks and history {{{2
fun! s:NetrwHome()
  if exists("g:netrw_home")
   let home= g:netrw_home
  else
   " go to vim plugin home
   for home in split(&rtp,',') + ['']
    if isdirectory(s:NetrwFile(home)) && filewritable(s:NetrwFile(home)) | break | endif
     let basehome= substitute(home,'[/\\]\.vim$','','')
     if isdirectory(s:NetrwFile(basehome)) && filewritable(s:NetrwFile(basehome))
     let home= basehome."/.vim"
     break
    endif
   endfor
   if home == ""
    " just pick the first directory
    let home= substitute(&rtp,',.*$','','')
   endif
   if (has("win32") || has("win95") || has("win64") || has("win16"))
    let home= substitute(home,'/','\\','g')
   endif
  endif
  " insure that the home directory exists
  if g:netrw_dirhistmax > 0 && !isdirectory(s:NetrwFile(home))
   if exists("g:netrw_mkdir")
    call system(g:netrw_mkdir." ".s:ShellEscape(s:NetrwFile(home)))
   else
    call mkdir(home)
   endif
  endif
  let g:netrw_home= home
  return home
endfun

" ---------------------------------------------------------------------
" s:NetrwLeftmouse: handles the <leftmouse> when in a netrw browsing window {{{2
fun! s:NetrwLeftmouse(islocal)
  if exists("s:netrwdrag")
   return
  endif
"  call Dfunc("s:NetrwLeftmouse(islocal=".a:islocal.")")

  let ykeep= @@
  " check if the status bar was clicked on instead of a file/directory name
  while getchar(0) != 0
   "clear the input stream
  endwhile
  call feedkeys("\<LeftMouse>")
  let c          = getchar()
  let mouse_lnum = v:mouse_lnum
  let wlastline  = line('w$')
  let lastline   = line('$')
"  call Decho("v:mouse_lnum=".mouse_lnum." line(w$)=".wlastline." line($)=".lastline." v:mouse_win=".v:mouse_win." winnr#".winnr(),'~'.expand("<slnum>"))
"  call Decho("v:mouse_col =".v:mouse_col."     col=".col(".")."  wincol =".wincol()." winwidth   =".winwidth(0),'~'.expand("<slnum>"))
  if mouse_lnum >= wlastline + 1 || v:mouse_win != winnr()
   " appears to be a status bar leftmouse click
   let @@= ykeep
"   call Dret("s:NetrwLeftmouse : detected a status bar leftmouse click")
   return
  endif
   " Dec 04, 2013: following test prevents leftmouse selection/deselection of directories and files in treelist mode
   " Windows are separated by vertical separator bars - but the mouse seems to be doing what it should when dragging that bar
   " without this test when its disabled.
   " May 26, 2014: edit file, :Lex, resize window -- causes refresh.  Reinstated a modified test.  See if problems develop.
"   call Decho("v:mouse_col=".v:mouse_col." col#".col('.')." virtcol#".virtcol('.')." col($)#".col("$")." virtcol($)#".virtcol("$"),'~'.expand("<slnum>"))
   if v:mouse_col > virtcol('.')
    let @@= ykeep
"    call Dret("s:NetrwLeftmouse : detected a vertical separator bar leftmouse click")
    return
   endif

  if a:islocal
   if exists("b:netrw_curdir")
    NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   endif
  else
   if exists("b:netrw_curdir")
    NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwLeftmouse")
endfun

" ---------------------------------------------------------------------
" s:NetrwCLeftmouse: used to select a file/directory for a target {{{2
fun! s:NetrwCLeftmouse(islocal)
"  call Dfunc("s:NetrwCLeftmouse(islocal=".a:islocal.")")
  call s:NetrwMarkFileTgt(a:islocal)
"  call Dret("s:NetrwCLeftmouse")
endfun

" ---------------------------------------------------------------------
" s:NetrwServerEdit: edit file in a server gvim, usually NETRWSERVER  (implements <c-r>){{{2
"   a:islocal=0 : <c-r> not used, remote
"   a:islocal=1 : <c-r> no  used, local
"   a:islocal=2 : <c-r>     used, remote
"   a:islocal=3 : <c-r>     used, local
fun! s:NetrwServerEdit(islocal,fname)
"  call Dfunc("s:NetrwServerEdit(islocal=".a:islocal.",fname<".a:fname.">)")
  let islocal = a:islocal%2      " =0: remote           =1: local
  let ctrlr   = a:islocal >= 2   " =0: <c-r> not used   =1: <c-r> used
"  call Decho("islocal=".islocal." ctrlr=".ctrlr,'~'.expand("<slnum>"))

  if (islocal && isdirectory(s:NetrwFile(a:fname))) || (!islocal && a:fname =~ '/$')
   " handle directories in the local window -- not in the remote vim server
   " user must have closed the NETRWSERVER window.  Treat as normal editing from netrw.
"   call Decho("handling directory in client window",'~'.expand("<slnum>"))
   let g:netrw_browse_split= 0
   if exists("s:netrw_browse_split") && exists("s:netrw_browse_split_".winnr())
    let g:netrw_browse_split= s:netrw_browse_split_{winnr()}
    unlet s:netrw_browse_split_{winnr()}
   endif
   call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,a:fname))
"   call Dret("s:NetrwServerEdit")
   return
  endif

"  call Decho("handling file in server window",'~'.expand("<slnum>"))
  if has("clientserver") && executable("gvim")
"   call Decho("has clientserver and gvim",'~'.expand("<slnum>"))

    if exists("g:netrw_browse_split") && type(g:netrw_browse_split) == 3
"     call Decho("g:netrw_browse_split=".string(g:netrw_browse_split),'~'.expand("<slnum>"))
     let srvrname = g:netrw_browse_split[0]
     let tabnum   = g:netrw_browse_split[1]
     let winnum   = g:netrw_browse_split[2]

     if serverlist() !~ '\<'.srvrname.'\>'
"      call Decho("server not available; ctrlr=".ctrlr,'~'.expand("<slnum>"))

      if !ctrlr
       " user must have closed the server window and the user did not use <c-r>, but
       " used something like <cr>.
"       call Decho("user must have closed server AND did not use ctrl-r",'~'.expand("<slnum>"))
       if exists("g:netrw_browse_split")
	unlet g:netrw_browse_split
       endif
       let g:netrw_browse_split= 0
       if exists("s:netrw_browse_split_".winnr())
        let g:netrw_browse_split= s:netrw_browse_split_{winnr()}
       endif
       call s:NetrwBrowseChgDir(islocal,a:fname)
"       call Dret("s:NetrwServerEdit")
       return

      elseif has("win32") && executable("start")
       " start up remote netrw server under windows
"       call Decho("starting up gvim server<".srvrname."> for windows",'~'.expand("<slnum>"))
       call system("start gvim --servername ".srvrname)

      else
       " start up remote netrw server under linux
"       call Decho("starting up gvim server<".srvrname.">",'~'.expand("<slnum>"))
       call system("gvim --servername ".srvrname)
      endif
     endif

"     call Decho("srvrname<".srvrname."> tabnum=".tabnum." winnum=".winnum." server-editing<".a:fname.">",'~'.expand("<slnum>"))
     call remote_send(srvrname,":tabn ".tabnum."\<cr>")
     call remote_send(srvrname,":".winnum."wincmd w\<cr>")
     call remote_send(srvrname,":e ".fnameescape(s:NetrwFile(a:fname))."\<cr>")

    else

     if serverlist() !~ '\<'.g:netrw_servername.'\>'

      if !ctrlr
"       call Decho("server<".g:netrw_servername."> not available and ctrl-r not used",'~'.expand("<slnum>"))
       if exists("g:netrw_browse_split")
	unlet g:netrw_browse_split
       endif
       let g:netrw_browse_split= 0
       call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,a:fname))
"       call Dret("s:NetrwServerEdit")
       return

      else
"       call Decho("server<".g:netrw_servername."> not available but ctrl-r used",'~'.expand("<slnum>"))
       if has("win32") && executable("start")
        " start up remote netrw server under windows
"        call Decho("starting up gvim server<".g:netrw_servername."> for windows",'~'.expand("<slnum>"))
        call system("start gvim --servername ".g:netrw_servername)
       else
        " start up remote netrw server under linux
"        call Decho("starting up gvim server<".g:netrw_servername.">",'~'.expand("<slnum>"))
        call system("gvim --servername ".g:netrw_servername)
       endif
      endif
     endif

     while 1
      try
"       call Decho("remote-send: e ".a:fname,'~'.expand("<slnum>"))
       call remote_send(g:netrw_servername,":e ".fnameescape(s:NetrwFile(a:fname))."\<cr>")
       break
      catch /^Vim\%((\a\+)\)\=:E241/
       sleep 200m
      endtry
     endwhile

     if exists("g:netrw_browse_split")
      if type(g:netrw_browse_split) != 3
        let s:netrw_browse_split_{winnr()}= g:netrw_browse_split
       endif
      unlet g:netrw_browse_split
     endif
     let g:netrw_browse_split= [g:netrw_servername,1,1]
    endif

   else
    call netrw#ErrorMsg(s:ERROR,"you need a gui-capable vim and client-server to use <ctrl-r>",98)
   endif

"  call Dret("s:NetrwServerEdit")
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftmouse: marks the file under the cursor.  May be dragged to select additional files {{{2
fun! s:NetrwSLeftmouse(islocal)
"  call Dfunc("s:NetrwSLeftmouse(islocal=".a:islocal.")")

  let s:ngw= s:NetrwGetWord()
  call s:NetrwMarkFile(a:islocal,s:ngw)

"  call Dret("s:NetrwSLeftmouse")
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftdrag: invoked via a shift-leftmouse and dragging {{{2
"                   Used to mark multiple files.
fun! s:NetrwSLeftdrag(islocal)
"  call Dfunc("s:NetrwSLeftdrag(islocal=".a:islocal.")")
  if !exists("s:netrwdrag")
   let s:netrwdrag = winnr()
   if a:islocal
    nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(1)<cr>
   else
    nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(0)<cr>
   endif
  endif
  let ngw = s:NetrwGetWord()
  if !exists("s:ngw") || s:ngw != ngw
   call s:NetrwMarkFile(a:islocal,ngw)
  endif
  let s:ngw= ngw
"  call Dret("s:NetrwSLeftdrag : s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftrelease: terminates shift-leftmouse dragging {{{2
fun! s:NetrwSLeftrelease(islocal)
"  call Dfunc("s:NetrwSLeftrelease(islocal=".a:islocal.") s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
  if exists("s:netrwdrag")
   nunmap <s-leftrelease>
   let ngw = s:NetrwGetWord()
   if !exists("s:ngw") || s:ngw != ngw
    call s:NetrwMarkFile(a:islocal,ngw)
   endif
   if exists("s:ngw")
    unlet s:ngw
   endif
   unlet s:netrwdrag
  endif
"  call Dret("s:NetrwSLeftrelease")
endfun

" ---------------------------------------------------------------------
" s:NetrwListHide: uses [range]g~...~d to delete files that match comma {{{2
" separated patterns given in g:netrw_list_hide
fun! s:NetrwListHide()
"  call Dfunc("s:NetrwListHide() g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
  let ykeep= @@

  " find a character not in the "hide" string to use as a separator for :g and :v commands
  " How-it-works: take the hiding command, convert it into a range.  Duplicate
  " characters don't matter.  Remove all such characters from the '/~...90'
  " string.  Use the first character left as a separator character.
  let listhide= g:netrw_list_hide
  let sep     = strpart(substitute('/~@#$%^&*{};:,<.>?|1234567890','['.escape(listhide,'-]^\').']','','ge'),1,1)
"  call Decho("sep=".sep,'~'.expand("<slnum>"))

  while listhide != ""
   if listhide =~ ','
    let hide     = substitute(listhide,',.*$','','e')
    let listhide = substitute(listhide,'^.\{-},\(.*\)$','\1','e')
   else
    let hide     = listhide
    let listhide = ""
   endif

   " Prune the list by hiding any files which match
   if g:netrw_hide == 1
"    call Decho("hiding<".hide."> listhide<".listhide.">",'~'.expand("<slnum>"))
    exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'d'
   elseif g:netrw_hide == 2
"    call Decho("showing<".hide."> listhide<".listhide.">",'~'.expand("<slnum>"))
    exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'s@^@ /-KEEP-/ @'
   endif
  endwhile
  if g:netrw_hide == 2
   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$v@^ /-KEEP-/ @d'
   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s@^\%( /-KEEP-/ \)\+@@e'
  endif

  " remove any blank lines that have somehow remained.
  " This seems to happen under Windows.
  exe 'sil! NetrwKeepj 1,$g@^\s*$@d'

  let @@= ykeep
"  call Dret("s:NetrwListHide")
endfun

" ---------------------------------------------------------------------
" s:NetrwMakeDir: this function makes a directory (both local and remote) {{{2
"                 implements the "d" mapping.
fun! s:NetrwMakeDir(usrhost)
"  call Dfunc("s:NetrwMakeDir(usrhost<".a:usrhost.">)")

  let ykeep= @@
  " get name of new directory from user.  A bare <CR> will skip.
  " if its currently a directory, also request will be skipped, but with
  " a message.
  call inputsave()
  let newdirname= input("Please give directory name: ")
  call inputrestore()
"  call Decho("newdirname<".newdirname.">",'~'.expand("<slnum>"))

  if newdirname == ""
   let @@= ykeep
"   call Dret("s:NetrwMakeDir : user aborted with bare <cr>")
   return
  endif

  if a:usrhost == ""
"   call Decho("local mkdir",'~'.expand("<slnum>"))

   " Local mkdir:
   " sanity checks
   let fullnewdir= b:netrw_curdir.'/'.newdirname
"   call Decho("fullnewdir<".fullnewdir.">",'~'.expand("<slnum>"))
   if isdirectory(s:NetrwFile(fullnewdir))
    if !exists("g:netrw_quiet")
     NetrwKeepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a directory!",24)
    endif
    let @@= ykeep
"    call Dret("s:NetrwMakeDir : directory<".newdirname."> exists previously")
    return
   endif
   if s:FileReadable(fullnewdir)
    if !exists("g:netrw_quiet")
     NetrwKeepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a file!",25)
    endif
    let @@= ykeep
"    call Dret("s:NetrwMakeDir : file<".newdirname."> exists previously")
    return
   endif

   " requested new local directory is neither a pre-existing file or
   " directory, so make it!
   if exists("*mkdir")
    if has("unix")
     call mkdir(fullnewdir,"p",xor(0777, system("umask")))
    else
     call mkdir(fullnewdir,"p")
    endif
   else
    let netrw_origdir= s:NetrwGetcwd(1)
    call s:NetrwLcd(b:netrw_curdir)
"    call Decho("netrw_origdir<".netrw_origdir.">: lcd b:netrw_curdir<".fnameescape(b:netrw_curdir).">",'~'.expand("<slnum>"))
    call s:NetrwExe("sil! !".g:netrw_localmkdir.' '.s:ShellEscape(newdirname,1))
    if v:shell_error != 0
     let @@= ykeep
     call netrw#ErrorMsg(s:ERROR,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
"     call Dret("s:NetrwMakeDir : failed: sil! !".g:netrw_localmkdir.' '.s:ShellEscape(newdirname,1))
     return
    endif
    if !g:netrw_keepdir
"     call Decho("restoring netrw_origdir since g:netrw_keepdir=".g:netrw_keepdir,'~'.expand("<slnum>"))
     call s:NetrwLcd(netrw_origdir)
    endif
   endif

   if v:shell_error == 0
    " refresh listing
"    call Decho("refresh listing",'~'.expand("<slnum>"))
    let svpos= winsaveview()
"    call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
"    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    call winrestview(svpos)
   elseif !exists("g:netrw_quiet")
    call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",26)
   endif
"   redraw!

  elseif !exists("b:netrw_method") || b:netrw_method == 4
   " Remote mkdir:  using ssh
"   call Decho("remote mkdir",'~'.expand("<slnum>"))
   let mkdircmd  = s:MakeSshCmd(g:netrw_mkdir_cmd)
   let newdirname= substitute(b:netrw_curdir,'^\%(.\{-}/\)\{3}\(.*\)$','\1','').newdirname
   call s:NetrwExe("sil! !".mkdircmd." ".s:ShellEscape(newdirname,1))
   if v:shell_error == 0
    " refresh listing
    let svpos= winsaveview()
"    call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    NetrwKeepj call winrestview(svpos)
   elseif !exists("g:netrw_quiet")
    NetrwKeepj call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",27)
   endif
"   redraw!

  elseif b:netrw_method == 2
   " Remote mkdir:  using ftp+.netrc
   let svpos= winsaveview()
"   call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
"   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
   if exists("b:netrw_fname")
"    call Decho("b:netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
    let remotepath= b:netrw_fname
   else
    let remotepath= ""
   endif
   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
   NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)

  elseif b:netrw_method == 3
   " Remote mkdir: using ftp + machine, id, passwd, and fname (ie. no .netrc)
   let svpos= winsaveview()
"   call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
"   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
   if exists("b:netrw_fname")
"    call Decho("b:netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
    let remotepath= b:netrw_fname
   else
    let remotepath= ""
   endif
   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
   NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  endif

  let @@= ykeep
"  call Dret("s:NetrwMakeDir")
endfun

" ---------------------------------------------------------------------
" s:TreeSqueezeDir: allows a shift-cr (gvim only) to squeeze the current tree-listing directory {{{2
fun! s:TreeSqueezeDir(islocal)
"  call Dfunc("s:TreeSqueezeDir(islocal=".a:islocal.")")
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " its a tree-listing style
   let curdepth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
   let stopline = (exists("w:netrw_bannercnt")? (w:netrw_bannercnt + 1) : 1)
   let depth    = strchars(substitute(curdepth,' ','','g'))
   let srch     = -1
"   call Decho("curdepth<".curdepth.'>','~'.expand("<slnum>"))
"   call Decho("depth   =".depth,'~'.expand("<slnum>"))
"   call Decho("stopline#".stopline,'~'.expand("<slnum>"))
"   call Decho("curline#".line(".")."<".getline('.').'>','~'.expand("<slnum>"))
   if depth >= 2
    NetrwKeepj norm! 0
    let curdepthm1= substitute(curdepth,'^'.s:treedepthstring,'','')
    let srch      = search('^'.curdepthm1.'\%('.s:treedepthstring.'\)\@!','bW',stopline)
"    call Decho("curdepthm1<".curdepthm1.'>','~'.expand("<slnum>"))
"    call Decho("case depth>=2: srch<".srch.'>','~'.expand("<slnum>"))
   elseif depth == 1
    NetrwKeepj norm! 0
    let treedepthchr= substitute(s:treedepthstring,' ','','')
    let srch        = search('^[^'.treedepthchr.']','bW',stopline)
"    call Decho("case depth==1: srch<".srch.'>','~'.expand("<slnum>"))
   endif
   if srch > 0
"    call Decho("squeezing at line#".line(".").": ".getline('.'),'~'.expand("<slnum>"))
    call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,s:NetrwGetWord()))
    exe srch
   endif
  endif
"  call Dret("s:TreeSqueezeDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwMaps: {{{2
fun! s:NetrwMaps(islocal)
"  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")

  if g:netrw_mousemaps && g:netrw_retmap
"   call Decho("set up Rexplore 2-leftmouse",'~'.expand("<slnum>"))
   if !hasmapto("<Plug>NetrwReturn")
    if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
"     call Decho("making map for 2-leftmouse",'~'.expand("<slnum>"))
     nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
    elseif maparg("<c-leftmouse>","n") == ""
"     call Decho("making map for c-leftmouse",'~'.expand("<slnum>"))
     nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
    endif
   endif
   nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
"   call Decho("made <Plug>NetrwReturn map",'~'.expand("<slnum>"))
  endif

  if a:islocal
"   call Decho("make local maps",'~'.expand("<slnum>"))
   " local normal-mode maps
   nnoremap <buffer> <silent> <nowait> a	:<c-u>call <SID>NetrwHide(1)<cr>
   nnoremap <buffer> <silent> <nowait> -	:<c-u>call <SID>NetrwBrowseUpDir(1)<cr>
   nnoremap <buffer> <silent> <nowait> %	:<c-u>call <SID>NetrwOpenFile(1)<cr>
   nnoremap <buffer> <silent> <nowait> c	:<c-u>call <SID>NetrwLcd(b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> C	:<c-u>call <SID>NetrwSetChgwin()<cr>
   nnoremap <buffer> <silent> <nowait> <cr>	:<c-u>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   nnoremap <buffer> <silent> <nowait> <c-r>	:<c-u>call <SID>NetrwServerEdit(3,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> d	:<c-u>call <SID>NetrwMakeDir("")<cr>
   nnoremap <buffer> <silent> <nowait> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
   nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
   nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(1)<cr>
   nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(1,0)<cr>
   nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(1,1)<cr>
   nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   nnoremap <buffer> <silent> <nowait> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
   nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
   nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(1)<cr>
   nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(3)<cr>
   nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(1)<cr>
   nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
   nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(1)<cr>
   nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(1)<cr>
   nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
   nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(4)<cr>
   nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
   nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(5)<cr>
   nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   nnoremap <buffer> <silent> <nowait> X	:<c-u>call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
"   " local insert-mode maps
"   inoremap <buffer> <silent> <nowait> a	<c-o>:call <SID>NetrwHide(1)<cr>
"   inoremap <buffer> <silent> <nowait> c	<c-o>:exe "NetrwKeepj lcd ".fnameescape(b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> c	<c-o>:call <SID>NetrwLcd(b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> C	<c-o>:call <SID>NetrwSetChgwin()<cr>
"   inoremap <buffer> <silent> <nowait> %	<c-o>:call <SID>NetrwOpenFile(1)<cr>
"   inoremap <buffer> <silent> <nowait> -	<c-o>:call <SID>NetrwBrowseUpDir(1)<cr>
"   inoremap <buffer> <silent> <nowait> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
"   inoremap <buffer> <silent> <nowait> d	<c-o>:call <SID>NetrwMakeDir("")<cr>
"   inoremap <buffer> <silent> <nowait> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
"   nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> I	<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
"   inoremap <buffer> <silent> <nowait> i	<c-o>:call <SID>NetrwListStyle(1)<cr>
"   inoremap <buffer> <silent> <nowait> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
"   inoremap <buffer> <silent> <nowait> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
"   inoremap <buffer> <silent> <nowait> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
"   inoremap <buffer> <silent> <nowait> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
"   inoremap <buffer> <silent> <nowait> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
"   inoremap <buffer> <silent> <nowait> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
"   inoremap <buffer> <silent> <nowait> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
"   inoremap <buffer> <silent> <nowait> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
"   inoremap <buffer> <silent> <nowait> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
"   inoremap <buffer> <silent> <nowait> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
"   inoremap <buffer> <silent> <nowait> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
"   inoremap <buffer> <silent> <nowait> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
"   inoremap <buffer> <silent> <nowait> mv	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
"   inoremap <buffer> <silent> <nowait> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
"   inoremap <buffer> <silent> <nowait> mX	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
"   inoremap <buffer> <silent> <nowait> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
"   inoremap <buffer> <silent> <nowait> O	<c-o>:call <SID>NetrwObtain(1)<cr>
"   inoremap <buffer> <silent> <nowait> o	<c-o>:call <SID>NetrwSplit(3)<cr>
"   inoremap <buffer> <silent> <nowait> p	<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
"   inoremap <buffer> <silent> <nowait> P	<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
"   inoremap <buffer> <silent> <nowait> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
"   inoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
"   inoremap <buffer> <silent> <nowait> r	<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
"   inoremap <buffer> <silent> <nowait> s	<c-o>:call <SID>NetrwSortStyle(1)<cr>
"   inoremap <buffer> <silent> <nowait> S	<c-o>:call <SID>NetSortSequence(1)<cr>
"   inoremap <buffer> <silent> <nowait> t	<c-o>:call <SID>NetrwSplit(4)<cr>
"   inoremap <buffer> <silent> <nowait> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
"   inoremap <buffer> <silent> <nowait> Th	<c-o>:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
"   inoremap <buffer> <silent> <nowait> u	<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
"   inoremap <buffer> <silent> <nowait> U	<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
"   inoremap <buffer> <silent> <nowait> v	<c-o>:call <SID>NetrwSplit(5)<cr>
"   inoremap <buffer> <silent> <nowait> x	<c-o>:call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   if !hasmapto('<Plug>NetrwHideEdit')
    nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
"    imap <buffer> <unique> <c-h> <c-o><Plug>NetrwHideEdit
   endif
   nnoremap <buffer> <silent> <Plug>NetrwHideEdit		:call <SID>NetrwHideEdit(1)<cr>
   if !hasmapto('<Plug>NetrwRefresh')
    nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
"    imap <buffer> <unique> <c-l> <c-o><Plug>NetrwRefresh
   endif
   nnoremap <buffer> <silent> <Plug>NetrwRefresh		<c-l>:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,(w:netrw_liststyle == 3)? w:netrw_treetop : './'))<cr>
   if s:didstarstar || !mapcheck("<s-down>","n")
    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
"    inoremap <buffer> <silent> <s-down>	<c-o>:Nexplore<cr>
   endif
   if s:didstarstar || !mapcheck("<s-up>","n")
    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
"    inoremap <buffer> <silent> <s-up>	<c-o>:Pexplore<cr>
   endif
   if !hasmapto('<Plug>NetrwTreeSqueeze')
    nmap <buffer> <silent> <nowait> <s-cr>			<Plug>NetrwTreeSqueeze
"    imap <buffer> <silent> <nowait> <s-cr>			<c-o><Plug>NetrwTreeSqueeze
   endif
   nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze		:call <SID>TreeSqueezeDir(1)<cr>
   let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
   if g:netrw_mousemaps == 1
    nmap <buffer> <leftmouse>   				<Plug>NetrwLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
    nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	<leftmouse>:call <SID>NetrwCLeftmouse(1)<cr>
    nmap <buffer> <middlemouse>		<Plug>NetrwMiddlemouse
    nno  <buffer> <silent>		<Plug>NetrwMiddlemouse	<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
    nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(1)<cr>
    nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
    nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(1)<cr>
    nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
    nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
    imap <buffer> <leftmouse>		<Plug>ILeftmouse
"    ino  <buffer> <silent>		<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
    imap <buffer> <middlemouse>		<Plug>IMiddlemouse
"    ino  <buffer> <silent>		<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
"    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
"    ino  <buffer> <silent>		<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
    exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
"    exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   endif
   exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> d		<c-o>:call <SID>NetrwMakeDir("")<cr>'
   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>

   " support user-specified maps
   call netrw#UserMaps(1)

  else " remote
"   call Decho("make remote maps",'~'.expand("<slnum>"))
   call s:RemotePathAnalysis(b:netrw_curdir)
   " remote normal-mode maps
   nnoremap <buffer> <silent> <nowait> a	:<c-u>call <SID>NetrwHide(0)<cr>
   nnoremap <buffer> <silent> <nowait> -	:<c-u>call <SID>NetrwBrowseUpDir(0)<cr>
   nnoremap <buffer> <silent> <nowait> %	:<c-u>call <SID>NetrwOpenFile(0)<cr>
   nnoremap <buffer> <silent> <nowait> C	:<c-u>call <SID>NetrwSetChgwin()<cr>
   nnoremap <buffer> <silent> <nowait> <c-l>	:<c-u>call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   nnoremap <buffer> <silent> <nowait> <cr>	:<c-u>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
   nnoremap <buffer> <silent> <nowait> <c-r>	:<c-u>call <SID>NetrwServerEdit(2,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
   nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
   nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(0)<cr>
   nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(0,0)<cr>
   nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(0,1)<cr>
   nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
   nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
   nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
   nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
   nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
   nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
   nnoremap <buffer> <silent> <nowait> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
   nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
   nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
   nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
   nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
   nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
   nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
   nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
   nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
   nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
   nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(0)<cr>
   nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(0)<cr>
   nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(0)<cr>
   nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
   nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
   nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(0)<cr>
   nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(0)<cr>
   nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(0,'b',v:count1)<cr>
   nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(1)<cr>
   nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(0,'h',v:count)<cr>
   nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(2)<cr>
   nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
"   " remote insert-mode maps
"   inoremap <buffer> <silent> <nowait> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
"   inoremap <buffer> <silent> <nowait> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
"   inoremap <buffer> <silent> <nowait> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(0)<cr>
"   inoremap <buffer> <silent> <nowait> -		<c-o>:call <SID>NetrwBrowseUpDir(0)<cr>
"   inoremap <buffer> <silent> <nowait> a		<c-o>:call <SID>NetrwHide(0)<cr>
"   inoremap <buffer> <silent> <nowait> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
"   inoremap <buffer> <silent> <nowait> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
"   inoremap <buffer> <silent> <nowait> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
"   inoremap <buffer> <silent> <nowait> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
"   inoremap <buffer> <silent> <nowait> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
"   inoremap <buffer> <silent> <nowait> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
"   inoremap <buffer> <silent> <nowait> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
"   inoremap <buffer> <silent> <nowait> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
"   inoremap <buffer> <silent> <nowait> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
"   inoremap <buffer> <silent> <nowait> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
"   inoremap <buffer> <silent> <nowait> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
"   inoremap <buffer> <silent> <nowait> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
"   nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
"   inoremap <buffer> <silent> <nowait> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
"   inoremap <buffer> <silent> <nowait> mX	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
"   inoremap <buffer> <silent> <nowait> mv	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
"   inoremap <buffer> <silent> <nowait> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
"   inoremap <buffer> <silent> <nowait> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
"   inoremap <buffer> <silent> <nowait> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
"   inoremap <buffer> <silent> <nowait> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
"   inoremap <buffer> <silent> <nowait> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
"   inoremap <buffer> <silent> <nowait> o		<c-o>:call <SID>NetrwSplit(0)<cr>
"   inoremap <buffer> <silent> <nowait> O		<c-o>:call <SID>NetrwObtain(0)<cr>
"   inoremap <buffer> <silent> <nowait> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
"   inoremap <buffer> <silent> <nowait> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
"   inoremap <buffer> <silent> <nowait> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
"   inoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
"   inoremap <buffer> <silent> <nowait> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
"   inoremap <buffer> <silent> <nowait> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
"   inoremap <buffer> <silent> <nowait> S		<c-o>:call <SID>NetSortSequence(0)<cr>
"   inoremap <buffer> <silent> <nowait> t		<c-o>:call <SID>NetrwSplit(1)<cr>
"   inoremap <buffer> <silent> <nowait> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
"   inoremap <buffer> <silent> <nowait> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
"   inoremap <buffer> <silent> <nowait> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> v		<c-o>:call <SID>NetrwSplit(2)<cr>
"   inoremap <buffer> <silent> <nowait> x		<c-o>:call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
"   inoremap <buffer> <silent> <nowait> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
   if !hasmapto('<Plug>NetrwHideEdit')
    nmap <buffer> <c-h> <Plug>NetrwHideEdit
"    imap <buffer> <c-h> <Plug>NetrwHideEdit
   endif
   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
   if !hasmapto('<Plug>NetrwRefresh')
    nmap <buffer> <c-l> <Plug>NetrwRefresh
"    imap <buffer> <c-l> <Plug>NetrwRefresh
   endif
   if !hasmapto('<Plug>NetrwTreeSqueeze')
    nmap <buffer> <silent> <nowait> <s-cr>	<Plug>NetrwTreeSqueeze
"    imap <buffer> <silent> <nowait> <s-cr>	<c-o><Plug>NetrwTreeSqueeze
   endif
   nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze	:call <SID>TreeSqueezeDir(0)<cr>

   let mapsafepath     = escape(s:path, s:netrw_map_escape)
   let mapsafeusermach = escape(((s:user == "")? "" : s:user."@").s:machine, s:netrw_map_escape)

   nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   if g:netrw_mousemaps == 1
    nmap <buffer> <leftmouse>		<Plug>NetrwLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
    nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	<leftmouse>:call <SID>NetrwCLeftmouse(0)<cr>
    nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(0)<cr>
    nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
    nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(0)<cr>
    nmap <middlemouse>			<Plug>NetrwMiddlemouse
    nno  <buffer> <silent>		<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
    nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
    nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
    imap <buffer> <leftmouse>		<Plug>ILeftmouse
"    ino  <buffer> <silent>		<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
    imap <buffer> <middlemouse>		<Plug>IMiddlemouse
"    ino  <buffer> <silent>		<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
"    ino  <buffer> <silent>		<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
    exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
    exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
"    exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   endif
   exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
"   inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>

   " support user-specified maps
   call netrw#UserMaps(0)
  endif

"  call Dret("s:NetrwMaps")
endfun

" ---------------------------------------------------------------------
" s:NetrwCommands: set up commands 				{{{2
"  If -buffer, the command is only available from within netrw buffers
"  Otherwise, the command is available from any window, so long as netrw
"  has been used at least once in the session.
fun! s:NetrwCommands(islocal)
"  call Dfunc("s:NetrwCommands(islocal=".a:islocal.")")

  com! -nargs=* -complete=file -bang	NetrwMB	call s:NetrwBookmark(<bang>0,<f-args>)
  com! -nargs=*			    	NetrwC	call s:NetrwSetChgwin(<q-args>)
  com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"win#".winnr()." not a former netrw window",79)|endif
  if a:islocal
   com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(1,<f-args>)
  else
   com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(0,<f-args>)
  endif
  com! -buffer -nargs=? -complete=file	MT	call s:NetrwMarkTarget(<q-args>)

"  call Dret("s:NetrwCommands")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFiles: apply s:NetrwMarkFile() to named file(s) {{{2
"                   glob()ing only works with local files
fun! s:NetrwMarkFiles(islocal,...)
"  call Dfunc("s:NetrwMarkFiles(islocal=".a:islocal."...) a:0=".a:0)
  let curdir = s:NetrwGetCurdir(a:islocal)
  let i      = 1
  while i <= a:0
   if a:islocal
    if v:version == 704 && has("patch656")
     let mffiles= glob(a:{i},0,1,1)
    else
     let mffiles= glob(a:{i},0,1)
    endif
   else
    let mffiles= [a:{i}]
   endif
"   call Decho("mffiles".string(mffiles),'~'.expand("<slnum>"))
   for mffile in mffiles
"    call Decho("mffile<".mffile.">",'~'.expand("<slnum>"))
    call s:NetrwMarkFile(a:islocal,mffile)
   endfor
   let i= i + 1
  endwhile
"  call Dret("s:NetrwMarkFiles")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkTarget: implements :MT (mark target) {{{2
fun! s:NetrwMarkTarget(...)
"  call Dfunc("s:NetrwMarkTarget() a:0=".a:0)
  if a:0 == 0 || (a:0 == 1 && a:1 == "")
   let curdir = s:NetrwGetCurdir(1)
   let tgt    = b:netrw_curdir
  else
   let curdir = s:NetrwGetCurdir((a:1 =~ '^\a\{3,}://')? 0 : 1)
   let tgt    = a:1
  endif
"  call Decho("tgt<".tgt.">",'~'.expand("<slnum>"))
  let s:netrwmftgt         = tgt
  let s:netrwmftgt_islocal = tgt !~ '^\a\{3,}://'
  let curislocal           = b:netrw_curdir !~ '^\a\{3,}://'
  let svpos                = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call s:NetrwRefresh(curislocal,s:NetrwBrowseChgDir(curislocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)
"  call Dret("s:NetrwMarkTarget")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFile: (invoked by mf) This function is used to both {{{2
"                  mark and unmark files.  If a markfile list exists,
"                  then the rename and delete functions will use it instead
"                  of whatever may happen to be under the cursor at that
"                  moment.  When the mouse and gui are available,
"                  shift-leftmouse may also be used to mark files.
"
"  Creates two lists
"    s:netrwmarkfilelist    -- holds complete paths to all marked files
"    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
"
"  Creates a marked file match string
"    s:netrwmarfilemtch_#   -- used with 2match to display marked files
"
"  Creates a buffer version of islocal
"    b:netrw_islocal
fun! s:NetrwMarkFile(islocal,fname)
"  call Dfunc("s:NetrwMarkFile(islocal=".a:islocal." fname<".a:fname.">)")
"  call Decho("bufnr(%)=".bufnr("%").": ".bufname("%"),'~'.expand("<slnum>"))

  " sanity check
  if empty(a:fname)
"   call Dret("s:NetrwMarkFile : emtpy fname")
   return
  endif
  let curdir = s:NetrwGetCurdir(a:islocal)

  let ykeep   = @@
  let curbufnr= bufnr("%")
  if a:fname =~ '^\a'
   let leader= '\<'
  else
   let leader= ''
  endif
  if a:fname =~ '\a$'
   let trailer = '\>[@=|\/\*]\=\ze\%(  \|\t\|$\)'
  else
   let trailer = '[@=|\/\*]\=\ze\%(  \|\t\|$\)'
  endif

  if exists("s:netrwmarkfilelist_".curbufnr)
   " markfile list pre-exists
"   call Decho("case s:netrwmarkfilelist_".curbufnr." already exists",'~'.expand("<slnum>"))
"   call Decho("starting s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
"   call Decho("starting s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">",'~'.expand("<slnum>"))
   let b:netrw_islocal= a:islocal

   if index(s:netrwmarkfilelist_{curbufnr},a:fname) == -1
    " append filename to buffer's markfilelist
"    call Decho("append filename<".a:fname."> to local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
    call add(s:netrwmarkfilelist_{curbufnr},a:fname)
    let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(a:fname,g:netrw_markfileesc).trailer

   else
    " remove filename from buffer's markfilelist
"    call Decho("remove filename<".a:fname."> from local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
    call filter(s:netrwmarkfilelist_{curbufnr},'v:val != a:fname')
    if s:netrwmarkfilelist_{curbufnr} == []
     " local markfilelist is empty; remove it entirely
"     call Decho("markfile list now empty",'~'.expand("<slnum>"))
     call s:NetrwUnmarkList(curbufnr,curdir)
    else
     " rebuild match list to display markings correctly
"     call Decho("rebuild s:netrwmarkfilemtch_".curbufnr,'~'.expand("<slnum>"))
     let s:netrwmarkfilemtch_{curbufnr}= ""
     let first                         = 1
     for fname in s:netrwmarkfilelist_{curbufnr}
      if first
       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.leader.escape(fname,g:netrw_markfileesc).trailer
      else
       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(fname,g:netrw_markfileesc).trailer
      endif
      let first= 0
     endfor
"     call Decho("ending s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
    endif
   endif

  else
   " initialize new markfilelist
"   call Decho("case: initialize new markfilelist",'~'.expand("<slnum>"))

"   call Decho("add fname<".a:fname."> to new markfilelist_".curbufnr,'~'.expand("<slnum>"))
   let s:netrwmarkfilelist_{curbufnr}= []
   call add(s:netrwmarkfilelist_{curbufnr},substitute(a:fname,'[|@]$','',''))
"   call Decho("ending s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))

   " build initial markfile matching pattern
   if a:fname =~ '/$'
    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc)
   else
    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc).trailer
   endif
"   call Decho("ending s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">",'~'.expand("<slnum>"))
  endif

  " handle global markfilelist
  if exists("s:netrwmarkfilelist")
   let dname= s:ComposePath(b:netrw_curdir,a:fname)
   if index(s:netrwmarkfilelist,dname) == -1
    " append new filename to global markfilelist
    call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
"    call Decho("append filename<".a:fname."> to global markfilelist<".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
   else
    " remove new filename from global markfilelist
"    call Decho("filter(".string(s:netrwmarkfilelist).",'v:val != '.".dname.")",'~'.expand("<slnum>"))
    call filter(s:netrwmarkfilelist,'v:val != "'.dname.'"')
"    call Decho("ending s:netrwmarkfilelist  <".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
    if s:netrwmarkfilelist == []
     unlet s:netrwmarkfilelist
    endif
   endif
  else
   " initialize new global-directory markfilelist
   let s:netrwmarkfilelist= []
   call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
"   call Decho("init s:netrwmarkfilelist<".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
  endif

  " set up 2match'ing to netrwmarkfilemtch_# list
  if exists("s:netrwmarkfilemtch_{curbufnr}") && s:netrwmarkfilemtch_{curbufnr} != ""
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/",'~'.expand("<slnum>"))
   if exists("g:did_drchip_netrwlist_syntax")
    exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/"
   endif
  else
"   call Decho("2match none",'~'.expand("<slnum>"))
   2match none
  endif
  let @@= ykeep
"  call Dret("s:NetrwMarkFile : s:netrwmarkfilelist_".curbufnr."<".(exists("s:netrwmarkfilelist_{curbufnr}")? string(s:netrwmarkfilelist_{curbufnr}) : " doesn't exist").">")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileArgList: ma: move the marked file list to the argument list (tomflist=0) {{{2
"                         mA: move the argument list to marked file list     (tomflist=1)
"                            Uses the global marked file list
fun! s:NetrwMarkFileArgList(islocal,tomflist)
"  call Dfunc("s:NetrwMarkFileArgList(islocal=".a:islocal.",tomflist=".a:tomflist.")")

  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  if a:tomflist
   " mA: move argument list to marked file list
   while argc()
    let fname= argv(0)
"    call Decho("exe argdel ".fname,'~'.expand("<slnum>"))
    exe "argdel ".fnameescape(fname)
    call s:NetrwMarkFile(a:islocal,fname)
   endwhile

  else
   " ma: move marked file list to argument list
   if exists("s:netrwmarkfilelist")

    " for every filename in the marked list
    for fname in s:netrwmarkfilelist
"     call Decho("exe argadd ".fname,'~'.expand("<slnum>"))
     exe "argadd ".fnameescape(fname)
    endfor	" for every file in the marked list

    " unmark list and refresh
    call s:NetrwUnmarkList(curbufnr,curdir)
    NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    NetrwKeepj call winrestview(svpos)
   endif
  endif

"  call Dret("s:NetrwMarkFileArgList")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileCompress: (invoked by mz) This function is used to {{{2
"                          compress/decompress files using the programs
"                          in g:netrw_compress and g:netrw_uncompress,
"                          using g:netrw_compress_suffix to know which to
"                          do.  By default:
"                            g:netrw_compress        = "gzip"
"                            g:netrw_decompress      = { ".gz" : "gunzip" , ".bz2" : "bunzip2" , ".zip" : "unzip" , ".tar" : "tar -xf", ".xz" : "unxz"}
fun! s:NetrwMarkFileCompress(islocal)
"  call Dfunc("s:NetrwMarkFileCompress(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileCompress")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{curbufnr}") && exists("g:netrw_compress") && exists("g:netrw_decompress")

   " for every filename in the marked list
   for fname in s:netrwmarkfilelist_{curbufnr}
    let sfx= substitute(fname,'^.\{-}\(\.\a\+\)$','\1','')
"    call Decho("extracted sfx<".sfx.">",'~'.expand("<slnum>"))
    if exists("g:netrw_decompress['".sfx."']")
     " fname has a suffix indicating that its compressed; apply associated decompression routine
     let exe= g:netrw_decompress[sfx]
"     call Decho("fname<".fname."> is compressed so decompress with <".exe.">",'~'.expand("<slnum>"))
     let exe= netrw#WinPath(exe)
     if a:islocal
      if g:netrw_keepdir
       let fname= s:ShellEscape(s:ComposePath(curdir,fname))
      endif
     else
      let fname= s:ShellEscape(b:netrw_curdir.fname,1)
     endif
     if executable(exe)
      if a:islocal
       call system(exe." ".fname)
      else
       NetrwKeepj call s:RemoteSystem(exe." ".fname)
      endif
     else
      NetrwKeepj call netrw#ErrorMsg(s:WARNING,"unable to apply<".exe."> to file<".fname.">",50)
     endif
    endif
    unlet sfx

    if exists("exe")
     unlet exe
    elseif a:islocal
     " fname not a compressed file, so compress it
     call system(netrw#WinPath(g:netrw_compress)." ".s:ShellEscape(s:ComposePath(b:netrw_curdir,fname)))
    else
     " fname not a compressed file, so compress it
     NetrwKeepj call s:RemoteSystem(netrw#WinPath(g:netrw_compress)." ".s:ShellEscape(fname))
    endif
   endfor	" for every file in the marked list

   call s:NetrwUnmarkList(curbufnr,curdir)
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  endif
"  call Dret("s:NetrwMarkFileCompress")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileCopy: (invoked by mc) copy marked files to target {{{2
"                      If no marked files, then set up directory as the
"                      target.  Currently does not support copying entire
"                      directories.  Uses the local-buffer marked file list.
"                      Returns 1=success  (used by NetrwMarkFileMove())
"                              0=failure
fun! s:NetrwMarkFileCopy(islocal,...)
"  call Dfunc("s:NetrwMarkFileCopy(islocal=".a:islocal.") target<".(exists("s:netrwmftgt")? s:netrwmftgt : '---')."> a:0=".a:0)

  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")
  if b:netrw_curdir !~ '/$'
   if !exists("b:netrw_curdir")
    let b:netrw_curdir= curdir
   endif
   let b:netrw_curdir= b:netrw_curdir."/"
  endif

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileCopy")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if !exists("s:netrwmftgt")
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your marked file target is empty! (:help netrw-mt)",67)
"   call Dret("s:NetrwMarkFileCopy 0")
   return 0
  endif
"  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))

  if a:islocal &&  s:netrwmftgt_islocal
   " Copy marked files, local directory to local directory
"   call Decho("copy from local to local",'~'.expand("<slnum>"))
   if !executable(g:netrw_localcopycmd) && g:netrw_localcopycmd !~ '^'.expand("$COMSPEC").'\s'
    call netrw#ErrorMsg(s:ERROR,"g:netrw_localcopycmd<".g:netrw_localcopycmd."> not executable on your system, aborting",91)
"    call Dfunc("s:NetrwMarkFileMove : g:netrw_localcopycmd<".g:netrw_localcopycmd."> n/a!")
    return
   endif

   " copy marked files while within the same directory (ie. allow renaming)
   if simplify(s:netrwmftgt) == simplify(b:netrw_curdir)
    if len(s:netrwmarkfilelist_{bufnr('%')}) == 1
     " only one marked file
"     call Decho("case: only one marked file",'~'.expand("<slnum>"))
     let args    = s:ShellEscape(b:netrw_curdir.s:netrwmarkfilelist_{bufnr('%')}[0])
     let oldname = s:netrwmarkfilelist_{bufnr('%')}[0]
    elseif a:0 == 1
"     call Decho("case: handling one input argument",'~'.expand("<slnum>"))
     " this happens when the next case was used to recursively call s:NetrwMarkFileCopy()
     let args    = s:ShellEscape(b:netrw_curdir.a:1)
     let oldname = a:1
    else
     " copy multiple marked files inside the same directory
"     call Decho("case: handling a multiple marked files",'~'.expand("<slnum>"))
     let s:recursive= 1
     for oldname in s:netrwmarkfilelist_{bufnr("%")}
      let ret= s:NetrwMarkFileCopy(a:islocal,oldname)
      if ret == 0
       break
      endif
     endfor
     unlet s:recursive
     call s:NetrwUnmarkList(curbufnr,curdir)
"     call Dret("s:NetrwMarkFileCopy ".ret)
     return ret
    endif

    call inputsave()
    let newname= input("Copy ".oldname." to : ",oldname,"file")
    call inputrestore()
    if newname == ""
"     call Dret("s:NetrwMarkFileCopy 0")
     return 0
    endif
    let args= s:ShellEscape(oldname)
    let tgt = s:ShellEscape(s:netrwmftgt.'/'.newname)
   else
    let args= join(map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),"s:ShellEscape(b:netrw_curdir.\"/\".v:val)"))
    let tgt = s:ShellEscape(s:netrwmftgt)
   endif
   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    let args= substitute(args,'/','\\','g')
    let tgt = substitute(tgt, '/','\\','g')
   endif
   if args =~ "'" |let args= substitute(args,"'\\(.*\\)'",'\1','')|endif
   if tgt  =~ "'" |let tgt = substitute(tgt ,"'\\(.*\\)'",'\1','')|endif
   if args =~ '//'|let args= substitute(args,'//','/','g')|endif
   if tgt  =~ '//'|let tgt = substitute(tgt ,'//','/','g')|endif
"   call Decho("args   <".args.">",'~'.expand("<slnum>"))
"   call Decho("tgt    <".tgt.">",'~'.expand("<slnum>"))
   if isdirectory(s:NetrwFile(args))
"    call Decho("args<".args."> is a directory",'~'.expand("<slnum>"))
    let copycmd= g:netrw_localcopydircmd
"    call Decho("using copydircmd<".copycmd.">",'~'.expand("<slnum>"))
    if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
     " window's xcopy doesn't copy a directory to a target properly.  Instead, it copies a directory's
     " contents to a target.  One must append the source directory name to the target to get xcopy to
     " do the right thing.
     let tgt= tgt.'\'.substitute(a:1,'^.*[\\/]','','')
"     call Decho("modified tgt for xcopy",'~'.expand("<slnum>"))
    endif
   else
    let copycmd= g:netrw_localcopycmd
   endif
   if g:netrw_localcopycmd =~ '\s'
    let copycmd     = substitute(copycmd,'\s.*$','','')
    let copycmdargs = substitute(copycmd,'^.\{-}\(\s.*\)$','\1','')
    let copycmd     = netrw#WinPath(copycmd).copycmdargs
   else
    let copycmd = netrw#WinPath(copycmd)
   endif
"   call Decho("args   <".args.">",'~'.expand("<slnum>"))
"   call Decho("tgt    <".tgt.">",'~'.expand("<slnum>"))
"   call Decho("copycmd<".copycmd.">",'~'.expand("<slnum>"))
"   call Decho("system(".copycmd." '".args."' '".tgt."')",'~'.expand("<slnum>"))
   call system(copycmd." '".args."' '".tgt."'")
   if v:shell_error != 0
    if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
     call netrw#ErrorMsg(s:ERROR,"copy failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",101)
    else
     call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localcopycmd<".g:netrw_localcopycmd.">; it doesn't work!",80)
    endif
"    call Dret("s:NetrwMarkFileCopy 0 : failed: system(".g:netrw_localcopycmd." ".args." ".s:ShellEscape(s:netrwmftgt))
    return 0
   endif

  elseif  a:islocal && !s:netrwmftgt_islocal
   " Copy marked files, local directory to remote directory
"   call Decho("copy from local to remote",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwUpload(s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)

  elseif !a:islocal &&  s:netrwmftgt_islocal
   " Copy marked files, remote directory to local directory
"   call Decho("copy from remote to local",'~'.expand("<slnum>"))
   NetrwKeepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)

  elseif !a:islocal && !s:netrwmftgt_islocal
   " Copy marked files, remote directory to remote directory
"   call Decho("copy from remote to remote",'~'.expand("<slnum>"))
   let curdir = getcwd()
   let tmpdir = s:GetTempfile("")
   if tmpdir !~ '/'
    let tmpdir= curdir."/".tmpdir
   endif
   if exists("*mkdir")
    call mkdir(tmpdir)
   else
    call s:NetrwExe("sil! !".g:netrw_localmkdir.' '.s:ShellEscape(tmpdir,1))
    if v:shell_error != 0
     call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
"     call Dret("s:NetrwMarkFileCopy : failed: sil! !".g:netrw_localmkdir.' '.s:ShellEscape(tmpdir,1) )
     return
    endif
   endif
   if isdirectory(s:NetrwFile(tmpdir))
    call s:NetrwLcd(tmpdir)
    NetrwKeepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},tmpdir)
    let localfiles= map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),'substitute(v:val,"^.*/","","")')
    NetrwKeepj call s:NetrwUpload(localfiles,s:netrwmftgt)
    if getcwd() == tmpdir
     for fname in s:netrwmarkfilelist_{bufnr('%')}
      NetrwKeepj call s:NetrwDelete(fname)
     endfor
     call s:NetrwLcd(curdir)
     if v:version < 704 || !has("patch1109")
      call s:NetrwExe("sil !".g:netrw_localrmdir." ".s:ShellEscape(tmpdir,1))
      if v:shell_error != 0
       call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localrmdir<".g:netrw_localrmdir."> to something that works",80)
" "      call Dret("s:NetrwMarkFileCopy : failed: sil !".g:netrw_localrmdir." ".s:ShellEscape(tmpdir,1) )
       return
      endif
     else
      if delete(tmpdir,"d")
       call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".tmpdir.">!",103)
      endif
     endif
    else
     call s:NetrwLcd(curdir)
    endif
   endif
  endif

  " -------
  " cleanup
  " -------
"  call Decho("cleanup",'~'.expand("<slnum>"))
"  call Decho(" g:netrw_fastbrowse  =".g:netrw_fastbrowse,'~'.expand("<slnum>"))
"  call Decho(" s:netrwmftgt        =".s:netrwmftgt,'~'.expand("<slnum>"))
"  call Decho(" s:netrwmftgt_islocal=".s:netrwmftgt_islocal,'~'.expand("<slnum>"))
"  call Decho(" curdir              =".curdir,'~'.expand("<slnum>"))
"  call Decho(" a:islocal           =".a:islocal,'~'.expand("<slnum>"))
"  call Decho(" curbufnr            =".curbufnr,'~'.expand("<slnum>"))
  if exists("s:recursive")
"   call Decho(" s:recursive         =".s:recursive,'~'.expand("<slnum>"))
  else
"   call Decho(" s:recursive         =n/a",'~'.expand("<slnum>"))
  endif
  " see s:LocalFastBrowser() for g:netrw_fastbrowse interpretation (refreshing done for both slow and medium)
  if g:netrw_fastbrowse <= 1
   NetrwKeepj call s:LocalBrowseRefresh()
  else
   " refresh local and targets for fast browsing
   if !exists("s:recursive")
    " remove markings from local buffer
"    call Decho(" remove markings from local buffer",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwUnmarkList(curbufnr,curdir)
   endif

   " refresh buffers
   if s:netrwmftgt_islocal
"    call Decho(" refresh s:netrwmftgt=".s:netrwmftgt,'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
   endif
   if a:islocal && s:netrwmftgt != curdir
"    call Decho(" refresh curdir=".curdir,'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshDir(a:islocal,curdir)
   endif
  endif

"  call Dret("s:NetrwMarkFileCopy 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileDiff: (invoked by md) This function is used to {{{2
"                      invoke vim's diff mode on the marked files.
"                      Either two or three files can be so handled.
"                      Uses the global marked file list.
fun! s:NetrwMarkFileDiff(islocal)
"  call Dfunc("s:NetrwMarkFileDiff(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileDiff")
   return
  endif
  let curdir= s:NetrwGetCurdir(a:islocal)
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{".curbufnr."}")
   let cnt    = 0
   for fname in s:netrwmarkfilelist
    let cnt= cnt + 1
    if cnt == 1
"     call Decho("diffthis: fname<".fname.">",'~'.expand("<slnum>"))
     exe "NetrwKeepj e ".fnameescape(fname)
     diffthis
    elseif cnt == 2 || cnt == 3
     vsplit
     wincmd l
"     call Decho("diffthis: ".fname,'~'.expand("<slnum>"))
     exe "NetrwKeepj e ".fnameescape(fname)
     diffthis
    else
     break
    endif
   endfor
   call s:NetrwUnmarkList(curbufnr,curdir)
  endif

"  call Dret("s:NetrwMarkFileDiff")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileEdit: (invoked by me) put marked files on arg list and start editing them {{{2
"                       Uses global markfilelist
fun! s:NetrwMarkFileEdit(islocal)
"  call Dfunc("s:NetrwMarkFileEdit(islocal=".a:islocal.")")

  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileEdit")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   call s:SetRexDir(a:islocal,curdir)
   let flist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
   " unmark markedfile list
"   call s:NetrwUnmarkList(curbufnr,curdir)
   call s:NetrwUnmarkAll()
"   call Decho("exe sil args ".flist,'~'.expand("<slnum>"))
   exe "sil args ".flist
  endif
  echo "(use :bn, :bp to navigate files; :Rex to return)"

"  call Dret("s:NetrwMarkFileEdit")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileQFEL: convert a quickfix-error or location list into a marked file list {{{2
fun! s:NetrwMarkFileQFEL(islocal,qfel)
"  call Dfunc("s:NetrwMarkFileQFEL(islocal=".a:islocal.",qfel)")
  call s:NetrwUnmarkAll()
  let curbufnr= bufnr("%")

  if !empty(a:qfel)
   for entry in a:qfel
    let bufnmbr= entry["bufnr"]
"    call Decho("bufname(".bufnmbr.")<".bufname(bufnmbr)."> line#".entry["lnum"]." text=".entry["text"],'~'.expand("<slnum>"))
    if !exists("s:netrwmarkfilelist_{curbufnr}")
"     call Decho("case: no marked file list",'~'.expand("<slnum>"))
     call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
    elseif index(s:netrwmarkfilelist_{curbufnr},bufname(bufnmbr)) == -1
     " s:NetrwMarkFile will remove duplicate entries from the marked file list.
     " So, this test lets two or more hits on the same pattern to be ignored.
"     call Decho("case: ".bufname(bufnmbr)." not currently in marked file list",'~'.expand("<slnum>"))
     call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
    else
"     call Decho("case: ".bufname(bufnmbr)." already in marked file list",'~'.expand("<slnum>"))
    endif
   endfor
   echo "(use me to edit marked files)"
  else
   call netrw#ErrorMsg(s:WARNING,"can't convert quickfix error list; its empty!",92)
  endif

"  call Dret("s:NetrwMarkFileQFEL")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileExe: (invoked by mx and mX) execute arbitrary system command on marked files {{{2
"                     mx enbloc=0: Uses the local marked-file list, applies command to each file individually
"                     mX enbloc=1: Uses the global marked-file list, applies command to entire list
fun! s:NetrwMarkFileExe(islocal,enbloc)
"  call Dfunc("s:NetrwMarkFileExe(islocal=".a:islocal.",enbloc=".a:enbloc.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  if a:enbloc == 0
   " individually apply command to files, one at a time
    " sanity check
    if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
     NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"     call Dret("s:NetrwMarkFileExe")
     return
    endif
"    call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

    if exists("s:netrwmarkfilelist_{curbufnr}")
     " get the command
     call inputsave()
     let cmd= input("Enter command: ","","file")
     call inputrestore()
"     call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
     if cmd == ""
"      call Dret("s:NetrwMarkFileExe : early exit, empty command")
      return
     endif

     " apply command to marked files, individually.  Substitute: filename -> %
     " If no %, then append a space and the filename to the command
     for fname in s:netrwmarkfilelist_{curbufnr}
      if a:islocal
       if g:netrw_keepdir
	let fname= s:ShellEscape(netrw#WinPath(s:ComposePath(curdir,fname)))
       endif
      else
       let fname= s:ShellEscape(netrw#WinPath(b:netrw_curdir.fname))
      endif
      if cmd =~ '%'
       let xcmd= substitute(cmd,'%',fname,'g')
      else
       let xcmd= cmd.' '.fname
      endif
      if a:islocal
"       call Decho("local: xcmd<".xcmd.">",'~'.expand("<slnum>"))
       let ret= system(xcmd)
      else
"       call Decho("remote: xcmd<".xcmd.">",'~'.expand("<slnum>"))
       let ret= s:RemoteSystem(xcmd)
      endif
      if v:shell_error < 0
       NetrwKeepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
       break
      else
       echo ret
      endif
     endfor

   " unmark marked file list
   call s:NetrwUnmarkList(curbufnr,curdir)

   " refresh the listing
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

 else " apply command to global list of files, en bloc

  call inputsave()
  let cmd= input("Enter command: ","","file")
  call inputrestore()
"  call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
  if cmd == ""
"   call Dret("s:NetrwMarkFileExe : early exit, empty command")
   return
  endif
  if cmd =~ '%'
   let cmd= substitute(cmd,'%',join(map(s:netrwmarkfilelist,'s:ShellEscape(v:val)'),' '),'g')
  else
   let cmd= cmd.' '.join(map(s:netrwmarkfilelist,'s:ShellEscape(v:val)'),' ')
  endif
  if a:islocal
   call system(cmd)
   if v:shell_error < 0
    NetrwKeepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
   endif
  else
   let ret= s:RemoteSystem(cmd)
  endif
  call s:NetrwUnmarkAll()

  " refresh the listing
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

 endif

"  call Dret("s:NetrwMarkFileExe")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
"                  as the marked file(s) (toggles suffix presence)
"                  Uses the local marked file list.
fun! s:NetrwMarkHideSfx(islocal)
"  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curbufnr = bufnr("%")

  " s:netrwmarkfilelist_{curbufnr}: the List of marked files
  if exists("s:netrwmarkfilelist_{curbufnr}")

   for fname in s:netrwmarkfilelist_{curbufnr}
"     call Decho("s:NetrwMarkFileCopy: fname<".fname.">",'~'.expand("<slnum>"))
     " construct suffix pattern
     if fname =~ '\.'
      let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
     else
      let sfxpat= '^\%(\%(\.\)\@!.\)*$'
     endif
     " determine if its in the hiding list or not
     let inhidelist= 0
     if g:netrw_list_hide != ""
      let itemnum = 0
      let hidelist= split(g:netrw_list_hide,',')
      for hidepat in hidelist
       if sfxpat == hidepat
        let inhidelist= 1
        break
       endif
       let itemnum= itemnum + 1
      endfor
     endif
"     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">",'~'.expand("<slnum>"))
     if inhidelist
      " remove sfxpat from list
      call remove(hidelist,itemnum)
      let g:netrw_list_hide= join(hidelist,",")
     elseif g:netrw_list_hide != ""
      " append sfxpat to non-empty list
      let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
     else
      " set hiding list to sfxpat
      let g:netrw_list_hide= sfxpat
     endif
    endfor

   " refresh the listing
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkHideSfx")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileVimCmd: (invoked by mv) execute arbitrary vim command on marked files, one at a time {{{2
"                     Uses the local marked-file list.
fun! s:NetrwMarkFileVimCmd(islocal)
"  call Dfunc("s:NetrwMarkFileVimCmd(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileVimCmd")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   " get the command
   call inputsave()
   let cmd= input("Enter vim command: ","","file")
   call inputrestore()
"   call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
   if cmd == ""
"    "   call Dret("s:NetrwMarkFileVimCmd : early exit, empty command")
    return
   endif

   " apply command to marked files.  Substitute: filename -> %
   " If no %, then append a space and the filename to the command
   for fname in s:netrwmarkfilelist_{curbufnr}
"    call Decho("fname<".fname.">",'~'.expand("<slnum>"))
    if a:islocal
     1split
     exe "sil! NetrwKeepj keepalt e ".fnameescape(fname)
"     call Decho("local<".fname.">: exe ".cmd,'~'.expand("<slnum>"))
     exe cmd
     exe "sil! keepalt wq!"
    else
"     call Decho("remote<".fname.">: exe ".cmd." : NOT SUPPORTED YET",'~'.expand("<slnum>"))
     echo "sorry, \"mv\" not supported yet for remote files"
    endif
   endfor

   " unmark marked file list
   call s:NetrwUnmarkList(curbufnr,curdir)

   " refresh the listing
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkFileVimCmd")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
"                  as the marked file(s) (toggles suffix presence)
"                  Uses the local marked file list.
fun! s:NetrwMarkHideSfx(islocal)
"  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curbufnr = bufnr("%")

  " s:netrwmarkfilelist_{curbufnr}: the List of marked files
  if exists("s:netrwmarkfilelist_{curbufnr}")

   for fname in s:netrwmarkfilelist_{curbufnr}
"     call Decho("s:NetrwMarkFileCopy: fname<".fname.">",'~'.expand("<slnum>"))
     " construct suffix pattern
     if fname =~ '\.'
      let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
     else
      let sfxpat= '^\%(\%(\.\)\@!.\)*$'
     endif
     " determine if its in the hiding list or not
     let inhidelist= 0
     if g:netrw_list_hide != ""
      let itemnum = 0
      let hidelist= split(g:netrw_list_hide,',')
      for hidepat in hidelist
       if sfxpat == hidepat
        let inhidelist= 1
        break
       endif
       let itemnum= itemnum + 1
      endfor
     endif
"     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">",'~'.expand("<slnum>"))
     if inhidelist
      " remove sfxpat from list
      call remove(hidelist,itemnum)
      let g:netrw_list_hide= join(hidelist,",")
     elseif g:netrw_list_hide != ""
      " append sfxpat to non-empty list
      let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
     else
      " set hiding list to sfxpat
      let g:netrw_list_hide= sfxpat
     endif
    endfor

   " refresh the listing
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkHideSfx")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileGrep: (invoked by mg) This function applies vimgrep to marked files {{{2
"                     Uses the global markfilelist
fun! s:NetrwMarkFileGrep(islocal)
"  call Dfunc("s:NetrwMarkFileGrep(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curbufnr = bufnr("%")
  let curdir   = s:NetrwGetCurdir(a:islocal)

  if exists("s:netrwmarkfilelist")
"  call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
   let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
   call s:NetrwUnmarkAll()
  else
"   call Decho('no marked files, using "*"','~'.expand("<slnum>"))
   let netrwmarkfilelist= "*"
  endif

  " ask user for pattern
  call inputsave()
  let pat= input("Enter pattern: ","")
  call inputrestore()
  let patbang = ""
  if pat =~ '^!'
   let patbang = "!"
   let pat     = strpart(pat,2)
  endif
  if pat =~ '^\i'
   let pat    = escape(pat,'/')
   let pat    = '/'.pat.'/'
  else
   let nonisi = pat[0]
  endif

  " use vimgrep for both local and remote
"  call Decho("exe vimgrep".patbang." ".pat." ".netrwmarkfilelist,'~'.expand("<slnum>"))
  try
   exe "NetrwKeepj noautocmd vimgrep".patbang." ".pat." ".netrwmarkfilelist
  catch /^Vim\%((\a\+)\)\=:E480/
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pat.">",76)
"   call Dret("s:NetrwMarkFileGrep : unable to find pattern<".pat.">")
   return
  endtry
  echo "(use :cn, :cp to navigate, :Rex to return)"

  2match none
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

  if exists("nonisi")
   " original, user-supplied pattern did not begin with a character from isident
"   call Decho("looking for trailing nonisi<".nonisi."> followed by a j, gj, or jg",'~'.expand("<slnum>"))
   if pat =~ nonisi.'j$\|'.nonisi.'gj$\|'.nonisi.'jg$'
    call s:NetrwMarkFileQFEL(a:islocal,getqflist())
   endif
  endif

"  call Dret("s:NetrwMarkFileGrep")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileMove: (invoked by mm) execute arbitrary command on marked files, one at a time {{{2
"                      uses the global marked file list
"                      s:netrwmfloc= 0: target directory is remote
"                                  = 1: target directory is local
fun! s:NetrwMarkFileMove(islocal)
"  call Dfunc("s:NetrwMarkFileMove(islocal=".a:islocal.")")
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileMove")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if !exists("s:netrwmftgt")
   NetrwKeepj call netrw#ErrorMsg(2,"your marked file target is empty! (:help netrw-mt)",67)
"   call Dret("s:NetrwMarkFileCopy 0")
   return 0
  endif
"  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))

  if      a:islocal &&  s:netrwmftgt_islocal
   " move: local -> local
"   call Decho("move from local to local",'~'.expand("<slnum>"))
"   call Decho("local to local move",'~'.expand("<slnum>"))
   if !executable(g:netrw_localmovecmd) && g:netrw_localmovecmd !~ '^'.expand("$COMSPEC").'\s'
    call netrw#ErrorMsg(s:ERROR,"g:netrw_localmovecmd<".g:netrw_localmovecmd."> not executable on your system, aborting",90)
"    call Dfunc("s:NetrwMarkFileMove : g:netrw_localmovecmd<".g:netrw_localmovecmd."> n/a!")
    return
   endif
   let tgt         = s:ShellEscape(s:netrwmftgt)
"   call Decho("tgt<".tgt.">",'~'.expand("<slnum>"))
   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    let tgt         = substitute(tgt, '/','\\','g')
"    call Decho("windows exception: tgt<".tgt.">",'~'.expand("<slnum>"))
    if g:netrw_localmovecmd =~ '\s'
     let movecmd     = substitute(g:netrw_localmovecmd,'\s.*$','','')
     let movecmdargs = substitute(g:netrw_localmovecmd,'^.\{-}\(\s.*\)$','\1','')
     let movecmd     = netrw#WinPath(movecmd).movecmdargs
"     call Decho("windows exception: movecmd<".movecmd."> (#1: had a space)",'~'.expand("<slnum>"))
    else
     let movecmd = netrw#WinPath(movecmd)
"     call Decho("windows exception: movecmd<".movecmd."> (#2: no space)",'~'.expand("<slnum>"))
    endif
   else
    let movecmd = netrw#WinPath(g:netrw_localmovecmd)
"    call Decho("movecmd<".movecmd."> (#3 linux or cygwin)",'~'.expand("<slnum>"))
   endif
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
     let fname= substitute(fname,'/','\\','g')
    endif
"    call Decho("system(".movecmd." ".s:ShellEscape(fname)." ".tgt.")",'~'.expand("<slnum>"))
    let ret= system(movecmd." ".s:ShellEscape(fname)." ".tgt)
    if v:shell_error != 0
     if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
      call netrw#ErrorMsg(s:ERROR,"move failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",100)
     else
      call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localmovecmd<".g:netrw_localmovecmd.">; it doesn't work!",54)
     endif
     break
    endif
   endfor

  elseif  a:islocal && !s:netrwmftgt_islocal
   " move: local -> remote
"   call Decho("move from local to remote",'~'.expand("<slnum>"))
"   call Decho("copy",'~'.expand("<slnum>"))
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove",'~'.expand("<slnum>"))
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwLocalRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist

  elseif !a:islocal &&  s:netrwmftgt_islocal
   " move: remote -> local
"   call Decho("move from remote to local",'~'.expand("<slnum>"))
"   call Decho("copy",'~'.expand("<slnum>"))
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove",'~'.expand("<slnum>"))
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist

  elseif !a:islocal && !s:netrwmftgt_islocal
   " move: remote -> remote
"   call Decho("move from remote to remote",'~'.expand("<slnum>"))
"   call Decho("copy",'~'.expand("<slnum>"))
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove",'~'.expand("<slnum>"))
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist
  endif

  " -------
  " cleanup
  " -------
"  call Decho("cleanup",'~'.expand("<slnum>"))

  " remove markings from local buffer
  call s:NetrwUnmarkList(curbufnr,curdir)                   " remove markings from local buffer

  " refresh buffers
  if !s:netrwmftgt_islocal
"   call Decho("refresh netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
  endif
  if a:islocal
"   call Decho("refresh b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwRefreshDir(a:islocal,b:netrw_curdir)
  endif
  if g:netrw_fastbrowse <= 1
"   call Decho("since g:netrw_fastbrowse=".g:netrw_fastbrowse.", perform shell cmd refresh",'~'.expand("<slnum>"))
   NetrwKeepj call s:LocalBrowseRefresh()
  endif

"  call Dret("s:NetrwMarkFileMove")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFilePrint: (invoked by mp) This function prints marked files {{{2
"                       using the hardcopy command.  Local marked-file list only.
fun! s:NetrwMarkFilePrint(islocal)
"  call Dfunc("s:NetrwMarkFilePrint(islocal=".a:islocal.")")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFilePrint")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
  let curdir= s:NetrwGetCurdir(a:islocal)

  if exists("s:netrwmarkfilelist_{curbufnr}")
   let netrwmarkfilelist = s:netrwmarkfilelist_{curbufnr}
   call s:NetrwUnmarkList(curbufnr,curdir)
   for fname in netrwmarkfilelist
    if a:islocal
     if g:netrw_keepdir
      let fname= s:ComposePath(curdir,fname)
     endif
    else
     let fname= curdir.fname
    endif
    1split
    " the autocmds will handle both local and remote files
"    call Decho("exe sil e ".escape(fname,' '),'~'.expand("<slnum>"))
    exe "sil NetrwKeepj e ".fnameescape(fname)
"    call Decho("hardcopy",'~'.expand("<slnum>"))
    hardcopy
    q
   endfor
   2match none
  endif
"  call Dret("s:NetrwMarkFilePrint")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileRegexp: (invoked by mr) This function is used to mark {{{2
"                        files when given a regexp (for which a prompt is
"                        issued) (matches to name of files).
fun! s:NetrwMarkFileRegexp(islocal)
"  call Dfunc("s:NetrwMarkFileRegexp(islocal=".a:islocal.")")

  " get the regular expression
  call inputsave()
  let regexp= input("Enter regexp: ","","file")
  call inputrestore()

  if a:islocal
   let curdir= s:NetrwGetCurdir(a:islocal)
   " get the matching list of files using local glob()
"   call Decho("handle local regexp",'~'.expand("<slnum>"))
   let dirname = escape(b:netrw_curdir,g:netrw_glob_escape)
   if v:version == 704 && has("patch656")
    let files   = glob(s:ComposePath(dirname,regexp),0,0,1)
   else
    let files   = glob(s:ComposePath(dirname,regexp),0,0)
   endif
"   call Decho("files<".files.">",'~'.expand("<slnum>"))
   let filelist= split(files,"\n")

  " mark the list of files
  for fname in filelist
"   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwMarkFile(a:islocal,substitute(fname,'^.*/','',''))
  endfor

  else
"   call Decho("handle remote regexp",'~'.expand("<slnum>"))

   " convert displayed listing into a filelist
   let eikeep = &ei
   let areg   = @a
   sil NetrwKeepj %y a
   setl ei=all ma
"   call Decho("setl ei=all ma",'~'.expand("<slnum>"))
   1split
   NetrwKeepj call s:NetrwEnew()
   NetrwKeepj call s:NetrwSafeOptions()
   sil NetrwKeepj norm! "ap
   NetrwKeepj 2
   let bannercnt= search('^" =====','W')
   exe "sil NetrwKeepj 1,".bannercnt."d"
   setl bt=nofile
   if     g:netrw_liststyle == s:LONGLIST
    sil NetrwKeepj %s/\s\{2,}\S.*$//e
    call histdel("/",-1)
   elseif g:netrw_liststyle == s:WIDELIST
    sil NetrwKeepj %s/\s\{2,}/\r/ge
    call histdel("/",-1)
   elseif g:netrw_liststyle == s:TREELIST
    exe 'sil NetrwKeepj %s/^'.s:treedepthstring.' //e'
    sil! NetrwKeepj g/^ .*$/d
    call histdel("/",-1)
    call histdel("/",-1)
   endif
   " convert regexp into the more usual glob-style format
   let regexp= substitute(regexp,'\*','.*','g')
"   call Decho("regexp<".regexp.">",'~'.expand("<slnum>"))
   exe "sil! NetrwKeepj v/".escape(regexp,'/')."/d"
   call histdel("/",-1)
   let filelist= getline(1,line("$"))
   q!
   for filename in filelist
    NetrwKeepj call s:NetrwMarkFile(a:islocal,substitute(filename,'^.*/','',''))
   endfor
   unlet filelist
   let @a  = areg
   let &ei = eikeep
  endif
  echo "  (use me to edit marked files)"

"  call Dret("s:NetrwMarkFileRegexp")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileSource: (invoked by ms) This function sources marked files {{{2
"                        Uses the local marked file list.
fun! s:NetrwMarkFileSource(islocal)
"  call Dfunc("s:NetrwMarkFileSource(islocal=".a:islocal.")")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileSource")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
  let curdir= s:NetrwGetCurdir(a:islocal)

  if exists("s:netrwmarkfilelist_{curbufnr}")
   let netrwmarkfilelist = s:netrwmarkfilelist_{bufnr("%")}
   call s:NetrwUnmarkList(curbufnr,curdir)
   for fname in netrwmarkfilelist
    if a:islocal
     if g:netrw_keepdir
      let fname= s:ComposePath(curdir,fname)
     endif
    else
     let fname= curdir.fname
    endif
    " the autocmds will handle sourcing both local and remote files
"    call Decho("exe so ".fnameescape(fname),'~'.expand("<slnum>"))
    exe "so ".fnameescape(fname)
   endfor
   2match none
  endif
"  call Dret("s:NetrwMarkFileSource")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileTag: (invoked by mT) This function applies g:netrw_ctags to marked files {{{2
"                     Uses the global markfilelist
fun! s:NetrwMarkFileTag(islocal)
"  call Dfunc("s:NetrwMarkFileTag(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileTag")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist")
"   call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
   let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "s:ShellEscape(v:val,".!a:islocal.")"))
   call s:NetrwUnmarkAll()

   if a:islocal
    if executable(g:netrw_ctags)
"     call Decho("call system(".g:netrw_ctags." ".netrwmarkfilelist.")",'~'.expand("<slnum>"))
     call system(g:netrw_ctags." ".netrwmarkfilelist)
    else
     call netrw#ErrorMsg(s:ERROR,"g:netrw_ctags<".g:netrw_ctags."> is not executable!",51)
    endif
   else
    let cmd   = s:RemoteSystem(g:netrw_ctags." ".netrwmarkfilelist)
    call netrw#Obtain(a:islocal,"tags")
    let curdir= b:netrw_curdir
    1split
    NetrwKeepj e tags
    let path= substitute(curdir,'^\(.*\)/[^/]*$','\1/','')
"    call Decho("curdir<".curdir."> path<".path.">",'~'.expand("<slnum>"))
    exe 'NetrwKeepj %s/\t\(\S\+\)\t/\t'.escape(path,"/\n\r\\").'\1\t/e'
    call histdel("/",-1)
    wq!
   endif
   2match none
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   call winrestview(svpos)
  endif

"  call Dret("s:NetrwMarkFileTag")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileTgt:  (invoked by mt) This function sets up a marked file target {{{2
"   Sets up two variables,
"     s:netrwmftgt         : holds the target directory
"     s:netrwmftgt_islocal : 0=target directory is remote
"                            1=target directory is local
fun! s:NetrwMarkFileTgt(islocal)
" call Dfunc("s:NetrwMarkFileTgt(islocal=".a:islocal.")")
  let svpos  = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir = s:NetrwGetCurdir(a:islocal)
  let hadtgt = exists("s:netrwmftgt")
  if !exists("w:netrw_bannercnt")
   let w:netrw_bannercnt= b:netrw_bannercnt
  endif

  " set up target
  if line(".") < w:netrw_bannercnt
"   call Decho("set up target: line(.) < w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
   " if cursor in banner region, use b:netrw_curdir for the target unless its already the target
   if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal") && s:netrwmftgt == b:netrw_curdir
"    call Decho("cursor in banner region, and target already is <".b:netrw_curdir.">: removing target",'~'.expand("<slnum>"))
    unlet s:netrwmftgt s:netrwmftgt_islocal
    if g:netrw_fastbrowse <= 1
     call s:LocalBrowseRefresh()
    endif
    call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    call winrestview(svpos)
"    call Dret("s:NetrwMarkFileTgt : removed target")
    return
   else
    let s:netrwmftgt= b:netrw_curdir
"    call Decho("inbanner: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   endif

  else
   " get word under cursor.
   "  * If directory, use it for the target.
   "  * If file, use b:netrw_curdir for the target
"   call Decho("get word under cursor",'~'.expand("<slnum>"))
   let curword= s:NetrwGetWord()
   let tgtdir = s:ComposePath(curdir,curword)
   if a:islocal && isdirectory(s:NetrwFile(tgtdir))
    let s:netrwmftgt = tgtdir
"    call Decho("local isdir: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   elseif !a:islocal && tgtdir =~ '/$'
    let s:netrwmftgt = tgtdir
"    call Decho("remote isdir: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   else
    let s:netrwmftgt = curdir
"    call Decho("isfile: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   endif
  endif
  if a:islocal
   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
   let s:netrwmftgt= simplify(s:netrwmftgt)
"   call Decho("simplify: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
  endif
  if g:netrw_cygwin
   let s:netrwmftgt= substitute(system("cygpath ".s:ShellEscape(s:netrwmftgt)),'\n$','','')
   let s:netrwmftgt= substitute(s:netrwmftgt,'\n$','','')
  endif
  let s:netrwmftgt_islocal= a:islocal

  " need to do refresh so that the banner will be updated
  "  s:LocalBrowseRefresh handles all local-browsing buffers when not fast browsing
  if g:netrw_fastbrowse <= 1
"   call Decho("g:netrw_fastbrowse=".g:netrw_fastbrowse.", so refreshing all local netrw buffers")
   call s:LocalBrowseRefresh()
  endif
"  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,w:netrw_treetop))
  else
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  endif
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)
  if !hadtgt
   sil! NetrwKeepj norm! j
  endif

"  call Decho("getmatches=".string(getmatches()),'~'.expand("<slnum>"))
"  call Decho("s:netrwmarkfilelist=".(exists("s:netrwmarkfilelist")? string(s:netrwmarkfilelist) : 'n/a'),'~'.expand("<slnum>"))
"  call Dret("s:NetrwMarkFileTgt : netrwmftgt<".(exists("s:netrwmftgt")? s:netrwmftgt : "").">")
endfun

" ---------------------------------------------------------------------
" s:NetrwGetCurdir: gets current directory and sets up b:netrw_curdir if necessary {{{2
fun! s:NetrwGetCurdir(islocal)
"  call Dfunc("s:NetrwGetCurdir(islocal=".a:islocal.")")

  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
   let b:netrw_curdir = s:NetrwTreePath(w:netrw_treetop)
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used s:NetrwTreeDir)",'~'.expand("<slnum>"))
  elseif !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)",'~'.expand("<slnum>"))
  endif

"  call Decho("b:netrw_curdir<".b:netrw_curdir."> ".((b:netrw_curdir !~ '\<\a\{3,}://')? "does not match" : "matches")." url pattern")
  if b:netrw_curdir !~ '\<\a\{3,}://'
   let curdir= b:netrw_curdir
"   call Decho("g:netrw_keepdir=".g:netrw_keepdir)
   if g:netrw_keepdir == 0
    call s:NetrwLcd(curdir)
   endif
  endif

"  call Dret("s:NetrwGetCurdir <".curdir.">")
  return b:netrw_curdir
endfun

" ---------------------------------------------------------------------
" s:NetrwOpenFile: query user for a filename and open it {{{2
fun! s:NetrwOpenFile(islocal)
"  call Dfunc("s:NetrwOpenFile(islocal=".a:islocal.")")
  let ykeep= @@
  call inputsave()
  let fname= input("Enter filename: ")
  call inputrestore()
  if fname !~ '[/\\]'
   if exists("b:netrw_curdir")
    if exists("g:netrw_quiet")
     let netrw_quiet_keep = g:netrw_quiet
    endif
    let g:netrw_quiet = 1
    " save position for benefit of Rexplore
    let s:rexposn_{bufnr("%")}= winsaveview()
"    call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
    if b:netrw_curdir =~ '/$'
     exe "NetrwKeepj e ".fnameescape(b:netrw_curdir.fname)
    else
     exe "e ".fnameescape(b:netrw_curdir."/".fname)
    endif
    if exists("netrw_quiet_keep")
     let g:netrw_quiet= netrw_quiet_keep
    else
     unlet g:netrw_quiet
    endif
   endif
  else
   exe "NetrwKeepj e ".fnameescape(fname)
  endif
  let @@= ykeep
"  call Dret("s:NetrwOpenFile")
endfun

" ---------------------------------------------------------------------
" netrw#Shrink: shrinks/expands a netrw or Lexplorer window {{{2
"               For the mapping to this function be made via
"               netrwPlugin, you'll need to have had
"               g:netrw_usetab set to non-zero.
fun! netrw#Shrink()
"  call Dfunc("netrw#Shrink() ft<".&ft."> winwidth=".winwidth(0)." lexbuf#".((exists("t:netrw_lexbufnr"))? t:netrw_lexbufnr : 'n/a'))
  let curwin  = winnr()
  let wiwkeep = &wiw
  set wiw=1

  if &ft == "netrw"
   if winwidth(0) > g:netrw_wiw
    let t:netrw_winwidth= winwidth(0)
    exe "vert resize ".g:netrw_wiw
    wincmd l
    if winnr() == curwin
     wincmd h
    endif
"    call Decho("vert resize 0",'~'.expand("<slnum>"))
   else
    exe "vert resize ".t:netrw_winwidth
"    call Decho("vert resize ".t:netrw_winwidth,'~'.expand("<slnum>"))
   endif

  elseif exists("t:netrw_lexbufnr")
   exe bufwinnr(t:netrw_lexbufnr)."wincmd w"
   if     winwidth(bufwinnr(t:netrw_lexbufnr)) >  g:netrw_wiw
    let t:netrw_winwidth= winwidth(0)
    exe "vert resize ".g:netrw_wiw
    wincmd l
    if winnr() == curwin
     wincmd h
    endif
"    call Decho("vert resize 0",'~'.expand("<slnum>"))
   elseif winwidth(bufwinnr(t:netrw_lexbufnr)) >= 0
    exe "vert resize ".t:netrw_winwidth
"    call Decho("vert resize ".t:netrw_winwidth,'~'.expand("<slnum>"))
   else 
    call netrw#Lexplore(0,0)
   endif

  else
   call netrw#Lexplore(0,0)
  endif
  let wiw= wiwkeep

"  call Dret("netrw#Shrink")
endfun

" ---------------------------------------------------------------------
" s:NetSortSequence: allows user to edit the sorting sequence {{{2
fun! s:NetSortSequence(islocal)
"  call Dfunc("NetSortSequence(islocal=".a:islocal.")")

  let ykeep= @@
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call inputsave()
  let newsortseq= input("Edit Sorting Sequence: ",g:netrw_sort_sequence)
  call inputrestore()

  " refresh the listing
  let g:netrw_sort_sequence= newsortseq
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep

"  call Dret("NetSortSequence")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkList: delete local marked file list and remove their contents from the global marked-file list {{{2
"   User access provided by the <mF> mapping. (see :help netrw-mF)
"   Used by many MarkFile functions.
fun! s:NetrwUnmarkList(curbufnr,curdir)
"  call Dfunc("s:NetrwUnmarkList(curbufnr=".a:curbufnr." curdir<".a:curdir.">)")

  "  remove all files in local marked-file list from global list
  if exists("s:netrwmarkfilelist")
   for mfile in s:netrwmarkfilelist_{a:curbufnr}
    let dfile = s:ComposePath(a:curdir,mfile)       " prepend directory to mfile
    let idx   = index(s:netrwmarkfilelist,dfile)    " get index in list of dfile
    call remove(s:netrwmarkfilelist,idx)            " remove from global list
   endfor
   if s:netrwmarkfilelist == []
    unlet s:netrwmarkfilelist
   endif

   " getting rid of the local marked-file lists is easy
   unlet s:netrwmarkfilelist_{a:curbufnr}
  endif
  if exists("s:netrwmarkfilemtch_{a:curbufnr}")
   unlet s:netrwmarkfilemtch_{a:curbufnr}
  endif
  2match none
"  call Dret("s:NetrwUnmarkList")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkAll: remove the global marked file list and all local ones {{{2
fun! s:NetrwUnmarkAll()
"  call Dfunc("s:NetrwUnmarkAll()")
  if exists("s:netrwmarkfilelist")
   unlet s:netrwmarkfilelist
  endif
  sil call s:NetrwUnmarkAll2()
  2match none
"  call Dret("s:NetrwUnmarkAll")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkAll2: unmark all files from all buffers {{{2
fun! s:NetrwUnmarkAll2()
"  call Dfunc("s:NetrwUnmarkAll2()")
  redir => netrwmarkfilelist_let
  let
  redir END
  let netrwmarkfilelist_list= split(netrwmarkfilelist_let,'\n')          " convert let string into a let list
  call filter(netrwmarkfilelist_list,"v:val =~ '^s:netrwmarkfilelist_'") " retain only those vars that start as s:netrwmarkfilelist_
  call map(netrwmarkfilelist_list,"substitute(v:val,'\\s.*$','','')")    " remove what the entries are equal to
  for flist in netrwmarkfilelist_list
   let curbufnr= substitute(flist,'s:netrwmarkfilelist_','','')
   unlet s:netrwmarkfilelist_{curbufnr}
   unlet s:netrwmarkfilemtch_{curbufnr}
  endfor
"  call Dret("s:NetrwUnmarkAll2")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnMarkFile: called via mu map; unmarks *all* marked files, both global and buffer-local {{{2
"
" Marked files are in two types of lists:
"    s:netrwmarkfilelist    -- holds complete paths to all marked files
"    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
"
" Marked files suitable for use with 2match are in:
"    s:netrwmarkfilemtch_#   -- used with 2match to display marked files
fun! s:NetrwUnMarkFile(islocal)
"  call Dfunc("s:NetrwUnMarkFile(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curbufnr = bufnr("%")

  " unmark marked file list
  " (although I expect s:NetrwUpload() to do it, I'm just making sure)
  if exists("s:netrwmarkfilelist")
"   "   call Decho("unlet'ing: s:netrwmarkfilelist",'~'.expand("<slnum>"))
   unlet s:netrwmarkfilelist
  endif

  let ibuf= 1
  while ibuf < bufnr("$")
   if exists("s:netrwmarkfilelist_".ibuf)
    unlet s:netrwmarkfilelist_{ibuf}
    unlet s:netrwmarkfilemtch_{ibuf}
   endif
   let ibuf = ibuf + 1
  endwhile
  2match none

"  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
call winrestview(svpos)
"  call Dret("s:NetrwUnMarkFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwMenu: generates the menu for gvim and netrw {{{2
fun! s:NetrwMenu(domenu)

  if !exists("g:NetrwMenuPriority")
   let g:NetrwMenuPriority= 80
  endif

  if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
"   call Dfunc("NetrwMenu(domenu=".a:domenu.")")

   if !exists("s:netrw_menu_enabled") && a:domenu
"    call Decho("initialize menu",'~'.expand("<slnum>"))
    let s:netrw_menu_enabled= 1
    exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
    exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
    exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
    if g:netrw_dirhistmax > 0
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
    else
     exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
    endif
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Tab<tab>t	t'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
    exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Exten<tab>s      :let g:netrw_sort_by="exten"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
    exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
    let s:netrw_menucnt= 28
    call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
    call s:NetrwTgtMenu()      " let bookmarks and history be easy targets

   elseif !a:domenu
    let s:netrwcnt = 0
    let curwin     = winnr()
    windo if getline(2) =~ "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
    exe curwin."wincmd w"

    if s:netrwcnt <= 1
"     call Decho("clear menus",'~'.expand("<slnum>"))
     exe 'sil! unmenu '.g:NetrwTopLvlMenu
"     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*','~'.expand("<slnum>"))
     sil! unlet s:netrw_menu_enabled
    endif
   endif
"   call Dret("NetrwMenu")
   return
  endif

endfun

" ---------------------------------------------------------------------
" s:NetrwObtain: obtain file under cursor or from markfile list {{{2
"                Used by the O maps (as <SID>NetrwObtain())
fun! s:NetrwObtain(islocal)
"  call Dfunc("NetrwObtain(islocal=".a:islocal.")")

  let ykeep= @@
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   let islocal= s:netrwmarkfilelist_{bufnr('%')}[1] !~ '^\a\{3,}://'
   call netrw#Obtain(islocal,s:netrwmarkfilelist_{bufnr('%')})
   call s:NetrwUnmarkList(bufnr('%'),b:netrw_curdir)
  else
   call netrw#Obtain(a:islocal,expand("<cWORD>"))
  endif
  let @@= ykeep

"  call Dret("NetrwObtain")
endfun

" ---------------------------------------------------------------------
" s:NetrwPrevWinOpen: open file/directory in previous window.  {{{2
"   If there's only one window, then the window will first be split.
"   Returns:
"     choice = 0 : didn't have to choose
"     choice = 1 : saved modified file in window first
"     choice = 2 : didn't save modified file, opened window
"     choice = 3 : cancel open
fun! s:NetrwPrevWinOpen(islocal)
"  call Dfunc("s:NetrwPrevWinOpen(islocal=".a:islocal.")")

  let ykeep= @@
  " grab a copy of the b:netrw_curdir to pass it along to newly split windows
  let curdir = b:netrw_curdir

  " get last window number and the word currently under the cursor
  let origwin   = winnr()
  let lastwinnr = winnr("$")
  let curword   = s:NetrwGetWord()
  let choice    = 0
  let s:treedir = s:NetrwTreeDir(a:islocal)
  let curdir    = s:treedir
"  call Decho("winnr($)#".lastwinnr." curword<".curword.">",'~'.expand("<slnum>"))

  let didsplit = 0
  if lastwinnr == 1
   " if only one window, open a new one first
"   call Decho("only one window, so open a new one (g:netrw_alto=".g:netrw_alto.")",'~'.expand("<slnum>"))
   if g:netrw_preview
    " vertically split preview window
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
"    call Decho("exe ".(g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s",'~'.expand("<slnum>"))
    exe (g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s"
   else
    " horizontally split preview window
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
"    call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
    exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   endif
   let didsplit = 1
"   call Decho("did split",'~'.expand("<slnum>"))

  else
   NetrwKeepj call s:SaveBufVars()
   let eikeep= &ei
   setl ei=all
   wincmd p
"   call Decho("wincmd p  (now in win#".winnr().") curdir<".curdir.">",'~'.expand("<slnum>"))

   " prevwinnr: the window number of the "prev" window
   " prevbufnr: the buffer number of the buffer in the "prev" window
   " bnrcnt   : the qty of windows open on the "prev" buffer
   let prevwinnr   = winnr()
   let prevbufnr   = bufnr("%")
   let prevbufname = bufname("%")
   let prevmod     = &mod
   let bnrcnt      = 0
   NetrwKeepj call s:RestoreBufVars()
"   call Decho("after wincmd p: win#".winnr()." win($)#".winnr("$")." origwin#".origwin." &mod=".&mod." bufname(%)<".bufname("%")."> prevbufnr=".prevbufnr,'~'.expand("<slnum>"))

   " if the previous window's buffer has been changed (ie. its modified flag is set),
   " and it doesn't appear in any other extant window, then ask the
   " user if s/he wants to abandon modifications therein.
   if prevmod
"    call Decho("detected that prev window's buffer has been modified: prevbufnr=".prevbufnr." winnr()#".winnr(),'~'.expand("<slnum>"))
    windo if winbufnr(0) == prevbufnr | let bnrcnt=bnrcnt+1 | endif
"    call Decho("prevbufnr=".prevbufnr." bnrcnt=".bnrcnt." buftype=".&bt." winnr()=".winnr()." prevwinnr#".prevwinnr,'~'.expand("<slnum>"))
    exe prevwinnr."wincmd w"

    if bnrcnt == 1 && &hidden == 0
     " only one copy of the modified buffer in a window, and
     " hidden not set, so overwriting will lose the modified file.  Ask first...
     let choice = confirm("Save modified buffer<".prevbufname."> first?","&Yes\n&No\n&Cancel")
"     call Decho("(NetrwPrevWinOpen) prevbufname<".prevbufname."> choice=".choice." current-winnr#".winnr(),'~'.expand("<slnum>"))
     let &ei= eikeep

     if choice == 1
      " Yes -- write file & then browse
      let v:errmsg= ""
      sil w
      if v:errmsg != ""
       call netrw#ErrorMsg(s:ERROR,"unable to write <".(exists("prevbufname")? prevbufname : 'n/a').">!",30)
       exe origwin."wincmd w"
       let &ei = eikeep
       let @@  = ykeep
"       call Dret("s:NetrwPrevWinOpen ".choice." : unable to write <".prevbufname.">")
       return choice
      endif

     elseif choice == 2
      " No -- don't worry about changed file, just browse anyway
"      call Decho("don't worry about chgd file, just browse anyway (winnr($)#".winnr("$").")",'~'.expand("<slnum>"))
      echomsg "**note** changes to ".prevbufname." abandoned"

     else
      " Cancel -- don't do this
"      call Decho("cancel, don't browse, switch to win#".origwin,'~'.expand("<slnum>"))
      exe origwin."wincmd w"
      let &ei= eikeep
      let @@ = ykeep
"      call Dret("s:NetrwPrevWinOpen ".choice." : cancelled")
      return choice
     endif
    endif
   endif
   let &ei= eikeep
  endif

  " restore b:netrw_curdir (window split/enew may have lost it)
  let b:netrw_curdir= curdir
  if a:islocal < 2
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(a:islocal,curword))
   else
    call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,curword))
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwPrevWinOpen ".choice)
  return choice
endfun

" ---------------------------------------------------------------------
" s:NetrwUpload: load fname to tgt (used by NetrwMarkFileCopy()) {{{2
"                Always assumed to be local -> remote
"                call s:NetrwUpload(filename, target)
"                call s:NetrwUpload(filename, target, fromdirectory)
fun! s:NetrwUpload(fname,tgt,...)
"  call Dfunc("s:NetrwUpload(fname<".((type(a:fname) == 1)? a:fname : string(a:fname))."> tgt<".a:tgt.">) a:0=".a:0)

  if a:tgt =~ '^\a\{3,}://'
   let tgtdir= substitute(a:tgt,'^\a\{3,}://[^/]\+/\(.\{-}\)$','\1','')
  else
   let tgtdir= substitute(a:tgt,'^\(.*\)/[^/]*$','\1','')
  endif
"  call Decho("tgtdir<".tgtdir.">",'~'.expand("<slnum>"))

  if a:0 > 0
   let fromdir= a:1
  else
   let fromdir= getcwd()
  endif
"  call Decho("fromdir<".fromdir.">",'~'.expand("<slnum>"))

  if type(a:fname) == 1
   " handle uploading a single file using NetWrite
"   call Decho("handle uploading a single file via NetWrite",'~'.expand("<slnum>"))
   1split
"   call Decho("exe e ".fnameescape(s:NetrwFile(a:fname)),'~'.expand("<slnum>"))
   exe "NetrwKeepj e ".fnameescape(s:NetrwFile(a:fname))
"   call Decho("now locally editing<".expand("%").">, has ".line("$")." lines",'~'.expand("<slnum>"))
   if a:tgt =~ '/$'
    let wfname= substitute(a:fname,'^.*/','','')
"    call Decho("exe w! ".fnameescape(wfname),'~'.expand("<slnum>"))
    exe "w! ".fnameescape(a:tgt.wfname)
   else
"    call Decho("writing local->remote: exe w ".fnameescape(a:tgt),'~'.expand("<slnum>"))
    exe "w ".fnameescape(a:tgt)
"    call Decho("done writing local->remote",'~'.expand("<slnum>"))
   endif
   q!

  elseif type(a:fname) == 3
   " handle uploading a list of files via scp
"   call Decho("handle uploading a list of files via scp",'~'.expand("<slnum>"))
   let curdir= getcwd()
   if a:tgt =~ '^scp:'
    call s:NetrwLcd(fromdir)
    let filelist= deepcopy(s:netrwmarkfilelist_{bufnr('%')})
    let args    = join(map(filelist,"s:ShellEscape(v:val, 1)"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    let machine = substitute(a:tgt,'^scp://\([^/:]\+\).*$','\1','')
    let tgt     = substitute(a:tgt,'^scp://[^/]\+/\(.*\)$','\1','')
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.s:ShellEscape(useport,1)." ".args." ".s:ShellEscape(machine.":".tgt,1))
    call s:NetrwLcd(curdir)

   elseif a:tgt =~ '^ftp:'
    call s:NetrwMethod(a:tgt)

    if b:netrw_method == 2
     " handle uploading a list of files via ftp+.netrc
     let netrw_fname = b:netrw_fname
     sil NetrwKeepj new
"     call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))

     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     NetrwKeepj call setline(line("$")+1,'lcd "'.fromdir.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

     if tgtdir == ""
      let tgtdir= '/'
     endif
     NetrwKeepj call setline(line("$")+1,'cd "'.tgtdir.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

     for fname in a:fname
      NetrwKeepj call setline(line("$")+1,'put "'.s:NetrwFile(fname).'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endfor

     if exists("g:netrw_port") && g:netrw_port != ""
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
     else
"      call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     sil NetrwKeepj g/Local directory now/d
     call histdel("/",-1)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      call netrw#ErrorMsg(s:ERROR,getline(1),14)
     else
      bw!|q
     endif

    elseif b:netrw_method == 3
     " upload with ftp + machine, id, passwd, and fname (ie. no .netrc)
     let netrw_fname= b:netrw_fname
     NetrwKeepj call s:SaveBufVars()|sil NetrwKeepj new|NetrwKeepj call s:RestoreBufVars()
     let tmpbufnr= bufnr("%")
     setl ff=unix

     if exists("g:netrw_port") && g:netrw_port != ""
      NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     else
      NetrwKeepj put ='open '.g:netrw_machine
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("g:netrw_uid") && g:netrw_uid != ""
      if exists("g:netrw_ftp") && g:netrw_ftp == 1
       NetrwKeepj put =g:netrw_uid
"       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
       if exists("s:netrw_passwd")
        NetrwKeepj call setline(line("$")+1,'"'.s:netrw_passwd.'"')
       endif
"       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
      elseif exists("s:netrw_passwd")
       NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
      endif
     endif

     NetrwKeepj call setline(line("$")+1,'lcd "'.fromdir.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

     if exists("b:netrw_fname") && b:netrw_fname != ""
      NetrwKeepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     for fname in a:fname
      NetrwKeepj call setline(line("$")+1,'put "'.fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endfor

     " perform ftp:
     " -i       : turns off interactive prompting from ftp
     " -n  unix : DON'T use <.netrc>, even though it exists
     " -n  win32: quit being obnoxious about password
     NetrwKeepj norm! 1Gdd
     call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     sil NetrwKeepj g/Local directory now/d
     call histdel("/",-1)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep= &debug
      setl debug=msg
      call netrw#ErrorMsg(s:ERROR,getline(1),15)
      let &debug = debugkeep
      let mod    = 1
     else
      bw!|q
     endif
    elseif !exists("b:netrw_method") || b:netrw_method < 0
"     call Dfunc("netrw#NetrwUpload : unsupported method")
     return
    endif
   else
    call netrw#ErrorMsg(s:ERROR,"can't obtain files with protocol from<".a:tgt.">",63)
   endif
  endif

"  call Dret("s:NetrwUpload")
endfun

" ---------------------------------------------------------------------
" s:NetrwPreview: {{{2
fun! s:NetrwPreview(path) range
"  call Dfunc("NetrwPreview(path<".a:path.">)")
  let ykeep= @@
  NetrwKeepj call s:NetrwOptionSave("s:")
  NetrwKeepj call s:NetrwSafeOptions()
  if has("quickfix")
   if !isdirectory(s:NetrwFile(a:path))
    if g:netrw_preview && !g:netrw_alto
     let pvhkeep = &pvh
     let winsz   = (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
     let &pvh    = winwidth(0) - winsz
    endif
    exe (g:netrw_alto? "top " : "bot ").(g:netrw_preview? "vert " : "")."pedit ".fnameescape(a:path)
    if exists("pvhkeep")
     let &pvh= pvhkeep
    endif
   elseif !exists("g:netrw_quiet")
    NetrwKeepj call netrw#ErrorMsg(s:WARNING,"sorry, cannot preview a directory such as <".a:path.">",38)
   endif
  elseif !exists("g:netrw_quiet")
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"sorry, to preview your vim needs the quickfix feature compiled in",39)
  endif
  NetrwKeepj call s:NetrwOptionRestore("s:")
  let @@= ykeep
"  call Dret("NetrwPreview")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefresh: {{{2
fun! s:NetrwRefresh(islocal,dirname)
"  call Dfunc("s:NetrwRefresh(islocal<".a:islocal.">,dirname=".a:dirname.") hide=".g:netrw_hide." sortdir=".g:netrw_sort_direction)
  " at the current time (Mar 19, 2007) all calls to NetrwRefresh() call NetrwBrowseChgDir() first.
  setl ma noro
"  call Decho("setl ma noro",'~'.expand("<slnum>"))
"  call Decho("clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
  let ykeep      = @@

  " save the cursor position before refresh.
  let screenposn = winsaveview()
"  call Decho("saving posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))

"  call Decho("win#".winnr().": ".winheight(0)."x".winwidth(0)." curfile<".expand("%").">",'~'.expand("<slnum>"))
"  call Decho("clearing buffer prior to refresh",'~'.expand("<slnum>"))
  sil! NetrwKeepj %d _
  if a:islocal
   NetrwKeepj call netrw#LocalBrowseCheck(a:dirname)
  else
   NetrwKeepj call s:NetrwBrowse(a:islocal,a:dirname)
  endif

  " restore position
"  call Decho("restoring posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(screenposn)

  " restore file marks
  if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/",'~'.expand("<slnum>"))
   exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
  else
"   call Decho("2match none  (bufnr(%)=".bufnr("%")."<".bufname("%").">)",'~'.expand("<slnum>"))
   2match none
  endif

"  restore
  let @@= ykeep
"  call Dret("s:NetrwRefresh")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefreshDir: refreshes a directory by name {{{2
"                    Called by NetrwMarkFileCopy()
"                    Interfaces to s:NetrwRefresh() and s:LocalBrowseRefresh()
fun! s:NetrwRefreshDir(islocal,dirname)
"  call Dfunc("s:NetrwRefreshDir(islocal=".a:islocal." dirname<".a:dirname.">) g:netrw_fastbrowse=".g:netrw_fastbrowse)
  if g:netrw_fastbrowse == 0
   " slowest mode (keep buffers refreshed, local or remote)
"   call Decho("slowest mode: keep buffers refreshed, local or remote",'~'.expand("<slnum>"))
   let tgtwin= bufwinnr(a:dirname)
"   call Decho("tgtwin= bufwinnr(".a:dirname.")=".tgtwin,'~'.expand("<slnum>"))

   if tgtwin > 0
    " tgtwin is being displayed, so refresh it
    let curwin= winnr()
"    call Decho("refresh tgtwin#".tgtwin." (curwin#".curwin.")",'~'.expand("<slnum>"))
    exe tgtwin."wincmd w"
    NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
    exe curwin."wincmd w"

   elseif bufnr(a:dirname) > 0
    let bn= bufnr(a:dirname)
"    call Decho("bd bufnr(".a:dirname.")=".bn,'~'.expand("<slnum>"))
    exe "sil keepj bd ".bn
   endif

  elseif g:netrw_fastbrowse <= 1
"   call Decho("medium-speed mode: refresh local buffers only",'~'.expand("<slnum>"))
   NetrwKeepj call s:LocalBrowseRefresh()
  endif
"  call Dret("s:NetrwRefreshDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetChgwin: set g:netrw_chgwin; a <cr> will use the specified
" window number to do its editing in.
" Supports   [count]C  where the count, if present, is used to specify
" a window to use for editing via the <cr> mapping.
fun! s:NetrwSetChgwin(...)
"  call Dfunc("s:NetrwSetChgwin() v:count=".v:count)
  if a:0 > 0
"   call Decho("a:1<".a:1.">",'~'.expand("<slnum>"))
   if a:1 == ""    " :NetrwC win#
    let g:netrw_chgwin= winnr()
   else              " :NetrwC
    let g:netrw_chgwin= a:1
   endif
  elseif v:count > 0 " [count]C
   let g:netrw_chgwin= v:count
  else               " C
   let g:netrw_chgwin= winnr()
  endif
  echo "editing window now set to window#".g:netrw_chgwin
"  call Dret("s:NetrwSetChgwin : g:netrw_chgwin=".g:netrw_chgwin)
endfun

" ---------------------------------------------------------------------
" s:NetrwSetSort: sets up the sort based on the g:netrw_sort_sequence {{{2
"          What this function does is to compute a priority for the patterns
"          in the g:netrw_sort_sequence.  It applies a substitute to any
"          "files" that satisfy each pattern, putting the priority / in
"          front.  An "*" pattern handles the default priority.
fun! s:NetrwSetSort()
"  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
  let ykeep= @@
  if w:netrw_liststyle == s:LONGLIST
   let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
  else
   let seqlist  = g:netrw_sort_sequence
  endif
  " sanity check -- insure that * appears somewhere
  if seqlist == ""
   let seqlist= '*'
  elseif seqlist !~ '\*'
   let seqlist= seqlist.',*'
  endif
  let priority = 1
  while seqlist != ""
   if seqlist =~ ','
    let seq     = substitute(seqlist,',.*$','','e')
    let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
   else
    let seq     = seqlist
    let seqlist = ""
   endif
   if priority < 10
    let spriority= "00".priority.g:netrw_sepchr
   elseif priority < 100
    let spriority= "0".priority.g:netrw_sepchr
   else
    let spriority= priority.g:netrw_sepchr
   endif
"   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">",'~'.expand("<slnum>"))

   " sanity check
   if w:netrw_bannercnt > line("$")
    " apparently no files were left after a Hiding pattern was used
"    call Dret("SetSort : no files left after hiding")
    return
   endif
   if seq == '*'
    let starpriority= spriority
   else
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
    call histdel("/",-1)
    " sometimes multiple sorting patterns will match the same file or directory.
    " The following substitute is intended to remove the excess matches.
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
    NetrwKeepj call histdel("/",-1)
   endif
   let priority = priority + 1
  endwhile
  if exists("starpriority")
   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/e'
   NetrwKeepj call histdel("/",-1)
  endif

  " Following line associated with priority -- items that satisfy a priority
  " pattern get prefixed by ###/ which permits easy sorting by priority.
  " Sometimes files can satisfy multiple priority patterns -- only the latest
  " priority pattern needs to be retained.  So, at this point, these excess
  " priority prefixes need to be removed, but not directories that happen to
  " be just digits themselves.
  exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
  NetrwKeepj call histdel("/",-1)
  let @@= ykeep

"  call Dret("SetSort")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetTgt: sets the target to the specified choice index {{{2
"    Implements [count]Tb  (bookhist<b>)
"               [count]Th  (bookhist<h>)
"               See :help netrw-qb for how to make the choice.
fun! s:NetrwSetTgt(islocal,bookhist,choice)
"  call Dfunc("s:NetrwSetTgt(islocal=".a:islocal." bookhist<".a:bookhist."> choice#".a:choice.")")

  if     a:bookhist == 'b'
   " supports choosing a bookmark as a target using a qb-generated list
   let choice= a:choice - 1
   if exists("g:netrw_bookmarklist[".choice."]")
    call netrw#MakeTgt(g:netrw_bookmarklist[choice])
   else
    echomsg "Sorry, bookmark#".a:choice." doesn't exist!"
   endif

  elseif a:bookhist == 'h'
   " supports choosing a history stack entry as a target using a qb-generated list
   let choice= (a:choice % g:netrw_dirhistmax) + 1
   if exists("g:netrw_dirhist_".choice)
    let histentry = g:netrw_dirhist_{choice}
    call netrw#MakeTgt(histentry)
   else
    echomsg "Sorry, history#".a:choice." not available!"
   endif
  endif

  " refresh the display
  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
  endif
  call s:NetrwRefresh(a:islocal,b:netrw_curdir)

"  call Dret("s:NetrwSetTgt")
endfun

" =====================================================================
" s:NetrwSortStyle: change sorting style (name - time - size) and refresh display {{{2
fun! s:NetrwSortStyle(islocal)
"  call Dfunc("s:NetrwSortStyle(islocal=".a:islocal.") netrw_sort_by<".g:netrw_sort_by.">")
  NetrwKeepj call s:NetrwSaveWordPosn()
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  let g:netrw_sort_by= (g:netrw_sort_by =~ '^n')? 'time' : (g:netrw_sort_by =~ '^t')? 'size' : (g:netrw_sort_by =~ '^siz')? 'exten' : 'name'
  NetrwKeepj norm! 0
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

"  call Dret("s:NetrwSortStyle : netrw_sort_by<".g:netrw_sort_by.">")
endfun

" ---------------------------------------------------------------------
" s:NetrwSplit: mode {{{2
"           =0 : net   and o
"           =1 : net   and t
"           =2 : net   and v
"           =3 : local and o
"           =4 : local and t
"           =5 : local and v
fun! s:NetrwSplit(mode)
"  call Dfunc("s:NetrwSplit(mode=".a:mode.") alto=".g:netrw_alto." altv=".g:netrw_altv)

  let ykeep= @@
  call s:SaveWinVars()

  if a:mode == 0
   " remote and o
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
   exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 1
   " remote and t
   let newdir  = s:NetrwBrowseChgDir(0,s:NetrwGetWord())
"   call Decho("tabnew",'~'.expand("<slnum>"))
   tabnew
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call s:NetrwBrowse(0,newdir)
   unlet s:didsplit

  elseif a:mode == 2
   " remote and v
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v",'~'.expand("<slnum>"))
   exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 3
   " local and o
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
   exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 4
   " local and t
   let cursorword  = s:NetrwGetWord()
   let eikeep      = &ei
   let netrw_winnr = winnr()
   let netrw_line  = line(".")
   let netrw_col   = virtcol(".")
   NetrwKeepj norm! H0
   let netrw_hline = line(".")
   setl ei=all
   exe "NetrwKeepj norm! ".netrw_hline."G0z\<CR>"
   exe "NetrwKeepj norm! ".netrw_line."G0".netrw_col."\<bar>"
   let &ei          = eikeep
   let netrw_curdir = s:NetrwTreeDir(0)
"   call Decho("tabnew",'~'.expand("<slnum>"))
   tabnew
   let b:netrw_curdir = netrw_curdir
   let s:didsplit     = 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,cursorword))
   if &ft == "netrw"
    setl ei=all
    exe "NetrwKeepj norm! ".netrw_hline."G0z\<CR>"
    exe "NetrwKeepj norm! ".netrw_line."G0".netrw_col."\<bar>"
    let &ei= eikeep
   endif
   unlet s:didsplit

  elseif a:mode == 5
   " local and v
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v",'~'.expand("<slnum>"))
   exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   "call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   unlet s:didsplit

  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"(NetrwSplit) unsupported mode=".a:mode,45)
  endif

  let @@= ykeep
"  call Dret("s:NetrwSplit")
endfun

" ---------------------------------------------------------------------
" s:NetrwTgtMenu: {{{2
fun! s:NetrwTgtMenu()
  if !exists("s:netrw_menucnt")
   return
  endif
"  call Dfunc("s:NetrwTgtMenu()")

  " the following test assures that gvim is running, has menus available, and has menus enabled.
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   if exists("g:NetrwTopLvlMenu")
"    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
    exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
   endif
   if !exists("s:netrw_initbookhist")
    call s:NetrwBookHistRead()
   endif

   " try to cull duplicate entries
   let tgtdict={}

   " target bookmarked places
   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
"    call Decho("installing bookmarks as easy targets",'~'.expand("<slnum>"))
    let cnt= 1
    for bmd in g:netrw_bookmarklist
     if has_key(tgtdict,bmd)
      let cnt= cnt + 1
      continue
     endif
     let tgtdict[bmd]= cnt
     let ebmd= escape(bmd,g:netrw_menu_escape)
     " show bookmarks for goto menu
"     call Decho("menu: Targets: ".bmd,'~'.expand("<slnum>"))
     exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#MakeTgt('".bmd."')\<cr>"
     let cnt= cnt + 1
    endfor
   endif

   " target directory browsing history
   if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
"    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")",'~'.expand("<slnum>"))
    let histcnt = 1
    while histcnt <= g:netrw_dirhistmax
     let priority = g:netrw_dirhist_cnt + histcnt
     if exists("g:netrw_dirhist_{histcnt}")
      let histentry  = g:netrw_dirhist_{histcnt}
      if has_key(tgtdict,histentry)
       let histcnt = histcnt + 1
       continue
      endif
      let tgtdict[histentry] = histcnt
      let ehistentry         = escape(histentry,g:netrw_menu_escape)
"      call Decho("menu: Targets: ".histentry,'~'.expand("<slnum>"))
      exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#MakeTgt('".histentry."')\<cr>"
     endif
     let histcnt = histcnt + 1
    endwhile
   endif
  endif
"  call Dret("s:NetrwTgtMenu")
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeDir: determine tree directory given current cursor position {{{2
" (full path directory with trailing slash returned)
fun! s:NetrwTreeDir(islocal)
"  call Dfunc("s:NetrwTreeDir(islocal=".a:islocal.") getline(".line(".").")"."<".getline('.')."> b:netrw_curdir<".b:netrw_curdir."> tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft)
"  call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'))
"  call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
"  call Decho("w:netrw_treetop  =".(exists("w:netrw_treetop")?   w:netrw_treetop   : 'n/a'))

  if exists("s:treedir")
   " s:NetrwPrevWinOpen opens a "previous" window -- and thus needs to and does call s:NetrwTreeDir early
   let treedir= s:treedir
   unlet s:treedir
"   call Dret("s:NetrwTreeDir ".treedir)
   return treedir
  endif

  if !exists("b:netrw_curdir") || b:netrw_curdir == ""
   let b:netrw_curdir= getcwd()
  endif
  let treedir = b:netrw_curdir
"  call Decho("set initial treedir<".treedir.">",'~'.expand("<slnum>"))

  let s:treecurpos= winsaveview()
"  call Decho("saving posn to s:treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))

  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
"   call Decho("w:netrw_liststyle is TREELIST:",'~'.expand("<slnum>"))
"   call Decho("line#".line(".")." getline(.)<".getline('.')."> treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))

   " extract tree directory if on a line specifying a subdirectory (ie. ends with "/")
   let curline= substitute(getline('.'),"\t -->.*$",'','')
   if curline =~ '/$'
"    call Decho("extract tree subdirectory from current line",'~'.expand("<slnum>"))
    let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
"    call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
   elseif curline =~ '@$'
"    call Decho("handle symbolic link from current line",'~'.expand("<slnum>"))
    let treedir= resolve(substitute(substitute(getline('.'),'@.*$','','e'),'^|*\s*','','e'))
"    call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
   else
"    call Decho("do not extract tree subdirectory from current line and set treedir to empty",'~'.expand("<slnum>"))
    let treedir= ""
   endif

   " detect user attempting to close treeroot
"   call Decho("check if user is attempting to close treeroot",'~'.expand("<slnum>"))
"   call Decho(".win#".winnr()." buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
"   call Decho(".getline(".line(".").")<".getline('.').'> '.((getline('.') =~ '^'.s:treedepthstring)? '=~' : '!~').' ^'.s:treedepthstring,'~'.expand("<slnum>"))
   if curline !~ '^'.s:treedepthstring && getline('.') != '..'
"    call Decho(".user may have attempted to close treeroot",'~'.expand("<slnum>"))
    " now force a refresh
"    call Decho(".force refresh: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
    sil! NetrwKeepj %d _
"    call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".(exists("s:treecurpos")? string(s:treecurpos) : 'n/a').">")
    return b:netrw_curdir
"   else " Decho
"    call Decho(".user not attempting to close treeroot",'~'.expand("<slnum>"))
   endif

"   call Decho("islocal=".a:islocal." curline<".curline.">",'~'.expand("<slnum>"))
   let potentialdir= s:NetrwFile(substitute(curline,'^'.s:treedepthstring.'\+ \(.*\)@$','\1',''))
"   call Decho("potentialdir<".potentialdir."> isdir=".isdirectory(potentialdir),'~'.expand("<slnum>"))

   " COMBAK: a symbolic link may point anywhere -- so it will be used to start a new treetop
"   if a:islocal && curline =~ '@$' && isdirectory(s:NetrwFile(potentialdir))
"    let newdir          = w:netrw_treetop.'/'.potentialdir
" "   call Decho("apply NetrwTreePath to newdir<".newdir.">",'~'.expand("<slnum>"))
"    let treedir         = s:NetrwTreePath(newdir)
"    let w:netrw_treetop = newdir
" "   call Decho("newdir <".newdir.">",'~'.expand("<slnum>"))
"   else
"    call Decho("apply NetrwTreePath to treetop<".w:netrw_treetop.">",'~'.expand("<slnum>"))
    let treedir = s:NetrwTreePath(w:netrw_treetop)
"   endif
  endif

  " sanity maintenance: keep those //s away...
  let treedir= substitute(treedir,'//$','/','')
"  call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))

"  call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".(exists("s:treecurpos")? string(s:treecurpos) : 'n/a').">")
  return treedir
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeDisplay: recursive tree display {{{2
fun! s:NetrwTreeDisplay(dir,depth)
"  call Dfunc("NetrwTreeDisplay(dir<".a:dir."> depth<".a:depth.">)")

  " insure that there are no folds
  setl nofen

  " install ../ and shortdir
  if a:depth == ""
   call setline(line("$")+1,'../')
"   call Decho("setline#".line("$")." ../ (depth is zero)",'~'.expand("<slnum>"))
  endif
  if a:dir =~ '^\a\{3,}://'
   if a:dir == w:netrw_treetop
    let shortdir= a:dir
   else
    let shortdir= substitute(a:dir,'^.*/\([^/]\+\)/$','\1/','e')
   endif
   call setline(line("$")+1,a:depth.shortdir)
  else
   let shortdir= substitute(a:dir,'^.*/','','e')
   call setline(line("$")+1,a:depth.shortdir.'/')
  endif
"  call Decho("setline#".line("$")." shortdir<".a:depth.shortdir.">",'~'.expand("<slnum>"))

  " append a / to dir if its missing one
  let dir= a:dir

  " display subtrees (if any)
  let depth= s:treedepthstring.a:depth
"  call Decho("display subtrees with depth<".depth."> and current leaves",'~'.expand("<slnum>"))

"  call Decho("for every entry in w:netrw_treedict[".dir."]=".string(w:netrw_treedict[dir]),'~'.expand("<slnum>"))
  for entry in w:netrw_treedict[dir]
   if dir =~ '/$'
    let direntry= substitute(dir.entry,'[@/]$','','e')
   else
    let direntry= substitute(dir.'/'.entry,'[@/]$','','e')
   endif
"   call Decho("dir<".dir."> entry<".entry."> direntry<".direntry.">",'~'.expand("<slnum>"))
   if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
"    call Decho("<".direntry."> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwTreeDisplay(direntry,depth)
   elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwTreeDisplay(direntry.'/',depth)
   elseif entry =~ '@$' && has_key(w:netrw_treedict,direntry.'@')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwTreeDisplay(direntry.'/',depth)
   else
"    call Decho("<".entry."> is not a key in treedict (no subtree)",'~'.expand("<slnum>"))
    sil! NetrwKeepj call setline(line("$")+1,depth.entry)
   endif
  endfor

"  call Dret("NetrwTreeDisplay")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefreshTreeDict: updates the contents information for a tree (w:netrw_treedict) {{{2
fun! s:NetrwRefreshTreeDict(dir)
"  call Dfunc("s:NetrwRefreshTreeDict(dir<".a:dir.">)")
  for entry in w:netrw_treedict[a:dir]
   let direntry= substitute(a:dir.'/'.entry,'[@/]$','','e')
"   call Decho("a:dir<".a:dir."> entry<".entry."> direntry<".direntry.">",'~'.expand("<slnum>"))

   if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
"    call Decho("<".direntry."> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshTreeDict(direntry)
    let liststar                   = s:NetrwGlob(direntry,'*')
    let listdotstar                = s:NetrwGlob(direntry,'.*')
    let w:netrw_treedict[direntry] = liststar + listdotstar
"    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))

   elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshTreeDict(direntry.'/')
    let liststar   = s:NetrwGlob(direntry.'/','*')
    let listdotstar= s:NetrwGlob(direntry.'/','.*')
    let w:netrw_treedict[direntry]= liststar + listdotstar
"    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))

   elseif entry =~ '@$' && has_key(w:netrw_treedict,direntry.'@')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshTreeDict(direntry.'/')
    let liststar   = s:NetrwGlob(direntry.'/','*')
    let listdotstar= s:NetrwGlob(direntry.'/','.*')
"    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))

   else
"    call Decho('not updating w:netrw_treedict['.direntry.'] with entry<'.entry.'> (no subtree)',,'~'.expand("<slnum>"))
   endif
  endfor
"  call Dret("s:NetrwRefreshTreeDict")
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeListing: displays tree listing from treetop on down, using NetrwTreeDisplay() {{{2
"                     Called by s:PerformListing()
fun! s:NetrwTreeListing(dirname)
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
"   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
"   call Decho("curdir<".a:dirname.">",'~'.expand("<slnum>"))
"   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exist")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"),'~'.expand("<slnum>"))
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

   " update the treetop
"   call Decho("update the treetop",'~'.expand("<slnum>"))
   if !exists("w:netrw_treetop")
    let w:netrw_treetop= a:dirname
"    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)",'~'.expand("<slnum>"))
   elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
    let w:netrw_treetop= a:dirname
"    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)",'~'.expand("<slnum>"))
   endif

   if !exists("w:netrw_treedict")
    " insure that we have a treedict, albeit empty
"    call Decho("initializing w:netrw_treedict to empty",'~'.expand("<slnum>"))
    let w:netrw_treedict= {}
   endif

   " update the dictionary for the current directory
"   call Decho("updating: w:netrw_treedict[".a:dirname.'] -> [directory listing]','~'.expand("<slnum>"))
"   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." line($)=".line("$"),'~'.expand("<slnum>"))
   exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d _'
   let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
"   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]),'~'.expand("<slnum>"))
   exe "sil! NetrwKeepj ".w:netrw_bannercnt.",$d _"

   " if past banner, record word
   if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
    let fname= expand("<cword>")
   else
    let fname= ""
   endif
"   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

   " display from treetop on down
   NetrwKeepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
"   call Decho("s:NetrwTreeDisplay) setl noma nomod ro",'~'.expand("<slnum>"))

   " remove any blank line remaining as line#1 (happens in treelisting mode with banner suppressed)
   while getline(1) =~ '^\s*$' && byte2line(1) > 0
"    call Decho("deleting blank line",'~'.expand("<slnum>"))
    1d
   endwhile

   exe "setl ".g:netrw_bufsettings

"   call Dret("NetrwTreeListing : bufname<".expand("%").">")
   return
  endif
endfun

" ---------------------------------------------------------------------
" s:NetrwTreePath: returns path to current file in tree listing {{{2
"                  Normally, treetop is w:netrw_treetop, but a
"                  user of the function ( netrw#SetTreetop() )
"                  wipes that out prior to calling this function
fun! s:NetrwTreePath(treetop)
"  call Dfunc("s:NetrwTreePath() line#".line(".")."<".getline(".").">")
  let svpos = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
"  call Decho("depth<".depth."> 1st subst",'~'.expand("<slnum>"))
  let depth = substitute(depth,'^'.s:treedepthstring,'','')
"  call Decho("depth<".depth."> 2nd subst (first depth removed)",'~'.expand("<slnum>"))
  let curline= getline('.')
"  call Decho("curline<".curline.'>','~'.expand("<slnum>"))
  if curline =~ '/$'
"   call Decho("extract tree directory from current line",'~'.expand("<slnum>"))
   let treedir= substitute(curline,'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
"   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
  elseif curline =~ '@\s\+-->'
"   call Decho("extract tree directory using symbolic link",'~'.expand("<slnum>"))
   let treedir= substitute(curline,'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
   let treedir= substitute(treedir,'@\s\+-->.*$','','e')
"   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
  else
"   call Decho("do not extract tree directory from current line and set treedir to empty",'~'.expand("<slnum>"))
   let treedir= ""
  endif
  " construct treedir by searching backwards at correct depth
"  call Decho("construct treedir by searching backwards for correct depth",'~'.expand("<slnum>"))
"  call Decho("initial      treedir<".treedir."> depth<".depth.">",'~'.expand("<slnum>"))
  while depth != "" && search('^'.depth.'[^'.s:treedepthstring.'].\{-}/$','bW')
   let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
   let treedir= dirname.treedir
   let depth  = substitute(depth,'^'.s:treedepthstring,'','')
"   call Decho("constructing treedir<".treedir.">: dirname<".dirname."> while depth<".depth.">",'~'.expand("<slnum>"))
  endwhile
  if a:treetop =~ '/$'
   let treedir= a:treetop.treedir
  else
   let treedir= a:treetop.'/'.treedir
  endif
  let treedir= substitute(treedir,'//$','/','')
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))"
  call winrestview(svpos)
"  call Dret("s:NetrwTreePath <".treedir.">")
  return treedir
endfun

" ---------------------------------------------------------------------
" s:NetrwWideListing: {{{2
fun! s:NetrwWideListing()

  if w:netrw_liststyle == s:WIDELIST
"   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
   " look for longest filename (cpf=characters per filename)
   " cpf: characters per filename
   " fpl: filenames per line
   " fpc: filenames per column
   setl ma noro
"   call Decho("setl ma noro",'~'.expand("<slnum>"))
   let b:netrw_cpf= 0
   if line("$") >= w:netrw_bannercnt
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
    NetrwKeepj call histdel("/",-1)
   else
"    call Dret("NetrwWideListing")
    return
   endif
   let b:netrw_cpf= b:netrw_cpf + 2
"   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf,'~'.expand("<slnum>"))

   " determine qty files per line (fpl)
   let w:netrw_fpl= winwidth(0)/b:netrw_cpf
   if w:netrw_fpl <= 0
    let w:netrw_fpl= 1
   endif
"   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl,'~'.expand("<slnum>"))

   " make wide display
   "   fpc: files per column of wide listing
   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'S",submatch(0)),"\\")/'
   NetrwKeepj call histdel("/",-1)
   let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
   let newcolstart = w:netrw_bannercnt + fpc
   let newcolend   = newcolstart + fpc - 1
"   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]",'~'.expand("<slnum>"))
   if has("clipboard")
    sil! let keepregstar = @*
    sil! let keepregplus = @+
   endif
   while line("$") >= newcolstart
    if newcolend > line("$") | let newcolend= line("$") | endif
    let newcolqty= newcolend - newcolstart
    exe newcolstart
    if newcolqty == 0
     exe "sil! NetrwKeepj norm! 0\<c-v>$hx".w:netrw_bannercnt."G$p"
    else
     exe "sil! NetrwKeepj norm! 0\<c-v>".newcolqty.'j$hx'.w:netrw_bannercnt.'G$p'
    endif
    exe "sil! NetrwKeepj ".newcolstart.','.newcolend.'d _'
    exe 'sil! NetrwKeepj '.w:netrw_bannercnt
   endwhile
   if has("clipboard")
    sil! let @*= keepregstar
    sil! let @+= keepregplus
   endif
   exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$s/\s\+$//e'
   NetrwKeepj call histdel("/",-1)
   exe 'nno <buffer> <silent> w	:call search(''^.\\|\s\s\zs\S'',''W'')'."\<cr>"
   exe 'nno <buffer> <silent> b	:call search(''^.\\|\s\s\zs\S'',''bW'')'."\<cr>"
"   call Decho("NetrwWideListing) setl noma nomod ro",'~'.expand("<slnum>"))
   exe "setl ".g:netrw_bufsettings
"   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Dret("NetrwWideListing")
   return
  else
   if hasmapto("w","n")
    sil! nunmap <buffer> w
   endif
   if hasmapto("b","n")
    sil! nunmap <buffer> b
   endif
  endif

endfun

" ---------------------------------------------------------------------
" s:PerformListing: {{{2
fun! s:PerformListing(islocal)
"  call Dfunc("s:PerformListing(islocal=".a:islocal.")")
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
"  call Decho("settings: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (enter)",'~'.expand("<slnum>"))

  " set up syntax highlighting {{{3
"  call Decho("--set up syntax highlighting (ie. setl ft=netrw)",'~'.expand("<slnum>"))
  sil! setl ft=netrw

  NetrwKeepj call s:NetrwSafeOptions()
  setl noro ma
"  call Decho("setl noro ma bh=".&bh,'~'.expand("<slnum>"))

"  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
"   call Decho("(netrw) Processing your browsing request...",'~'.expand("<slnum>"))
"  endif								" Decho

"  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " force a refresh for tree listings
"   call Decho("force refresh for treelisting: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
   sil! NetrwKeepj %d _
  endif

  " save current directory on directory history list
  NetrwKeepj call s:NetrwBookHistHandler(3,b:netrw_curdir)

  " Set up the banner {{{3
  if g:netrw_banner
"   call Decho("--set up banner",'~'.expand("<slnum>"))
   NetrwKeepj call setline(1,'" ============================================================================')
   if exists("g:netrw_pchk")
    " this undocumented option allows pchk to run with different versions of netrw without causing spurious
    " failure detections.
    NetrwKeepj call setline(2,'" Netrw Directory Listing')
   else
    NetrwKeepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
   endif
   if exists("g:netrw_pchk")
    let curdir= substitute(b:netrw_curdir,expand("$HOME"),'~','')
   else
    let curdir= b:netrw_curdir
   endif
   if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
    NetrwKeepj call setline(3,'"   '.substitute(curdir,'/','\\','g'))
   else
    NetrwKeepj call setline(3,'"   '.curdir)
   endif
   let w:netrw_bannercnt= 3
   NetrwKeepj exe "sil! NetrwKeepj ".w:netrw_bannercnt
  else
"   call Decho("--no banner",'~'.expand("<slnum>"))
   NetrwKeepj 1
   let w:netrw_bannercnt= 1
  endif
"  call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." win#".winnr(),'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))

  let sortby= g:netrw_sort_by
  if g:netrw_sort_direction =~ "^r"
   let sortby= sortby." reversed"
  endif

  " Sorted by... {{{3
  if g:netrw_banner
"   call Decho("--handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))
   if g:netrw_sort_by =~ "^n"
"   call Decho("directories will be sorted by name",'~'.expand("<slnum>"))
    " sorted by name
    NetrwKeepj put ='\"   Sorted by      '.sortby
    NetrwKeepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
    let w:netrw_bannercnt= w:netrw_bannercnt + 2
   else
"   call Decho("directories will be sorted by size or time",'~'.expand("<slnum>"))
    " sorted by size or date
    NetrwKeepj put ='\"   Sorted by '.sortby
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   endif
   exe "sil! NetrwKeepj ".w:netrw_bannercnt
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
  endif

  " show copy/move target, if any
  if g:netrw_banner
   if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
"    call Decho("--show copy/move target<".s:netrwmftgt.">",'~'.expand("<slnum>"))
    NetrwKeepj put =''
    if s:netrwmftgt_islocal
     sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
    else
     sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
    endif
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   else
"    call Decho("s:netrwmftgt does not exist, don't make Copy/Move Tgt",'~'.expand("<slnum>"))
   endif
   exe "sil! NetrwKeepj ".w:netrw_bannercnt
  endif

  " Hiding...  -or-  Showing... {{{3
  if g:netrw_banner
"   call Decho("--handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)",'~'.expand("<slnum>"))
   if g:netrw_list_hide != "" && g:netrw_hide
    if g:netrw_hide == 1
     NetrwKeepj put ='\"   Hiding:        '.g:netrw_list_hide
    else
     NetrwKeepj put ='\"   Showing:       '.g:netrw_list_hide
    endif
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   endif
   exe "NetrwKeepj ".w:netrw_bannercnt

"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   let quickhelp   = g:netrw_quickhelp%len(s:QuickHelp)
"   call Decho("quickhelp   =".quickhelp,'~'.expand("<slnum>"))
   NetrwKeepj put ='\"   Quick Help: <F1>:help  '.s:QuickHelp[quickhelp]
"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   NetrwKeepj put ='\" =============================================================================='
   let w:netrw_bannercnt= w:netrw_bannercnt + 2
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
  endif

  " bannercnt should index the line just after the banner
  if g:netrw_banner
   let w:netrw_bannercnt= w:netrw_bannercnt + 1
   exe "sil! NetrwKeepj ".w:netrw_bannercnt
"   call Decho("--w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"),'~'.expand("<slnum>"))
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
  endif

  " get list of files
"  call Decho("--Get list of files - islocal=".a:islocal,'~'.expand("<slnum>"))
  if a:islocal
   NetrwKeepj call s:LocalListing()
  else " remote
   NetrwKeepj let badresult= s:NetrwRemoteListing()
   if badresult
"    call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
"    call Dret("s:PerformListing : error detected by NetrwRemoteListing")
    return
   endif
  endif

  " manipulate the directory listing (hide, sort) {{{3
  if !exists("w:netrw_bannercnt")
   let w:netrw_bannercnt= 0
  endif
"  call Decho("--manipulate directory listing (hide, sort)",'~'.expand("<slnum>"))
"  call Decho("g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)",'~'.expand("<slnum>"))
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

  if !g:netrw_banner || line("$") >= w:netrw_bannercnt
"   call Decho("manipulate directory listing (hide)",'~'.expand("<slnum>"))
"   call Decho("g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
   if g:netrw_hide && g:netrw_list_hide != ""
    NetrwKeepj call s:NetrwListHide()
   endif
   if !g:netrw_banner || line("$") >= w:netrw_bannercnt
"    call Decho("manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))

    if g:netrw_sort_by =~ "^n"
     " sort by name
     NetrwKeepj call s:NetrwSetSort()

     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
      if g:netrw_sort_direction =~ 'n'
       " normal direction sorting
       exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
       " reverse direction sorting
       exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     endif
     " remove priority pattern prefix
"     call Decho("remove priority pattern prefix",'~'.expand("<slnum>"))
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
     NetrwKeepj call histdel("/",-1)

    elseif g:netrw_sort_by =~ "^ext"
     " sort by extension
     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g+/+s/^/001'.g:netrw_sepchr.'/'
     NetrwKeepj call histdel("/",-1)
     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+[./]+s/^/002'.g:netrw_sepchr.'/'
     NetrwKeepj call histdel("/",-1)
     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+['.g:netrw_sepchr.'/]+s/^\(.*\.\)\(.\{-\}\)$/\2'.g:netrw_sepchr.'&/e'
     NetrwKeepj call histdel("/",-1)
     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
      if g:netrw_sort_direction =~ 'n'
       " normal direction sorting
       exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
       " reverse direction sorting
       exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     endif
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^.\{-}'.g:netrw_sepchr.'//e'
     NetrwKeepj call histdel("/",-1)

    elseif a:islocal
     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction,'~'.expand("<slnum>"))
      if g:netrw_sort_direction =~ 'n'
"       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort','~'.expand("<slnum>"))
       exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
"       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort!','~'.expand("<slnum>"))
       exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
     NetrwKeepj call histdel("/",-1)
     endif
    endif

   elseif g:netrw_sort_direction =~ 'r'
"    call Decho('(s:PerformListing) reverse the sorted listing','~'.expand("<slnum>"))
    if !g:netrw_banner || w:netrw_bannercnt < line('$')
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
     call histdel("/",-1)
    endif
   endif
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

  " convert to wide/tree listing {{{3
"  call Decho("--modify display if wide/tree listing style",'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#1)",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwWideListing()
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#2)",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwTreeListing(b:netrw_curdir)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#3)",'~'.expand("<slnum>"))

  " resolve symbolic links if local and (thin or tree)
  if a:islocal && (w:netrw_liststyle == s:THINLIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST))
"   call Decho("--resolve symbolic links if local and thin|tree",'~'.expand("<slnum>"))
   g/@$/call s:ShowLink()
  endif

  if exists("w:netrw_bannercnt") && (line("$") >= w:netrw_bannercnt || !g:netrw_banner)
   " place cursor on the top-left corner of the file listing
"   call Decho("--place cursor on top-left corner of file listing",'~'.expand("<slnum>"))
   exe 'sil! '.w:netrw_bannercnt
   sil! NetrwKeepj norm! 0
"   call Decho("  tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
  else
"   call Decho("--did NOT place cursor on top-left corner",'~'.expand("<slnum>"))
"   call Decho("  w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a'),'~'.expand("<slnum>"))
"   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
"   call Decho("  g:netrw_banner=".(exists("g:netrw_banner")? g:netrw_banner : 'n/a'),'~'.expand("<slnum>"))
  endif

  " record previous current directory
  let w:netrw_prvdir= b:netrw_curdir
"  call Decho("--record netrw_prvdir<".w:netrw_prvdir.">",'~'.expand("<slnum>"))

  " save certain window-oriented variables into buffer-oriented variables {{{3
"  call Decho("--save some window-oriented variables into buffer oriented variables",'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#4)",'~'.expand("<slnum>"))
  NetrwKeepj call s:SetBufWinVars()
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#5)",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwOptionRestore("w:")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#6)",'~'.expand("<slnum>"))

  " set display to netrw display settings
"  call Decho("--set display to netrw display settings (".g:netrw_bufsettings.")",'~'.expand("<slnum>"))
  exe "setl ".g:netrw_bufsettings
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#7)",'~'.expand("<slnum>"))
  if g:netrw_liststyle == s:LONGLIST
"   call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
   exe "setl ts=".(g:netrw_maxfilenamelen+1)
  endif

  if exists("s:treecurpos")
"   call Decho("s:treecurpos exists; restore posn",'~'.expand("<slnum>"))
"   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#8)",'~'.expand("<slnum>"))
"   call Decho("restoring posn to s:treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(s:treecurpos)
   unlet s:treecurpos
  endif

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (return)",'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
"  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")
endfun

" ---------------------------------------------------------------------
" s:SetupNetrwStatusLine: {{{2
fun! s:SetupNetrwStatusLine(statline)
"  call Dfunc("SetupNetrwStatusLine(statline<".a:statline.">)")

  if !exists("s:netrw_setup_statline")
   let s:netrw_setup_statline= 1
"   call Decho("do first-time status line setup",'~'.expand("<slnum>"))

   if !exists("s:netrw_users_stl")
    let s:netrw_users_stl= &stl
   endif
   if !exists("s:netrw_users_ls")
    let s:netrw_users_ls= &laststatus
   endif

   " set up User9 highlighting as needed
   let keepa= @a
   redir @a
   try
    hi User9
   catch /^Vim\%((\a\{3,})\)\=:E411/
    if &bg == "dark"
     hi User9 ctermfg=yellow ctermbg=blue guifg=yellow guibg=blue
    else
     hi User9 ctermbg=yellow ctermfg=blue guibg=yellow guifg=blue
    endif
   endtry
   redir END
   let @a= keepa
  endif

  " set up status line (may use User9 highlighting)
  " insure that windows have a statusline
  " make sure statusline is displayed
  let &stl=a:statline
  setl laststatus=2
"  call Decho("stl=".&stl,'~'.expand("<slnum>"))
  redraw

"  call Dret("SetupNetrwStatusLine : stl=".&stl)
endfun

" ---------------------------------------------------------------------
"  Remote Directory Browsing Support:    {{{1
" ===========================================

" ---------------------------------------------------------------------
" s:NetrwRemoteFtpCmd: unfortunately, not all ftp servers honor options for ls {{{2
"  This function assumes that a long listing will be received.  Size, time,
"  and reverse sorts will be requested of the server but not otherwise
"  enforced here.
fun! s:NetrwRemoteFtpCmd(path,listcmd)
"  call Dfunc("NetrwRemoteFtpCmd(path<".a:path."> listcmd<".a:listcmd.">) w:netrw_method=".(exists("w:netrw_method")? w:netrw_method : (exists("b:netrw_method")? b:netrw_method : "???")))
"  call Decho("line($)=".line("$")." win#".winnr()." w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
  " sanity check: {{{3
  if !exists("w:netrw_method")
   if exists("b:netrw_method")
    let w:netrw_method= b:netrw_method
   else
    call netrw#ErrorMsg(2,"(s:NetrwRemoteFtpCmd) internal netrw error",93)
"    call Dret("NetrwRemoteFtpCmd")
    return
   endif
  endif

  " WinXX ftp uses unix style input, so set ff to unix	" {{{3
  let ffkeep= &ff
  setl ma ff=unix noro
"  call Decho("setl ma ff=unix noro",'~'.expand("<slnum>"))

  " clear off any older non-banner lines	" {{{3
  " note that w:netrw_bannercnt indexes the line after the banner
"  call Decho('exe sil! NetrwKeepj '.w:netrw_bannercnt.",$d _  (clear off old non-banner lines)",'~'.expand("<slnum>"))
  exe "sil! NetrwKeepj ".w:netrw_bannercnt.",$d _"

  ".........................................
  if w:netrw_method == 2 || w:netrw_method == 5	" {{{3
   " ftp + <.netrc>:  Method #2
   if a:path != ""
    NetrwKeepj put ='cd \"'.a:path.'\"'
   endif
   if exists("g:netrw_ftpextracmd")
    NetrwKeepj put =g:netrw_ftpextracmd
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
   endif
   NetrwKeepj call setline(line("$")+1,a:listcmd)
"   exe "NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."),''~''.expand("<slnum>"))'
   if exists("g:netrw_port") && g:netrw_port != ""
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1),'~'.expand("<slnum>"))
    exe s:netrw_silentxfer." NetrwKeepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1)
   else
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1),'~'.expand("<slnum>"))
    exe s:netrw_silentxfer." NetrwKeepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)
   endif

  ".........................................
  elseif w:netrw_method == 3	" {{{3
   " ftp + machine,id,passwd,filename:  Method #3
    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
    else
     NetrwKeepj put ='open '.g:netrw_machine
    endif

    " handle userid and password
    let host= substitute(g:netrw_machine,'\..*$','','')
"    call Decho("host<".host.">",'~'.expand("<slnum>"))
    if exists("s:netrw_hup") && exists("s:netrw_hup[host]")
     call NetUserPass("ftp:".host)
    endif
    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
     elseif exists("s:netrw_passwd")
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
     endif
    endif

   if a:path != ""
    NetrwKeepj put ='cd \"'.a:path.'\"'
   endif
   if exists("g:netrw_ftpextracmd")
    NetrwKeepj put =g:netrw_ftpextracmd
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
   endif
   NetrwKeepj call setline(line("$")+1,a:listcmd)

   " perform ftp:
   " -i       : turns off interactive prompting from ftp
   " -n  unix : DON'T use <.netrc>, even though it exists
   " -n  win32: quit being obnoxious about password
   if exists("w:netrw_bannercnt")
"    exe w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."),''~''.expand("<slnum>"))'
    call s:NetrwExe(s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
"   else " Decho
"    call Decho("WARNING: w:netrw_bannercnt doesn't exist!",'~'.expand("<slnum>"))
"    g/^./call Decho("SKIPPING ftp#".line(".").": ".getline("."),'~'.expand("<slnum>"))
   endif

  ".........................................
  elseif w:netrw_method == 9	" {{{3
   " sftp username@machine: Method #9
   " s:netrw_sftp_cmd
   setl ff=unix

   " restore settings
   let &ff= ffkeep
"   call Dret("NetrwRemoteFtpCmd")
   return

  ".........................................
  else	" {{{3
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . bufname("%") . ">",23)
  endif

  " cleanup for Windows " {{{3
  if has("win32") || has("win95") || has("win64") || has("win16")
   sil! NetrwKeepj %s/\r$//e
   NetrwKeepj call histdel("/",-1)
  endif
  if a:listcmd == "dir"
   " infer directory/link based on the file permission string
   sil! NetrwKeepj g/d\%([-r][-w][-x]\)\{3}/NetrwKeepj s@$@/@e
   sil! NetrwKeepj g/l\%([-r][-w][-x]\)\{3}/NetrwKeepj s/$/@/e
   NetrwKeepj call histdel("/",-1)
   NetrwKeepj call histdel("/",-1)
   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST)
    exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$s/^\%(\S\+\s\+\)\{8}//e'
    NetrwKeepj call histdel("/",-1)
   endif
  endif

  " ftp's listing doesn't seem to include ./ or ../ " {{{3
  if !search('^\.\/$\|\s\.\/$','wn')
   exe 'NetrwKeepj '.w:netrw_bannercnt
   NetrwKeepj put ='./'
  endif
  if !search('^\.\.\/$\|\s\.\.\/$','wn')
   exe 'NetrwKeepj '.w:netrw_bannercnt
   NetrwKeepj put ='../'
  endif

  " restore settings " {{{3
  let &ff= ffkeep
"  call Dret("NetrwRemoteFtpCmd")
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteListing: {{{2
fun! s:NetrwRemoteListing()
"  call Dfunc("s:NetrwRemoteListing() b:netrw_curdir<".b:netrw_curdir.">) win#".winnr())

  if !exists("w:netrw_bannercnt") && exists("s:bannercnt")
   let w:netrw_bannercnt= s:bannercnt
  endif
  if !exists("w:netrw_bannercnt") && exists("b:bannercnt")
   let w:netrw_bannercnt= s:bannercnt
  endif

  call s:RemotePathAnalysis(b:netrw_curdir)

  " sanity check:
  if exists("b:netrw_method") && b:netrw_method =~ '[235]'
"   call Decho("b:netrw_method=".b:netrw_method,'~'.expand("<slnum>"))
   if !executable("ftp")
"    call Decho("ftp is not executable",'~'.expand("<slnum>"))
    if !exists("g:netrw_quiet")
     call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ftp",18)
    endif
    call s:NetrwOptionRestore("w:")
"    call Dret("s:NetrwRemoteListing -1")
    return -1
   endif

  elseif !exists("g:netrw_list_cmd") || g:netrw_list_cmd == ''
"   call Decho("g:netrw_list_cmd<",(exists("g:netrw_list_cmd")? 'n/a' : "-empty-").">",'~'.expand("<slnum>"))
   if !exists("g:netrw_quiet")
    if g:netrw_list_cmd == ""
     NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your g:netrw_list_cmd is empty; perhaps ".g:netrw_ssh_cmd." is not executable on your system",47)
    else
     NetrwKeepj call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ".g:netrw_list_cmd,19)
    endif
   endif

   NetrwKeepj call s:NetrwOptionRestore("w:")
"   call Dret("s:NetrwRemoteListing -1")
   return -1
  endif  " (remote handling sanity check)
"  call Decho("passed remote listing sanity checks",'~'.expand("<slnum>"))

  if exists("b:netrw_method")
"   call Decho("setting w:netrw_method to b:netrw_method<".b:netrw_method.">",'~'.expand("<slnum>"))
   let w:netrw_method= b:netrw_method
  endif

  if s:method == "ftp"
   " use ftp to get remote file listing {{{3
"   call Decho("use ftp to get remote file listing",'~'.expand("<slnum>"))
   let s:method  = "ftp"
   let listcmd = g:netrw_ftp_list_cmd
   if g:netrw_sort_by =~ '^t'
    let listcmd= g:netrw_ftp_timelist_cmd
   elseif g:netrw_sort_by =~ '^s'
    let listcmd= g:netrw_ftp_sizelist_cmd
   endif
"   call Decho("listcmd<".listcmd."> (using g:netrw_ftp_list_cmd)",'~'.expand("<slnum>"))
   call s:NetrwRemoteFtpCmd(s:path,listcmd)
"   exe "sil! keepalt NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("raw listing: ".getline("."),''~''.expand("<slnum>"))'

   " report on missing file or directory messages
   if search('[Nn]o such file or directory\|Failed to change directory')
    let mesg= getline(".")
    if exists("w:netrw_bannercnt")
     setl ma
     exe w:netrw_bannercnt.",$d _"
     setl noma
    endif
    NetrwKeepj call s:NetrwOptionRestore("w:")
    call netrw#ErrorMsg(s:WARNING,mesg,96)
"    call Dret("s:NetrwRemoteListing : -1")
    return -1
   endif

   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST)
    " shorten the listing
"    call Decho("generate short listing",'~'.expand("<slnum>"))
    exe "sil! keepalt NetrwKeepj ".w:netrw_bannercnt

    " cleanup
    if g:netrw_ftp_browse_reject != ""
     exe "sil! keepalt NetrwKeepj g/".g:netrw_ftp_browse_reject."/NetrwKeepj d"
     NetrwKeepj call histdel("/",-1)
    endif
    sil! NetrwKeepj %s/\r$//e
    NetrwKeepj call histdel("/",-1)

    " if there's no ../ listed, then put ../ in
    let line1= line(".")
    exe "sil! NetrwKeepj ".w:netrw_bannercnt
    let line2= search('\.\.\/\%(\s\|$\)','cnW')
"    call Decho("search(".'\.\.\/\%(\s\|$\)'."','cnW')=".line2."  w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
    if line2 == 0
"     call Decho("netrw is putting ../ into listing",'~'.expand("<slnum>"))
     sil! NetrwKeepj put='../'
    endif
    exe "sil! NetrwKeepj ".line1
    sil! NetrwKeepj norm! 0

"    call Decho("line1=".line1." line2=".line2." line(.)=".line("."),'~'.expand("<slnum>"))
    if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
"     call Decho("M$ ftp cleanup",'~'.expand("<slnum>"))
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+//'
     NetrwKeepj call histdel("/",-1)
    else " normal ftp cleanup
"     call Decho("normal ftp cleanup",'~'.expand("<slnum>"))
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2/e'
     exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*/$#/#e'
     exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*$#/#e'
     NetrwKeepj call histdel("/",-1)
     NetrwKeepj call histdel("/",-1)
     NetrwKeepj call histdel("/",-1)
    endif
   endif

   else
   " use ssh to get remote file listing {{{3
"   call Decho("use ssh to get remote file listing: s:path<".s:path.">",'~'.expand("<slnum>"))
   let listcmd= s:MakeSshCmd(g:netrw_list_cmd)
"   call Decho("listcmd<".listcmd."> (using g:netrw_list_cmd)",'~'.expand("<slnum>"))
   if g:netrw_scp_cmd =~ '^pscp'
"    call Decho("1: exe r! ".s:ShellEscape(listcmd.s:path, 1),'~'.expand("<slnum>"))
    exe "NetrwKeepj r! ".listcmd.s:ShellEscape(s:path, 1)
    " remove rubbish and adjust listing format of 'pscp' to 'ssh ls -FLa' like
    sil! NetrwKeepj g/^Listing directory/NetrwKeepj d
    sil! NetrwKeepj g/^d[-rwx][-rwx][-rwx]/NetrwKeepj s+$+/+e
    sil! NetrwKeepj g/^l[-rwx][-rwx][-rwx]/NetrwKeepj s+$+@+e
    NetrwKeepj call histdel("/",-1)
    NetrwKeepj call histdel("/",-1)
    NetrwKeepj call histdel("/",-1)
    if g:netrw_liststyle != s:LONGLIST
     sil! NetrwKeepj g/^[dlsp-][-rwx][-rwx][-rwx]/NetrwKeepj s/^.*\s\(\S\+\)$/\1/e
     NetrwKeepj call histdel("/",-1)
    endif
   else
    if s:path == ""
"     call Decho("2: exe r! ".listcmd,'~'.expand("<slnum>"))
     exe "NetrwKeepj keepalt r! ".listcmd
    else
"     call Decho("3: exe r! ".listcmd.' '.s:ShellEscape(fnameescape(s:path),1),'~'.expand("<slnum>"))
     exe "NetrwKeepj keepalt r! ".listcmd.' '.s:ShellEscape(fnameescape(s:path),1)
"     call Decho("listcmd<".listcmd."> path<".s:path.">",'~'.expand("<slnum>"))
    endif
   endif

   " cleanup
   if g:netrw_ssh_browse_reject != ""
"    call Decho("cleanup: exe sil! g/".g:netrw_ssh_browse_reject."/NetrwKeepj d",'~'.expand("<slnum>"))
    exe "sil! g/".g:netrw_ssh_browse_reject."/NetrwKeepj d"
    NetrwKeepj call histdel("/",-1)
   endif
  endif

  if w:netrw_liststyle == s:LONGLIST
   " do a long listing; these substitutions need to be done prior to sorting {{{3
"   call Decho("fix long listing:",'~'.expand("<slnum>"))

   if s:method == "ftp"
    " cleanup
    exe "sil! NetrwKeepj ".w:netrw_bannercnt
    while getline('.') =~ g:netrw_ftp_browse_reject
     sil! NetrwKeepj d
    endwhile
    " if there's no ../ listed, then put ../ in
    let line1= line(".")
    sil! NetrwKeepj 1
    sil! NetrwKeepj call search('^\.\.\/\%(\s\|$\)','W')
    let line2= line(".")
    if line2 == 0
     if b:netrw_curdir != '/'
      exe 'sil! NetrwKeepj '.w:netrw_bannercnt."put='../'"
     endif
    endif
    exe "sil! NetrwKeepj ".line1
    sil! NetrwKeepj norm! 0
   endif

   if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
"    call Decho("M$ ftp site listing cleanup",'~'.expand("<slnum>"))
    exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+\)\(\w.*\)$/\2\t\1/'
   elseif exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$")
"    call Decho("normal ftp site listing cleanup: bannercnt=".w:netrw_bannercnt." line($)=".line("$"),'~'.expand("<slnum>"))
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/ -> .*$//e'
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2 \t\1/e'
    exe 'sil NetrwKeepj '.w:netrw_bannercnt
    NetrwKeepj call histdel("/",-1)
    NetrwKeepj call histdel("/",-1)
    NetrwKeepj call histdel("/",-1)
   endif
  endif

"  if exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$") " Decho
"   exe "NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("listing: ".getline("."),''~''.expand("<slnum>"))'
"  endif " Decho

"  call Dret("s:NetrwRemoteListing 0")
  return 0
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRm: remove/delete a remote file or directory {{{2
fun! s:NetrwRemoteRm(usrhost,path) range
"  call Dfunc("s:NetrwRemoteRm(usrhost<".a:usrhost."> path<".a:path.">) virtcol=".virtcol("."))
"  call Decho("firstline=".a:firstline." lastline=".a:lastline,'~'.expand("<slnum>"))
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  let all= 0
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   " remove all marked files
"   call Decho("remove all marked files with bufnr#".bufnr("%"),'~'.expand("<slnum>"))
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    let ok= s:NetrwRemoteRmFile(a:path,fname,all)
    if ok =~ 'q\%[uit]'
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
   endfor
   call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)

  else
   " remove files specified by range
"   call Decho("remove files specified by range",'~'.expand("<slnum>"))

   " preparation for removing multiple files/directories
   let keepsol = &l:sol
   setl nosol
   let ctr    = a:firstline

   " remove multiple files and directories
   while ctr <= a:lastline
    exe "NetrwKeepj ".ctr
    let ok= s:NetrwRemoteRmFile(a:path,s:NetrwGetWord(),all)
    if ok =~ 'q\%[uit]'
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
    let ctr= ctr + 1
   endwhile
   let &l:sol = keepsol
  endif

  " refresh the (remote) directory listing
"  call Decho("refresh remote directory listing",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

"  call Dret("s:NetrwRemoteRm")
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRmFile: {{{2
fun! s:NetrwRemoteRmFile(path,rmfile,all)
"  call Dfunc("s:NetrwRemoteRmFile(path<".a:path."> rmfile<".a:rmfile.">) all=".a:all)

  let all= a:all
  let ok = ""

  if a:rmfile !~ '^"' && (a:rmfile =~ '@$' || a:rmfile !~ '[\/]$')
   " attempt to remove file
"    call Decho("attempt to remove file (all=".all.")",'~'.expand("<slnum>"))
   if !all
    echohl Statement
"    call Decho("case all=0:",'~'.expand("<slnum>"))
    call inputsave()
    let ok= input("Confirm deletion of file<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    echohl NONE
    if ok == ""
     let ok="no"
    endif
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
"    call Decho("case all=".all." or ok<".ok.">".(exists("w:netrw_method")? ': netrw_method='.w:netrw_method : ""),'~'.expand("<slnum>"))
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
"     call Decho("case ftp:",'~'.expand("<slnum>"))
     let path= a:path
     if path =~ '^\a\{3,}://'
      let path= substitute(path,'^\a\{3,}://[^/]\+/','','')
     endif
     sil! NetrwKeepj .,$d _
     call s:NetrwRemoteFtpCmd(path,"delete ".'"'.a:rmfile.'"')
    else
"     call Decho("case ssh: g:netrw_rm_cmd<".g:netrw_rm_cmd.">",'~'.expand("<slnum>"))
     let netrw_rm_cmd= s:MakeSshCmd(g:netrw_rm_cmd)
"     call Decho("netrw_rm_cmd<".netrw_rm_cmd.">",'~'.expand("<slnum>"))
     if !exists("b:netrw_curdir")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
      let ok="q"
     else
      let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
"      call Decho("netrw_rm_cmd<".netrw_rm_cmd.">",'~'.expand("<slnum>"))
"      call Decho("remotedir<".remotedir.">",'~'.expand("<slnum>"))
"      call Decho("rmfile<".a:rmfile.">",'~'.expand("<slnum>"))
      if remotedir != ""
       let netrw_rm_cmd= netrw_rm_cmd." ".s:ShellEscape(fnameescape(remotedir.a:rmfile))
      else
       let netrw_rm_cmd= netrw_rm_cmd." ".s:ShellEscape(fnameescape(a:rmfile))
      endif
"      call Decho("call system(".netrw_rm_cmd.")",'~'.expand("<slnum>"))
      let ret= system(netrw_rm_cmd)
      if v:shell_error != 0
       if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
        call netrw#ErrorMsg(s:ERROR,"remove failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",102)
       else
        call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
       endif
      else if ret != 0
       call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
      endif
"      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))
     endif
    endif
   elseif ok =~ 'q\%[uit]'
"    call Decho("ok==".ok,'~'.expand("<slnum>"))
   endif

  else
   " attempt to remove directory
"    call Decho("attempt to remove directory",'~'.expand("<slnum>"))
   if !all
    call inputsave()
    let ok= input("Confirm deletion of directory<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    if ok == ""
     let ok="no"
    endif
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     NetrwKeepj call s:NetrwRemoteFtpCmd(a:path,"rmdir ".a:rmfile)
    else
     let rmfile          = substitute(a:path.a:rmfile,'/$','','')
     let netrw_rmdir_cmd = s:MakeSshCmd(netrw#WinPath(g:netrw_rmdir_cmd)).' '.s:ShellEscape(netrw#WinPath(rmfile))
"      call Decho("attempt to remove dir: system(".netrw_rmdir_cmd.")",'~'.expand("<slnum>"))
     let ret= system(netrw_rmdir_cmd)
"      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))

     if v:shell_error != 0
"      call Decho("v:shell_error not 0",'~'.expand("<slnum>"))
      let netrw_rmf_cmd= s:MakeSshCmd(netrw#WinPath(g:netrw_rmf_cmd)).' '.s:ShellEscape(netrw#WinPath(substitute(rmfile,'[\/]$','','e')))
"      call Decho("2nd attempt to remove dir: system(".netrw_rmf_cmd.")",'~'.expand("<slnum>"))
      let ret= system(netrw_rmf_cmd)
"      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))

      if v:shell_error != 0 && !exists("g:netrw_quiet")
      	NetrwKeepj call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",22)
      endif
     endif
    endif

   elseif ok =~ 'q\%[uit]'
"    call Decho("ok==".ok,'~'.expand("<slnum>"))
   endif
  endif

"  call Dret("s:NetrwRemoteRmFile ".ok)
  return ok
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRename: rename a remote file or directory {{{2
fun! s:NetrwRemoteRename(usrhost,path) range
"  call Dfunc("NetrwRemoteRename(usrhost<".a:usrhost."> path<".a:path.">)")

  " preparation for removing multiple files/directories
  let svpos      = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let ctr        = a:firstline
  let rename_cmd = s:MakeSshCmd(g:netrw_rename_cmd)

  " rename files given by the markfilelist
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   for oldname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))
    if exists("subfrom")
     let newname= substitute(oldname,subfrom,subto,'')
"     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
    else
     call inputsave()
     let newname= input("Moving ".oldname." to : ",oldname)
     call inputrestore()
     if newname =~ '^s/'
      let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
      let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
      let newname = substitute(oldname,subfrom,subto,'')
"      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
     endif
    endif

    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     NetrwKeepj call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
    else
     let oldname= s:ShellEscape(a:path.oldname)
     let newname= s:ShellEscape(a:path.newname)
"     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")",'~'.expand("<slnum>"))
     let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
    endif

   endfor
   call s:NetrwUnMarkFile(1)

  else

  " attempt to rename files/directories
   let keepsol= &l:sol
   setl nosol
   while ctr <= a:lastline
    exe "NetrwKeepj ".ctr

    let oldname= s:NetrwGetWord()
"   call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))

    call inputsave()
    let newname= input("Moving ".oldname." to : ",oldname)
    call inputrestore()

    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
    else
     let oldname= s:ShellEscape(a:path.oldname)
     let newname= s:ShellEscape(a:path.newname)
"     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")",'~'.expand("<slnum>"))
     let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
    endif

    let ctr= ctr + 1
   endwhile
   let &l:sol= keepsol
  endif

  " refresh the directory
  NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

"  call Dret("NetrwRemoteRename")
endfun

" ---------------------------------------------------------------------
"  Local Directory Browsing Support:    {{{1
" ==========================================

" ---------------------------------------------------------------------
" netrw#FileUrlRead: handles reading file://* files {{{2
"   Should accept:   file://localhost/etc/fstab
"                    file:///etc/fstab
"                    file:///c:/WINDOWS/clock.avi
"                    file:///c|/WINDOWS/clock.avi
"                    file://localhost/c:/WINDOWS/clock.avi
"                    file://localhost/c|/WINDOWS/clock.avi
"                    file://c:/foo.txt
"                    file:///c:/foo.txt
" and %XX (where X is [0-9a-fA-F] is converted into a character with the given hexadecimal value
fun! netrw#FileUrlRead(fname)
"  call Dfunc("netrw#FileUrlRead(fname<".a:fname.">)")
  let fname = a:fname
  if fname =~ '^file://localhost/'
"   call Decho('converting file://localhost/   -to-  file:///','~'.expand("<slnum>"))
   let fname= substitute(fname,'^file://localhost/','file:///','')
"   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
  endif
  if (has("win32") || has("win95") || has("win64") || has("win16"))
   if fname  =~ '^file:///\=\a[|:]/'
"    call Decho('converting file:///\a|/   -to-  file://\a:/','~'.expand("<slnum>"))
    let fname = substitute(fname,'^file:///\=\(\a\)[|:]/','file://\1:/','')
"    call Decho("fname<".fname.">",'~'.expand("<slnum>"))
   endif
  endif
  let fname2396 = netrw#RFC2396(fname)
  let fname2396e= fnameescape(fname2396)
  let plainfname= substitute(fname2396,'file://\(.*\)','\1',"")
  if (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows exception for plainfname",'~'.expand("<slnum>"))
   if plainfname =~ '^/\+\a:'
"    call Decho('removing leading "/"s','~'.expand("<slnum>"))
    let plainfname= substitute(plainfname,'^/\+\(\a:\)','\1','')
   endif
  endif
"  call Decho("fname2396<".fname2396.">",'~'.expand("<slnum>"))
"  call Decho("plainfname<".plainfname.">",'~'.expand("<slnum>"))
  exe "sil doau BufReadPre ".fname2396e
  exe 'NetrwKeepj r '.plainfname
  exe 'sil! bdelete '.plainfname
  exe 'keepalt file! '.plainfname
  NetrwKeepj 1d
"  call Decho("setl nomod",'~'.expand("<slnum>"))
  setl nomod
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Dret("netrw#FileUrlRead")
  exe "sil doau BufReadPost ".fname2396e
endfun

" ---------------------------------------------------------------------
" netrw#LocalBrowseCheck: {{{2
fun! netrw#LocalBrowseCheck(dirname)
  " This function is called by netrwPlugin.vim's s:LocalBrowse(), s:NetrwRexplore(), and by <cr> when atop listed file/directory
  " unfortunate interaction -- split window debugging can't be
  " used here, must use D-echoRemOn or D-echoTabOn -- the BufEnter
  " event triggers another call to LocalBrowseCheck() when attempts
  " to write to the DBG buffer are made.
  " The &ft == "netrw" test was installed because the BufEnter event
  " would hit when re-entering netrw windows, creating unexpected
  " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
"  call Dfunc("netrw#LocalBrowseCheck(dirname<".a:dirname.">")
"  call Decho("isdir<".a:dirname.">=".isdirectory(s:NetrwFile(a:dirname)).((exists("s:treeforceredraw")? " treeforceredraw" : "")).expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Dredir("ls!","ls!")
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"  call Decho("current buffer#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))

  let ykeep= @@
  if isdirectory(s:NetrwFile(a:dirname))
"   call Decho("is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse,'~'.expand("<slnum>"))

   if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
"    call Decho("case 1 : ft=".&ft,'~'.expand("<slnum>"))
"    call Decho("s:rexposn_".bufnr("%")."<".bufname("%")."> ".(exists("s:rexposn_".bufnr("%"))? "exists" : "does not exist"),'~'.expand("<slnum>"))
    sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)

   elseif &ft == "netrw" && line("$") == 1
"    call Decho("case 2 (ft≡netrw && line($)≡1)",'~'.expand("<slnum>"))
    sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)

   elseif exists("s:treeforceredraw")
"    call Decho("case 3 (treeforceredraw)",'~'.expand("<slnum>"))
    unlet s:treeforceredraw
    sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
   endif

"   call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"   call Dret("netrw#LocalBrowseCheck")
   return
  endif

  " following code wipes out currently unused netrw buffers
  "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
  "   AND IF the listing style is not a tree listing
  if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
"   call Decho("wiping out currently unused netrw buffers",'~'.expand("<slnum>"))
   let ibuf    = 1
   let buflast = bufnr("$")
   while ibuf <= buflast
    if bufwinnr(ibuf) == -1 && isdirectory(s:NetrwFile(bufname(ibuf)))
     exe "sil! keepj keepalt ".ibuf."bw!"
    endif
    let ibuf= ibuf + 1
   endwhile
  endif
  let @@= ykeep
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
  " not a directory, ignore it
"  call Dret("netrw#LocalBrowseCheck : not a directory, ignoring it; dirname<".a:dirname.">")
endfun

" ---------------------------------------------------------------------
" s:LocalBrowseRefresh: this function is called after a user has {{{2
" performed any shell command.  The idea is to cause all local-browsing
" buffers to be refreshed after a user has executed some shell command,
" on the chance that s/he removed/created a file/directory with it.
fun! s:LocalBrowseRefresh()
"  call Dfunc("s:LocalBrowseRefresh() tabpagenr($)=".tabpagenr("$"))
"  call Decho("s:netrw_browselist =".(exists("s:netrw_browselist")?  string(s:netrw_browselist)  : '<n/a>'),'~'.expand("<slnum>"))
"  call Decho("w:netrw_bannercnt  =".(exists("w:netrw_bannercnt")?   string(w:netrw_bannercnt)   : '<n/a>'),'~'.expand("<slnum>"))

  " determine which buffers currently reside in a tab
  if !exists("s:netrw_browselist")
"   call Dret("s:LocalBrowseRefresh : browselist is empty")
   return
  endif
  if !exists("w:netrw_bannercnt")
"   call Dret("s:LocalBrowseRefresh : don't refresh when focus not on netrw window")
   return
  endif
  if exists("s:netrw_events") && s:netrw_events == 1
   " s:LocalFastBrowser gets called (indirectly) from a
   let s:netrw_events= 2
"   call Dret("s:LocalBrowseRefresh : avoid initial double refresh")
   return
  endif
  let itab       = 1
  let buftablist = []
  let ykeep      = @@
  while itab <= tabpagenr("$")
   let buftablist = buftablist + tabpagebuflist()
   let itab       = itab + 1
   tabn
  endwhile
"  call Decho("buftablist".string(buftablist),'~'.expand("<slnum>"))
"  call Decho("s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">",'~'.expand("<slnum>"))
  "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
  "   | refresh any netrw window
  "   | wipe out any non-displaying netrw buffer
  let curwin = winnr()
  let ibl    = 0
  for ibuf in s:netrw_browselist
"   call Decho("bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf),'~'.expand("<slnum>"))
   if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
    " wipe out any non-displaying netrw buffer
"    call Decho("wiping  buf#".ibuf,"<".bufname(ibuf).">",'~'.expand("<slnum>"))
    exe "sil! keepj bd ".fnameescape(ibuf)
    call remove(s:netrw_browselist,ibl)
"    call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
    continue
   elseif index(tabpagebuflist(),ibuf) != -1
    " refresh any netrw buffer
"    call Decho("refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf),'~'.expand("<slnum>"))
    exe bufwinnr(ibuf)."wincmd w"
    if getline(".") =~ 'Quick Help'
     " decrement g:netrw_quickhelp to prevent refresh from changing g:netrw_quickhelp
     " (counteracts s:NetrwBrowseChgDir()'s incrementing)
     let g:netrw_quickhelp= g:netrw_quickhelp - 1
    endif
"    call Decho("#3: quickhelp=".g:netrw_quickhelp,'~'.expand("<slnum>"))
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
     NetrwKeepj call s:NetrwRefreshTreeDict(w:netrw_treetop)
    endif
    NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
   endif
   let ibl= ibl + 1
"   call Decho("bottom of s:netrw_browselist for loop: ibl=".ibl,'~'.expand("<slnum>"))
  endfor
"  call Decho("restore window: exe ".curwin."wincmd w",'~'.expand("<slnum>"))
  exe curwin."wincmd w"
  let @@= ykeep

"  call Dret("s:LocalBrowseRefresh")
endfun

" ---------------------------------------------------------------------
" s:LocalFastBrowser: handles setting up/taking down fast browsing for the local browser {{{2
"
"     g:netrw_    Directory Is
"     fastbrowse  Local  Remote
"  slow   0         D      D      D=Deleting a buffer implies it will not be re-used (slow)
"  med    1         D      H      H=Hiding a buffer implies it may be re-used        (fast)
"  fast   2         H      H
"
"  Deleting a buffer means that it will be re-loaded when examined, hence "slow".
"  Hiding   a buffer means that it will be re-used   when examined, hence "fast".
"                       (re-using a buffer may not be as accurate)
"
"  s:netrw_events : doesn't exist, s:LocalFastBrowser() will install autocmds whena med or fast browsing
"                   =1: autocmds installed, but ignore next FocusGained event to avoid initial double-refresh of listing.
"                       BufEnter may be first event, then a FocusGained event.  Ignore the first FocusGained event.
"                       If :Explore used: it sets s:netrw_events to 2, so no FocusGained events are ignored.
"                   =2: autocmds installed (doesn't ignore any FocusGained events)
fun! s:LocalFastBrowser()
"  call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse)
"  call Decho("s:netrw_events        ".(exists("s:netrw_events")? "exists"    : 'n/a'),'~'.expand("<slnum>"))
"  call Decho("autocmd: ShellCmdPost ".(exists("#ShellCmdPost")?  "installed" : "not installed"),'~'.expand("<slnum>"))
"  call Decho("autocmd: FocusGained  ".(exists("#FocusGained")?   "installed" : "not installed"),'~'.expand("<slnum>"))

  " initialize browselist, a list of buffer numbers that the local browser has used
  if !exists("s:netrw_browselist")
"   call Decho("initialize s:netrw_browselist",'~'.expand("<slnum>"))
   let s:netrw_browselist= []
  endif

  " append current buffer to fastbrowse list
  if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
"   call Decho("appendng current buffer to browselist",'~'.expand("<slnum>"))
   call add(s:netrw_browselist,bufnr("%"))
"   call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
  endif

  " enable autocmd events to handle refreshing/removing local browser buffers
  "    If local browse buffer is currently showing: refresh it
  "    If local browse buffer is currently hidden : wipe it
  "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
  "                      =1 : medium speed, re-use directory listing for remote only
  "                      =2 : fast   speed, always re-use directory listing when possible
  if g:netrw_fastbrowse <= 1 && !exists("#ShellCmdPost") && !exists("s:netrw_events")
   let s:netrw_events= 1
   augroup AuNetrwEvent
    au!
    if (has("win32") || has("win95") || has("win64") || has("win16"))
"     call Decho("installing autocmd: ShellCmdPost",'~'.expand("<slnum>"))
     au ShellCmdPost			*	call s:LocalBrowseRefresh()
    else
"     call Decho("installing autocmds: ShellCmdPost FocusGained",'~'.expand("<slnum>"))
     au ShellCmdPost,FocusGained	*	call s:LocalBrowseRefresh()
    endif
   augroup END

  " user must have changed fastbrowse to its fast setting, so remove
  " the associated autocmd events
  elseif g:netrw_fastbrowse > 1 && exists("#ShellCmdPost") && exists("s:netrw_events")
"   call Decho("remove AuNetrwEvent autcmd group",'~'.expand("<slnum>"))
   unlet s:netrw_events
   augroup AuNetrwEvent
    au!
   augroup END
   augroup! AuNetrwEvent
  endif

"  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")
endfun

" ---------------------------------------------------------------------
"  s:LocalListing: does the job of "ls" for local directories {{{2
fun! s:LocalListing()
"  call Dfunc("s:LocalListing()")
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Decho("modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))

"  if exists("b:netrw_curdir") |call Decho('b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("b:netrw_curdir doesn't exist",'~'.expand("<slnum>")) |endif
"  if exists("g:netrw_sort_by")|call Decho('g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("g:netrw_sort_by doesn't exist",'~'.expand("<slnum>"))|endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

  " get the list of files contained in the current directory
  let dirname    = b:netrw_curdir
  let dirnamelen = strlen(b:netrw_curdir)
  if v:version == 704 && has("patch656")
"   call Decho("using glob with patch656",'~'.expand("<slnum>"))
   let filelist   = glob(s:ComposePath(dirname,"*"),0,1,1)
   let filelist   = filelist + glob(s:ComposePath(dirname,".*"),0,1,1)
  else
"   call Decho("using glob without patch656",'~'.expand("<slnum>"))
   let filelist   = glob(s:ComposePath(dirname,"*"),0,1)
   let filelist   = filelist + glob(s:ComposePath(dirname,".*"),0,1)
  endif
"  call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))

  if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
  elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
    " include ../ in the glob() entry if its missing
"   call Decho("forcibly including on \"..\"",'~'.expand("<slnum>"))
   let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
"   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
  endif

"  call Decho("before while: dirname<".dirname.">",'~'.expand("<slnum>"))
"  call Decho("before while: dirnamelen<".dirnamelen.">",'~'.expand("<slnum>"))
"  call Decho("before while: filelist=".string(filelist),'~'.expand("<slnum>"))

  if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
   let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
   let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
"   call Decho("dynamic_maxfilenamelen: filenames             =".string(filelistcopy),'~'.expand("<slnum>"))
"   call Decho("dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen,'~'.expand("<slnum>"))
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

  for filename in filelist
"   call Decho(" ",'~'.expand("<slnum>"))
"   call Decho("for filename in filelist: filename<".filename.">",'~'.expand("<slnum>"))

   if getftype(filename) == "link"
    " indicate a symbolic link
"    call Decho("indicate <".filename."> is a symbolic link with trailing @",'~'.expand("<slnum>"))
    let pfile= filename."@"

   elseif getftype(filename) == "socket"
    " indicate a socket
"    call Decho("indicate <".filename."> is a socket with trailing =",'~'.expand("<slnum>"))
    let pfile= filename."="

   elseif getftype(filename) == "fifo"
    " indicate a fifo
"    call Decho("indicate <".filename."> is a fifo with trailing |",'~'.expand("<slnum>"))
    let pfile= filename."|"

   elseif isdirectory(s:NetrwFile(filename))
    " indicate a directory
"    call Decho("indicate <".filename."> is a directory with trailing /",'~'.expand("<slnum>"))
    let pfile= filename."/"

   elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(s:NetrwFile(filename))
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
      " indicate an executable
"      call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
      let pfile= filename."*"
     else
      " normal file
      let pfile= filename
     endif
    elseif executable(filename)
     " indicate an executable
"     call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
     let pfile= filename."*"
    else
     " normal file
     let pfile= filename
    endif

   else
    " normal file
    let pfile= filename
   endif
"   call Decho("pfile<".pfile."> (after *@/ appending)",'~'.expand("<slnum>"))

   if pfile =~ '//$'
    let pfile= substitute(pfile,'//$','/','e')
"    call Decho("change // to /: pfile<".pfile.">",'~'.expand("<slnum>"))
   endif
   let pfile= strpart(pfile,dirnamelen)
   let pfile= substitute(pfile,'^[/\\]','','e')
"   call Decho("filename<".filename.">",'~'.expand("<slnum>"))
"   call Decho("pfile   <".pfile.">",'~'.expand("<slnum>"))

   if w:netrw_liststyle == s:LONGLIST
    let sz   = getfsize(filename)
    if g:netrw_sizestyle =~ "[hH]"
     let sz= s:NetrwHumanReadable(sz)
    endif
    let fsz  = strpart("               ",1,15-strlen(sz)).sz
    let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
"    call Decho("sz=".sz." fsz=".fsz,'~'.expand("<slnum>"))
   endif

   if     g:netrw_sort_by =~ "^t"
    " sort by time (handles time up to 1 quintillion seconds, US)
"    call Decho("getftime(".filename.")=".getftime(filename),'~'.expand("<slnum>"))
    let t  = getftime(filename)
    let ft = strpart("000000000000000000",1,18-strlen(t)).t
"    call Decho("exe NetrwKeepj put ='".ft.'/'.filename."'",'~'.expand("<slnum>"))
    let ftpfile= ft.'/'.pfile
    sil! NetrwKeepj put=ftpfile

   elseif g:netrw_sort_by =~ "^s"
    " sort by size (handles file sizes up to 1 quintillion bytes, US)
"    call Decho("getfsize(".filename.")=".getfsize(filename),'~'.expand("<slnum>"))
    let sz   = getfsize(filename)
    if g:netrw_sizestyle =~ "[hH]"
     let sz= s:NetrwHumanReadable(sz)
    endif
    let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
"    call Decho("exe NetrwKeepj put ='".fsz.'/'.filename."'",'~'.expand("<slnum>"))
    let fszpfile= fsz.'/'.pfile
    sil! NetrwKeepj put =fszpfile

   else
    " sort by name
"    call Decho("exe NetrwKeepj put ='".pfile."'",'~'.expand("<slnum>"))
    sil! NetrwKeepj put=pfile
   endif
  endfor

  " cleanup any windows mess at end-of-line
  sil! NetrwKeepj g/^$/d
  sil! NetrwKeepj %s/\r$//e
  call histdel("/",-1)
"  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
  exe "setl ts=".(g:netrw_maxfilenamelen+1)

"  call Dret("s:LocalListing")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalExecute: uses system() to execute command under cursor ("X" command support) {{{2
fun! s:NetrwLocalExecute(cmd)
"  call Dfunc("s:NetrwLocalExecute(cmd<".a:cmd.">)")
  let ykeep= @@
  " sanity check
  if !executable(a:cmd)
   call netrw#ErrorMsg(s:ERROR,"the file<".a:cmd."> is not executable!",89)
   let @@= ykeep
"   call Dret("s:NetrwLocalExecute")
   return
  endif

  let optargs= input(":!".a:cmd,"","file")
"  call Decho("optargs<".optargs.">",'~'.expand("<slnum>"))
  let result= system(a:cmd.optargs)
"  call Decho("result,'~'.expand("<slnum>"))

  " strip any ansi escape sequences off
  let result = substitute(result,"\e\\[[0-9;]*m","","g")

  " show user the result(s)
  echomsg result
  let @@= ykeep

"  call Dret("s:NetrwLocalExecute")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRename: rename a local file or directory {{{2
fun! s:NetrwLocalRename(path) range
"  call Dfunc("NetrwLocalRename(path<".a:path.">)")

  " preparation for removing multiple files/directories
  let ykeep    = @@
  let ctr      = a:firstline
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  " rename files given by the markfilelist
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   for oldname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))
    if exists("subfrom")
     let newname= substitute(oldname,subfrom,subto,'')
"     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
    else
     call inputsave()
     let newname= input("Moving ".oldname." to : ",oldname,"file")
     call inputrestore()
     if newname =~ ''
      " two ctrl-x's : ignore all of string preceding the ctrl-x's
      let newname = substitute(newname,'^.*','','')
     elseif newname =~ ''
      " one ctrl-x : ignore portion of string preceding ctrl-x but after last /
      let newname = substitute(newname,'[^/]*','','')
     endif
     if newname =~ '^s/'
      let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
      let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
"      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
      let newname = substitute(oldname,subfrom,subto,'')
     endif
    endif
    call rename(oldname,newname)
   endfor
   call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)

  else

   " attempt to rename files/directories
   while ctr <= a:lastline
    exe "NetrwKeepj ".ctr

    " sanity checks
    if line(".") < w:netrw_bannercnt
     let ctr= ctr + 1
     continue
    endif
    let curword= s:NetrwGetWord()
    if curword == "./" || curword == "../"
     let ctr= ctr + 1
     continue
    endif

    NetrwKeepj norm! 0
    let oldname= s:ComposePath(a:path,curword)
"   call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))

    call inputsave()
    let newname= input("Moving ".oldname." to : ",substitute(oldname,'/*$','','e'))
    call inputrestore()

    call rename(oldname,newname)
"   call Decho("renaming <".oldname."> to <".newname.">",'~'.expand("<slnum>"))

    let ctr= ctr + 1
   endwhile
  endif

  " refresh the directory
"  call Decho("refresh the directory listing",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep

"  call Dret("NetrwLocalRename")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRm: {{{2
fun! s:NetrwLocalRm(path) range
"  call Dfunc("s:NetrwLocalRm(path<".a:path.">)")
"  call Decho("firstline=".a:firstline." lastline=".a:lastline,'~'.expand("<slnum>"))

  " preparation for removing multiple files/directories
  let ykeep = @@
  let ret   = 0
  let all   = 0
  let svpos = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   " remove all marked files
"   call Decho("remove all marked files",'~'.expand("<slnum>"))
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    let ok= s:NetrwLocalRmFile(a:path,fname,all)
    if ok =~ 'q\%[uit]' || ok == "no"
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
   endfor
   call s:NetrwUnMarkFile(1)

  else
  " remove (multiple) files and directories
"   call Decho("remove files in range [".a:firstline.",".a:lastline."]",'~'.expand("<slnum>"))

   let keepsol= &l:sol
   setl nosol
   let ctr = a:firstline
   while ctr <= a:lastline
    exe "NetrwKeepj ".ctr

    " sanity checks
    if line(".") < w:netrw_bannercnt
     let ctr= ctr + 1
     continue
    endif
    let curword= s:NetrwGetWord()
    if curword == "./" || curword == "../"
     let ctr= ctr + 1
     continue
    endif
    let ok= s:NetrwLocalRmFile(a:path,curword,all)
    if ok =~ 'q\%[uit]' || ok == "no"
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
    let ctr= ctr + 1
   endwhile
   let &l:sol= keepsol
  endif

  " refresh the directory
"  call Decho("bufname<".bufname("%").">",'~'.expand("<slnum>"))
  if bufname("%") != "NetrwMessage"
   NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  endif
  let @@= ykeep

"  call Dret("s:NetrwLocalRm")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRmFile: remove file fname given the path {{{2
"                     Give confirmation prompt unless all==1
fun! s:NetrwLocalRmFile(path,fname,all)
"  call Dfunc("s:NetrwLocalRmFile(path<".a:path."> fname<".a:fname."> all=".a:all)

  let all= a:all
  let ok = ""
  NetrwKeepj norm! 0
  let rmfile= s:NetrwFile(s:ComposePath(a:path,a:fname))
"  call Decho("rmfile<".rmfile.">",'~'.expand("<slnum>"))

  if rmfile !~ '^"' && (rmfile =~ '@$' || rmfile !~ '[\/]$')
   " attempt to remove file
"   call Decho("attempt to remove file<".rmfile.">",'~'.expand("<slnum>"))
   if !all
    echohl Statement
    call inputsave()
    let ok= input("Confirm deletion of file<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    echohl NONE
    if ok == ""
     let ok="no"
    endif
"    call Decho("response: ok<".ok.">",'~'.expand("<slnum>"))
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
"    call Decho("response: ok<".ok."> (after sub)",'~'.expand("<slnum>"))
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
    let ret= s:NetrwDelete(rmfile)
"    call Decho("errcode=".v:shell_error." ret=".ret,'~'.expand("<slnum>"))
   endif

  else
   " attempt to remove directory
   if !all
    echohl Statement
    call inputsave()
    let ok= input("Confirm deletion of directory<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok == ""
     let ok="no"
    endif
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif
   let rmfile= substitute(rmfile,'[\/]$','','e')

   if all || ok =~ 'y\%[es]' || ok == ""
    if v:version < 704 || !has("patch1109")
" "    call Decho("1st attempt: system(netrw#WinPath(".g:netrw_localrmdir.') '.s:ShellEscape(rmfile).')','~'.expand("<slnum>"))
     call system(netrw#WinPath(g:netrw_localrmdir).' '.s:ShellEscape(rmfile))
" "    call Decho("v:shell_error=".v:shell_error,'~'.expand("<slnum>"))

     if v:shell_error != 0
" "     call Decho("2nd attempt to remove directory<".rmfile.">",'~'.expand("<slnum>"))
      let errcode= s:NetrwDelete(rmfile)
" "     call Decho("errcode=".errcode,'~'.expand("<slnum>"))

      if errcode != 0
       if has("unix")
" "       call Decho("3rd attempt to remove directory<".rmfile.">",'~'.expand("<slnum>"))
	call system("rm ".s:ShellEscape(rmfile))
	if v:shell_error != 0 && !exists("g:netrw_quiet")
	 call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",34)
	 let ok="no"
	endif
       elseif !exists("g:netrw_quiet")
	call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",35)
	let ok="no"
       endif
      endif
     endif
    else
     if delete(rmfile,"d")
      call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".rmfile.">!",103)
     endif
    endif
   endif
  endif

"  call Dret("s:NetrwLocalRmFile ".ok)
  return ok
endfun

" ---------------------------------------------------------------------
" Support Functions: {{{1

" ---------------------------------------------------------------------
" netrw#Access: intended to provide access to variable values for netrw's test suite {{{2
"   0: marked file list of current buffer
"   1: marked file target
fun! netrw#Access(ilist)
  if     a:ilist == 0
   if exists("s:netrwmarkfilelist_".bufnr('%'))
    return s:netrwmarkfilelist_{bufnr('%')}
   else
    return "no-list-buf#".bufnr('%')
   endif
  elseif a:ilist == 1
   return s:netrwmftgt
endfun

" ---------------------------------------------------------------------
" netrw#Call: allows user-specified mappings to call internal netrw functions {{{2
fun! netrw#Call(funcname,...)
"  call Dfunc("netrw#Call(funcname<".a:funcname.">,".string(a:000).")")
  if a:0 > 0
   exe "call s:".a:funcname."(".string(a:000).")"
  else
   exe "call s:".a:funcname."()"
  endif
"  call Dret("netrw#Call")
endfun

" ------------------------------------------------------------------------

" ---------------------------------------------------------------------
" netrw#Expose: allows UserMaps and pchk to look at otherwise script-local variables {{{2
"               I expect this function to be used in
"                 :PChkAssert netrw#Expose("netrwmarkfilelist")
"               for example.
fun! netrw#Expose(varname)
"   call Dfunc("netrw#Expose(varname<".a:varname.">)")
  exe "let retval= s:".a:varname
  if exists("g:netrw_pchk")
   if type(retval) == 3
    let retval = copy(retval)
    let i      = 0
    while i < len(retval)
     let retval[i]= substitute(retval[i],expand("$HOME"),'~','')
     let i        = i + 1
    endwhile
   endif
"    call Dret("netrw#Expose ".string(retval))
   return string(retval)
  endif

"  call Dret("netrw#Expose ".string(retval))
  return retval
endfun

" ---------------------------------------------------------------------
" netrw#Modify: allows UserMaps to set (modify) script-local variables {{{2
fun! netrw#Modify(varname,newvalue)
"  call Dfunc("netrw#Modify(varname<".a:varname.">,newvalue<".string(a:newvalue).">)")
  exe "let s:".a:varname."= ".string(a:newvalue)
"  call Dret("netrw#Modify")
endfun

" ---------------------------------------------------------------------
"  netrw#RFC2396: converts %xx into characters {{{2
fun! netrw#RFC2396(fname)
"  call Dfunc("netrw#RFC2396(fname<".a:fname.">)")
  let fname = escape(substitute(a:fname,'%\(\x\x\)','\=nr2char("0x".submatch(1))','ge')," \t")
"  call Dret("netrw#RFC2396 ".fname)
  return fname
endfun

" ---------------------------------------------------------------------
" netrw#UserMaps: supports user-specified maps {{{2
"                 see :help function()
"
"                 g:Netrw_UserMaps is a List with members such as:
"                       [[keymap sequence, function reference],...]
"
"                 The referenced function may return a string,
"                 	refresh : refresh the display
"                 	-other- : this string will be executed
"                 or it may return a List of strings.
"
"                 Each keymap-sequence will be set up with a nnoremap
"                 to invoke netrw#UserMaps(islocal).
"                 Related functions:
"                   netrw#Expose(varname)          -- see s:varname variables
"                   netrw#Modify(varname,newvalue) -- modify value of s:varname variable
"                   netrw#Call(funcname,...)       -- call internal netrw function with optional arguments
fun! netrw#UserMaps(islocal)
"  call Dfunc("netrw#UserMaps(islocal=".a:islocal.")")
"  call Decho("g:Netrw_UserMaps ".(exists("g:Netrw_UserMaps")? "exists" : "does NOT exist"),'~'.expand("<slnum>"))

   " set up usermaplist
   if exists("g:Netrw_UserMaps") && type(g:Netrw_UserMaps) == 3
"    call Decho("g:Netrw_UserMaps has type 3<List>",'~'.expand("<slnum>"))
    for umap in g:Netrw_UserMaps
"     call Decho("type(umap[0]<".string(umap[0]).">)=".type(umap[0])." (should be 1=string)",'~'.expand("<slnum>"))
"     call Decho("type(umap[1])=".type(umap[1])." (should be 1=string)",'~'.expand("<slnum>"))
     " if umap[0] is a string and umap[1] is a string holding a function name
     if type(umap[0]) == 1 && type(umap[1]) == 1
"      call Decho("nno <buffer> <silent> ".umap[0]." :call s:UserMaps(".a:islocal.",".string(umap[1]).")<cr>",'~'.expand("<slnum>"))
      exe "nno <buffer> <silent> ".umap[0]." :call <SID>UserMaps(".a:islocal.",'".umap[1]."')<cr>"
      else
       call netrw#ErrorMsg(s:WARNING,"ignoring usermap <".string(umap[0])."> -- not a [string,funcref] entry",99)
     endif
    endfor
   endif
"  call Dret("netrw#UserMaps")
endfun

" ---------------------------------------------------------------------
" netrw#WinPath: tries to insure that the path is windows-acceptable, whether cygwin is used or not {{{2
fun! netrw#WinPath(path)
"  call Dfunc("netrw#WinPath(path<".a:path.">)")
  if (!g:netrw_cygwin || &shell !~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$') && (has("win32") || has("win95") || has("win64") || has("win16"))
   " remove cygdrive prefix, if present
   let path = substitute(a:path,g:netrw_cygdrive.'/\(.\)','\1:','')
   " remove trailing slash (Win95)
   let path = substitute(path, '\(\\\|/\)$', '', 'g')
   " remove escaped spaces
   let path = substitute(path, '\ ', ' ', 'g')
   " convert slashes to backslashes
   let path = substitute(path, '/', '\', 'g')
  else
   let path= a:path
  endif
"  call Dret("netrw#WinPath <".path.">")
  return path
endfun

" ---------------------------------------------------------------------
"  s:ComposePath: Appends a new part to a path taking different systems into consideration {{{2
fun! s:ComposePath(base,subdir)
"  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")

  if has("amiga")
"   call Decho("amiga",'~'.expand("<slnum>"))
   let ec = a:base[s:Strlen(a:base)-1]
   if ec != '/' && ec != ':'
    let ret = a:base . "/" . a:subdir
   else
    let ret = a:base . a:subdir
   endif

  elseif a:subdir =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows",'~'.expand("<slnum>"))
   let ret= a:subdir

  elseif a:base =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows",'~'.expand("<slnum>"))
   if a:base =~ '[/\\]$'
    let ret= a:base.a:subdir
   else
    let ret= a:base.'/'.a:subdir
   endif

  elseif a:base =~ '^\a\{3,}://'
"   call Decho("remote linux/macos",'~'.expand("<slnum>"))
   let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
   let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
   if a:subdir == '../'
    if curpath =~ '[^/]/[^/]\+/$'
     let curpath= substitute(curpath,'[^/]\+/$','','')
    else
     let curpath=""
    endif
    let ret= urlbase.curpath
   else
    let ret= urlbase.curpath.a:subdir
   endif
"   call Decho("urlbase<".urlbase.">",'~'.expand("<slnum>"))
"   call Decho("curpath<".curpath.">",'~'.expand("<slnum>"))
"   call Decho("ret<".ret.">",'~'.expand("<slnum>"))

  else
"   call Decho("local linux/macos",'~'.expand("<slnum>"))
   let ret = substitute(a:base."/".a:subdir,"//","/","g")
   if a:base =~ '^//'
    " keeping initial '//' for the benefit of network share listing support
    let ret= '/'.ret
   endif
   let ret= simplify(ret)
  endif

"  call Dret("s:ComposePath ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:DeleteBookmark: deletes a file/directory from Netrw's bookmark system {{{2
"   Related Functions: s:MakeBookmark() s:NetrwBookHistHandler() s:NetrwBookmark()
fun! s:DeleteBookmark(fname)
"  call Dfunc("s:DeleteBookmark(fname<".a:fname.">)")
  call s:MergeBookmarks()

  if exists("g:netrw_bookmarklist")
   let indx= index(g:netrw_bookmarklist,a:fname)
   if indx == -1
    let indx= 0
    while indx < len(g:netrw_bookmarklist)
     if g:netrw_bookmarklist[indx] =~ a:fname
      call remove(g:netrw_bookmarklist,indx)
      let indx= indx - 1
     endif
     let indx= indx + 1
    endwhile
   else
    " remove exact match
    call remove(g:netrw_bookmarklist,indx)
   endif
  endif

"  call Dret("s:DeleteBookmark")
endfun

" ---------------------------------------------------------------------
" s:FileReadable: o/s independent filereadable {{{2
fun! s:FileReadable(fname)
"  call Dfunc("s:FileReadable(fname<".a:fname.">)")

  if g:netrw_cygwin
   let ret= filereadable(s:NetrwFile(substitute(a:fname,g:netrw_cygdrive.'/\(.\)','\1:/','')))
  else
   let ret= filereadable(s:NetrwFile(a:fname))
  endif

"  call Dret("s:FileReadable ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
"  s:GetTempfile: gets a tempname that'll work for various o/s's {{{2
"                 Places correct suffix on end of temporary filename,
"                 using the suffix provided with fname
fun! s:GetTempfile(fname)
"  call Dfunc("s:GetTempfile(fname<".a:fname.">)")

  if !exists("b:netrw_tmpfile")
   " get a brand new temporary filename
   let tmpfile= tempname()
"   call Decho("tmpfile<".tmpfile."> : from tempname()",'~'.expand("<slnum>"))

   let tmpfile= substitute(tmpfile,'\','/','ge')
"   call Decho("tmpfile<".tmpfile."> : chgd any \\ -> /",'~'.expand("<slnum>"))

   " sanity check -- does the temporary file's directory exist?
   if !isdirectory(s:NetrwFile(substitute(tmpfile,'[^/]\+$','','e')))
"    call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
    NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your <".substitute(tmpfile,'[^/]\+$','','e')."> directory is missing!",2)
"    call Dret("s:GetTempfile getcwd<".getcwd().">")
    return ""
   endif

   " let netrw#NetSource() know about the tmpfile
   let s:netrw_tmpfile= tmpfile " used by netrw#NetSource() and netrw#BrowseX()
"   call Decho("tmpfile<".tmpfile."> s:netrw_tmpfile<".s:netrw_tmpfile.">",'~'.expand("<slnum>"))

   " o/s dependencies
   if g:netrw_cygwin != 0
    let tmpfile = substitute(tmpfile,'^\(\a\):',g:netrw_cygdrive.'/\1','e')
   elseif has("win32") || has("win95") || has("win64") || has("win16")
    if !exists("+shellslash") || !&ssl
     let tmpfile = substitute(tmpfile,'/','\','g')
    endif
   else
    let tmpfile = tmpfile
   endif
   let b:netrw_tmpfile= tmpfile
"   call Decho("o/s dependent fixed tempname<".tmpfile.">",'~'.expand("<slnum>"))
  else
   " re-use temporary filename
   let tmpfile= b:netrw_tmpfile
"   call Decho("tmpfile<".tmpfile."> re-using",'~'.expand("<slnum>"))
  endif

  " use fname's suffix for the temporary file
  if a:fname != ""
   if a:fname =~ '\.[^./]\+$'
"    call Decho("using fname<".a:fname.">'s suffix",'~'.expand("<slnum>"))
    if a:fname =~ '\.tar\.gz$' || a:fname =~ '\.tar\.bz2$' || a:fname =~ '\.tar\.xz$'
     let suffix = ".tar".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    elseif a:fname =~ '.txz$'
     let suffix = ".txz".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    else
     let suffix = substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    endif
"    call Decho("suffix<".suffix.">",'~'.expand("<slnum>"))
    let tmpfile= substitute(tmpfile,'\.tmp$','','e')
"    call Decho("chgd tmpfile<".tmpfile."> (removed any .tmp suffix)",'~'.expand("<slnum>"))
    let tmpfile .= suffix
"    call Decho("chgd tmpfile<".tmpfile."> (added ".suffix." suffix) netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
    let s:netrw_tmpfile= tmpfile " supports netrw#NetSource()
   endif
  endif

"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Dret("s:GetTempfile <".tmpfile.">")
  return tmpfile
endfun

" ---------------------------------------------------------------------
" s:MakeSshCmd: transforms input command using USEPORT HOSTNAME into {{{2
"               a correct command for use with a system() call
fun! s:MakeSshCmd(sshcmd)
"  call Dfunc("s:MakeSshCmd(sshcmd<".a:sshcmd.">) user<".s:user."> machine<".s:machine.">")
  if s:user == ""
   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:machine,'')
  else
   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user."@".s:machine,'')
  endif
  if exists("g:netrw_port") && g:netrw_port != ""
   let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.g:netrw_port,'')
  elseif exists("s:port") && s:port != ""
   let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.s:port,'')
  else
   let sshcmd= substitute(sshcmd,"USEPORT ",'','')
  endif
"  call Dret("s:MakeSshCmd <".sshcmd.">")
  return sshcmd
endfun

" ---------------------------------------------------------------------
" s:MakeBookmark: enters a bookmark into Netrw's bookmark system   {{{2
fun! s:MakeBookmark(fname)
"  call Dfunc("s:MakeBookmark(fname<".a:fname.">)")

  if !exists("g:netrw_bookmarklist")
   let g:netrw_bookmarklist= []
  endif

  if index(g:netrw_bookmarklist,a:fname) == -1
   " curdir not currently in g:netrw_bookmarklist, so include it
   if isdirectory(s:NetrwFile(a:fname)) && a:fname !~ '/$'
    call add(g:netrw_bookmarklist,a:fname.'/')
   elseif a:fname !~ '/'
    call add(g:netrw_bookmarklist,getcwd()."/".a:fname)
   else
    call add(g:netrw_bookmarklist,a:fname)
   endif
   call sort(g:netrw_bookmarklist)
  endif

"  call Dret("s:MakeBookmark")
endfun

" ---------------------------------------------------------------------
" s:MergeBookmarks: merge current bookmarks with saved bookmarks {{{2
fun! s:MergeBookmarks()
"  call Dfunc("s:MergeBookmarks() : merge current bookmarks into .netrwbook")
  " get bookmarks from .netrwbook file
  let savefile= s:NetrwHome()."/.netrwbook"
  if filereadable(s:NetrwFile(savefile))
"   call Decho("merge bookmarks (active and file)",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwBookHistSave()
"   call Decho("bookmark delete savefile<".savefile.">",'~'.expand("<slnum>"))
   NetrwKeepj call delete(savefile)
  endif
"  call Dret("s:MergeBookmarks")
endfun

" ---------------------------------------------------------------------
" s:NetrwBMShow: {{{2
fun! s:NetrwBMShow()
"  call Dfunc("s:NetrwBMShow()")
  redir => bmshowraw
   menu
  redir END
  let bmshowlist = split(bmshowraw,'\n')
  if bmshowlist != []
   let bmshowfuncs= filter(bmshowlist,'v:val =~ "<SNR>\\d\\+_BMShow()"')
   if bmshowfuncs != []
    let bmshowfunc = substitute(bmshowfuncs[0],'^.*:\(call.*BMShow()\).*$','\1','')
    if bmshowfunc =~ '^call.*BMShow()'
     exe "sil! NetrwKeepj ".bmshowfunc
    endif
   endif
  endif
"  call Dret("s:NetrwBMShow : bmshowfunc<".(exists("bmshowfunc")? bmshowfunc : 'n/a').">")
endfun

" ---------------------------------------------------------------------
" s:NetrwCursor: responsible for setting cursorline/cursorcolumn based upon g:netrw_cursor {{{2
fun! s:NetrwCursor()
  if !exists("w:netrw_liststyle")
   let w:netrw_liststyle= g:netrw_liststyle
  endif
"  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)

  if &ft != "netrw"
   " if the current window isn't a netrw directory listing window, then use user cursorline/column
   " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
"   call Decho("case ft!=netrw: use user cul,cuc",'~'.expand("<slnum>"))
   let &l:cursorline   = s:netrw_usercul
   let &l:cursorcolumn = s:netrw_usercuc

  elseif g:netrw_cursor == 4
   " all styles: cursorline, cursorcolumn
"   call Decho("case g:netrw_cursor==4: setl cul cuc",'~'.expand("<slnum>"))
   setl cursorline
   setl cursorcolumn

  elseif g:netrw_cursor == 3
   " thin-long-tree: cursorline, user's cursorcolumn
   " wide          : cursorline, cursorcolumn
   if w:netrw_liststyle == s:WIDELIST
"    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc",'~'.expand("<slnum>"))
    setl cursorline
    setl cursorcolumn
   else
"    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
    setl cursorline
    let &l:cursorcolumn   = s:netrw_usercuc
   endif

  elseif g:netrw_cursor == 2
   " thin-long-tree: cursorline, user's cursorcolumn
   " wide          : cursorline, user's cursorcolumn
"   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)",'~'.expand("<slnum>"))
   let &l:cursorcolumn = s:netrw_usercuc
   setl cursorline

  elseif g:netrw_cursor == 1
   " thin-long-tree: user's cursorline, user's cursorcolumn
   " wide          : cursorline,        user's cursorcolumn
   let &l:cursorcolumn = s:netrw_usercuc
   if w:netrw_liststyle == s:WIDELIST
"    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
    setl cursorline
   else
"    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)",'~'.expand("<slnum>"))
    let &l:cursorline   = s:netrw_usercul
   endif

  else
   " all styles: user's cursorline, user's cursorcolumn
"   call Decho("default: (use user's cul,cuc)",'~'.expand("<slnum>"))
   let &l:cursorline   = s:netrw_usercul
   let &l:cursorcolumn = s:netrw_usercuc
  endif

"  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)
endfun

" ---------------------------------------------------------------------
" s:RestoreCursorline: restores cursorline/cursorcolumn to original user settings {{{2
fun! s:RestoreCursorline()
"  call Dfunc("s:RestoreCursorline() currently, cul=".&l:cursorline." cuc=".&l:cursorcolumn." win#".winnr()." buf#".bufnr("%"))
  if exists("s:netrw_usercul")
   let &l:cursorline   = s:netrw_usercul
  endif
  if exists("s:netrw_usercuc")
   let &l:cursorcolumn = s:netrw_usercuc
  endif
"  call Dret("s:RestoreCursorline : restored cul=".&l:cursorline." cuc=".&l:cursorcolumn)
endfun

" ---------------------------------------------------------------------
" s:NetrwDelete: Deletes a file. {{{2
"           Uses Steve Hall's idea to insure that Windows paths stay
"           acceptable.  No effect on Unix paths.
"  Examples of use:  let result= s:NetrwDelete(path)
fun! s:NetrwDelete(path)
"  call Dfunc("s:NetrwDelete(path<".a:path.">)")

  let path = netrw#WinPath(a:path)
  if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
   if exists("+shellslash")
    let sskeep= &shellslash
    setl noshellslash
    let result      = delete(path)
    let &shellslash = sskeep
   else
"    call Decho("exe let result= ".a:cmd."('".path."')",'~'.expand("<slnum>"))
    let result= delete(path)
   endif
  else
"   call Decho("let result= delete(".path.")",'~'.expand("<slnum>"))
   let result= delete(path)
  endif
  if result < 0
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"delete(".path.") failed!",71)
  endif

"  call Dret("s:NetrwDelete ".result)
  return result
endfun

" ---------------------------------------------------------------------
" s:NetrwEnew: opens a new buffer, passes netrw buffer variables through {{{2
fun! s:NetrwEnew(...)
"  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
"  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))

  " grab a function-local-variable copy of buffer variables
"  call Decho("make function-local copy of netrw variables",'~'.expand("<slnum>"))
  if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
  if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
  if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
  if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
  if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
  if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
  if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
  if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
  if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
  if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
  if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
  if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
  if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
  if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
  if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
  if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif

  NetrwKeepj call s:NetrwOptionRestore("w:")
"  call Decho("generate a buffer with NetrwKeepj keepalt enew!",'~'.expand("<slnum>"))
  " when tree listing uses file TreeListing... a new buffer is made.
  " Want the old buffer to be unlisted.
  setl nobl
  let netrw_keepdiff= &l:diff
  noswapfile NetrwKeepj keepalt enew!
  let &l:diff= netrw_keepdiff
"  call Decho("bufnr($)=".bufnr("$")." winnr($)=".winnr("$"),'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwOptionSave("w:")

  " copy function-local-variables to buffer variable equivalents
"  call Decho("copy function-local variables back to buffer netrw variables",'~'.expand("<slnum>"))
  if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
  if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
  if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
  if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
  if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
  if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
  if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
  if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
  if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
  if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
  if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
  if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
  if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
  if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
  if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
  if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif

  if a:0 > 0
   let b:netrw_curdir= a:1
   if b:netrw_curdir =~ '/$'
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
     setl nobl
     file NetrwTreeListing
     setl nobl bt=nowrite bh=hide
     nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
     nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
    else
     exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
    endif
   endif
  endif

"  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))
endfun

" ---------------------------------------------------------------------
" s:NetrwExe: executes a string using "!" {{{2
fun! s:NetrwExe(cmd)
"  call Dfunc("s:NetrwExe(a:cmd)")
  if has("win32") && &shell !~? 'cmd' && !g:netrw_cygwin
    let savedShell=[&shell,&shellcmdflag,&shellxquote,&shellxescape,&shellquote,&shellpipe,&shellredir,&shellslash]
    set shell& shellcmdflag& shellxquote& shellxescape&
    set shellquote& shellpipe& shellredir& shellslash&
    exe a:cmd
    let [&shell,&shellcmdflag,&shellxquote,&shellxescape,&shellquote,&shellpipe,&shellredir,&shellslash] = savedShell
  else
   exe a:cmd
  endif
"  call Dret("s:NetrwExe")
endfun

" ---------------------------------------------------------------------
" s:NetrwInsureWinVars: insure that a netrw buffer has its w: variables in spite of a wincmd v or s {{{2
fun! s:NetrwInsureWinVars()
"  call Dfunc("s:NetrwInsureWinVars() win#".winnr())
  if !exists("w:netrw_liststyle")
   let curbuf = bufnr("%")
   let curwin = winnr()
   let iwin   = 1
   while iwin <= winnr("$")
    exe iwin."wincmd w"
    if winnr() != curwin && bufnr("%") == curbuf && exists("w:netrw_liststyle")
     " looks like ctrl-w_s or ctrl-w_v was used to split a netrw buffer
     let winvars= w:
     break
    endif
    let iwin= iwin + 1
   endwhile
   exe "keepalt ".curwin."wincmd w"
   if exists("winvars")
"    call Decho("copying w#".iwin." window variables to w#".curwin,'~'.expand("<slnum>"))
    for k in keys(winvars)
     let w:{k}= winvars[k]
    endfor
   endif
  endif
"  call Dret("s:NetrwInsureWinVars win#".winnr())
endfun

" ---------------------------------------------------------------------
" s:NetrwLcd: handles changing the (local) directory {{{2
fun! s:NetrwLcd(newdir)
"  call Dfunc("s:NetrwLcd(newdir<".a:newdir.">)")

  try
   exe 'NetrwKeepj sil lcd '.fnameescape(a:newdir)
  catch /^Vim\%((\a\+)\)\=:E344/
     " Vim's lcd fails with E344 when attempting to go above the 'root' of a Windows share.
     " Therefore, detect if a Windows share is present, and if E344 occurs, just settle at
     " 'root' (ie. '\').  The share name may start with either backslashes ('\\Foo') or
     " forward slashes ('//Foo'), depending on whether backslashes have been converted to
     " forward slashes by earlier code; so check for both.
     if (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
       if a:newdir =~ '^\\\\\w\+' || a:newdir =~ '^//\w\+'
         let dirname = '\'
	 exe 'NetrwKeepj sil lcd '.fnameescape(dirname)
       endif
     endif
  catch /^Vim\%((\a\+)\)\=:E472/
   call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".a:newdir."> (permissions?)",61)
   if exists("w:netrw_prvdir")
    let a:newdir= w:netrw_prvdir
   else
    call s:NetrwOptionRestore("w:")
"    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
    exe "setl ".g:netrw_bufsettings
"    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
    let a:newdir= dirname
"    call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
    return
   endif
  endtry

"  call Dret("s:NetrwLcd")
endfun

" ------------------------------------------------------------------------
" s:NetrwSaveWordPosn: used to keep cursor on same word after refresh, {{{2
" changed sorting, etc.  Also see s:NetrwRestoreWordPosn().
fun! s:NetrwSaveWordPosn()
"  call Dfunc("NetrwSaveWordPosn()")
  let s:netrw_saveword= '^'.fnameescape(getline('.')).'$'
"  call Dret("NetrwSaveWordPosn : saveword<".s:netrw_saveword.">")
endfun

" ---------------------------------------------------------------------
" s:NetrwHumanReadable: takes a number and makes it "human readable" {{{2
"                       1000 -> 1K, 1000000 -> 1M, 1000000000 -> 1G
fun! s:NetrwHumanReadable(sz)
"  call Dfunc("s:NetrwHumanReadable(sz=".a:sz.") type=".type(a:sz)." style=".g:netrw_sizestyle )

  if g:netrw_sizestyle == 'h'
   if a:sz >= 1000000000 
    let sz = printf("%.1f",a:sz/1000000000.0)."g"
   elseif a:sz >= 10000000
    let sz = printf("%d",a:sz/1000000)."m"
   elseif a:sz >= 1000000
    let sz = printf("%.1f",a:sz/1000000.0)."m"
   elseif a:sz >= 10000
    let sz = printf("%d",a:sz/1000)."k"
   elseif a:sz >= 1000
    let sz = printf("%.1f",a:sz/1000.0)."k"
   else
    let sz= a:sz
   endif

  elseif g:netrw_sizestyle == 'H'
   if a:sz >= 1073741824
    let sz = printf("%.1f",a:sz/1073741824.0)."G"
   elseif a:sz >= 10485760
    let sz = printf("%d",a:sz/1048576)."M"
   elseif a:sz >= 1048576
    let sz = printf("%.1f",a:sz/1048576.0)."M"
   elseif a:sz >= 10240
    let sz = printf("%d",a:sz/1024)."K"
   elseif a:sz >= 1024
    let sz = printf("%.1f",a:sz/1024.0)."K"
   else
    let sz= a:sz
   endif

  else
   let sz= a:sz
  endif

"  call Dret("s:NetrwHumanReadable ".sz)
  return sz
endfun

" ---------------------------------------------------------------------
" s:NetrwRestoreWordPosn: used to keep cursor on same word after refresh, {{{2
"  changed sorting, etc.  Also see s:NetrwSaveWordPosn().
fun! s:NetrwRestoreWordPosn()
"  call Dfunc("NetrwRestoreWordPosn()")
  sil! call search(s:netrw_saveword,'w')
"  call Dret("NetrwRestoreWordPosn")
endfun

" ---------------------------------------------------------------------
" s:RestoreBufVars: {{{2
fun! s:RestoreBufVars()
"  call Dfunc("s:RestoreBufVars()")

  if exists("s:netrw_curdir")        |let b:netrw_curdir         = s:netrw_curdir        |endif
  if exists("s:netrw_lastfile")      |let b:netrw_lastfile       = s:netrw_lastfile      |endif
  if exists("s:netrw_method")        |let b:netrw_method         = s:netrw_method        |endif
  if exists("s:netrw_fname")         |let b:netrw_fname          = s:netrw_fname         |endif
  if exists("s:netrw_machine")       |let b:netrw_machine        = s:netrw_machine       |endif
  if exists("s:netrw_browser_active")|let b:netrw_browser_active = s:netrw_browser_active|endif

"  call Dret("s:RestoreBufVars")
endfun

" ---------------------------------------------------------------------
" s:RemotePathAnalysis: {{{2
fun! s:RemotePathAnalysis(dirname)
"  call Dfunc("s:RemotePathAnalysis(a:dirname<".a:dirname.">)")

  "                method   ://    user  @      machine      :port            /path
  let dirpat  = '^\(\w\{-}\)://\(\(\w\+\)@\)\=\([^/:#]\+\)\%([:#]\(\d\+\)\)\=/\(.*\)$'
  let s:method  = substitute(a:dirname,dirpat,'\1','')
  let s:user    = substitute(a:dirname,dirpat,'\3','')
  let s:machine = substitute(a:dirname,dirpat,'\4','')
  let s:port    = substitute(a:dirname,dirpat,'\5','')
  let s:path    = substitute(a:dirname,dirpat,'\6','')
  let s:fname   = substitute(s:path,'^.*/\ze.','','')
  if s:machine =~ '@'
   let dirpat    = '^\(.*\)@\(.\{-}\)$'
   let s:user    = s:user.'@'.substitute(s:machine,dirpat,'\1','')
   let s:machine = substitute(s:machine,dirpat,'\2','')
  endif

"  call Decho("set up s:method <".s:method .">",'~'.expand("<slnum>"))
"  call Decho("set up s:user   <".s:user   .">",'~'.expand("<slnum>"))
"  call Decho("set up s:machine<".s:machine.">",'~'.expand("<slnum>"))
"  call Decho("set up s:port   <".s:port.">",'~'.expand("<slnum>"))
"  call Decho("set up s:path   <".s:path   .">",'~'.expand("<slnum>"))
"  call Decho("set up s:fname  <".s:fname  .">",'~'.expand("<slnum>"))

"  call Dret("s:RemotePathAnalysis")
endfun

" ---------------------------------------------------------------------
" s:RemoteSystem: runs a command on a remote host using ssh {{{2
"                 Returns status
" Runs system() on
"    [cd REMOTEDIRPATH;] a:cmd
" Note that it doesn't do s:ShellEscape(a:cmd)!
fun! s:RemoteSystem(cmd)
"  call Dfunc("s:RemoteSystem(cmd<".a:cmd.">)")
  if !executable(g:netrw_ssh_cmd)
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"g:netrw_ssh_cmd<".g:netrw_ssh_cmd."> is not executable!",52)
  elseif !exists("b:netrw_curdir")
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
  else
   let cmd      = s:MakeSshCmd(g:netrw_ssh_cmd." USEPORT HOSTNAME")
   let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
   if remotedir != ""
    let cmd= cmd.' cd '.s:ShellEscape(remotedir).";"
   else
    let cmd= cmd.' '
   endif
   let cmd= cmd.a:cmd
"   call Decho("call system(".cmd.")",'~'.expand("<slnum>"))
   let ret= system(cmd)
  endif
"  call Dret("s:RemoteSystem ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:RestoreWinVars: (used by Explore() and NetrwSplit()) {{{2
fun! s:RestoreWinVars()
"  call Dfunc("s:RestoreWinVars()")
  if exists("s:bannercnt")      |let w:netrw_bannercnt       = s:bannercnt      |unlet s:bannercnt      |endif
  if exists("s:col")            |let w:netrw_col             = s:col            |unlet s:col            |endif
  if exists("s:curdir")         |let w:netrw_curdir          = s:curdir         |unlet s:curdir         |endif
  if exists("s:explore_bufnr")  |let w:netrw_explore_bufnr   = s:explore_bufnr  |unlet s:explore_bufnr  |endif
  if exists("s:explore_indx")   |let w:netrw_explore_indx    = s:explore_indx   |unlet s:explore_indx   |endif
  if exists("s:explore_line")   |let w:netrw_explore_line    = s:explore_line   |unlet s:explore_line   |endif
  if exists("s:explore_listlen")|let w:netrw_explore_listlen = s:explore_listlen|unlet s:explore_listlen|endif
  if exists("s:explore_list")   |let w:netrw_explore_list    = s:explore_list   |unlet s:explore_list   |endif
  if exists("s:explore_mtchcnt")|let w:netrw_explore_mtchcnt = s:explore_mtchcnt|unlet s:explore_mtchcnt|endif
  if exists("s:fpl")            |let w:netrw_fpl             = s:fpl            |unlet s:fpl            |endif
  if exists("s:hline")          |let w:netrw_hline           = s:hline          |unlet s:hline          |endif
  if exists("s:line")           |let w:netrw_line            = s:line           |unlet s:line           |endif
  if exists("s:liststyle")      |let w:netrw_liststyle       = s:liststyle      |unlet s:liststyle      |endif
  if exists("s:method")         |let w:netrw_method          = s:method         |unlet s:method         |endif
  if exists("s:prvdir")         |let w:netrw_prvdir          = s:prvdir         |unlet s:prvdir         |endif
  if exists("s:treedict")       |let w:netrw_treedict        = s:treedict       |unlet s:treedict       |endif
  if exists("s:treetop")        |let w:netrw_treetop         = s:treetop        |unlet s:treetop        |endif
  if exists("s:winnr")          |let w:netrw_winnr           = s:winnr          |unlet s:winnr          |endif
"  call Dret("s:RestoreWinVars")
endfun

" ---------------------------------------------------------------------
" s:Rexplore: implements returning from a buffer to a netrw directory {{{2
"
"             s:SetRexDir() sets up <2-leftmouse> maps (if g:netrw_retmap
"             is true) and a command, :Rexplore, which call this function.
"
"             s:nbcd_curpos_{bufnr('%')} is set up by s:NetrwBrowseChgDir()
"
"             s:rexposn_BUFNR used to save/restore cursor position
fun! s:NetrwRexplore(islocal,dirname)
  if exists("s:netrwdrag")
   return
  endif
"  call Dfunc("s:NetrwRexplore() w:netrw_rexlocal=".w:netrw_rexlocal." w:netrw_rexdir<".w:netrw_rexdir."> win#".winnr())
"  call Decho("currently in bufname<".bufname("%").">",'~'.expand("<slnum>"))
"  call Decho("ft=".&ft." win#".winnr()." w:netrw_rexfile<".(exists("w:netrw_rexfile")? w:netrw_rexfile : 'n/a').">",'~'.expand("<slnum>"))

  if &ft == "netrw" && exists("w:netrw_rexfile") && w:netrw_rexfile != ""
   " a :Rex while in a netrw buffer means: edit the file in w:netrw_rexfile
"   call Decho("in netrw buffer, will edit file<".w:netrw_rexfile.">",'~'.expand("<slnum>"))
   exe "NetrwKeepj e ".w:netrw_rexfile
   unlet w:netrw_rexfile
"   call Dret("s:NetrwRexplore returning from netrw to buf#".bufnr("%")."<".bufname("%").">  (ft=".&ft.")")
   return
"  else " Decho
"   call Decho("treating as not-netrw-buffer: ft=".&ft.((&ft == "netrw")? " == netrw" : "!= netrw"),'~'.expand("<slnum>"))
"   call Decho("treating as not-netrw-buffer: w:netrw_rexfile<".((exists("w:netrw_rexfile"))? w:netrw_rexfile : 'n/a').">",'~'.expand("<slnum>"))
  endif

  " ---------------------------
  " :Rex issued while in a file
  " ---------------------------

  " record current file so :Rex can return to it from netrw
  let w:netrw_rexfile= expand("%")
"  call Decho("set w:netrw_rexfile<".w:netrw_rexfile.">  (win#".winnr().")",'~'.expand("<slnum>"))

  if !exists("w:netrw_rexlocal")
"   call Dret("s:NetrwRexplore w:netrw_rexlocal doesn't exist (".&ft." win#".winnr().")")
   return
  endif
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
  if w:netrw_rexlocal
   NetrwKeepj call netrw#LocalBrowseCheck(w:netrw_rexdir)
  else
   NetrwKeepj call s:NetrwBrowse(0,w:netrw_rexdir)
  endif
  if exists("s:initbeval")
   setl beval
  endif
  if exists("s:rexposn_".bufnr("%"))
"   call Decho("restore posn, then unlet s:rexposn_".bufnr('%')."<".bufname("%").">",'~'.expand("<slnum>"))
   " restore position in directory listing
"   call Decho("restoring posn to s:rexposn_".bufnr('%')."<".string(s:rexposn_{bufnr('%')}).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(s:rexposn_{bufnr('%')})
   if exists("s:rexposn_".bufnr('%'))
    unlet s:rexposn_{bufnr('%')}
   endif
  else
"   call Decho("s:rexposn_".bufnr('%')."<".bufname("%")."> doesn't exist",'~'.expand("<slnum>"))
  endif

  if exists("s:explore_match")
   exe "2match netrwMarkFile /".s:explore_match."/"
  endif

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Dret("s:NetrwRexplore : ft=".&ft)
endfun

" ---------------------------------------------------------------------
" s:SaveBufVars: save selected b: variables to s: variables {{{2
"                use s:RestoreBufVars() to restore b: variables from s: variables
fun! s:SaveBufVars()
"  call Dfunc("s:SaveBufVars() buf#".bufnr("%"))

  if exists("b:netrw_curdir")        |let s:netrw_curdir         = b:netrw_curdir        |endif
  if exists("b:netrw_lastfile")      |let s:netrw_lastfile       = b:netrw_lastfile      |endif
  if exists("b:netrw_method")        |let s:netrw_method         = b:netrw_method        |endif
  if exists("b:netrw_fname")         |let s:netrw_fname          = b:netrw_fname         |endif
  if exists("b:netrw_machine")       |let s:netrw_machine        = b:netrw_machine       |endif
  if exists("b:netrw_browser_active")|let s:netrw_browser_active = b:netrw_browser_active|endif

"  call Dret("s:SaveBufVars")
endfun

" ---------------------------------------------------------------------
" s:SaveWinVars: (used by Explore() and NetrwSplit()) {{{2
fun! s:SaveWinVars()
"  call Dfunc("s:SaveWinVars() win#".winnr())
  if exists("w:netrw_bannercnt")      |let s:bannercnt       = w:netrw_bannercnt      |endif
  if exists("w:netrw_col")            |let s:col             = w:netrw_col            |endif
  if exists("w:netrw_curdir")         |let s:curdir          = w:netrw_curdir         |endif
  if exists("w:netrw_explore_bufnr")  |let s:explore_bufnr   = w:netrw_explore_bufnr  |endif
  if exists("w:netrw_explore_indx")   |let s:explore_indx    = w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_line")   |let s:explore_line    = w:netrw_explore_line   |endif
  if exists("w:netrw_explore_listlen")|let s:explore_listlen = w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_list")   |let s:explore_list    = w:netrw_explore_list   |endif
  if exists("w:netrw_explore_mtchcnt")|let s:explore_mtchcnt = w:netrw_explore_mtchcnt|endif
  if exists("w:netrw_fpl")            |let s:fpl             = w:netrw_fpl            |endif
  if exists("w:netrw_hline")          |let s:hline           = w:netrw_hline          |endif
  if exists("w:netrw_line")           |let s:line            = w:netrw_line           |endif
  if exists("w:netrw_liststyle")      |let s:liststyle       = w:netrw_liststyle      |endif
  if exists("w:netrw_method")         |let s:method          = w:netrw_method         |endif
  if exists("w:netrw_prvdir")         |let s:prvdir          = w:netrw_prvdir         |endif
  if exists("w:netrw_treedict")       |let s:treedict        = w:netrw_treedict       |endif
  if exists("w:netrw_treetop")        |let s:treetop         = w:netrw_treetop        |endif
  if exists("w:netrw_winnr")          |let s:winnr           = w:netrw_winnr          |endif
"  call Dret("s:SaveWinVars")
endfun

" ---------------------------------------------------------------------
" s:SetBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck()) {{{2
"   To allow separate windows to have their own activities, such as
"   Explore **/pattern, several variables have been made window-oriented.
"   However, when the user splits a browser window (ex: ctrl-w s), these
"   variables are not inherited by the new window.  SetBufWinVars() and
"   UseBufWinVars() get around that.
fun! s:SetBufWinVars()
"  call Dfunc("s:SetBufWinVars() win#".winnr())
  if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
  if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
  if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
  if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
  if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
  if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
  if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
  if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
"  call Dret("s:SetBufWinVars")
endfun

" ---------------------------------------------------------------------
" s:SetRexDir: set directory for :Rexplore {{{2
fun! s:SetRexDir(islocal,dirname)
"  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">) win#".winnr())
  let w:netrw_rexdir         = a:dirname
  let w:netrw_rexlocal       = a:islocal
  let s:rexposn_{bufnr("%")} = winsaveview()
"  call Decho("setting w:netrw_rexdir  =".w:netrw_rexdir)
"  call Decho("setting w:netrw_rexlocal=".w:netrw_rexlocal)
"  call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
"  call Decho("setting s:rexposn_".bufnr("%")."<".bufname("%")."> to SavePosn",'~'.expand("<slnum>"))
"  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)
endfun

" ---------------------------------------------------------------------
" s:ShowLink: used to modify thin and tree listings to show links {{{2
fun! s:ShowLink()
" "  call Dfunc("s:ShowLink()")
" "  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist").">",'~'.expand("<slnum>"))
" "  call Decho(printf("line#%4d: %s",line("."),getline(".")),'~'.expand("<slnum>"))
  if exists("b:netrw_curdir")
   norm! $?\a
   let fname   = b:netrw_curdir.'/'.s:NetrwGetWord()
   let resname = resolve(fname)
" "   call Decho("fname         <".fname.">",'~'.expand("<slnum>"))
" "   call Decho("resname       <".resname.">",'~'.expand("<slnum>"))
" "   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
   if resname =~ '^\M'.b:netrw_curdir.'/'
    let dirlen  = strlen(b:netrw_curdir)
    let resname = strpart(resname,dirlen+1)
" "    call Decho("resname<".resname.">  (b:netrw_curdir elided)",'~'.expand("<slnum>"))
   endif
   let modline = getline(".")."\t --> ".resname
" "   call Decho("fname  <".fname.">",'~'.expand("<slnum>"))
" "   call Decho("modline<".modline.">",'~'.expand("<slnum>"))
   setl noro ma
   call setline(".",modline)
   setl ro noma nomod
  endif
" "  call Dret("s:ShowLink".((exists("fname")? ' : '.fname : 'n/a')))
endfun

" ---------------------------------------------------------------------
" s:ShowStyle: {{{2
fun! s:ShowStyle()
  if !exists("w:netrw_liststyle")
   let liststyle= g:netrw_liststyle
  else
   let liststyle= w:netrw_liststyle
  endif
  if     liststyle == s:THINLIST
   return s:THINLIST.":thin"
  elseif liststyle == s:LONGLIST
   return s:LONGLIST.":long"
  elseif liststyle == s:WIDELIST
   return s:WIDELIST.":wide"
  elseif liststyle == s:TREELIST
   return s:TREELIST.":tree"
  else
   return 'n/a'
  endif
endfun

" ---------------------------------------------------------------------
" s:Strlen: this function returns the length of a string, even if its using multi-byte characters. {{{2
"           Solution from Nicolai Weibull, vim docs (:help strlen()),
"           Tony Mechelynck, and my own invention.
fun! s:Strlen(x)
"  "" call Dfunc("s:Strlen(x<".a:x."> g:Align_xstrlen=".g:Align_xstrlen.")")

  if v:version >= 703 && exists("*strdisplaywidth")
   let ret= strdisplaywidth(a:x)

  elseif type(g:Align_xstrlen) == 1
   " allow user to specify a function to compute the string length  (ie. let g:Align_xstrlen="mystrlenfunc")
   exe "let ret= ".g:Align_xstrlen."('".substitute(a:x,"'","''","g")."')"

  elseif g:Align_xstrlen == 1
   " number of codepoints (Latin a + combining circumflex is two codepoints)
   " (comment from TM, solution from NW)
   let ret= strlen(substitute(a:x,'.','c','g'))

  elseif g:Align_xstrlen == 2
   " number of spacing codepoints (Latin a + combining circumflex is one spacing
   " codepoint; a hard tab is one; wide and narrow CJK are one each; etc.)
   " (comment from TM, solution from TM)
   let ret=strlen(substitute(a:x, '.\Z', 'x', 'g'))

  elseif g:Align_xstrlen == 3
   " virtual length (counting, for instance, tabs as anything between 1 and
   " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately
   " preceded by lam, one otherwise, etc.)
   " (comment from TM, solution from me)
   let modkeep= &l:mod
   exe "norm! o\<esc>"
   call setline(line("."),a:x)
   let ret= virtcol("$") - 1
   d
   NetrwKeepj norm! k
   let &l:mod= modkeep

  else
   " at least give a decent default
    let ret= strlen(a:x)
  endif
"  "" call Dret("s:Strlen ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:ShellEscape: shellescape(), or special windows handling {{{2
fun! s:ShellEscape(s, ...)
  if (has('win32') || has('win64')) && $SHELL == '' && &shellslash
    return printf('"%s"', substitute(a:s, '"', '""', 'g'))
  endif 
  let f = a:0 > 0 ? a:1 : 0
  return shellescape(a:s, f)
endfun

" ---------------------------------------------------------------------
" s:TreeListMove: supports [[, ]], [], and ][ in tree mode {{{2
fun! s:TreeListMove(dir)
"  call Dfunc("s:TreeListMove(dir<".a:dir.">)")
  let curline      = getline('.')
  let prvline      = (line(".") > 1)?         getline(line(".")-1) : ''
  let nxtline      = (line(".") < line("$"))? getline(line(".")+1) : ''
  let curindent    = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
  let indentm1     = substitute(curindent,'^'.s:treedepthstring,'','')
  let treedepthchr = substitute(s:treedepthstring,' ','','g')
  let stopline     = exists("w:netrw_bannercnt")? w:netrw_bannercnt : 1
"  call Decho("prvline  <".prvline."> #".(line(".")-1), '~'.expand("<slnum>"))
"  call Decho("curline  <".curline."> #".line(".")    , '~'.expand("<slnum>"))
"  call Decho("nxtline  <".nxtline."> #".(line(".")+1), '~'.expand("<slnum>"))
"  call Decho("curindent<".curindent.">"              , '~'.expand("<slnum>"))
"  call Decho("indentm1 <".indentm1.">"               , '~'.expand("<slnum>"))
  "  COMBAK : need to handle when on a directory
  "  COMBAK : need to handle ]] and ][.  In general, needs work!!!
  if curline !~ '/$'
   if     a:dir == '[[' && prvline != ''
    NetrwKeepj norm! 0
    let nl = search('^'.indentm1.'\%('.s:treedepthstring.'\)\@!','bWe',stopline) " search backwards
"    call Decho("regfile srch back: ".nl,'~'.expand("<slnum>"))
   elseif a:dir == '[]' && nxtline != ''
    NetrwKeepj norm! 0
"    call Decho('srchpat<'.'^\%('.curindent.'\)\@!'.'>')
    let nl = search('^\%('.curindent.'\)\@!','We') " search forwards
    if nl != 0
     NetrwKeepj norm! k
    else
     NetrwKeepj norm! G
    endif
"    call Decho("regfile srch fwd: ".nl,'~'.expand("<slnum>"))
   endif
  endif

"  call Dret("s:TreeListMove")
endfun

" ---------------------------------------------------------------------
" s:UpdateBuffersMenu: does emenu Buffers.Refresh (but due to locale, the menu item may not be called that) {{{2
"                      The Buffers.Refresh menu calls s:BMShow(); unfortunately, that means that that function
"                      can't be called except via emenu.  But due to locale, that menu line may not be called
"                      Buffers.Refresh; hence, s:NetrwBMShow() utilizes a "cheat" to call that function anyway.
fun! s:UpdateBuffersMenu()
"  call Dfunc("s:UpdateBuffersMenu()")
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   try
    sil emenu Buffers.Refresh\ menu
   catch /^Vim\%((\a\+)\)\=:E/
    let v:errmsg= ""
    sil NetrwKeepj call s:NetrwBMShow()
   endtry
  endif
"  call Dret("s:UpdateBuffersMenu")
endfun

" ---------------------------------------------------------------------
" s:UseBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck() {{{2
"              Matching function to s:SetBufWinVars()
fun! s:UseBufWinVars()
"  call Dfunc("s:UseBufWinVars()")
  if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
  if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
  if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
  if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
  if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
  if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
  if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
  if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
  if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
  if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
"  call Dret("s:UseBufWinVars")
endfun

" ---------------------------------------------------------------------
" s:UserMaps: supports user-defined UserMaps {{{2
"               * calls a user-supplied funcref(islocal,curdir)
"               * interprets result
"             See netrw#UserMaps()
fun! s:UserMaps(islocal,funcname)
"  call Dfunc("s:UserMaps(islocal=".a:islocal.",funcname<".a:funcname.">)")

  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
  endif
  let Funcref = function(a:funcname)
  let result  = Funcref(a:islocal)

  if     type(result) == 1
   " if result from user's funcref is a string...
"   call Decho("result string from user funcref<".result.">",'~'.expand("<slnum>"))
   if result == "refresh"
"    call Decho("refreshing display",'~'.expand("<slnum>"))
    call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   elseif result != ""
"    call Decho("executing result<".result.">",'~'.expand("<slnum>"))
    exe result
   endif

  elseif type(result) == 3
   " if result from user's funcref is a List...
"   call Decho("result List from user funcref<".string(result).">",'~'.expand("<slnum>"))
   for action in result
    if action == "refresh"
"     call Decho("refreshing display",'~'.expand("<slnum>"))
     call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
    elseif action != ""
"     call Decho("executing action<".action.">",'~'.expand("<slnum>"))
     exe action
    endif
   endfor
  endif

"  call Dret("s:UserMaps")
endfun

" ---------------------------------------------------------------------
" Settings Restoration: {{{1
let &cpo= s:keepcpo
unlet s:keepcpo

" ------------------------------------------------------------------------
" Modelines: {{{1
" vim:ts=8 fdm=marker
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *insert.txt*    For Vim version 7.4.  Last change: 2016 Jan 31


		  VIM REFERENCE MANUAL    by Bram Moolenaar


						*Insert* *Insert-mode*
Inserting and replacing text				*mode-ins-repl*

Most of this file is about Insert and Replace mode.  At the end are a few
commands for inserting text in other ways.

An overview of the most often used commands can be found in chapter 24 of the
user manual |usr_24.txt|.

1. Special keys						|ins-special-keys|
2. Special special keys					|ins-special-special|
3. 'textwidth' and 'wrapmargin' options			|ins-textwidth|
4. 'expandtab', 'smarttab' and 'softtabstop'  options	|ins-expandtab|
5. Replace mode						|Replace-mode|
6. Virtual Replace mode					|Virtual-Replace-mode|
7. Insert mode completion				|ins-completion|
8. Insert mode commands					|inserting|
9. Ex insert commands					|inserting-ex|
10. Inserting a file					|inserting-file|

Also see 'virtualedit', for moving the cursor to positions where there is no
character.  Useful for editing a table.

==============================================================================
1. Special keys						*ins-special-keys*

In Insert and Replace mode, the following characters have a special meaning;
other characters are inserted directly.  To insert one of these special
characters into the buffer, precede it with CTRL-V.  To insert a <Nul>
character use "CTRL-V CTRL-@" or "CTRL-V 000".  On some systems, you have to
use "CTRL-V 003" to insert a CTRL-C.  Note: When CTRL-V is mapped you can
often use CTRL-Q instead |i_CTRL-Q|.

If you are working in a special language mode when inserting text, see the
'langmap' option, |'langmap'|, on how to avoid switching this mode on and off
all the time.

If you have 'insertmode' set, <Esc> and a few other keys get another meaning.
See |'insertmode'|.

char		action	~
-----------------------------------------------------------------------
						*i_CTRL-[* *i_<Esc>*
<Esc> or CTRL-[	End insert or Replace mode, go back to Normal mode.  Finish
		abbreviation.
		Note: If your <Esc> key is hard to hit on your keyboard, train
		yourself to use CTRL-[.
		If Esc doesn't work and you are using a Mac, try CTRL-Esc.
		Or disable Listening under Accessibility preferences.
						*i_CTRL-C*
CTRL-C		Quit insert mode, go back to Normal mode.  Do not check for
		abbreviations.  Does not trigger the |InsertLeave| autocommand
		event.

						*i_CTRL-@*
CTRL-@		Insert previously inserted text and stop insert.

						*i_CTRL-A*
CTRL-A		Insert previously inserted text.

						*i_CTRL-H* *i_<BS>* *i_BS*
<BS> or CTRL-H	Delete the character before the cursor (see |i_backspacing|
		about joining lines).
						*i_<Del>* *i_DEL*
<Del>		Delete the character under the cursor.  If the cursor is at
		the end of the line, and the 'backspace' option includes
		"eol" (the default), delete the <EOL>; the next line is
		appended after the current one.
						*i_CTRL-W*
CTRL-W		Delete the word before the cursor (see |i_backspacing| about
		joining lines).  See the section "word motions",
		|word-motions|, for the definition of a word.
						*i_CTRL-U*
CTRL-U		Delete all entered characters before the cursor in the current
		line.  If there are no newly entered characters and
		'backspace' is not empty, delete all characters before the
		cursor in the current line.
		See |i_backspacing| about joining lines.
						*i_CTRL-I* *i_<Tab>* *i_Tab*
<Tab> or CTRL-I Insert a tab.  If the 'expandtab' option is on, the
		equivalent number of spaces is inserted (use CTRL-V <Tab> to
		avoid the expansion; use CTRL-Q <Tab> if CTRL-V is mapped
		|i_CTRL-Q|).  See also the 'smarttab' option and
		|ins-expandtab|.
						*i_CTRL-J* *i_<NL>*
<NL> or CTRL-J	Begin new line.
						*i_CTRL-M* *i_<CR>*
<CR> or CTRL-M	Begin new line.
						*i_CTRL-K*
CTRL-K {char1} [char2]
		Enter digraph (see |digraphs|).  When {char1} is a special
		key, the code for that key is inserted in <> form.  For
		example, the string "<S-Space>" can be entered by typing
		<C-K><S-Space> (two keys).  Neither char is considered for
		mapping.

CTRL-N		Find next keyword (see |i_CTRL-N|).
CTRL-P		Find previous keyword (see |i_CTRL-P|).

CTRL-R {0-9a-z"%#*+:.-=}					*i_CTRL-R*
		Insert the contents of a register.  Between typing CTRL-R and
		the second character, '"' will be displayed to indicate that
		you are expected to enter the name of a register.
		The text is inserted as if you typed it, but mappings and
		abbreviations are not used.  If you have options like
		'textwidth', 'formatoptions', or 'autoindent' set, this will
		influence what will be inserted.  This is different from what
		happens with the "p" command and pasting with the mouse.
		Special registers:
			'"'	the unnamed register, containing the text of
				the last delete or yank
			'%'	the current file name
			'#'	the alternate file name
			'*'	the clipboard contents (X11: primary selection)
			'+'	the clipboard contents
			'/'	the last search pattern
			':'	the last command-line
			'.'	the last inserted text
			'-'	the last small (less than a line) delete
							*i_CTRL-R_=*
			'='	the expression register: you are prompted to
				enter an expression (see |expression|)
				Note that 0x80 (128 decimal) is used for
				special keys.  E.g., you can use this to move
				the cursor up:
					CTRL-R ="\<Up>"
				Use CTRL-R CTRL-R to insert text literally.
				When the result is a |List| the items are used
				as lines.  They can have line breaks inside
				too.
				When the result is a Float it's automatically
				converted to a String.
				When append() or setline() is invoked the undo
				sequence will be broken.
		See |registers| about registers.

CTRL-R CTRL-R {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-R*
		Insert the contents of a register.  Works like using a single
		CTRL-R, but the text is inserted literally, not as if typed.
		This differs when the register contains characters like <BS>.
		Example, where register a contains "ab^Hc": >
	CTRL-R a		results in "ac".
	CTRL-R CTRL-R a		results in "ab^Hc".
<		Options 'textwidth', 'formatoptions', etc. still apply.  If
		you also want to avoid these, use CTRL-R CTRL-O, see below.
		The '.' register (last inserted text) is still inserted as
		typed.

CTRL-R CTRL-O {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-O*
		Insert the contents of a register literally and don't
		auto-indent.  Does the same as pasting with the mouse
		|<MiddleMouse>|.
		Does not replace characters!
		The '.' register (last inserted text) is still inserted as
		typed.

CTRL-R CTRL-P {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-P*
		Insert the contents of a register literally and fix the
		indent, like |[<MiddleMouse>|.
		Does not replace characters!
		The '.' register (last inserted text) is still inserted as
		typed.

						*i_CTRL-T*
CTRL-T		Insert one shiftwidth of indent at the start of the current
		line.  The indent is always rounded to a 'shiftwidth'.
						*i_CTRL-D*
CTRL-D		Delete one shiftwidth of indent at the start of the current
		line.  The indent is always rounded to a 'shiftwidth'.

						*i_0_CTRL-D*
0 CTRL-D	Delete all indent in the current line.

						*i_^_CTRL-D*
^ CTRL-D	Delete all indent in the current line.  The indent is
		restored in the next line.  This is useful when inserting a
		label.

						*i_CTRL-V*
CTRL-V		Insert next non-digit literally.  For special keys, the
		terminal code is inserted.  It's also possible to enter the
		decimal, octal or hexadecimal value of a character
		|i_CTRL-V_digit|.
		The characters typed right after CTRL-V are not considered for
		mapping.
		Note: When CTRL-V is mapped (e.g., to paste text) you can
		often use CTRL-Q instead |i_CTRL-Q|.

						*i_CTRL-Q*
CTRL-Q		Same as CTRL-V.
		Note: Some terminal connections may eat CTRL-Q, it doesn't
		work then.  It does work in the GUI.

CTRL-X		Enter CTRL-X mode.  This is a sub-mode where commands can
		be given to complete words or scroll the window.  See
		|i_CTRL-X| and |ins-completion|.

						*i_CTRL-E*
CTRL-E		Insert the character which is below the cursor.
						*i_CTRL-Y*
CTRL-Y		Insert the character which is above the cursor.
		Note that for CTRL-E and CTRL-Y 'textwidth' is not used, to be
		able to copy characters from a long line.

						*i_CTRL-_*
CTRL-_		Switch between languages, as follows:
		-  When in a rightleft window, revins and nohkmap are toggled,
		   since English will likely be inserted in this case.
		-  When in a norightleft window, revins and hkmap are toggled,
		   since Hebrew will likely be inserted in this case.

		CTRL-_ moves the cursor to the end of the typed text.

		This command is only available when the 'allowrevins' option
		is set.
		Please refer to |rileft.txt| for more information about
		right-to-left mode.

						*i_CTRL-^*
CTRL-^		Toggle the use of typing language characters.
		When language |:lmap| mappings are defined:
		- If 'iminsert' is 1 (langmap mappings used) it becomes 0 (no
		  langmap mappings used).
		- If 'iminsert' has another value it becomes 1, thus langmap
		  mappings are enabled.
		When no language mappings are defined:
		- If 'iminsert' is 2 (Input Method used) it becomes 0 (no
		  Input Method used).
		- If 'iminsert' has another value it becomes 2, thus the Input
		  Method is enabled.
		When set to 1, the value of the "b:keymap_name" variable, the
		'keymap' option or "<lang>" appears in the status line.
		The language mappings are normally used to type characters
		that are different from what the keyboard produces.  The
		'keymap' option can be used to install a whole number of them.

						*i_CTRL-]*
CTRL-]		Trigger abbreviation, without inserting a character.

						*i_<Insert>*
<Insert>	Toggle between Insert and Replace mode.
-----------------------------------------------------------------------

						*i_backspacing*
The effect of the <BS>, CTRL-W, and CTRL-U depend on the 'backspace' option
(unless 'revins' is set).  This is a comma separated list of items:

item	    action ~
indent	    allow backspacing over autoindent
eol	    allow backspacing over end-of-line (join lines)
start	    allow backspacing over the start position of insert; CTRL-W and
	    CTRL-U stop once at the start position

When 'backspace' is empty, Vi compatible backspacing is used.  You cannot
backspace over autoindent, before column 1 or before where insert started.

For backwards compatibility the values "0", "1" and "2" are also allowed, see
|'backspace'|.

If the 'backspace' option does contain "eol" and the cursor is in column 1
when one of the three keys is used, the current line is joined with the
previous line.  This effectively deletes the <EOL> in front of the cursor.

						*i_CTRL-V_digit*
With CTRL-V the decimal, octal or hexadecimal value of a character can be
entered directly.  This way you can enter any character, except a line break
(<NL>, value 10).  There are five ways to enter the character value:

first char	mode	     max nr of chars   max value ~
(none)		decimal		   3		255
o or O		octal		   3		377	 (255)
x or X		hexadecimal	   2		ff	 (255)
u		hexadecimal	   4		ffff	 (65535)
U		hexadecimal	   8		7fffffff (2147483647)

Normally you would type the maximum number of characters.  Thus to enter a
space (value 32) you would type <C-V>032.  You can omit the leading zero, in
which case the character typed after the number must be a non-digit.  This
happens for the other modes as well: As soon as you type a character that is
invalid for the mode, the value before it will be used and the "invalid"
character is dealt with in the normal way.

If you enter a value of 10, it will end up in the file as a 0.  The 10 is a
<NL>, which is used internally to represent the <Nul> character.  When writing
the buffer to a file, the <NL> character is translated into <Nul>.  The <NL>
character is written at the end of each line.  Thus if you want to insert a
<NL> character in a file you will have to make a line break.

						*i_CTRL-X* *insert_expand*
CTRL-X enters a sub-mode where several commands can be used.  Most of these
commands do keyword completion; see |ins-completion|.  These are not available
when Vim was compiled without the |+insert_expand| feature.

Two commands can be used to scroll the window up or down, without exiting
insert mode:

						*i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		scroll window one line up.
			When doing completion look here: |complete_CTRL-E|

						*i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		scroll window one line down.
			When doing completion look here: |complete_CTRL-Y|

After CTRL-X is pressed, each CTRL-E (CTRL-Y) scrolls the window up (down) by
one line unless that would cause the cursor to move from its current position
in the file.  As soon as another key is pressed, CTRL-X mode is exited and
that key is interpreted as in Insert mode.


==============================================================================
2. Special special keys				*ins-special-special*

The following keys are special.  They stop the current insert, do something,
and then restart insertion.  This means you can do something without getting
out of Insert mode.  This is very handy if you prefer to use the Insert mode
all the time, just like editors that don't have a separate Normal mode.  You
may also want to set the 'insertmode' option.  You can use CTRL-O if you want
to map a function key to a command.

The changes (inserted or deleted characters) before and after these keys can
be undone separately.  Only the last change can be redone and always behaves
like an "i" command.

char		action	~
-----------------------------------------------------------------------
<Up>		cursor one line up			     *i_<Up>*
<Down>		cursor one line down			     *i_<Down>*
CTRL-G <Up>	cursor one line up, insert start column	     *i_CTRL-G_<Up>*
CTRL-G k	cursor one line up, insert start column	     *i_CTRL-G_k*
CTRL-G CTRL-K	cursor one line up, insert start column	     *i_CTRL-G_CTRL-K*
CTRL-G <Down>	cursor one line down, insert start column    *i_CTRL-G_<Down>*
CTRL-G j	cursor one line down, insert start column    *i_CTRL-G_j*
CTRL-G CTRL-J	cursor one line down, insert start column    *i_CTRL-G_CTRL-J*
<Left>		cursor one character left		     *i_<Left>*
<Right>		cursor one character right		     *i_<Right>*
<S-Left>	cursor one word back (like "b" command)	     *i_<S-Left>*
<C-Left>	cursor one word back (like "b" command)	     *i_<C-Left>*
<S-Right>	cursor one word forward (like "w" command)   *i_<S-Right>*
<C-Right>	cursor one word forward (like "w" command)   *i_<C-Right>*
<Home>		cursor to first char in the line	     *i_<Home>*
<End>		cursor to after last char in the line	     *i_<End>*
<C-Home>	cursor to first char in the file	     *i_<C-Home>*
<C-End>		cursor to after last char in the file	     *i_<C-End>*
<LeftMouse>	cursor to position of mouse click	     *i_<LeftMouse>*
<S-Up>		move window one page up			     *i_<S-Up>*
<PageUp>	move window one page up			     *i_<PageUp>*
<S-Down>	move window one page down		     *i_<S-Down>*
<PageDown>	move window one page down		     *i_<PageDown>*
<ScrollWheelDown>    move window three lines down	*i_<ScrollWheelDown>*
<S-ScrollWheelDown>  move window one page down		*i_<S-ScrollWheelDown>*
<ScrollWheelUp>      move window three lines up		*i_<ScrollWheelUp>*
<S-ScrollWheelUp>    move window one page up		*i_<S-ScrollWheelUp>*
<ScrollWheelLeft>    move window six columns left	*i_<ScrollWheelLeft>*
<S-ScrollWheelLeft>  move window one page left		*i_<S-ScrollWheelLeft>*
<ScrollWheelRight>   move window six columns right	*i_<ScrollWheelRight>*
<S-ScrollWheelRight> move window one page right		*i_<S-ScrollWheelRight>*
CTRL-O		execute one command, return to Insert mode   *i_CTRL-O*
CTRL-\ CTRL-O	like CTRL-O but don't move the cursor	     *i_CTRL-\_CTRL-O*
CTRL-L		when 'insertmode' is set: go to Normal mode  *i_CTRL-L*
CTRL-G u	break undo sequence, start new change	     *i_CTRL-G_u*
CTRL-G U	don't break undo with next left/right cursor *i_CTRL-G_U*
		movement (but only if the cursor stays
		within same the line)
-----------------------------------------------------------------------

Note: If the cursor keys take you out of Insert mode, check the 'noesckeys'
option.

The CTRL-O command sometimes has a side effect: If the cursor was beyond the
end of the line, it will be put on the last character in the line.  In
mappings it's often better to use <Esc> (first put an "x" in the text, <Esc>
will then always put the cursor on it).  Or use CTRL-\ CTRL-O, but then
beware of the cursor possibly being beyond the end of the line.  Note that the
command following CTRL-\ CTRL-O can still move the cursor, it is not restored
to its original position.

The CTRL-O command takes you to Normal mode.  If you then use a command enter
Insert mode again it normally doesn't nest.  Thus when typing "a<C-O>a" and
then <Esc> takes you back to Normal mode, you do not need to type <Esc> twice.
An exception is when not typing the command, e.g. when executing a mapping or
sourcing a script.  This makes mappings work that briefly switch to Insert
mode.

The shifted cursor keys are not available on all terminals.

Another side effect is that a count specified before the "i" or "a" command is
ignored.  That is because repeating the effect of the command after CTRL-O is
too complicated.

An example for using CTRL-G u: >

	:inoremap <C-H> <C-G>u<C-H>

This redefines the backspace key to start a new undo sequence.  You can now
undo the effect of the backspace key, without changing what you typed before
that, with CTRL-O u.  Another example: >

	:inoremap <CR> <C-]><C-G>u<CR>

This breaks undo at each line break.  It also expands abbreviations before
this.

An example for using CTRL-G U: >

	inoremap <Left>  <C-G>U<Left>
	inoremap <Right> <C-G>U<Right>
	inoremap <expr> <Home> col('.') == match(getline('.'), '\S') + 1 ?
	 \ repeat('<C-G>U<Left>', col('.') - 1) :
	 \ (col('.') < match(getline('.'), '\S') ?
	 \     repeat('<C-G>U<Right>', match(getline('.'), '\S') + 0) :
	 \     repeat('<C-G>U<Left>', col('.') - 1 - match(getline('.'), '\S')))
	inoremap <expr> <End> repeat('<C-G>U<Right>', col('$') - col('.'))
	inoremap ( ()<C-G>U<Left>

This makes it possible to use the cursor keys in Insert mode, without breaking
the undo sequence and therefore using |.| (redo) will work as expected. 
Also entering a text like (with the "(" mapping from above): >

   Lorem ipsum (dolor

will be repeatable by the |.|to the expected

   Lorem ipsum (dolor)


Using CTRL-O splits undo: the text typed before and after it is undone
separately.  If you want to avoid this (e.g., in a mapping) you might be able
to use CTRL-R = |i_CTRL-R|.  E.g., to call a function: >
	:imap <F2> <C-R>=MyFunc()<CR>

When the 'whichwrap' option is set appropriately, the <Left> and <Right>
keys on the first/last character in the line make the cursor wrap to the
previous/next line.

The CTRL-G j and CTRL-G k commands can be used to insert text in front of a
column.  Example: >
   int i;
   int j;
Position the cursor on the first "int", type "istatic <C-G>j       ".  The
result is: >
   static int i;
	  int j;
When inserting the same text in front of the column in every line, use the
Visual blockwise command "I" |v_b_I|.

==============================================================================
3. 'textwidth' and 'wrapmargin' options			*ins-textwidth*

The 'textwidth' option can be used to automatically break a line before it
gets too long.  Set the 'textwidth' option to the desired maximum line
length.  If you then type more characters (not spaces or tabs), the
last word will be put on a new line (unless it is the only word on the
line).  If you set 'textwidth' to 0, this feature is disabled.

The 'wrapmargin' option does almost the same.  The difference is that
'textwidth' has a fixed width while 'wrapmargin' depends on the width of the
screen.  When using 'wrapmargin' this is equal to using 'textwidth' with a
value equal to (columns - 'wrapmargin'), where columns is the width of the
screen.

When 'textwidth' and 'wrapmargin' are both set, 'textwidth' is used.

If you don't really want to break the line, but view the line wrapped at a
convenient place, see the 'linebreak' option.

The line is only broken automatically when using Insert mode, or when
appending to a line.  When in replace mode and the line length is not
changed, the line will not be broken.

Long lines are broken if you enter a non-white character after the margin.
The situations where a line will be broken can be restricted by adding
characters to the 'formatoptions' option:
"l"  Only break a line if it was not longer than 'textwidth' when the insert
     started.
"v"  Only break at a white character that has been entered during the
     current insert command.  This is mostly Vi-compatible.
"lv" Only break if the line was not longer than 'textwidth' when the insert
     started and only at a white character that has been entered during the
     current insert command.  Only differs from "l" when entering non-white
     characters while crossing the 'textwidth' boundary.

Normally an internal function will be used to decide where to break the line.
If you want to do it in a different way set the 'formatexpr' option to an
expression that will take care of the line break.

If you want to format a block of text, you can use the "gq" operator.  Type
"gq" and a movement command to move the cursor to the end of the block.  In
many cases, the command "gq}" will do what you want (format until the end of
paragraph).  Alternatively, you can use "gqap", which will format the whole
paragraph, no matter where the cursor currently is.  Or you can use Visual
mode: hit "v", move to the end of the block, and type "gq".  See also |gq|.

==============================================================================
4. 'expandtab', 'smarttab' and 'softtabstop' options	*ins-expandtab*

If the 'expandtab' option is on, spaces will be used to fill the amount of
whitespace of the tab.  If you want to enter a real <Tab>, type CTRL-V first
(use CTRL-Q when CTRL-V is mapped |i_CTRL-Q|).
The 'expandtab' option is off by default.  Note that in Replace mode, a single
character is replaced with several spaces.  The result of this is that the
number of characters in the line increases.  Backspacing will delete one
space at a time.  The original character will be put back for only one space
that you backspace over (the last one).

							*ins-smarttab*
When the 'smarttab' option is on, a <Tab> inserts 'shiftwidth' positions at
the beginning of a line and 'tabstop' positions in other places.  This means
that often spaces instead of a <Tab> character are inserted.  When 'smarttab'
is off, a <Tab> always inserts 'tabstop' positions, and 'shiftwidth' is only
used for ">>" and the like.

							*ins-softtabstop*
When the 'softtabstop' option is non-zero, a <Tab> inserts 'softtabstop'
positions, and a <BS> used to delete white space, will delete 'softtabstop'
positions.  This feels like 'tabstop' was set to 'softtabstop', but a real
<Tab> character still takes 'tabstop' positions, so your file will still look
correct when used by other applications.

If 'softtabstop' is non-zero, a <BS> will try to delete as much white space to
move to the previous 'softtabstop' position, except when the previously
inserted character is a space, then it will only delete the character before
the cursor.  Otherwise you cannot always delete a single character before the
cursor.  You will have to delete 'softtabstop' characters first, and then type
extra spaces to get where you want to be.

==============================================================================
5. Replace mode				*Replace* *Replace-mode* *mode-replace*

Enter Replace mode with the "R" command in normal mode.

In Replace mode, one character in the line is deleted for every character you
type.  If there is no character to delete (at the end of the line), the
typed character is appended (as in Insert mode).  Thus the number of
characters in a line stays the same until you get to the end of the line.
If a <NL> is typed, a line break is inserted and no character is deleted.

Be careful with <Tab> characters.  If you type a normal printing character in
its place, the number of characters is still the same, but the number of
columns will become smaller.

If you delete characters in Replace mode (with <BS>, CTRL-W, or CTRL-U), what
happens is that you delete the changes.  The characters that were replaced
are restored.  If you had typed past the existing text, the characters you
added are deleted.  This is effectively a character-at-a-time undo.

If the 'expandtab' option is on, a <Tab> will replace one character with
several spaces.  The result of this is that the number of characters in the
line increases.  Backspacing will delete one space at a time.  The original
character will be put back for only one space that you backspace over (the
last one).

==============================================================================
6. Virtual Replace mode		*vreplace-mode* *Virtual-Replace-mode*

Enter Virtual Replace mode with the "gR" command in normal mode.

Virtual Replace mode is similar to Replace mode, but instead of replacing
actual characters in the file, you are replacing screen real estate, so that
characters further on in the file never appear to move.

So if you type a <Tab> it may replace several normal characters, and if you
type a letter on top of a <Tab> it may not replace anything at all, since the
<Tab> will still line up to the same place as before.

Typing a <NL> still doesn't cause characters later in the file to appear to
move.  The rest of the current line will be replaced by the <NL> (that is,
they are deleted), and replacing continues on the next line.  A new line is
NOT inserted unless you go past the end of the file.

Interesting effects are seen when using CTRL-T and CTRL-D.  The characters
before the cursor are shifted sideways as normal, but characters later in the
line still remain still.  CTRL-T will hide some of the old line under the
shifted characters, but CTRL-D will reveal them again.

As with Replace mode, using <BS> etc will bring back the characters that were
replaced.  This still works in conjunction with 'smartindent', CTRL-T and
CTRL-D, 'expandtab', 'smarttab', 'softtabstop', etc.

In 'list' mode, Virtual Replace mode acts as if it was not in 'list' mode,
unless "L" is in 'cpoptions'.

Note that the only situations for which characters beyond the cursor should
appear to move are in List mode |'list'|, and occasionally when 'wrap' is set
(and the line changes length to become shorter or wider than the width of the
screen).  In other cases spaces may be inserted to avoid following characters
to move.

This mode is very useful for editing <Tab> separated columns in tables, for
entering new data while keeping all the columns aligned.

==============================================================================
7. Insert mode completion				*ins-completion*

In Insert and Replace mode, there are several commands to complete part of a
keyword or line that has been typed.  This is useful if you are using
complicated keywords (e.g., function names with capitals and underscores).

These commands are not available when the |+insert_expand| feature was
disabled at compile time.

Completion can be done for:

1. Whole lines						|i_CTRL-X_CTRL-L|
2. keywords in the current file				|i_CTRL-X_CTRL-N|
3. keywords in 'dictionary'				|i_CTRL-X_CTRL-K|
4. keywords in 'thesaurus', thesaurus-style		|i_CTRL-X_CTRL-T|
5. keywords in the current and included files		|i_CTRL-X_CTRL-I|
6. tags							|i_CTRL-X_CTRL-]|
7. file names						|i_CTRL-X_CTRL-F|
8. definitions or macros				|i_CTRL-X_CTRL-D|
9. Vim command-line					|i_CTRL-X_CTRL-V|
10. User defined completion				|i_CTRL-X_CTRL-U|
11. omni completion					|i_CTRL-X_CTRL-O|
12. Spelling suggestions				|i_CTRL-X_s|
13. keywords in 'complete'				|i_CTRL-N|

All these (except 2) are done in CTRL-X mode.  This is a sub-mode of Insert
and Replace modes.  You enter CTRL-X mode by typing CTRL-X and one of the
CTRL-X commands.  You exit CTRL-X mode by typing a key that is not a valid
CTRL-X mode command.  Valid keys are the CTRL-X command itself, CTRL-N (next),
and CTRL-P (previous).

Also see the 'infercase' option if you want to adjust the case of the match.

							*complete_CTRL-E*
When completion is active you can use CTRL-E to stop it and go back to the
originally typed text.  The CTRL-E will not be inserted.

							*complete_CTRL-Y*
When the popup menu is displayed you can use CTRL-Y to stop completion and
accept the currently selected entry.  The CTRL-Y is not inserted.  Typing a
space, Enter, or some other unprintable character will leave completion mode
and insert that typed character.

When the popup menu is displayed there are a few more special keys, see
|popupmenu-keys|.

Note: The keys that are valid in CTRL-X mode are not mapped.  This allows for
":map ^F ^X^F" to work (where ^F is CTRL-F and ^X is CTRL-X).  The key that
ends CTRL-X mode (any key that is not a valid CTRL-X mode command) is mapped.
Also, when doing completion with 'complete' mappings apply as usual.

Note: While completion is active Insert mode can't be used recursively.
Mappings that somehow invoke ":normal i.." will generate an E523 error.

The following mappings are suggested to make typing the completion commands
a bit easier (although they will hide other commands): >
    :inoremap ^] ^X^]
    :inoremap ^F ^X^F
    :inoremap ^D ^X^D
    :inoremap ^L ^X^L

As a special case, typing CTRL-R to perform register insertion (see
|i_CTRL-R|) will not exit CTRL-X mode.  This is primarily to allow the use of
the '=' register to call some function to determine the next operation.  If
the contents of the register (or result of the '=' register evaluation) are
not valid CTRL-X mode keys, then CTRL-X mode will be exited as if those keys
had been typed.

For example, the following will map <Tab> to either actually insert a <Tab> if
the current line is currently only whitespace, or start/continue a CTRL-N
completion operation: >

	function! CleverTab()
	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
	      return "\<Tab>"
	   else
	      return "\<C-N>"
	   endif
	endfunction
	inoremap <Tab> <C-R>=CleverTab()<CR>



Completing whole lines					*compl-whole-line*

							*i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Search backwards for a line that starts with the
			same characters as those in the current line before
			the cursor.  Indent is ignored.  The matching line is
			inserted in front of the cursor.
			The 'complete' option is used to decide which buffers
			are searched for a match.  Both loaded and unloaded
			buffers are used.
	CTRL-L	or
	CTRL-P		Search backwards for next matching line.  This line
			replaces the previous matching line.

	CTRL-N		Search forward for next matching line.  This line
			replaces the previous matching line.

	CTRL-X CTRL-L	After expanding a line you can additionally get the
			line next to it by typing CTRL-X CTRL-L again, unless
			a double CTRL-X is used.  Only works for loaded
			buffers.

Completing keywords in current file			*compl-current*

							*i_CTRL-X_CTRL-P*
							*i_CTRL-X_CTRL-N*
CTRL-X CTRL-N		Search forwards for words that start with the keyword
			in front of the cursor.  The found keyword is inserted
			in front of the cursor.

CTRL-X CTRL-P		Search backwards for words that start with the keyword
			in front of the cursor.  The found keyword is inserted
			in front of the cursor.

	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.

If there is a keyword in front of the cursor (a name made out of alphabetic
characters and characters in 'iskeyword'), it is used as the search pattern,
with "\<" prepended (meaning: start of a word).  Otherwise "\<\k\k" is used
as search pattern (start of any keyword of at least two characters).

In Replace mode, the number of characters that are replaced depends on the
length of the matched string.  This works like typing the characters of the
matched string in Replace mode.

If there is not a valid keyword character before the cursor, any keyword of
at least two characters is matched.
	e.g., to get:
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	just type:
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);

The search wraps around the end of the file, the value of 'wrapscan' is not
used here.

Multiple repeats of the same completion are skipped; thus a different match
will be inserted at each CTRL-N and CTRL-P (unless there is only one
matching keyword).

Single character matches are never included, as they usually just get in
the way of what you were really after.
	e.g., to get:
		printf("name = %s\n", name);
	just type:
		printf("name = %s\n", n^P);
	or even:
		printf("name = %s\n", ^P);
The 'n' in '\n' is skipped.

After expanding a word, you can use CTRL-X CTRL-P or CTRL-X CTRL-N to get the
word following the expansion in other contexts.  These sequences search for
the text just expanded and further expand by getting an extra word.  This is
useful if you need to repeat a sequence of complicated words.  Although CTRL-P
and CTRL-N look just for strings of at least two characters, CTRL-X CTRL-P and
CTRL-X CTRL-N can be used to expand words of just one character.
	e.g., to get:
		M&eacute;xico
	you can type:
		M^N^P^X^P^X^P
CTRL-N starts the expansion and then CTRL-P takes back the single character
"M", the next two CTRL-X CTRL-P's get the words "&eacute" and ";xico".

If the previous expansion was split, because it got longer than 'textwidth',
then just the text in the current line will be used.

If the match found is at the end of a line, then the first word in the next
line will be inserted and the message "word from next line" displayed, if
this word is accepted the next CTRL-X CTRL-P or CTRL-X CTRL-N will search
for those lines starting with this word.


Completing keywords in 'dictionary'			*compl-dictionary*

							*i_CTRL-X_CTRL-K*
CTRL-X CTRL-K		Search the files given with the 'dictionary' option
			for words that start with the keyword in front of the
			cursor.  This is like CTRL-N, but only the dictionary
			files are searched, not the current file.  The found
			keyword is inserted in front of the cursor.  This
			could potentially be pretty slow, since all matches
			are found before the first match is used.  By default,
			the 'dictionary' option is empty.
			For suggestions where to find a list of words, see the
			'dictionary' option.

	CTRL-K	or
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

							*i_CTRL-X_CTRL-T*
CTRL-X CTRL-T		Works as CTRL-X CTRL-K, but in a special way.  It uses
			the 'thesaurus' option instead of 'dictionary'.  If a
			match is found in the thesaurus file, all the
			remaining words on the same line are included as
			matches, even though they don't complete the word.
			Thus a word can be completely replaced.

			For an example, imagine the 'thesaurus' file has a
			line like this: >
				angry furious mad enraged
<			Placing the cursor after the letters "ang" and typing
			CTRL-X CTRL-T would complete the word "angry";
			subsequent presses would change the word to "furious",
			"mad" etc.
			Other uses include translation between two languages,
			or grouping API functions by keyword.

	CTRL-T	or
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.


Completing keywords in the current and included files	*compl-keyword*

The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		Search for the first keyword in the current and
			included files that starts with the same characters
			as those before the cursor.  The matched keyword is
			inserted in front of the cursor.

	CTRL-N		Search forwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
			Note: CTRL-I is the same as <Tab>, which is likely to
			be typed after a successful completion, therefore
			CTRL-I is not used for searching for the next match.

	CTRL-P		Search backward for previous matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-I	Further use of CTRL-X CTRL-I will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.

Completing tags						*compl-tag*
							*i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same
			characters as before the cursor.  The matching tag is
			inserted in front of the cursor.  Alphabetic
			characters and characters in 'iskeyword' are used
			to decide which characters are included in the tag
			name (same as for a keyword).  See also |CTRL-]|.
			The 'showfulltag' option can be used to add context
			from around the tag definition.
	CTRL-]	or
	CTRL-N		Search forwards for next matching tag.  This tag
			replaces the previous matching tag.

	CTRL-P		Search backward for previous matching tag.  This tag
			replaces the previous matching tag.


Completing file names					*compl-filename*
							*i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the
			same characters as before the cursor.  The matching
			file name is inserted in front of the cursor.
			Alphabetic characters and characters in 'isfname'
			are used to decide which characters are included in
			the file name.  Note: the 'path' option is not used
			here (yet).
	CTRL-F	or
	CTRL-N		Search forwards for next matching file name.  This
			file name replaces the previous matching file name.

	CTRL-P		Search backward for previous matching file name.
			This file name replaces the previous matching file
			name.


Completing definitions or macros			*compl-define*

The 'define' option is used to specify a line that contains a definition.
The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		Search in the current and included files for the
			first definition (or macro) name that starts with
			the same characters as before the cursor.  The found
			definition name is inserted in front of the cursor.
	CTRL-D	or
	CTRL-N		Search forwards for next matching macro name.  This
			macro name replaces the previous matching macro
			name.

	CTRL-P		Search backward for previous matching macro name.
			This macro name replaces the previous matching macro
			name.

	CTRL-X CTRL-D	Further use of CTRL-X CTRL-D will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.


Completing Vim commands					*compl-vim*

Completion is context-sensitive.  It works like on the Command-line.  It
completes an Ex command as well as its arguments.  This is useful when writing
a Vim script.

							*i_CTRL-X_CTRL-V*
CTRL-X CTRL-V		Guess what kind of item is in front of the cursor and
			find the first match for it.
			Note: When CTRL-V is mapped you can often use CTRL-Q
			instead of |i_CTRL-Q|.
	CTRL-V	or
	CTRL-N		Search forwards for next match.  This match replaces
			the previous one.

	CTRL-P		Search backwards for previous match.  This match
			replaces the previous one.

	CTRL-X CTRL-V	Further use of CTRL-X CTRL-V will do the same as
			CTRL-V.  This allows mapping a key to do Vim command
			completion, for example: >
				:imap <Tab> <C-X><C-V>

User defined completion					*compl-function*

Completion is done by a function that can be defined by the user with the
'completefunc' option.  See below for how the function is called and an
example |complete-functions|.

							*i_CTRL-X_CTRL-U*
CTRL-X CTRL-U		Guess what kind of item is in front of the cursor and
			find the first match for it.
	CTRL-U	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.

	CTRL-P		Use the previous match.  This match replaces the
			previous one.


Omni completion						*compl-omni*

Completion is done by a function that can be defined by the user with the
'omnifunc' option.  This is to be used for filetype-specific completion.

See below for how the function is called and an example |complete-functions|.
For remarks about specific filetypes see |compl-omni-filetypes|.
More completion scripts will appear, check www.vim.org.  Currently there is a
first version for C++.

							*i_CTRL-X_CTRL-O*
CTRL-X CTRL-O		Guess what kind of item is in front of the cursor and
			find the first match for it.
	CTRL-O	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.

	CTRL-P		Use the previous match.  This match replaces the
			previous one.


Spelling suggestions					*compl-spelling*

A word before or at the cursor is located and correctly spelled words are
suggested to replace it.  If there is a badly spelled word in the line, before
or under the cursor, the cursor is moved to after it.  Otherwise the word just
before the cursor is used for suggestions, even though it isn't badly spelled.

NOTE: CTRL-S suspends display in many Unix terminals.  Use 's' instead.  Type
CTRL-Q to resume displaying.

						*i_CTRL-X_CTRL-S* *i_CTRL-X_s*
CTRL-X CTRL-S   or
CTRL-X s		Locate the word in front of the cursor and find the
			first spell suggestion for it.
	CTRL-S	or
	CTRL-N		Use the next suggestion.  This replaces the previous
			one.  Note that you can't use 's' here.

	CTRL-P		Use the previous suggestion.  This replaces the
			previous one.


Completing keywords from different sources		*compl-generic*

							*i_CTRL-N*
CTRL-N			Find next match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.

							*i_CTRL-P*
CTRL-P			Find previous match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.

	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.


FUNCTIONS FOR FINDING COMPLETIONS			*complete-functions*

This applies to 'completefunc' and 'omnifunc'.

The function is called in two different ways:
- First the function is called to find the start of the text to be completed.
- Later the function is called to actually find the matches.

On the first invocation the arguments are:
   a:findstart  1
   a:base	empty

The function must return the column where the completion starts.  It must be a
number between zero and the cursor column "col('.')".  This involves looking
at the characters just before the cursor and including those characters that
could be part of the completed item.  The text between this column and the
cursor column will be replaced with the matches.

Special return values:
   -1 If no completion can be done, the completion will be cancelled with an
      error message.
   -2 To cancel silently and stay in completion mode.
   -3 To cancel silently and leave completion mode.

On the second invocation the arguments are:
   a:findstart  0
   a:base	the text with which matches should match; the text that was
		located in the first call (can be empty)

The function must return a List with the matching words.  These matches
usually include the "a:base" text.  When there are no matches return an empty
List.

In order to return more information than the matching words, return a Dict
that contains the List.  The Dict can have these items:
	words		The List of matching words (mandatory).
	refresh		A string to control re-invocation of the function
			(optional).
			The only value currently recognized is "always", the
			effect is that the function is called whenever the
			leading text is changed.
Other items are ignored.

For acting upon end of completion, see the |CompleteDone| autocommand event.

For example, the function can contain this: >
	let matches = ... list of words ...
	return {'words': matches, 'refresh': 'always'}
<
						*complete-items*
Each list item can either be a string or a Dictionary.  When it is a string it
is used as the completion.  When it is a Dictionary it can contain these
items:
	word		the text that will be inserted, mandatory
	abbr		abbreviation of "word"; when not empty it is used in
			the menu instead of "word"
	menu		extra text for the popup menu, displayed after "word"
			or "abbr"
	info		more information about the item, can be displayed in a
			preview window
	kind		single letter indicating the type of completion
	icase		when non-zero case is to be ignored when comparing
			items to be equal; when omitted zero is used, thus
			items that only differ in case are added
	dup		when non-zero this match will be added even when an
			item with the same word is already present.
	empty		when non-zero this match will be added even when it is
			an empty string

All of these except 'icase', 'dup' and 'empty' must be a string.  If an item
does not meet these requirements then an error message is given and further
items in the list are not used.  You can mix string and Dictionary items in
the returned list.

The "menu" item is used in the popup menu and may be truncated, thus it should
be relatively short.  The "info" item can be longer, it will  be displayed in
the preview window when "preview" appears in 'completeopt'.  The "info" item
will also remain displayed after the popup menu has been removed.  This is
useful for function arguments.  Use a single space for "info" to remove
existing text in the preview window.  The size of the preview window is three
lines, but 'previewheight' is used when it has a value of 1 or 2.

The "kind" item uses a single letter to indicate the kind of completion.  This
may be used to show the completion differently (different color or icon).
Currently these types can be used:
	v	variable
	f	function or method
	m	member of a struct or class
	t	typedef
	d	#define or macro

When searching for matches takes some time call |complete_add()| to add each
match to the total list.  These matches should then not appear in the returned
list!  Call |complete_check()| now and then to allow the user to press a key
while still searching for matches.  Stop searching when it returns non-zero.

							*E839* *E840*
The function is allowed to move the cursor, it is restored afterwards.
The function is not allowed to move to another window or delete text.

An example that completes the names of the months: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    let res = []
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' . a:base
		call add(res, m)
	      endif
	    endfor
	    return res
	  endif
	endfun
	set completefunc=CompleteMonths
<
The same, but now pretending searching for matches is slow: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' . a:base
		call complete_add(m)
	      endif
	      sleep 300m	" simulate searching for next match
	      if complete_check()
		break
	      endif
	    endfor
	    return []
	  endif
	endfun
	set completefunc=CompleteMonths
<

INSERT COMPLETION POPUP MENU				*ins-completion-menu*
							*popupmenu-completion*
Vim can display the matches in a simplistic popup menu.

The menu is used when:
- The 'completeopt' option contains "menu" or "menuone".
- The terminal supports at least 8 colors.
- There are at least two matches.  One if "menuone" is used.

The 'pumheight' option can be used to set a maximum height.  The default is to
use all space available.

There are three states:
1. A complete match has been inserted, e.g., after using CTRL-N or CTRL-P.
2. A cursor key has been used to select another match.  The match was not
   inserted then, only the entry in the popup menu is highlighted.
3. Only part of a match has been inserted and characters were typed or the
   backspace key was used.  The list of matches was then adjusted for what is
   in front of the cursor.

You normally start in the first state, with the first match being inserted.
When "longest" is in 'completeopt' and there is more than one match you start
in the third state.

If you select another match, e.g., with CTRL-N or CTRL-P, you go to the first
state.  This doesn't change the list of matches.

When you are back at the original text then you are in the third state.  To
get there right away you can use a mapping that uses CTRL-P right after
starting the completion: >
	:imap <F7> <C-N><C-P>
<
						*popupmenu-keys*
In the first state these keys have a special meaning:
<BS> and CTRL-H   Delete one character, find the matches for the word before
		  the cursor.  This reduces the list of matches, often to one
		  entry, and switches to the second state.
Any non-special character:
		  Stop completion without changing the match and insert the
		  typed character.

In the second and third state these keys have a special meaning:
<BS> and CTRL-H   Delete one character, find the matches for the shorter word
		  before the cursor.  This may find more matches.
CTRL-L		  Add one character from the current match, may reduce the
		  number of matches.
any printable, non-white character:
		  Add this character and reduce the number of matches.

In all three states these can be used:
CTRL-Y		  Yes: Accept the currently selected match and stop completion.
CTRL-E		  End completion, go back to what was there before selecting a
		  match (what was typed or longest common string).
<PageUp>	  Select a match several entries back, but don't insert it.
<PageDown>	  Select a match several entries further, but don't insert it.
<Up>		  Select the previous match, as if CTRL-P was used, but don't
		  insert it.
<Down>		  Select the next match, as if CTRL-N was used, but don't
		  insert it.
<Space> or <Tab>  Stop completion without changing the match and insert the
		  typed character.

The behavior of the <Enter> key depends on the state you are in:
first state:	  Use the text as it is and insert a line break.
second state:	  Insert the currently selected match.
third state:	  Use the text as it is and insert a line break.

In other words: If you used the cursor keys to select another entry in the
list of matches then the <Enter> key inserts that match.  If you typed
something else then <Enter> inserts a line break.


The colors of the menu can be changed with these highlight groups:
Pmenu		normal item  |hl-Pmenu|
PmenuSel	selected item  |hl-PmenuSel|
PmenuSbar	scrollbar  |hl-PmenuSbar|
PmenuThumb	thumb of the scrollbar  |hl-PmenuThumb|

There are no special mappings for when the popup menu is visible.  However,
you can use an Insert mode mapping that checks the |pumvisible()| function to
do something different.  Example: >
	:inoremap <Down> <C-R>=pumvisible() ? "\<lt>C-N>" : "\<lt>Down>"<CR>

You can use of <expr> in mapping to have the popup menu used when typing a
character and some condition is met.  For example, for typing a dot: >
	inoremap <expr> . MayComplete()
	func MayComplete()
	    if (can complete)
	      return ".\<C-X>\<C-O>"
	    endif
	    return '.'
	endfunc

See |:map-<expr>| for more info.


FILETYPE-SPECIFIC REMARKS FOR OMNI COMPLETION	    *compl-omni-filetypes*

The file used for {filetype} should be autoload/{filetype}complete.vim
in 'runtimepath'.  Thus for "java" it is autoload/javacomplete.vim.


C							*ft-c-omni*

Completion of C code requires a tags file.  You should use Exuberant ctags,
because it adds extra information that is needed for completion.  You can find
it here: http://ctags.sourceforge.net/  Version 5.6 or later is recommended.

For version 5.5.4 you should add a patch that adds the "typename:" field:
	ftp://ftp.vim.org/pub/vim/unstable/patches/ctags-5.5.4.patch
A compiled .exe for MS-Windows can be found at:
	http://georgevreilly.com/vim/ctags.html

If you want to complete system functions you can do something like this.  Use
ctags to generate a tags file for all the system header files: >
	% ctags -R -f ~/.config/nvim/systags /usr/include /usr/local/include
In your vimrc file add this tags file to the 'tags' option: >
	set tags+=~/.config/nvim/systags

When using CTRL-X CTRL-O after a name without any "." or "->" it is completed
from the tags file directly.  This works for any identifier, also function
names.  If you want to complete a local variable name, which does not appear
in the tags file, use CTRL-P instead.

When using CTRL-X CTRL-O after something that has "." or "->" Vim will attempt
to recognize the type of the variable and figure out what members it has.
This means only members valid for the variable will be listed.

When a member name already was complete, CTRL-X CTRL-O will add a "." or
"->" for composite types.

Vim doesn't include a C compiler, only the most obviously formatted
declarations are recognized.  Preprocessor stuff may cause confusion.
When the same structure name appears in multiple places all possible members
are included.


CSS							*ft-css-omni*

Complete properties and their appropriate values according to CSS 2.1
specification.


HTML							*ft-html-omni*
XHTML							*ft-xhtml-omni*

CTRL-X CTRL-O provides completion of various elements of (X)HTML files.  It is
designed to support writing of XHTML 1.0 Strict files but will also work for
other versions of HTML. Features:

- after "<" complete tag name depending on context (no div suggestion inside
  of an a tag); '/>' indicates empty tags
- inside of tag complete proper attributes (no width attribute for an a tag);
  show also type of attribute; '*' indicates required attributes
- when attribute has limited number of possible values help to complete them
- complete names of entities
- complete values of "class" and "id" attributes with data obtained from
  <style> tag and included CSS files
- when completing value of "style" attribute or working inside of "style" tag
  switch to |ft-css-omni| completion
- when completing values of events attributes or working inside of "script"
  tag switch to |ft-javascript-omni| completion
- when used after "</" CTRL-X CTRL-O will close the last opened tag

Note: When used first time completion menu will be shown with little delay
- this is time needed for loading of data file.
Note: Completion may fail in badly formatted documents. In such case try to
run |:make| command to detect formatting problems.


HTML flavor						*html-flavor*

The default HTML completion depends on the filetype.  For HTML files it is
HTML 4.01 Transitional ('filetype' is "html"), for XHTML it is XHTML 1.0
Strict ('filetype' is "xhtml").

When doing completion outside of any other tag you will have possibility to
choose DOCTYPE and the appropriate data file will be loaded and used for all
next completions.

More about format of data file in |xml-omni-datafile|. Some of the data files
may be found on the Vim website (|www|).

Note that b:html_omni_flavor may point to a file with any XML data.  This
makes possible to mix PHP (|ft-php-omni|) completion with any XML dialect
(assuming you have data file for it).  Without setting that variable XHTML 1.0
Strict will be used.


JAVASCRIPT					       *ft-javascript-omni*

Completion of most elements of JavaScript language and DOM elements.

Complete:

- variables
- function name; show function arguments
- function arguments
- properties of variables trying to detect type of variable
- complete DOM objects and properties depending on context
- keywords of language

Completion works in separate JavaScript files (&ft==javascript), inside of
<script> tag of (X)HTML and in values of event attributes (including scanning
of external files).

DOM compatibility

At the moment (beginning of 2006) there are two main browsers - MS Internet
Explorer and Mozilla Firefox. These two applications are covering over 90% of
market. Theoretically standards are created by W3C organisation
(http://www.w3c.org) but they are not always followed/implemented.

		IE	FF	W3C  Omni completion ~
		+/-	+/-	+    +		     ~
		+	+	-    +		     ~
		+	-	-    -		     ~
		-	+	-    -		     ~

Regardless from state of implementation in browsers but if element is defined
in standards, completion plugin will place element in suggestion list. When
both major engines implemented element, even if this is not in standards it
will be suggested. All other elements are not placed in suggestion list.


PHP							*ft-php-omni*

Completion of PHP code requires a tags file for completion of data from
external files and for class aware completion. You should use Exuberant ctags
version 5.5.4 or newer. You can find it here: http://ctags.sourceforge.net/

Script completes:

- after $ variables name
  - if variable was declared as object add "->", if tags file is available show
    name of class
  - after "->" complete only function and variable names specific for given
    class. To find class location and contents tags file is required. Because
    PHP isn't strongly typed language user can use @var tag to declare class: >

	/* @var $myVar myClass */
	$myVar->
<
    Still, to find myClass contents tags file is required.

- function names with additional info:
  - in case of built-in functions list of possible arguments and after | type
    data returned by function
  - in case of user function arguments and name of file where function was
    defined (if it is not current file)

- constants names
- class names after "new" declaration


Note: when doing completion first time Vim will load all necessary data into
memory. It may take several seconds. After next use of completion delay
should not be noticeable.

Script detects if cursor is inside <?php ?> tags. If it is outside it will
automatically switch to HTML/CSS/JavaScript completion. Note: contrary to
original HTML files completion of tags (and only tags) isn't context aware.


RUBY						 *ft-ruby-omni* {Nvim}

NOTE: |compl-omni| for Ruby code requires |provider-ruby| to be installed.

Ruby completion will parse your buffer on demand in order to provide a list of
completions.  These completions will be drawn from modules loaded by 'require'
and modules defined in the current buffer.

The completions provided by CTRL-X CTRL-O are sensitive to the context:

	  CONTEXT			   COMPLETIONS PROVIDED ~

 1. Not inside a class definition    Classes, constants and globals

 2. Inside a class definition	     Methods or constants defined in the class

 3. After '.', '::' or ':'	     Methods applicable to the object being
				       dereferenced

 4. After ':' or ':foo'		     Symbol name (beginning with 'foo')

Notes:
 - Vim will load/evaluate code in order to provide completions.  This may
   cause some code execution, which may be a concern. This is no longer
   enabled by default, to enable this feature add >
     let g:rubycomplete_buffer_loading = 1
<- In context 1 above, Vim can parse the entire buffer to add a list of
   classes to the completion results. This feature is turned off by default,
   to enable it add >
     let g:rubycomplete_classes_in_global = 1
<  to your vimrc
 - In context 2 above, anonymous classes are not supported.
 - In context 3 above, Vim will attempt to determine the methods supported by
   the object.
 - Vim can detect and load the Rails environment for files within a rails
   project. The feature is disabled by default, to enable it add >
     let g:rubycomplete_rails = 1
<  to your vimrc


SYNTAX							*ft-syntax-omni*

Vim has the ability to color syntax highlight nearly 500 languages.  Part of
this highlighting includes knowing what keywords are part of a language.  Many
filetypes already have custom completion scripts written for them, the
syntaxcomplete plugin provides basic completion for all other filetypes.  It
does this by populating the omni completion list with the text Vim already
knows how to color highlight.  It can be used for any filetype and provides a
minimal language-sensitive completion.

To enable syntax code completion you can run: >
    setlocal omnifunc=syntaxcomplete#Complete

You can automate this by placing the following in your |init.vim| (after any
":filetype" command): >
    if has("autocmd") && exists("+omnifunc")
	autocmd Filetype *
		    \	if &omnifunc == "" |
		    \		setlocal omnifunc=syntaxcomplete#Complete |
		    \	endif
    endif

The above will set completion to this script only if a specific plugin does
not already exist for that filetype.

Each filetype can have a wide range of syntax items.  The plugin allows you to
customize which syntax groups to include or exclude from the list.  Let's have
a look at the PHP filetype to see how this works.

If you edit a file called, index.php, run the following command: >
    syntax list

The first thing you will notice is that there are many different syntax groups.
The PHP language can include elements from different languages like HTML,
JavaScript and many more.  The syntax plugin will only include syntax groups
that begin with the filetype, "php", in this case.  For example these syntax
groups are included by default with the PHP: phpEnvVar, phpIntVar,
phpFunctions.

If you wish non-filetype syntax items to also be included, you can use a 
regular expression syntax (added in version 13.0 of autoload\syntaxcomplete.vim)
to add items.  Looking at the output from ":syntax list" while editing a PHP file 
I can see some of these entries: >
    htmlArg,htmlTag,htmlTagName,javaScriptStatement,javaScriptGlobalObjects

To pick up any JavaScript and HTML keyword syntax groups while editing a PHP
file, you can use 3 different regexs, one for each language.  Or you can 
simply restrict the include groups to a particular value, without using 
a regex string: >
    let g:omni_syntax_group_include_php = 'php\w\+,javaScript\w\+,html\w\+'
    let g:omni_syntax_group_include_php = 'phpFunctions,phpMethods'
<
The basic form of this variable is: >
    let g:omni_syntax_group_include_{filetype} = 'regex,comma,separated'

The PHP language has an enormous number of items which it knows how to syntax
highlight.  These items will be available within the omni completion list.

Some people may find this list unwieldy or are only interested in certain
items.  There are two ways to prune this list (if necessary).  If you find
certain syntax groups you do not wish displayed you can use two different 
methods to identify these groups.  The first specifically lists the syntax 
groups by name.  The second uses a regular expression to identify both 
syntax groups.  Simply add one the following to your vimrc: >
    let g:omni_syntax_group_exclude_php = 'phpCoreConstant,phpConstant'
    let g:omni_syntax_group_exclude_php = 'php\w*Constant'

Add as many syntax groups to this list by comma separating them.  The basic
form of this variable is: >
    let g:omni_syntax_group_exclude_{filetype} = 'regex,comma,separated'

You can create as many of these variables as you need, varying only the
filetype at the end of the variable name.

The plugin uses the isKeyword option to determine where word boundaries are
for the syntax items.  For example, in the Scheme language completion should
include the "-", call-with-output-file.  Depending on your filetype, this may
not provide the words you are expecting.  Setting the
g:omni_syntax_use_iskeyword option to 0 will force the syntax plugin to break
on word characters.   This can be controlled adding the following to your
vimrc: >
    let g:omni_syntax_use_iskeyword = 0

For plugin developers, the plugin exposes a public function OmniSyntaxList.
This function can be used to request a List of syntax items.  When editing a
SQL file (:e syntax.sql) you can use the ":syntax list" command to see the 
various groups and syntax items.  For example: >
    syntax list 

Yields data similar to this: >
    sqlOperator    xxx some prior all like and any escape exists in is not 
                       or intersect minus between distinct
                       links to Operator
    sqlType        xxx varbit varchar nvarchar bigint int uniqueidentifier 
                       date money long tinyint unsigned xml text smalldate 
                       double datetime nchar smallint numeric time bit char 
                       varbinary binary smallmoney
                       image float integer timestamp real decimal

There are two syntax groups listed here: sqlOperator and sqlType.  To retrieve
a List of syntax items you can call OmniSyntaxList a number of different 
ways.  To retrieve all syntax items regardless of syntax group:  >
    echo OmniSyntaxList( [] )

To retrieve only the syntax items for the sqlOperator syntax group: >
    echo OmniSyntaxList( ['sqlOperator'] )

To retrieve all syntax items for both the sqlOperator and sqlType groups: >
    echo OmniSyntaxList( ['sqlOperator', 'sqlType'] )

A regular expression can also be used: >
    echo OmniSyntaxList( ['sql\w\+'] )

From within a plugin, you would typically assign the output to a List: >
    let myKeywords = []
    let myKeywords = OmniSyntaxList( ['sqlKeyword'] )

    

SQL							*ft-sql-omni*

Completion for the SQL language includes statements, functions, keywords.
It will also dynamically complete tables, procedures, views and column lists
with data pulled directly from within a database.  For detailed instructions
and a tutorial see |omni-sql-completion|.

The SQL completion plugin can be used in conjunction with other completion
plugins.  For example, the PHP filetype has its own completion plugin.
Since PHP is often used to generate dynamic website by accessing a database,
the SQL completion plugin can also be enabled.  This allows you to complete
PHP code and SQL code at the same time.


XML							*ft-xml-omni*

Vim 7 provides a mechanism for context aware completion of XML files.  It
depends on a special |xml-omni-datafile| and two commands: |:XMLns| and
|:XMLent|.  Features are:

- after "<" complete the tag name, depending on context
- inside of a tag complete proper attributes
- when an attribute has a limited number of possible values help to complete
  them
- complete names of entities (defined in |xml-omni-datafile| and in the
  current file with "<!ENTITY" declarations)
- when used after "</" CTRL-X CTRL-O will close the last opened tag

Format of XML data file					*xml-omni-datafile*

XML data files are stored in the "autoload/xml" directory in 'runtimepath'.
Vim distribution provides examples of data files in the
"$VIMRUNTIME/autoload/xml" directory.  They have a meaningful name which will
be used in commands.  It should be a unique name which will not create
conflicts.  For example, the name xhtml10s.vim means it is the data file for
XHTML 1.0 Strict.

Each file contains a variable with a name like g:xmldata_xhtml10s . It is
a compound from two parts:

1. "g:xmldata_"  general prefix, constant for all data files
2. "xhtml10s"    the name of the file and the name of the described XML
		 dialect; it will be used as an argument for the |:XMLns|
		 command

Part two must be exactly the same as name of file.

The variable is a |Dictionary|.  Keys are tag names and each value is a two
element |List|.  The first element of the List is also a List with the names
of possible children.  The second element is a |Dictionary| with the names of
attributes as keys and the possible values of attributes as values.  Example: >

    let g:xmldata_crippled = {
    \ "vimxmlentities": ["amp", "lt", "gt", "apos", "quot"],
    \ 'vimxmlroot': ['tag1'],
    \ 'tag1':
    \ [ ['childoftag1a', 'childoftag1b'], {'attroftag1a': [],
    \ 'attroftag1b': ['valueofattr1', 'valueofattr2']}],
    \ 'childoftag1a':
    \ [ [], {'attrofchild': ['attrofchild']}],
    \ 'childoftag1b':
    \ [ ['childoftag1a'], {'attrofchild': []}],
    \ "vimxmltaginfo": {
    \ 'tag1': ['Menu info', 'Long information visible in preview window']},
    \ 'vimxmlattrinfo': {
    \ 'attrofchild': ['Menu info', 'Long information visible in preview window']}}

This example would be put in the "autoload/xml/crippled.vim" file and could
help to write this file: >

    <tag1 attroftag1b="valueofattr1">
        <childoftag1a attrofchild>
                &amp; &lt;
        </childoftag1a>
        <childoftag1b attrofchild="5">
            <childoftag1a>
                &gt; &apos; &quot;
            </childoftag1a>
        </childoftag1b>
    </tag1>

In the example four special elements are visible:

1. "vimxmlentities" - a special key with List containing entities of this XML
   dialect.
2. If the list containing possible values of attributes has one element and
   this element is equal to the name of the attribute this attribute will be
   treated as boolean and inserted as 'attrname' and not as 'attrname="'
3. "vimxmltaginfo" - a special key with a Dictionary containing tag
   names as keys and two element List as values, for additional menu info and
   the long description.
4. "vimxmlattrinfo" - special key with Dictionary containing attribute names
   as keys and two element List as values, for additional menu info and long
   description.

Note: Tag names in the data file MUST not contain a namespace description.
Check xsl.vim for an example.
Note: All data and functions are publicly available as global
variables/functions and can be used for personal editing functions.


DTD -> Vim							*dtd2vim*

On |www| is the script |dtd2vim| which parses DTD and creates an XML data file
for Vim XML omni completion.

    dtd2vim: http://www.vim.org/scripts/script.php?script_id=1462

Check the beginning of that file for usage details.
The script requires perl and:

    perlSGML: http://savannah.nongnu.org/projects/perlsgml


Commands

:XMLns {name} [{namespace}]					*:XMLns*

Vim has to know which data file should be used and with which namespace.  For
loading of the data file and connecting data with the proper namespace use
|:XMLns| command.  The first (obligatory) argument is the name of the data
(xhtml10s, xsl).  The second argument is the code of namespace (h, xsl).  When
used without a second argument the dialect will be used as default - without
namespace declaration.  For example to use XML completion in .xsl files: >

	:XMLns xhtml10s
	:XMLns xsl xsl


:XMLent {name}							*:XMLent*

By default entities will be completed from the data file of the default
namespace.  The XMLent command should be used in case when there is no default
namespace: >

	:XMLent xhtml10s

Usage

While used in this situation (after declarations from previous part, | is
cursor position): >

	<|

Will complete to an appropriate XHTML tag, and in this situation: >

	<xsl:|

Will complete to an appropriate XSL tag.


The script xmlcomplete.vim, provided through the |autoload| mechanism,
has the xmlcomplete#GetLastOpenTag() function which can be used in XML files
to get the name of the last open tag (b:unaryTagsStack has to be defined): >

	:echo xmlcomplete#GetLastOpenTag("b:unaryTagsStack")



==============================================================================
8. Insert mode commands					*inserting*

The following commands can be used to insert new text into the buffer.  They
can all be undone and repeated with the "." command.

							*a*
a			Append text after the cursor [count] times.  If the
			cursor is in the first column of an empty line Insert
			starts there.  But not when 'virtualedit' is set!

							*A*
A			Append text at the end of the line [count] times.

<insert>	or				*i* *insert* *<Insert>*
i			Insert text before the cursor [count] times.
			When using CTRL-O in Insert mode |i_CTRL-O| the count
			is not supported.

							*I*
I			Insert text before the first non-blank in the line
			[count] times.
			When the 'H' flag is present in 'cpoptions' and the
			line only contains blanks, insert start just before
			the last blank.

							*gI*
gI			Insert text in column 1 [count] times.

							*gi*
gi			Insert text in the same position as where Insert mode
			was stopped last time in the current buffer.
			This uses the |'^| mark.  It's different from "`^i"
			when the mark is past the end of the line.
			The position is corrected for inserted/deleted lines,
			but NOT for inserted/deleted characters.
			When the |:keepjumps| command modifier is used the |'^|
			mark won't be changed.

							*o*
o			Begin a new line below the cursor and insert text,
			repeat [count] times.
			When the '#' flag is in 'cpoptions' the count is
			ignored.

							*O*
O			Begin a new line above the cursor and insert text,
			repeat [count] times.
			When the '#' flag is in 'cpoptions' the count is
			ignored.

These commands are used to start inserting text.  You can end insert mode with
<Esc>.  See |mode-ins-repl| for the other special characters in Insert mode.
The effect of [count] takes place after Insert mode is exited.

When 'autoindent' is on, the indent for a new line is obtained from the
previous line.  When 'smartindent' or 'cindent' is on, the indent for a line
is automatically adjusted for C programs.

'textwidth' can be set to the maximum width for a line.  When a line becomes
too long when appending characters a line break is automatically inserted.


==============================================================================
9. Ex insert commands					*inserting-ex*

							*:a* *:append*
:{range}a[ppend][!]	Insert several lines of text below the specified
			line.  If the {range} is missing, the text will be
			inserted after the current line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.

							*:i* *:in* *:insert*
:{range}i[nsert][!]	Insert several lines of text above the specified
			line.  If the {range} is missing, the text will be
			inserted before the current line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.

These two commands will keep on asking for lines, until you type a line
containing only a ".".  Watch out for lines starting with a backslash, see
|line-continuation|.

When in Ex mode (see |-e|) a backslash at the end of the line can be used to
insert a NUL character.  To be able to have a line ending in a backslash use
two backslashes.  This means that the number of backslashes is halved, but
only at the end of the line.

NOTE: These commands cannot be used with |:global| or |:vglobal|.
":append" and ":insert" don't work properly in between ":if" and
":endif", ":for" and ":endfor", ":while" and ":endwhile".

							*:start* *:startinsert*
:star[tinsert][!]	Start Insert mode just after executing this command.
			Works like typing "i" in Normal mode.  When the ! is
			included it works like "A", append to the line.
			Otherwise insertion starts at the cursor position.
			Note that when using this command in a function or
			script, the insertion only starts after the function
			or script is finished.
			This command does not work from |:normal|.

							*:stopi* *:stopinsert*
:stopi[nsert]		Stop Insert mode as soon as possible.  Works like
			typing <Esc> in Insert mode.
			Can be used in an autocommand, example: >
				:au BufEnter scratch stopinsert
<
					*replacing-ex* *:startreplace*
:startr[eplace][!]	Start Replace mode just after executing this command.
			Works just like typing "R" in Normal mode.  When the
			! is included it acts just like "$R" had been typed
			(ie. begin replace mode at the end-of-line).  Other-
			wise replacement begins at the cursor position.
			Note that when using this command in a function or
			script that the replacement will only start after
			the function or script is finished.

							*:startgreplace*
:startg[replace][!]	Just like |:startreplace|, but use Virtual Replace
			mode, like with |gR|.

==============================================================================
10. Inserting a file					*inserting-file*

							*:r* *:re* *:read*
:r[ead] [++opt] [name]
			Insert the file [name] (default: current file) below
			the cursor.
			See |++opt| for the possible values of [++opt].

:{range}r[ead] [++opt] [name]
			Insert the file [name] (default: current file) below
			the specified line.
			See |++opt| for the possible values of [++opt].

							*:r!* *:read!*
:[range]r[ead] [++opt] !{cmd}
			Execute {cmd} and insert its standard output below
			the cursor or the specified line.  A temporary file is
			used to store the output of the command which is then
			read into the buffer.  'shellredir' is used to save
			the output of the command, which can be set to include
			stderr or not.  {cmd} is executed like with ":!{cmd}",
			any '!' is replaced with the previous command |:!|.
			See |++opt| for the possible values of [++opt].

These commands insert the contents of a file, or the output of a command,
into the buffer.  They can be undone.  They cannot be repeated with the "."
command.  They work on a line basis, insertion starts below the line in which
the cursor is, or below the specified line.  To insert text above the first
line use the command ":0r {name}".

After the ":read" command, the cursor is left on the first non-blank in the
first new line.  Unless in Ex mode, then the cursor is left on the last new
line (sorry, this is Vi compatible).

If a file name is given with ":r", it becomes the alternate file.  This can be
used, for example, when you want to edit that file instead: ":e! #".  This can
be switched off by removing the 'a' flag from the 'cpoptions' option.

Of the [++opt] arguments one is specifically for ":read", the ++edit argument.
This is useful when the ":read" command is actually used to read a file into
the buffer as if editing that file.  Use this command in an empty buffer: >
	:read ++edit filename
The effect is that the 'fileformat', 'fileencoding', 'bomb', etc. options are
set to what has been detected for "filename".  Note that a single empty line
remains, you may want to delete it.

							*file-read*
The 'fileformat' option sets the <EOL> style for a file:
'fileformat'    characters	   name				~
  "dos"		<CR><NL> or <NL>   DOS format
  "unix"	<NL>		   Unix format
  "mac"		<CR>		   Mac format

If 'fileformat' is "dos", a <CR> in front of an <NL> is ignored and a CTRL-Z
at the end of the file is ignored.

If 'fileformat' is "mac", a <NL> in the file is internally represented by a
<CR>.  This is to avoid confusion with a <NL> which is used to represent a
<NUL>.  See |CR-used-for-NL|.

If the 'fileformats' option is not empty Vim tries to recognize the type of
<EOL> (see |file-formats|).  However, the 'fileformat' option will not be
changed, the detected format is only used while reading the file.
A similar thing happens with 'fileencodings'.

On non-Windows systems the message "[dos format]" is shown if
a file is read in DOS format, to remind you that something unusual is done.
On Macintosh and Windows the message "[unix format]" is shown if
a file is read in Unix format.
On non-Macintosh systems, the message "[Mac format]" is shown if a file is
read in Mac format.

An example on how to use ":r !": >
	:r !uuencode binfile binfile
This command reads "binfile", uuencodes it and reads it into the current
buffer.  Useful when you are editing e-mail and want to include a binary
file.

							*read-messages*
When reading a file Vim will display a message with information about the read
file.  In the table is an explanation for some of the items.  The others are
self explanatory.  Using the long or the short version depends on the
'shortmess' option.

	long		short		meaning ~
	[readonly]	{RO}		the file is write protected
	[fifo/socket]			using a stream
	[fifo]				using a fifo stream
	[socket]			using a socket stream
	[CR missing]			reading with "dos" 'fileformat' and a
					NL without a preceding CR was found.
	[NL found]			reading with "mac" 'fileformat' and a
					NL was found (could be "unix" format)
	[long lines split]		at least one line was split in two
	[NOT converted]			conversion from 'fileencoding' to
					'encoding' was desired but not
					possible
	[converted]			conversion from 'fileencoding' to
					'encoding' done
	[READ ERRORS]			not all of the file could be read


 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                      *starting.txt*  For Vim version 7.4.  Last change: 2016 Apr 05


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Starting Vim						*starting*

1. Vim arguments		|vim-arguments|
2. Initialization		|initialization|
3. $VIM and $VIMRUNTIME		|$VIM|
4. Suspending			|suspend|
5. Exiting			|exiting|
6. Saving settings		|save-settings|
7. Views and Sessions		|views-sessions|
8. The ShaDa file		|shada-file|
9. Base Directories     	|base-directories|

==============================================================================
1. Vim arguments					*vim-arguments*

Most often, Vim is started to edit a single file with the command

	nvim filename					*-vim*

More generally, Vim is started with:

	nvim [option | filename] ..

Option arguments and file name arguments can be mixed, and any number of them
can be given.  However, watch out for options that take an argument.

Exactly one out of the following five items may be used to choose how to
start editing:

							*-file* *---*
filename	One or more file names.  The first one will be the current
		file and read into the buffer.  The cursor will be positioned
		on the first line of the buffer.
		To avoid a file name starting with a '-' being interpreted as
		an option, precede the arglist with "--", e.g.: >
			nvim -- -filename
<		All arguments after the "--" will be interpreted as file names,
		no other options or "+command" argument can follow.
		For behavior of quotes on MS-Windows, see |win32-quotes|.

							*--*
-		This argument can mean two things, depending on whether Ex
		mode is to be used.

		Starting in Normal mode: >
			nvim -
<		Start editing a new buffer, which is filled with text
		that is read from stdin.  The commands that would normally be
		read from stdin will now be read from stderr.  Example: >
			find . -name "*.c" -print | nvim -
<		The buffer will be marked modified, because it contains text
		that needs to be saved.  Except when in readonly mode, then
		the buffer is not marked modified.  Example: >
			ls | nvim -R -
<		Starting in Ex mode: >
			nvim -e -
			nvim -E
<		Start editing in silent mode.  See |-s-ex|.

							*-t* *-tag*
-t {tag}	A tag.  "tag" is looked up in the tags file, the associated
		file becomes the current file, and the associated command is
		executed.  Mostly this is used for C programs, in which case
		"tag" often is a function name.  The effect is that the file
		containing that function becomes the current file and the
		cursor is positioned on the start of the function (see
		|tags|).

							*-q* *-qf*
-q [errorfile]	QuickFix mode.  The file with the name [errorfile] is read
		and the first error is displayed.  See |quickfix|.
		If [errorfile] is not given, the 'errorfile' option is used
		for the file name.  See 'errorfile' for the default value.

(nothing)	Without one of the four items above, Vim will start editing a
		new buffer.  It's empty and doesn't have a file name.

							*startup-options*
The option arguments may be given in any order.  Single-letter options can be
combined after one dash.  There can be no option arguments after the "--"
argument.

--help							*-h* *--help*
-h		Give usage (help) message and exit.
		See |info-message| about capturing the text.

--version						*-v* *--version*
-v		Print version information and exit.  Same output as for
		|:version| command.
		See |info-message| about capturing the text.

							*--noplugin*
--noplugin	Skip loading plugins.  Resets the 'loadplugins' option.
		Note that the |-u| argument may also disable loading plugins:
			argument	load vimrc files	load plugins ~
			(nothing)		yes		    yes
			-u NONE			no		    no
			-u NORC			no		    yes
			--noplugin		yes		    no

--startuptime {fname}					*--startuptime*
		During startup write timing messages to the file {fname}.
		This can be used to find out where time is spent while loading
		your |init.vim|, plugins and opening the first file.
		When {fname} already exists new messages are appended.
		(Only available when compiled with the |+startuptime|
		feature).

							*--literal*
--literal	Take file names literally, don't expand wildcards.  Not needed
		for Unix, because Vim always takes file names literally (the
		shell expands wildcards).
		Applies to all the names, also the ones that come before this
		argument.

							*-+*
+[num]		The cursor will be positioned on line "num" for the first
		file being edited.  If "num" is missing, the cursor will be
		positioned on the last line.

							*-+/*
+/{pat}		The cursor will be positioned on the first line containing
		"pat" in the first file being edited (see |pattern| for the
		available search patterns).  The search starts at the cursor
		position, which can be the first line or the cursor position
		last used from |shada|. To force a search from the first
		line use "+1 +/pat".

+{command}						*-+c* *-c*
-c {command}	{command} will be executed after the first file has been
		read (and after autocommands and modelines for that file have
		been processed).  "command" is interpreted as an Ex command.
		If the "command" contains spaces, it must be enclosed in
		double quotes (this depends on the shell that is used).
		Example: >
			vim  "+set si"  main.c
			vim  "+find stdio.h"
			vim  -c "set ff=dos"  -c wq  mine.mak
<
		Note: You can use up to 10 "+" or "-c" arguments in a Vim
		command.  They are executed in the order given.  A "-S"
		argument counts as a "-c" argument as well.

--cmd {command}						*--cmd*
		{command} will be executed before processing any vimrc file.
		Otherwise it acts like -c {command}.  You can use up to 10 of
		these commands, independently from "-c" commands.

							*-S*
-S {file}	The {file} will be sourced after the first file has been read.
		This is an easy way to do the equivalent of: >
			-c "source {file}"
<		It can be mixed with "-c" arguments and repeated like "-c".
		The limit of 10 "-c" arguments applies here as well.
		{file} cannot start with a "-".

-S		Works like "-S Session.vim".  Only when used as the last
		argument or when another "-" option follows.

-L							*-L* *-r*
-r		Recovery mode.  Without a file name argument, a list of
		existing swap files is given.  With a file name, a swap file
		is read to recover a crashed editing session.  See
		|crash-recovery|.

							*-R*
-R		Readonly mode.  The 'readonly' option will be set for all the
		files being edited.  You can still edit the buffer, but will
		be prevented from accidentally overwriting a file.  If you
		forgot that you are in View mode and did make some changes,
		you can overwrite a file by adding an exclamation mark to
		the Ex command, as in ":w!".  The 'readonly' option can be
		reset with ":set noro" (see the options chapter, |options|).
		Subsequent edits will not be done in readonly mode.  Calling
		the executable "view" has the same effect as the -R argument.
		The 'updatecount' option will be set to 10000, meaning that
		the swap file will not be updated automatically very often.

							*-m*
-m		Modifications not allowed to be written.  The 'write' option
		will be reset, so that writing files is disabled.  However,
		the 'write' option can be set to enable writing again.

							*-M*
-M		Modifications not allowed.  The 'modifiable' option will be
		reset, so that changes are not allowed.  The 'write' option
		will be reset, so that writing files is disabled.  However,
		the 'modifiable' and 'write' options can be set to enable
		changes and writing.

						*-Z* *restricted-mode* *E145*
-Z		Restricted mode.  All commands that make use of an external
		shell are disabled.  This includes suspending with CTRL-Z,
		":sh", filtering, the system() function, backtick expansion,
		delete(), rename(), mkdir(), writefile(), libcall(),
		jobstart(), etc.

							*-e*
-e		Start Vim in Ex mode |Q|.

							*-E*
-E		Start Vim in improved Ex mode |gQ|.

							*-s-ex*
-s		Silent or batch mode.  Only when "-s" is preceded by the "-e"
		argument.  Otherwise see |-s|, which does take an argument
		while this use of "-s" doesn't.  To be used when Vim is used
		to execute Ex commands from a file instead of a terminal.
		Switches off most prompts and informative messages.  Also
		warnings and error messages.  The output of these commands is
		displayed (to stdout):
			:print
			:list
			:number
			:set      to display option values.
		When 'verbose' is non-zero messages are printed (for
		debugging, to stderr).
		$TERM is not used.
		If Vim appears to be stuck try typing "qa!<Enter>".  You don't
		get a prompt thus you can't see Vim is waiting for you to type
		something.
		Initializations are skipped (except the ones given with the
		"-u" argument).
		Example: >
			vim -e -s  < thefilter  thefile
<
							*-b*
-b		Binary mode.  File I/O will only recognize <NL> to separate
		lines.  The 'expandtab' option will be reset.  The 'textwidth'
		option is set to 0.  'modeline' is reset.  The 'binary' option
		is set.  This is done after reading the init.vim/exrc files 
		but before reading any file in the arglist.  See also
		|edit-binary|.

							*-l*
-l		Lisp mode.  Sets the 'lisp' and 'showmatch' options on.

							*-A*
-A		Arabic mode.  Sets the 'arabic' option on.

							*-F*
-F		Farsi mode.  Sets the 'fkmap' and 'rightleft' options on.

							*-H*
-H		Hebrew mode.  Sets the 'hkmap' and 'rightleft' options on.

							*-V* *verbose*
-V[N]		Verbose.  Sets the 'verbose' option to [N] (default: 10).
		Messages will be given for each file that is ":source"d and
		for reading or writing a ShaDa file.  Can be used to find
		out what is happening upon startup and exit.
		Example: >
			vim -V8 foobar

-V[N]{filename}
		Like -V and set 'verbosefile' to {filename}.  The result is
		that messages are not displayed but written to the file
		{filename}.  {filename} must not start with a digit.
		Example: >
			vim -V20vimlog foobar
<
							*-D*
-D		Debugging.  Go to debugging mode when executing the first
		command from a script. |debug-mode|
		{not available when compiled without the |+eval| feature}

							*-n*
-n		No swap file will be used.  Recovery after a crash will be
		impossible.  Handy if you want to view or edit a file on a
		very slow medium (e.g., a floppy).
		Can also be done with ":set updatecount=0".  You can switch it
		on again by setting the 'updatecount' option to some value,
		e.g., ":set uc=100".
		'updatecount' is set to 0 AFTER executing commands from a
		vimrc file, but before the GUI initializations.  Thus it
		overrides a setting for 'updatecount' in a vimrc file, but not
		in a gvimrc file.  See |startup|.
		When you want to reduce accesses to the disk (e.g., for a
		laptop), don't use "-n", but set 'updatetime' and
		'updatecount' to very big numbers, and type ":preserve" when
		you want to save your work.  This way you keep the possibility
		for crash recovery.

							*-o*
-o[N]		Open N windows, split horizontally.  If [N] is not given,
		one window is opened for every file given as argument.  If
		there is not enough room, only the first few files get a
		window.  If there are more windows than arguments, the last
		few windows will be editing an empty file.

							*-O*
-O[N]		Open N windows, split vertically.  Otherwise it's like -o.
		If both the -o and the -O option are given, the last one on
		the command line determines how the windows will be split.

							*-p*
-p[N]		Open N tab pages.  If [N] is not given, one tab page is opened
		for every file given as argument.  The maximum is set with
		'tabpagemax' pages (default 50).  If there are more tab pages
		than arguments, the last few tab pages will be editing an
		empty file.  Also see |tabpage|.
							*-d*
-d		Start in |diff-mode|.

							*-u* *E282*
-u {vimrc}	The file {vimrc} is read for initializations.  Most other
		initializations are skipped; see |initialization|.  This can
		be used to start Vim in a special mode, with special
		mappings and settings.  A shell alias can be used to make
		this easy to use.  For example: >
			alias vimc vim -u ~/.config/nvim/c_init.vim !*
<		Also consider using autocommands; see |autocommand|.
		When {vimrc} is equal to "NONE" (all uppercase), all
		initializations from files and environment variables are
		skipped, including reading the |ginit.vim| file when the GUI
		starts.  Plugins and syntax highlighting are also skipped.
		When {vimrc} is equal to "NORC" (all uppercase), this has the
		same effect as "NONE", but plugins and syntax highlighting are
		not skipped.

							*-i*
-i {shada}	The file {shada} is used instead of the default ShaDa
		file.  If the name "NONE" is used (all uppercase), no ShaDa
		file is read or written, even if 'shada' is set or when
		":rsh" or ":wsh" are used.  See also |shada-file|.

							*-s*
-s {scriptin}	The script file "scriptin" is read.  The characters in the
		file are interpreted as if you had typed them.  The same can
		be done with the command ":source! {scriptin}".  If the end
		of the file is reached before the editor exits, further
		characters are read from the keyboard.  Only works when not
		started in Ex mode, see |-s-ex|.  See also |complex-repeat|.

							*-w_nr*
-w {number}
-w{number}	Set the 'window' option to {number}.

							*-w*
-w {scriptout}	All the characters that you type are recorded in the file
		"scriptout", until you exit Vim.  This is useful if you want
		to create a script file to be used with "vim -s" or
		":source!".  When the "scriptout" file already exists, new
		characters are appended.  See also |complex-repeat|.
		{scriptout} cannot start with a digit.

							*-W*
-W {scriptout}	Like -w, but do not append, overwrite an existing file.

							*--api-info*
--api-info 	Print msgpack-encoded |api-metadata| and exit.

==============================================================================
2. Initialization				*initialization* *startup*

At startup, Vim checks environment variables and files and sets values
accordingly.  Vim proceeds in this order:

1. Set the 'shell' option		*SHELL* *COMSPEC* *TERM*
	The environment variable SHELL, if it exists, is used to set the
	'shell' option.  On Windows, the COMSPEC variable is used
	if SHELL is not set.

2. Process the arguments
	The options and file names from the command that start Vim are
	inspected.  Buffers are created for all files (but not loaded yet).
	The |-V| argument can be used to display or log what happens next,
	useful for debugging the initializations.

3. Execute Ex commands, from environment variables and/or files
	An environment variable is read as one Ex command line, where multiple
	commands must be separated with '|' or "<NL>".
						    *init.vim* *vimrc* *exrc*
	A file that contains initialization commands is called a "vimrc" file.
	Each line in a vimrc file is executed as an Ex command line.  It is
	sometimes also referred to as "exrc" file.  They are the same type of
	file, but "exrc" is what Vi always used, "vimrc" is a Vim specific
	name, "init.vim" is Neovim specific location for vimrc file.  Also see 
	|vimrc-intro|.

	Places for your personal initializations (see |base-directories|):
		Unix		$XDG_CONFIG_HOME/nvim/init.vim
				(default for $XDG_CONFIG_HOME is ~/.config)
		Windows		$XDG_CONFIG_HOME/nvim/init.vim
				(default for $XDG_CONFIG_HOME is ~/AppData/Local)

	The files are searched in the order specified above and only the first
	one that is found is read.

	RECOMMENDATION: Put all your Vim configuration stuff in the 
	$HOME/.config/nvim/ directory. That makes it easy to copy it to 
	another system.

	If Vim was started with "-u filename", the file "filename" is used.
	All following initializations until 4. are skipped. $MYVIMRC is not
	set.
	"vim -u NORC" can be used to skip these initializations without
	reading a file.  "vim -u NONE" also skips plugins and syntax
	highlighting.  |-u|

	If Vim was started in Ex mode with the "-s" argument, all following
	initializations until 4. are skipped.  Only the "-u" option is
	interpreted.
							*system-vimrc*
     a. For Unix, MS-Windows, and Macintosh, the system vimrc file is read for
	initializations.  The path of this file is shown with the
	":version" command.  Mostly it's "$VIM/vimrc".

						*VIMINIT* *EXINIT* *$MYVIMRC*
     b. Four places are searched for initializations.  The first that exists
	is used, the others are ignored.  The $MYVIMRC environment variable is
	set to the file that was first found, unless $MYVIMRC was already set
	and when using VIMINIT.
	-  The environment variable VIMINIT
	   The value of $VIMINIT is used as an Ex command line.
	-  The user vimrc file: $XDG_CONFIG_HOME/nvim/init.vim.
	-  Other vimrc file: {xdg_config_dir}/nvim/init.vim where 
	   {xdg_config_dir} is one of the directories in $XDG_CONFIG_DIRS.
	-  The environment variable EXINIT.
	   The value of $EXINIT is used as an Ex command line.

     c. If the 'exrc' option is on (which is not the default), the current
	directory is searched for three files.  The first that exists is used,
	the others are ignored.
	-  The file ".nvimrc" (for Unix)
		    "_nvimrc" (for Win32)
	-  The file "_nvimrc" (for Unix)
		    ".nvimrc" (for Win32)
	-  The file ".exrc"  (for Unix)
		    "_exrc"  (for Win32)

4. Enable filetype and indent plugins.
	This does the same as the commands: >
		:runtime! filetype.vim
		:runtime! ftplugin.vim
		:runtime! indent.vim
<	This step is skipped if ":filetype ..." was called before now or if
	the "-u NONE" command line argument was given.

5. Enable syntax highlighting.
	This does the same as the command: >
		:runtime! syntax/syntax.vim
<	Note: This enables filetype detection even if ":filetype off" was
	called before now.
	This step is skipped if the "-u NONE" command line argument was given.

6. Load the plugin scripts.					*load-plugins*
	This does the same as the command: >
		:runtime! plugin/**/*.vim
<	The result is that all directories in the 'runtimepath' option will be
	searched for the "plugin" sub-directory and all files ending in ".vim"
	will be sourced (in alphabetical order per directory), also in
	subdirectories.
	Loading plugins won't be done when:
	- The 'loadplugins' option was reset in a vimrc file.
	- The |--noplugin| command line argument is used.
	- The "-u NONE" command line argument is used |-u|.
	- When Vim was compiled without the |+eval| feature.
	Note that using "-c 'set noloadplugins'" doesn't work, because the
	commands from the command line have not been executed yet.  You can
	use "--cmd 'set noloadplugins'" |--cmd|.

	Packages are loaded.  These are plugins, as above, but found in the
	"start" directory of each entry in 'packpath'.  Every plugin directory
	found is added in 'runtimepath' and then the plugins are sourced.  See
	|packages|.

7. Set 'shellpipe' and 'shellredir'
	The 'shellpipe' and 'shellredir' options are set according to the
	value of the 'shell' option, unless they have been set before.
	This means that Vim will figure out the values of 'shellpipe' and
	'shellredir' for you, unless you have set them yourself.

8. Set 'updatecount' to zero, if "-n" command argument used

9. Set binary options
	If the "-b" flag was given to Vim, the options for binary editing will
	be set now.  See |-b|.

10. Perform GUI initializations
	Only when starting "gvim", the GUI initializations will be done.  See
	|gui-init|.

11. Read the ShaDa file
	See |shada-file|.

12. Read the quickfix file
	If the "-q" flag was given to Vim, the quickfix file is read.  If this
	fails, Vim exits.

13. Open all windows
	When the |-o| flag was given, windows will be opened (but not
	displayed yet).
	When the |-p| flag was given, tab pages will be created (but not
	displayed yet).
	When switching screens, it happens now.  Redrawing starts.
	If the "-q" flag was given to Vim, the first error is jumped to.
	Buffers for all windows will be loaded.

14. Execute startup commands
	If a "-t" flag was given to Vim, the tag is jumped to.
	The commands given with the |-c| and |+cmd| arguments are executed.
	If the 'insertmode' option is set, Insert mode is entered.
	The starting flag is reset, has("vim_starting") will now return zero.
	The |v:vim_did_enter| variable is set to 1.
	The |VimEnter| autocommands are executed.

Some hints on using initializations:

Standard setup:
Create a vimrc file to set the default settings and mappings for all your edit
sessions.  Put it in a place so that it will be found by 3b:
	~/.config/nvim/init.vim		(Unix)
	~/AppData/Local/nvim/init.vim	(Win32)

Local setup:
Put all commands that you need for editing a specific directory only into a
vimrc file and place it in that directory under the name ".nvimrc" ("_nvimrc"
for Windows).  NOTE: To make Vim look for these special files you
have to turn on the option 'exrc'.  See |trojan-horse| too.

System setup:
This only applies if you are managing a Unix system with several users and
want to set the defaults for all users.  Create a vimrc file with commands
for default settings and mappings and put it in the place that is given with
the ":version" command.  NOTE: System vimrc file needs specific compilation 
options (one needs to define SYS_VIMRC_FILE macros). If :version command does 
not show anything like this, consider contacting the nvim package maintainer.

Saving the current state of Vim to a file:
Whenever you have changed values of options or when you have created a
mapping, then you may want to save them in a vimrc file for later use.  See
|save-settings| about saving the current state of settings to a file.

Avoiding setup problems for Vi users:
Vi uses the variable EXINIT and the file "~/.exrc".  So if you do not want to
interfere with Vi, then use the variable VIMINIT and the file init.vim 
instead.

MS-DOS line separators:
On Windows systems Vim assumes that all the vimrc files have <CR> <NL> pairs
as line separators.  This will give problems if you have a file with only
<NL>s and have a line like ":map xx yy^M".  The trailing ^M will be ignored.

The $MYVIMRC or $MYGVIMRC file will be set to the first found vimrc and/or
gvimrc file.

Avoiding trojan horses:					*trojan-horse*
While reading the vimrc or the exrc file in the current directory, some
commands can be disabled for security reasons by setting the 'secure' option.
This is always done when executing the command from a tags file.  Otherwise it
would be possible that you accidentally use a vimrc or tags file that somebody
else created and contains nasty commands.  The disabled commands are the ones
that start a shell, the ones that write to a file, and ":autocmd".  The ":map"
commands are echoed, so you can see which keys are being mapped.
	If you want Vim to execute all commands in a local vimrc file, you
can reset the 'secure' option in the EXINIT or VIMINIT environment variable or
in the global exrc or vimrc file.  This is not possible in vimrc or
exrc in the current directory, for obvious reasons.
	On Unix systems, this only happens if you are not the owner of the
vimrc file.  Warning: If you unpack an archive that contains a vimrc or exrc
file, it will be owned by you.  You won't have the security protection.  Check
the vimrc file before you start Vim in that directory, or reset the 'exrc'
option.  Some Unix systems allow a user to do "chown" on a file.  This makes
it possible for another user to create a nasty vimrc and make you the owner.
Be careful!
	When using tag search commands, executing the search command (the last
part of the line in the tags file) is always done in secure mode.  This works
just like executing a command from a vimrc/exrc in the current directory.

							*slow-start*
If Vim takes a long time to start up, use the |--startuptime| argument to find
out what happens.

If you have 'shada' enabled, the loading of the ShaDa file may take a
while.  You can find out if this is the problem by disabling ShaDa for a
moment (use the Vim argument "-i NONE", |-i|).  Try reducing the number of
lines stored in a register with ":set shada='20,<50,s10".  |shada-file|.

							*:intro*
When Vim starts without a file name, an introductory message is displayed (for
those who don't know what Vim is).  It is removed as soon as the display is
redrawn in any way.  To see the message again, use the ":intro" command (if
there is not enough room, you will see only part of it).
   To avoid the intro message on startup, add the 'I' flag to 'shortmess'.

							*info-message*
The |--help| and |--version| arguments cause Vim to print a message and then
exit.  Normally the message is sent to stdout, thus can be redirected to a
file with: >

	vim --help >file

From inside Vim: >

	:read !vim --help

When using gvim, it detects that it might have been started from the desktop,
without a terminal to show messages on.  This is detected when both stdout and
stderr are not a tty.  This breaks the ":read" command, as used in the example
above.  To make it work again, set 'shellredir' to ">" instead of the default
">&": >

	:set shellredir=>
	:read !gvim --help

This still won't work for systems where gvim does not use stdout at all
though.

==============================================================================
3. $VIM and $VIMRUNTIME
								*$VIM*
The environment variable "$VIM" is used to locate various user files for Vim,
such as the user startup script |init.vim|.  This depends on the system, see
|startup|.

To avoid the need for every user to set the $VIM environment variable, Vim
will try to get the value for $VIM in this order:
1. The value defined by the $VIM environment variable.  You can use this to
   make Vim look in a specific directory for its support files.  Example: >
	setenv VIM /home/paul/vim
2. The path from 'helpfile' is used, unless it contains some environment
   variable too (the default is "$VIMRUNTIME/doc/help.txt": chicken-egg
   problem).  The file name ("help.txt" or any other) is removed.  Then
   trailing directory names are removed, in this order: "doc", "runtime" and
   "vim{version}" (e.g., "vim54").
3. For MSDOS and Win32 Vim tries to use the directory name of the
   executable.  If it ends in "/src", this is removed.  This is useful if you
   unpacked the .zip file in some directory, and adjusted the search path to
   find the vim executable.  Trailing directory names are removed, in this
   order: "runtime" and "vim{version}" (e.g., "vim54").
4. For Unix the compile-time defined installation directory is used (see the
   output of ":version").

Once Vim has done this once, it will set the $VIM environment variable.  To
change it later, use a ":let" command like this: >
	:let $VIM = "/home/paul/vim/"
<
								*$VIMRUNTIME*
The environment variable "$VIMRUNTIME" is used to locate various support
files, such as the on-line documentation and files used for syntax
highlighting.  For example, the main help file is normally
"$VIMRUNTIME/doc/help.txt".
You don't normally set $VIMRUNTIME yourself, but let Vim figure it out.  This
is the order used to find the value of $VIMRUNTIME:
1. If the environment variable $VIMRUNTIME is set, it is used.  You can use
   this when the runtime files are in an unusual location.
2. If "$VIM/vim{version}" exists, it is used.  {version} is the version
   number of Vim, without any '-' or '.'.  For example: "$VIM/vim54".  This is
   the normal value for $VIMRUNTIME.
3. If "$VIM/runtime" exists, it is used.
4. The value of $VIM is used.  This is for backwards compatibility with older
   versions.
5. When the 'helpfile' option is set and doesn't contain a '$', its value is
   used, with "doc/help.txt" removed from the end.

For Unix, when there is a compiled-in default for $VIMRUNTIME (check the
output of ":version"), steps 2, 3 and 4 are skipped, and the compiled-in
default is used after step 5.  This means that the compiled-in default
overrules the value of $VIM.  This is useful if $VIM is "/etc" and the runtime
files are in "/usr/share/vim/vim54".

Once Vim has done this once, it will set the $VIMRUNTIME environment variable.
To change it later, use a ":let" command like this: >
	:let $VIMRUNTIME = "/home/piet/vim/vim54"

In case you need the value of $VIMRUNTIME in a shell (e.g., for a script that
greps in the help files) you might be able to use this: >

	VIMRUNTIME="$(nvim -e --cmd 'echo $VIMRUNTIME|quit' 2>&1)"

==============================================================================
4. Suspending						*suspend*

					*iconize* *iconise* *CTRL-Z* *v_CTRL-Z*
CTRL-Z			Suspend Vim, like ":stop".
			Works in Normal and in Visual mode.  In Insert and
			Command-line mode, the CTRL-Z is inserted as a normal
			character.  In Visual mode Vim goes back to Normal
			mode.
			Note: if CTRL-Z undoes a change see |mswin.vim|.


:sus[pend][!]	or			*:sus* *:suspend* *:st* *:stop*
:st[op][!]		Suspend Vim.
			If the '!' is not given and 'autowrite' is set, every
			buffer with changes and a file name is written out.
			If the '!' is given or 'autowrite' is not set, changed
			buffers are not written, don't forget to bring Vim
			back to the foreground later!

In the GUI, suspending is implemented as iconising gvim.  In Windows 95/NT,
gvim is minimized.

On many Unix systems, it is possible to suspend Vim with CTRL-Z.  This is only
possible in Normal and Visual mode (see next chapter, |vim-modes|).  Vim will
continue if you make it the foreground job again.  On other systems, CTRL-Z
will start a new shell.  This is the same as the ":sh" command.  Vim will
continue if you exit from the shell.

In X-windows the selection is disowned when Vim suspends.  this means you
can't paste it in another application (since Vim is going to sleep an attempt
to get the selection would make the program hang).

==============================================================================
5. Exiting						*exiting*

There are several ways to exit Vim:
- Close the last window with `:quit`.  Only when there are no changes.
- Close the last window with `:quit!`.  Also when there are changes.
- Close all windows with `:qall`.  Only when there are no changes.
- Close all windows with `:qall!`.  Also when there are changes.
- Use `:cquit`.  Also when there are changes.

When using `:cquit` or when there was an error message Vim exits with exit
code 1.  Errors can be avoided by using `:silent!`.

==============================================================================
6. Saving settings					*save-settings*

Mostly you will edit your vimrc files manually.  This gives you the greatest
flexibility.  There are a few commands to generate a vimrc file automatically.
You can use these files as they are, or copy/paste lines to include in another
vimrc file.

							*:mk* *:mkexrc*
:mk[exrc] [file]	Write current key mappings and changed options to
			[file] (default ".exrc" in the current directory),
			unless it already exists.

:mk[exrc]! [file]	Always write current key mappings and changed
			options to [file] (default ".exrc" in the current
			directory).

							*:mkv* *:mkvimrc*
:mkv[imrc][!] [file]	Like ":mkexrc", but the default is ".nvimrc" in the
			current directory.  The ":version" command is also
			written to the file.

These commands will write ":map" and ":set" commands to a file, in such a way
that when these commands are executed, the current key mappings and options
will be set to the same values.  The options 'columns', 'endofline',
'fileformat', 'lines', 'modified', and 'scroll' are not included, because 
these are terminal or file dependent.
Note that the options 'binary', 'paste' and 'readonly' are included, this
might not always be what you want.

When special keys are used in mappings, The 'cpoptions' option will be
temporarily set to its Vim default, to avoid the mappings to be
misinterpreted.  This makes the file incompatible with Vi, but makes sure it
can be used with different terminals.

Only global mappings are stored, not mappings local to a buffer.

A common method is to use a default |init.vim| file, make some modifications
with ":map" and ":set" commands and write the modified file.  First read the
default vimrc in with a command like ":source ~piet/.vimrc.Cprogs", change
the settings and then save them in the current directory with ":mkvimrc!".  If
you want to make this file your default |init.vim|, move it to 
$XDG_CONFIG_HOME/nvim.  You could also use autocommands |autocommand| and/or 
modelines |modeline|.

						*vimrc-option-example*
If you only want to add a single option setting to your vimrc, you can use
these steps:
1. Edit your vimrc file with Vim.
2. Play with the option until it's right.  E.g., try out different values for
   'guifont'.
3. Append a line to set the value of the option, using the expression register
   '=' to enter the value.  E.g., for the 'guifont' option: >
   o:set guifont=<C-R>=&guifont<CR><Esc>
<  [<C-R> is a CTRL-R, <CR> is a return, <Esc> is the escape key]
   You need to escape special characters, esp. spaces.

==============================================================================
7. Views and Sessions					*views-sessions*

This is introduced in sections |21.4| and |21.5| of the user manual.

						*View* *view-file*
A View is a collection of settings that apply to one window.  You can save a
View and when you restore it later, the text is displayed in the same way.
The options and mappings in this window will also be restored, so that you can
continue editing like when the View was saved.

						*Session* *session-file*
A Session keeps the Views for all windows, plus the global settings.  You can
save a Session and when you restore it later the window layout looks the same.
You can use a Session to quickly switch between different projects,
automatically loading the files you were last working on in that project.

Views and Sessions are a nice addition to ShaDa files, which are used to
remember information for all Views and Sessions together |shada-file|.

You can quickly start editing with a previously saved View or Session with the
|-S| argument: >
	vim -S Session.vim
<
							*:mks* *:mksession*
:mks[ession][!] [file]	Write a Vim script that restores the current editing
			session.
			When [!] is included an existing file is overwritten.
			When [file] is omitted "Session.vim" is used.

The output of ":mksession" is like ":mkvimrc", but additional commands are
added to the file.  Which ones depends on the 'sessionoptions' option.  The
resulting file, when executed with a ":source" command:
1. Restores global mappings and options, if 'sessionoptions' contains
   "options".  Script-local mappings will not be written.
2. Restores global variables that start with an uppercase letter and contain
   at least one lowercase letter, if 'sessionoptions' contains "globals".
3. Unloads all currently loaded buffers.
4. Restores the current directory if 'sessionoptions' contains "curdir", or
   sets the current directory to where the Session file is if 'sessionoptions'
   contains "sesdir".
5. Restores GUI Vim window position, if 'sessionoptions' contains "winpos".
6. Restores screen size, if 'sessionoptions' contains "resize".
7. Reloads the buffer list, with the last cursor positions.  If
   'sessionoptions' contains "buffers" then all buffers are restored,
   including hidden and unloaded buffers.  Otherwise only buffers in windows
   are restored.
8. Restores all windows with the same layout.  If 'sessionoptions' contains
   "help", help windows are restored.  If 'sessionoptions' contains "blank",
   windows editing a buffer without a name will be restored.
   If 'sessionoptions' contains "winsize" and no (help/blank) windows were
   left out, the window sizes are restored (relative to the screen size).
   Otherwise, the windows are just given sensible sizes.
9. Restores the Views for all the windows, as with |:mkview|.  But
   'sessionoptions' is used instead of 'viewoptions'.
10. If a file exists with the same name as the Session file, but ending in
   "x.vim" (for eXtra), executes that as well.  You can use *x.vim files to
   specify additional settings and actions associated with a given Session,
   such as creating menu items in the GUI version.

After restoring the Session, the full filename of your current Session is
available in the internal variable "v:this_session" |this_session-variable|.
An example mapping: >
  :nmap <F2> :wa<Bar>exe "mksession! " . v:this_session<CR>:so ~/sessions/
This saves the current Session, and starts off the command to load another.

A session includes all tab pages, unless "tabpages" was removed from
'sessionoptions'. |tab-page|

The |SessionLoadPost| autocmd event is triggered after a session file is
loaded/sourced.
						*SessionLoad-variable*
While the session file is loading the SessionLoad global variable is set to 1.
Plugins can use this to postpone some work until the SessionLoadPost event is
triggered.

							*:mkvie* *:mkview*
:mkvie[w][!] [file]	Write a Vim script that restores the contents of the
			current window.
			When [!] is included an existing file is overwritten.
			When [file] is omitted or is a number from 1 to 9, a
			name is generated and 'viewdir' prepended.  When the
			last path part of 'viewdir' does not exist, this
			directory is created.  E.g., when 'viewdir' is
			"$VIM/vimfiles/view" then "view" is created in
			"$VIM/vimfiles".
			An existing file is always overwritten then.  Use
			|:loadview| to load this view again.
			When [file] is the name of a file ('viewdir' is not
			used), a command to edit the file is added to the
			generated file.

The output of ":mkview" contains these items:
1. The argument list used in the window.  When the global argument list is
   used it is reset to the global list.
   The index in the argument list is also restored.
2. The file being edited in the window.  If there is no file, the window is
   made empty.
3. Restore mappings, abbreviations and options local to the window if
   'viewoptions' contains "options" or "localoptions".  For the options it
   restores only values that are local to the current buffer and values local
   to the window.
   When storing the view as part of a session and "options" is in
   'sessionoptions', global values for local options will be stored too.
4. Restore folds when using manual folding and 'viewoptions' contains
   "folds".  Restore manually opened and closed folds.
5. The scroll position and the cursor position in the file.  Doesn't work very
   well when there are closed folds.
6. The local current directory, if it is different from the global current
   directory.

Note that Views and Sessions are not perfect:
- They don't restore everything.  For example, defined functions, autocommands
  and ":syntax on" are not included.  Things like register contents and
  command line history are in ShaDa, not in Sessions or Views.
- Global option values are only set when they differ from the default value.
  When the current value is not the default value, loading a Session will not
  set it back to the default value.  Local options will be set back to the
  default value though.
- Existing mappings will be overwritten without warning.  An existing mapping
  may cause an error for ambiguity.
- When storing manual folds and when storing manually opened/closed folds,
  changes in the file between saving and loading the view will mess it up.
- The Vim script is not very efficient.  But still faster than typing the
  commands yourself!

							*:lo* *:loadview*
:lo[adview] [nr]	Load the view for the current file.  When [nr] is
			omitted, the view stored with ":mkview" is loaded.
			When [nr] is specified, the view stored with ":mkview
			[nr]" is loaded.

The combination of ":mkview" and ":loadview" can be used to store up to ten
different views of a file.  These are remembered in the directory specified
with the 'viewdir' option.  The views are stored using the file name.  If a
file is renamed or accessed through a (symbolic) link the view will not be
found.

You might want to clean up your 'viewdir' directory now and then.

To automatically save and restore views for *.c files: >
	au BufWinLeave *.c mkview
	au BufWinEnter *.c silent loadview

==============================================================================
8. The ShaDa file				*shada* *shada-file*

If you exit Vim and later start it again, you would normally lose a lot of
information.  The ShaDa file can be used to remember that information, which
enables you to continue where you left off.  Its name is the abbreviation of 
SHAred DAta because it is used for sharing data between Neovim sessions.

This is introduced in section |21.3| of the user manual.

The ShaDa file is used to store:
- The command line history.
- The search string history.
- The input-line history.
- Contents of non-empty registers.
- Marks for several files.
- File marks, pointing to locations in files.
- Last search/substitute pattern (for 'n' and '&').
- The buffer list.
- Global variables.

You could also use a Session file.  The difference is that the ShaDa file
does not depend on what you are working on.  There normally is only one
ShaDa file.  Session files are used to save the state of a specific editing
Session.  You could have several Session files, one for each project you are
working on.  ShaDa and Session files together can be used to effectively
enter Vim and directly start working in your desired setup. |session-file|

							*shada-read*
When Vim is started and the 'shada' option is non-empty, the contents of
the ShaDa file are read and the info can be used in the appropriate places.
The |v:oldfiles| variable is filled.  The marks are not read in at startup
(but file marks are).  See |initialization| for how to set the 'shada'
option upon startup.

							*shada-write*
When Vim exits and 'shada' is non-empty, the info is stored in the ShaDa file 
(it's actually merged with the existing one, if one exists |shada-merging|).  
The 'shada' option is a string containing information about what info should 
be stored, and contains limits on how much should be stored (see 'shada').

Notes for Unix:
- The file protection for the ShaDa file will be set to prevent other users
  from being able to read it, because it may contain any text or commands that
  you have worked with.
- If you want to share the ShaDa file with other users (e.g. when you "su"
  to another user), you can make the file writable for the group or everybody.
  Vim will preserve this when writing new ShaDa files.  Be careful, don't
  allow just anybody to read and write your ShaDa file!
- Vim will not overwrite a ShaDa file that is not writable by the current
  "real" user.  This helps for when you did "su" to become root, but your
  $HOME is still set to a normal user's home directory.  Otherwise Vim would
  create a ShaDa file owned by root that nobody else can read.
- The ShaDa file cannot be a symbolic link.  This is to avoid security
  issues.

Marks are stored for each file separately.  When a file is read and 'shada'
is non-empty, the marks for that file are read from the ShaDa file.  NOTE:
The marks are only written when exiting Vim, which is fine because marks are
remembered for all the files you have opened in the current editing session,
unless ":bdel" is used.  If you want to save the marks for a file that you are
about to abandon with ":bdel", use ":wsh".  The '[' and ']' marks are not
stored, but the '"' mark is.  The '"' mark is very useful for jumping to the
cursor position when the file was last exited.  No marks are saved for files
that start with any string given with the "r" flag in 'shada'.  This can be
used to avoid saving marks for files on removable media (for Windows you would
use "ra:,rb:".
The |v:oldfiles| variable is filled with the file names that the ShaDa file
has marks for.

							*shada-file-marks*
Uppercase marks ('A to 'Z) are stored when writing the ShaDa file.  The
numbered marks ('0 to '9) are a bit special.  When the ShaDa file is written
(when exiting or with the |:wshada| command), '0 is set to the current cursor
position and file.  The old '0 is moved to '1, '1 to '2, etc.  This
resembles what happens with the "1 to "9 delete registers.  If the current
cursor position is already present in '0 to '9, it is moved to '0, to avoid
having the same position twice.  The result is that with "'0", you can jump
back to the file and line where you exited Vim.  To do that right away, try
using this command: >

	vim -c "normal '0"

In a csh compatible shell you could make an alias for it: >

	alias lvim vim -c '"'normal "'"0'"'

For a bash-like shell: >

	alias lvim='vim -c "normal '\''0"'

Use the "r" flag in 'shada' to specify for which files no marks should be
remembered.

MERGING							*shada-merging*
									{Nvim}
When writing ShaDa files with |:wshada| without bang or at regular exit 
information in the existing ShaDa file is merged with information from current 
Neovim instance.  For this purpose ShaDa files store timestamps associated 
with ShaDa entries.  Specifically the following is being done:

1. History lines are merged, ordered by timestamp.  Maximum amount of items in 
   ShaDa file is defined by 'shada' option (|shada-/|, |shada-:|, |shada-@|, 
   etc: one suboption for each character that represents history name 
   (|:history|)).
2. Local marks and changes for files that were not opened by Neovim are copied 
   to new ShaDa file. Marks for files that were opened by Neovim are merged, 
   changes to files opened by Neovim are ignored. |shada-'|
3. Jump list is merged: jumps are ordered by timestamp, identical jumps 
   (identical position AND timestamp) are squashed.
4. Search patterns and substitute strings are not merged: search pattern or 
   substitute string which has greatest timestamp will be the only one copied 
   to ShaDa file.
5. For each register entity with greatest timestamp is the only saved. 
   |shada-<|
6. All saved variables are saved from current Neovim instance. Additionally 
   existing variable values are copied, meaning that the only way to remove 
   variable from a ShaDa file is either removing it by hand or disabling 
   writing variables completely. |shada-!|
7. For each global mark entity with greatest timestamp is the only saved.
8. Buffer list and header are the only entries which are not merged in any 
   fashion: the only header and buffer list present are the ones from the 
   Neovim instance which was last writing the file. |shada-%|

COMPATIBILITY						*shada-compatibility*
									{Nvim}
ShaDa files are forward and backward compatible.  This means that

1. Entries which have unknown type (i.e. that hold unidentified data) are 
   ignored when reading and blindly copied when writing.
2. Register entries with unknown register name are ignored when reading and 
   blindly copied when writing. Limitation: only registers that use name with 
   code in interval [1, 255] are supported. |registers|
3. Register entries with unknown register type are ignored when reading and 
   merged as usual when writing. |getregtype()|
4. Local and global mark entries with unknown mark names are ignored when 
   reading. When writing global mark entries are blindly copied and local mark 
   entries are also blindly copied, but only if file they are attached to fits 
   in the |shada-'| limit. Unknown local mark entry's timestamp is also taken 
   into account when calculating which files exactly should fit into this 
   limit. Limitation: only marks that use name with code in interval [1, 255] 
   are supported. |mark-motions|
5. History entries with unknown history type are ignored when reading and 
   blindly copied when writing. Limitation: there can be only up to 256 
   history types. |history|
6. Unknown keys found in register, local mark, global mark, change, jump and 
   search pattern entries are saved internally and dumped when writing. 
   Entries created during Neovim session never have such additions.
7. Additional elements found in replacement string and history entries are 
   saved internally and dumped. Entries created during Neovim session never 
   have such additions.
8. Additional elements found in variable entries are simply ignored when 
   reading. When writing new variables they will be preserved during merging, 
   but that's all. Variable values dumped from current Neovim session never 
   have additional elements, even if variables themselves were obtained by 
   reading ShaDa files.

"Blindly" here means that there will be no attempts to somehow merge them, 
even if other entries (with known name/type/etc) are merged. |shada-merging|

SHADA FILE NAME						*shada-file-name*

- The default name of the ShaDa file is "$XDG_DATA_HOME/nvim/shada/main.shada" 
  for Unix. Default for $XDG_DATA_HOME is ~/.local/share. |base-directories|
- The 'n' flag in the 'shada' option can be used to specify another ShaDa
  file name |'shada'|.
- The "-i" Vim argument can be used to set another file name, |-i|.  When the
  file name given is "NONE" (all uppercase), no ShaDa file is ever read or
  written.  Also not for the commands below!
- For the commands below, another file name can be given, overriding the
  default and the name given with 'shada' or "-i" (unless it's NONE).


CHARACTER ENCODING					*shada-encoding*

The text in the ShaDa file is UTF-8-encoded.  Normally you will always work 
with the same 'encoding' value, and this works just fine.  However, if you 
read the ShaDa file with value for 'encoding' different from utf-8 and 
'encoding' used when writing ShaDa file, some of the text (non-ASCII 
characters) may be invalid as Neovim always attempts to convert the text in 
the ShaDa file from the UTF-8 to the current 'encoding' value.  Filenames are 
never converted, affected elements are:

- history strings;
- variable values;
- register values;
- last used search and substitute patterns;
- last used substitute replacement string.


MANUALLY READING AND WRITING				*shada-read-write*

Two commands can be used to read and write the ShaDa file manually.  This
can be used to exchange registers between two running Vim programs: First
type ":wsh" in one and then ":rsh" in the other.  Note that if the register
already contained something, then ":rsh!" would be required.  Also note
however that this means everything will be overwritten with information from
the first Vim, including the command line history, etc.

The ShaDa file itself can be edited by hand too, although we suggest you
start with an existing one to get the format right.  You need to understand 
MessagePack (or, more likely, find software that is able to use it) format to 
do this.  This can be useful in order to create a second file, say 
"~/.my.shada" which could contain certain settings that you always want when 
you first start Neovim.  For example, you can preload registers with 
particular data, or put certain commands in the command line history.  A line 
in your |init.vim| file like >
	:rshada! ~/.my.shada
can be used to load this information.  You could even have different ShaDa 
files for different types of files (e.g., C code) and load them based on the 
file name, using the ":autocmd" command (see |:autocmd|).  More information on 
ShaDa file format is contained in |shada-format| section.

					  *E136* *E138* *shada-error-handling*
Some errors make Neovim leave temporary file named `{basename}.tmp.X` (X is 
any free letter from `a` to `z`) while normally it will create this file, 
write to it and then rename `{basename}.tmp.X` to `{basename}`. Such errors 
include:

- Errors which make Neovim think that read file is not a ShaDa file at all: 
  non-ShaDa files are not overwritten for safety reasons to avoid accidentally 
  destroying an unrelated file.  This could happen e.g. when typing "nvim -i 
  file" in place of "nvim -R file" (yes, somebody did that at least with Vim).  
  Such errors are listed at |shada-critical-contents-errors|.
- If writing to the temporary file failed: e.g. because of the insufficient 
  space left.
- If renaming file failed: e.g. because of insufficient permissions.
- If target ShaDa file has different from the Neovim instance's owners (user 
  and group) and changing them failed.  Unix-specific, applies only when 
  Neovim was launched from root.

Do not forget to remove the temporary file or replace the target file with 
temporary one after getting one of the above errors or all attempts to create 
a ShaDa file may fail with |E138|.  If you got one of them when using 
|:wshada| (and not when exiting Neovim: i.e. when you have Neovim session 
running) you have additional options:

- First thing which you should consider if you got any error, except failure 
  to write to the temporary file: remove existing file and replace it with the 
  temporary file.  Do it even if you have running Neovim instance.
- Fix the permissions and/or file ownership, free some space and attempt to 
  write again.  Do not remove the existing file.
- Use |:wshada| with bang.  Does not help in case of permission error.  If 
  target file was actually the ShaDa file some information may be lost in this 
  case.  To make the matters slightly better use |:rshada| prior to writing, 
  but this still will loose buffer-local marks and change list entries for any 
  file which is not opened in the current Neovim instance.
- Remove the target file from shell and use |:wshada|.  Consequences are not 
  different from using |:wshada| with bang, but "rm -f" works in some cases 
  when you don't have write permissions.

						    *:rsh* *:rshada* *E886*
:rsh[ada][!] [file]	Read from ShaDa file [file] (default: see above).
			If [!] is given, then any information that is
			already set (registers, marks, |v:oldfiles|, etc.)
			will be overwritten.

						    *:wsh* *:wshada* *E137*
:wsh[ada][!] [file]	Write to ShaDa file [file] (default: see above).
			The information in the file is first read in to make
			a merge between old and new info.  When [!] is used,
			the old information is not read first, only the
			internal info is written (also disables safety checks 
			described in |shada-error-handling|).  If 'shada' is 
			empty, marks for up to 100 files will be written.
			When you get error "E138: All .tmp.X files exist, 
			cannot write ShaDa file!" check that no old temp files 
			were left behind (e.g. 
			~/.local/share/nvim/shada/main.shada.tmp*).

			Note: Executing :wshada will reset all |'quote| marks.

						*:o* *:ol* *:oldfiles*
:o[ldfiles]		List the files that have marks stored in the ShaDa
			file.  This list is read on startup and only changes
			afterwards with ":rshada!".  Also see |v:oldfiles|.
			The number can be used with |c_#<|.

:bro[wse] o[ldfiles][!]
			List file names as with |:oldfiles|, and then prompt
			for a number.  When the number is valid that file from
			the list is edited.
			If you get the |press-enter| prompt you can press "q"
			and still get the prompt to enter a file number.
			Use ! to abandon a modified buffer. |abandon|

SHADA FILE FORMAT						*shada-format*

ShaDa files are concats of MessagePack entries.  Each entry is a concat of 
exactly four MessagePack objects:

1. First goes type of the entry.  Object type must be an unsigned integer.  
   Object type must not be equal to zero.
2. Second goes entry timestamp.  It must also be an unsigned integer.
3. Third goes the length of the fourth entry.  Unsigned integer as well, used 
   for fast skipping without parsing.
4. Fourth is actual entry data.  All currently used ShaDa entries use 
   containers to hold data: either map or array.  Exact format depends on the 
   entry type:

   Entry type (name)   Entry data ~
   1 (Header)          Map containing data that describes the generator 
                       instance that wrote this ShaDa file.  It is ignored 
                       when reading ShaDa files.  Contains the following data:
                       Key        Data ~
                       generator  Binary, software used to generate ShaDa 
                                  file. Is equal to "nvim" when ShaDa file was 
                                  written by Neovim.
                       version    Binary, generator version.
                       encoding   Binary, effective 'encoding' value.
                       max_kbyte  Integer, effective |shada-s| limit value.
                       pid        Integer, instance process ID.
                       *          It is allowed to have any number of 
                                  additional keys with any data.
   2 (SearchPattern)   Map containing data describing last used search or 
                       substitute pattern.  Normally ShaDa file contains two 
                       such entries: one with "ss" key set to true (describes 
                       substitute pattern, see |:substitute|), and one set to 
                       false (describes search pattern, see 
                       |search-commands|). "su" key should be true on one of 
                       the entries.  If key value is equal to default then it 
                       is normally not present.  Keys:
                       Key  Type     Default  Description ~
                       sm   Boolean  true     Effective 'magic' value.
                       sc   Boolean  false    Effective 'smartcase' value.
                       sl   Boolean  true     True if search pattern comes 
                                              with a line offset.  See 
                                              |search-offset|.
                       se   Boolean  false    True if |search-offset| 
                                              requested to place cursor at 
                                              (relative to) the end of the 
                                              pattern.
                       so   Integer  0        Offset value. |search-offset|
                       su   Boolean  false    True if current entry was the 
                                              last used search pattern.
                       ss   Boolean  false    True if current entry describes 
                                              |:substitute| pattern.
                       sh   Boolean  false    True if |v:hlsearch| is on.
                                              With |shada-h| or 'nohlsearch' 
                                              this key is always false.
                       sp   Binary   N/A      Actual pattern.  Required.
                       sb   Boolean  false    True if search direction is 
                                              backward.
                       *    any      none     Other keys are allowed for 
                                              compatibility reasons, see 
                                              |shada-compatibility|.
   3 (SubString)       Array containing last |:substitute| replacement string.  
                       Contains single entry: binary, replacement string used.  
                       More entries are allowed for compatibility reasons, see 
                       |shada-compatibility|.
   4 (HistoryEntry)    Array containing one entry from history.  Should have 
                       two or three entries.  First one is history type 
                       (unsigned integer), second is history line (binary), 
                       third is the separator character (unsigned integer, 
                       must be in interval [0, 255]).  Third item is only 
                       valid for search history.  Possible history types are 
                       listed in |hist-names|, here are the corresponding 
                       numbers: 0 - cmd, 1 - search, 2 - expr, 3 - input, 
                       4 - debug.
   5 (Register)        Map describing one register (|registers|).  If key 
                       value is equal to default then it is normally not 
                       present.  Keys:
                       Key  Type             Def  Description ~
                       rt   UInteger         0    Register type:
                                                  No  Description ~
                                                  0   |characterwise-register|
                                                  1   |linewise-register|
                                                  2   |blockwise-register|
                       rw   UInteger         0    Register width. Only valid 
                                                  for |blockwise-register|s.
                       rc   Array of binary  N/A  Register contents.  Each 
                                                  entry in the array 
                                                  represents its own line.  
                                                  NUL characters inside the 
                                                  line should be represented 
                                                  as NL according to 
                                                  |NL-used-for-Nul|.
                       n    UInteger         N/A  Register name: character 
                                                  code in range [1, 255].  
                                                  Example: |quote0| register 
                                                  has name 48 (ASCII code for 
                                                  zero character).
                       *    any              none Other keys are allowed 
                                                  for compatibility reasons, 
                                                  see |shada-compatibility|.
   6 (Variable)        Array containing two items: variable name (binary) and 
                       variable value (any object).  Values are converted 
                       using the same code |msgpackparse()| uses when reading, 
                       |msgpackdump()| when writing, so there may appear 
                       |msgpack-special-dict|s.  If there are more then two 
                       entries then the rest are ignored 
                       (|shada-compatibility|).
   7 (GlobalMark)
   8 (Jump)
   10 (LocalMark)
   11 (Change)         Map containing some position description:
                       Entry      Position ~
                       GlobaMark  Global mark position. |'A|
                       LocalMark  Local mark position. |'a|
                       Jump       One position from the |jumplist|.
                       Change     One position from the |changelist|.

                       Data contained in the map:
                       Key  Type      Default  Description ~
                       l    UInteger  1        Position line number.  Must be 
                                               greater then zero.
                       c    UInteger  0        Position column number.
                       n    UInteger  34 ('"') Mark name.  Only valid for 
                                               GlobalMark and LocalMark 
                                               entries.
                       f    Binary    N/A      File name.  Required.
                       *    any       none     Other keys are allowed for 
                                               compatibility reasons, see 
                                               |shada-compatibility|.
   9 (BufferList)      Array containing maps.  Each map in the array 
                       represents one buffer.  Possible keys:
                       Key  Type      Default  Description ~
                       l    UInteger  1        Position line number.  Must be 
                                               greater then zero.
                       c    UInteger  0        Position column number.
                       f    Binary    N/A      File name.  Required.
                       *    any       none     Other keys are allowed for 
                                               compatibility reasons, see 
                                               |shada-compatibility|.
   * (Unknown)         Any other entry type is allowed for compatibility 
                       reasons, see |shada-compatibility|.

								*E575* *E576*
Errors in ShaDa file may have two types: E575 used for all “logical” errors 
and E576 used for all “critical” errors.  Critical errors trigger behaviour 
described in |shada-error-handling| when writing and skipping the rest of the 
file when reading and include:
					    *shada-critical-contents-errors*
- Any of first three MessagePack objects being not an unsigned integer.
- Third object requesting amount of bytes greater then bytes left in the ShaDa 
  file.
- Entry with zero type.  I.e. first object being equal to zero.
- MessagePack parser failing to parse the entry data.
- MessagePack parser consuming less or requesting greater bytes then described 
  in the third object for parsing fourth object.  I.e. when fourth object 
  either contains more then one MessagePack object or it does not contain 
  complete MessagePack object.

==============================================================================
9. Base Directories				*base-directories* *xdg*

Nvim conforms to the XDG Base Directory Specification for application
configuration and data file locations. This just means Nvim looks for some
optional settings and uses them if they exist, otherwise defaults are chosen.
https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html

CONFIGURATION DIRECTORY				*$XDG_CONFIG_HOME*

    Base directory default:
        Unix:     ~/.config
        Windows:  ~/AppData/Local

    Nvim directory:
        Unix:     ~/.config/nvim/
        Windows:  ~/AppData/Local/nvim/

DATA DIRECTORY					*$XDG_DATA_HOME*

    Base directory default:
        Unix:     ~/.local/share
        Windows:  ~/AppData/Local

    Nvim directory:
        Unix:     ~/.local/share/nvim/
        Windows:  ~/AppData/Local/nvim-data/

Note on Windows the configuration and data directory defaults are the same
(for lack of an alternative), but the sub-directory for data is named
"nvim-data" to separate it from the configuration sub-directory "nvim".

Throughout other sections of the user manual, the defaults are used as generic
placeholders, e.g. where "~/.config" is mentioned it should be understood to
mean "$XDG_CONFIG_HOME or ~/.config".

 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *usr_41.txt*	For Vim version 7.4.  Last change: 2016 Apr 12

		     VIM USER MANUAL - by Bram Moolenaar

			      Write a Vim script


The Vim script language is used for the startup vimrc file, syntax files, and
many other things.  This chapter explains the items that can be used in a Vim
script.  There are a lot of them, thus this is a long chapter.

|41.1|	Introduction
|41.2|	Variables
|41.3|	Expressions
|41.4|	Conditionals
|41.5|	Executing an expression
|41.6|	Using functions
|41.7|	Defining a function
|41.8|	Lists and Dictionaries
|41.9|	Exceptions
|41.10|	Various remarks
|41.11|	Writing a plugin
|41.12|	Writing a filetype plugin
|41.13|	Writing a compiler plugin
|41.14|	Writing a plugin that loads quickly
|41.15|	Writing library scripts
|41.16|	Distributing Vim scripts

     Next chapter: |usr_42.txt|  Add new menus
 Previous chapter: |usr_40.txt|  Make new commands
Table of contents: |usr_toc.txt|

==============================================================================
*41.1*	Introduction				*vim-script-intro* *script*

Your first experience with Vim scripts is the vimrc file.  Vim reads it when
it starts up and executes the commands.  You can set options to values you
prefer.  And you can use any colon command in it (commands that start with a
":"; these are sometimes referred to as Ex commands or command-line commands).
   Syntax files are also Vim scripts.  As are files that set options for a
specific file type.  A complicated macro can be defined by a separate Vim
script file.  You can think of other uses yourself.

Let's start with a simple example: >

	:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
<
	Note:
	The ":" characters are not really needed here.  You only need to use
	them when you type a command.  In a Vim script file they can be left
	out.  We will use them here anyway to make clear these are colon
	commands and make them stand out from Normal mode commands.
	Note:
	You can try out the examples by yanking the lines from the text here
	and executing them with :@"

The output of the example code is:

	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~

In the first line the ":let" command assigns a value to a variable.  The
generic form is: >

	:let {variable} = {expression}

In this case the variable name is "i" and the expression is a simple value,
the number one.
   The ":while" command starts a loop.  The generic form is: >

	:while {condition}
	:  {statements}
	:endwhile

The statements until the matching ":endwhile" are executed for as long as the
condition is true.  The condition used here is the expression "i < 5".  This
is true when the variable i is smaller than five.
	Note:
	If you happen to write a while loop that keeps on running, you can
	interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).

The ":echo" command prints its arguments.  In this case the string "count is"
and the value of the variable i.  Since i is one, this will print:

	count is 1 ~

Then there is the ":let i += 1" command.  This does the same thing as
":let i = i + 1".  This adds one to the variable i and assigns the new value
to the same variable.

The example was given to explain the commands, but would you really want to
make such a loop it can be written much more compact: >

	:for i in range(1, 4)
	:  echo "count is" i
	:endfor

We won't explain how |:for| and |range()| work until later.  Follow the links
if you are impatient.


THREE KINDS OF NUMBERS

Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts
with "0x" or "0X".  For example "0x1f" is decimal 31.  An octal number starts
with a zero.  "017" is decimal 15.  Careful: don't put a zero before a decimal
number, it will be interpreted as an octal number!
   The ":echo" command always prints decimal numbers.  Example: >

	:echo 0x7f 036
<	127 30 ~

A number is made negative with a minus sign.  This also works for hexadecimal
and octal numbers.   A minus sign is also used for subtraction.  Compare this
with the previous example: >

	:echo 0x7f -036
<	97 ~

White space in an expression is ignored.  However, it's recommended to use it
for separating items, to make the expression easier to read.  For example, to
avoid the confusion with a negative number above, put a space between the
minus sign and the following number: >

	:echo 0x7f - 036

==============================================================================
*41.2*	Variables

A variable name consists of ASCII letters, digits and the underscore.  It
cannot start with a digit.  Valid variable names are:

	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH

Invalid names are "foo+bar" and "6var".
   These variables are global.  To see a list of currently defined variables
use this command: >

	:let

You can use global variables everywhere.  This also means that when the
variable "count" is used in one script file, it might also be used in another
file.  This leads to confusion at least, and real problems at worst.  To avoid
this, you can use a variable local to a script file by prepending "s:".  For
example, one script contains this code: >

	:let s:count = 1
	:while s:count < 5
	:  source other.vim
	:  let s:count += 1
	:endwhile

Since "s:count" is local to this script, you can be sure that sourcing the
"other.vim" script will not change this variable.  If "other.vim" also uses an
"s:count" variable, it will be a different copy, local to that script.  More
about script-local variables here: |script-variable|.

There are more kinds of variables, see |internal-variables|.  The most often
used ones are:

	b:name		variable local to a buffer
	w:name		variable local to a window
	g:name		global variable (also in a function)
	v:name		variable predefined by Vim


DELETING VARIABLES

Variables take up memory and show up in the output of the ":let" command.  To
delete a variable use the ":unlet" command.  Example: >

	:unlet s:count

This deletes the script-local variable "s:count" to free up the memory it
uses.  If you are not sure if the variable exists, and don't want an error
message when it doesn't, append !: >

	:unlet! s:count

When a script finishes, the local variables used there will not be
automatically freed.  The next time the script executes, it can still use the
old value.  Example: >

	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"

The "exists()" function checks if a variable has already been defined.  Its
argument is the name of the variable you want to check.  Not the variable
itself!  If you would do this: >

	:if !exists(s:call_count)

Then the value of s:call_count will be used as the name of the variable that
exists() checks.  That's not what you want.
   The exclamation mark ! negates a value.  When the value was true, it
becomes false.  When it was false, it becomes true.  You can read it as "not".
Thus "if !exists()" can be read as "if not exists()".
   What Vim calls true is anything that is not zero.  Zero is false.
	Note:
	Vim automatically converts a string to a number when it is looking for
	a number.  When using a string that doesn't start with a digit the
	resulting number is zero.  Thus look out for this: >
		:if "true"
<	The "true" will be interpreted as a zero, thus as false!


STRING VARIABLES AND CONSTANTS

So far only numbers were used for the variable value.  Strings can be used as
well.  Numbers and strings are the basic types of variables that Vim supports.
The type is dynamic, it is set each time when assigning a value to the
variable with ":let".  More about types in |41.8|.
   To assign a string value to a variable, you need to use a string constant.
There are two types of these.  First the string in double quotes: >

	:let name = "peter"
	:echo name
<	peter ~

If you want to include a double quote inside the string, put a backslash in
front of it: >

	:let name = "\"peter\""
	:echo name
<	"peter" ~

To avoid the need for a backslash, you can use a string in single quotes: >

	:let name = '"peter"'
	:echo name
<	"peter" ~

Inside a single-quote string all the characters are as they are.  Only the
single quote itself is special: you need to use two to get one.  A backslash
is taken literally, thus you can't use it to change the meaning of the
character after it.
   In double-quote strings it is possible to use special characters.  Here are
a few useful ones:

	\t		<Tab>
	\n		<NL>, line break
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, backspace
	\"		"
	\\		\, backslash
	\<Esc>		<Esc>
	\<C-W>		CTRL-W

The last two are just examples.  The  "\<name>" form can be used to include
the special key "name".
   See |expr-quote| for the full list of special items in a string.

==============================================================================
*41.3*	Expressions

Vim has a rich, yet simple way to handle expressions.  You can read the
definition here: |expression-syntax|.  Here we will show the most common
items.
   The numbers, strings and variables mentioned above are expressions by
themselves.  Thus everywhere an expression is expected, you can use a number,
string or variable.  Other basic items in an expression are:

	$NAME		environment variable
	&name		option
	@r		register

Examples: >

	:echo "The value of 'tabstop' is" &ts
	:echo "Your home directory is" $HOME
	:if @a > 5

The &name form can be used to save an option value, set it to a new value,
do something and restore the old value.  Example: >

	:let save_ic = &ic
	:set noic
	:/The Start/,$delete
	:let &ic = save_ic

This makes sure the "The Start" pattern is used with the 'ignorecase' option
off.  Still, it keeps the value that the user had set.  (Another way to do
this would be to add "\C" to the pattern, see |/\C|.)


MATHEMATICS

It becomes more interesting if we combine these basic items.  Let's start with
mathematics on numbers:

	a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo

The usual precedence is used.  Example: >

	:echo 10 + 5 * 2
<	20 ~

Grouping is done with parentheses.  No surprises here.  Example: >

	:echo (10 + 5) * 2
<	30 ~

Strings can be concatenated with ".".  Example: >

	:echo "foo" . "bar"
<	foobar ~

When the ":echo" command gets multiple arguments, it separates them with a
space.  In the example the argument is a single expression, thus no space is
inserted.

Borrowed from the C language is the conditional expression:

	a ? b : c

If "a" evaluates to true "b" is used, otherwise "c" is used.  Example: >

	:let i = 4
	:echo i > 5 ? "i is big" : "i is small"
<	i is small ~

The three parts of the constructs are always evaluated first, thus you could
see it work as:

	(a) ? (b) : (c)

==============================================================================
*41.4*	Conditionals

The ":if" commands executes the following statements, until the matching
":endif", only when a condition is met.  The generic form is:

	:if {condition}
	   {statements}
	:endif

Only when the expression {condition} evaluates to true (non-zero) will the
{statements} be executed.  These must still be valid commands.  If they
contain garbage, Vim won't be able to find the ":endif".
   You can also use ":else".  The generic form for this is:

	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif

The second {statements} is only executed if the first one isn't.
   Finally, there is ":elseif":

	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif

This works just like using ":else" and then "if", but without the need for an
extra ":endif".
   A useful example for your vimrc file is checking the 'term' option and
doing something depending upon its value: >

	:if &term == "xterm"
	:  " Do stuff for xterm
	:elseif &term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif


LOGIC OPERATIONS

We already used some of them in the examples.  These are the most often used
ones:

	a == b		equal to
	a != b		not equal to
	a >  b		greater than
	a >= b		greater than or equal to
	a <  b		less than
	a <= b		less than or equal to

The result is one if the condition is met and zero otherwise.  An example: >

	:if v:version >= 700
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif

Here "v:version" is a variable defined by Vim, which has the value of the Vim
version.  600 is for version 6.0.  Version 6.1 has the value 601.  This is
very useful to write a script that works with multiple versions of Vim.
|v:version|

The logic operators work both for numbers and strings.  When comparing two
strings, the mathematical difference is used.  This compares byte values,
which may not be right for some languages.
   When comparing a string with a number, the string is first converted to a
number.  This is a bit tricky, because when a string doesn't look like a
number, the number zero is used.  Example: >

	:if 0 == "one"
	:  echo "yes"
	:endif

This will echo "yes", because "one" doesn't look like a number, thus it is
converted to the number zero.

For strings there are two more items:

	a =~ b		matches with
	a !~ b		does not match with

The left item "a" is used as a string.  The right item "b" is used as a
pattern, like what's used for searching.  Example: >

	:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str does not end in a full stop"
	:endif

Notice the use of a single-quote string for the pattern.  This is useful,
because backslashes would need to be doubled in a double-quote string and
patterns tend to contain many backslashes.

The 'ignorecase' option is used when comparing strings.  When you don't want
that, append "#" to match case and "?" to ignore case.  Thus "==?" compares
two strings to be equal while ignoring case.  And "!~#" checks if a pattern
doesn't match, also checking the case of letters.  For the full table see
|expr-==|.


MORE LOOPING

The ":while" command was already mentioned.  Two more statements can be used
in between the ":while" and the ":endwhile":

	:continue		Jump back to the start of the while loop; the
				loop continues.
	:break			Jump forward to the ":endwhile"; the loop is
				discontinued.

Example: >

	:while counter < 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile

The ":sleep" command makes Vim take a nap.  The "50m" specifies fifty
milliseconds.  Another example is ":sleep 4", which sleeps for four seconds.

Even more looping can be done with the ":for" command, see below in |41.8|.

==============================================================================
*41.5*	Executing an expression

So far the commands in the script were executed by Vim directly.  The
":execute" command allows executing the result of an expression.  This is a
very powerful way to build commands and execute them.
   An example is to jump to a tag, which is contained in a variable: >

	:execute "tag " . tag_name

The "." is used to concatenate the string "tag " with the value of variable
"tag_name".  Suppose "tag_name" has the value "get_cmd", then the command that
will be executed is: >

	:tag get_cmd

The ":execute" command can only execute colon commands.  The ":normal" command
executes Normal mode commands.  However, its argument is not an expression but
the literal command characters.  Example: >

	:normal gg=G

This jumps to the first line and formats all lines with the "=" operator.
   To make ":normal" work with an expression, combine ":execute" with it.
Example: >

	:execute "normal " . normal_commands

The variable "normal_commands" must contain the Normal mode commands.
   Make sure that the argument for ":normal" is a complete command.  Otherwise
Vim will run into the end of the argument and abort the command.  For example,
if you start Insert mode, you must leave Insert mode as well.  This works: >

	:execute "normal Inew text \<Esc>"

This inserts "new text " in the current line.  Notice the use of the special
key "\<Esc>".  This avoids having to enter a real <Esc> character in your
script.

If you don't want to execute a string but evaluate it to get its expression
value, you can use the eval() function: >

	:let optname = "path"
	:let optval = eval('&' . optname)

A "&" character is prepended to "path", thus the argument to eval() is
"&path".  The result will then be the value of the 'path' option.
   The same thing can be done with: >
	:exe 'let optval = &' . optname

==============================================================================
*41.6*	Using functions

Vim defines many functions and provides a large amount of functionality that
way.  A few examples will be given in this section.  You can find the whole
list here: |functions|.

A function is called with the ":call" command.  The parameters are passed in
between parentheses separated by commas.  Example: >

	:call search("Date: ", "W")

This calls the search() function, with arguments "Date: " and "W".  The
search() function uses its first argument as a search pattern and the second
one as flags.  The "W" flag means the search doesn't wrap around the end of
the file.

A function can be called in an expression.  Example: >

	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)

The getline() function obtains a line from the current buffer.  Its argument
is a specification of the line number.  In this case "." is used, which means
the line where the cursor is.
   The substitute() function does something similar to the ":substitute"
command.  The first argument is the string on which to perform the
substitution.  The second argument is the pattern, the third the replacement
string.  Finally, the last arguments are the flags.
   The setline() function sets the line, specified by the first argument, to a
new string, the second argument.  In this example the line under the cursor is
replaced with the result of the substitute().  Thus the effect of the three
statements is equal to: >

	:substitute/\a/*/g

Using the functions becomes more interesting when you do more work before and
after the substitute() call.


FUNCTIONS						*function-list*

There are many functions.  We will mention them here, grouped by what they are
used for.  You can find an alphabetical list here: |functions|.  Use CTRL-] on
the function name to jump to detailed help on it.

String manipulation:					*string-functions*
	nr2char()		get a character by its ASCII value
	char2nr()		get ASCII value of a character
	str2nr()		convert a string to a Number
	str2float()		convert a string to a Float
	printf()		format a string according to % items
	escape()		escape characters in a string with a '\'
	shellescape()		escape a string for use with a shell command
	fnameescape()		escape a file name for use with a Vim command
	tr()			translate characters from one set to another
	strtrans()		translate a string to make it printable
	tolower()		turn a string to lowercase
	toupper()		turn a string to uppercase
	match()			position where a pattern matches in a string
	matchend()		position where a pattern match ends in a string
	matchstr()		match of a pattern in a string
	matchlist()		like matchstr() and also return submatches
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string in bytes
	strchars()		length of a string in characters
	strwidth()		size of string when displayed
	strdisplaywidth()	size of string when displayed, deals with tabs
	substitute()		substitute a pattern match with a string
	submatch()		get a specific match in ":s" and substitute()
	strpart()		get part of a string
	expand()		expand special keywords
	iconv()			convert text from one encoding to another
	byteidx()		byte index of a character in a string
	byteidxcomp()		like byteidx() but count composing characters
	repeat()		repeat a string multiple times
	eval()			evaluate a string expression

List manipulation:					*list-functions*
	get()			get an item without error for wrong index
	len()			number of items in a List
	empty()			check if List is empty
	insert()		insert an item somewhere in a List
	add()			append an item to a List
	extend()		append a List to a List
	remove()		remove one or more items from a List
	copy()			make a shallow copy of a List
	deepcopy()		make a full copy of a List
	filter()		remove selected items from a List
	map()			change each List item
	sort()			sort a List
	reverse()		reverse the order of a List
	uniq()			remove copies of repeated adjacent items
	split()			split a String into a List
	join()			join List items into a String
	range()			return a List with a sequence of numbers
	string()		String representation of a List
	call()			call a function with List as arguments
	index()			index of a value in a List
	max()			maximum value in a List
	min()			minimum value in a List
	count()			count number of times a value appears in a List
	repeat()		repeat a List multiple times

Dictionary manipulation:				*dict-functions*
	get()			get an entry without an error for a wrong key
	len()			number of entries in a Dictionary
	has_key()		check whether a key appears in a Dictionary
	empty()			check if Dictionary is empty
	remove()		remove an entry from a Dictionary
	extend()		add entries from one Dictionary to another
	filter()		remove selected entries from a Dictionary
	map()			change each Dictionary entry
	keys()			get List of Dictionary keys
	values()		get List of Dictionary values
	items()			get List of Dictionary key-value pairs
	copy()			make a shallow copy of a Dictionary
	deepcopy()		make a full copy of a Dictionary
	string()		String representation of a Dictionary
	max()			maximum value in a Dictionary
	min()			minimum value in a Dictionary
	count()			count number of times a value appears

Floating point computation:				*float-functions*
	float2nr()		convert Float to Number
	abs()			absolute value (also works for Number)
	round()			round off
	ceil()			round up
	floor()			round down
	trunc()			remove value after decimal point
	fmod()			remainder of division
	exp()			exponential
	log()			natural logarithm (logarithm to base e)
	log10()			logarithm to base 10
	pow()			value of x to the exponent y
	sqrt()			square root
	sin()			sine
	cos()			cosine
	tan()			tangent
	asin()			arc sine
	acos()			arc cosine
	atan()			arc tangent
	atan2()			arc tangent
	sinh()			hyperbolic sine
	cosh()			hyperbolic cosine
	tanh()			hyperbolic tangent

Other computation:					*bitwise-function*
	and()			bitwise AND
	invert()		bitwise invert
	or()			bitwise OR
	xor()			bitwise XOR
	sha256()		SHA-256 hash

Variables:						*var-functions*
	type()			type of a variable
	islocked()		check if a variable is locked
	function()		get a Funcref for a function name
	getbufvar()		get a variable value from a specific buffer
	setbufvar()		set a variable in a specific buffer
	getwinvar()		get a variable from specific window
	gettabvar()		get a variable from specific tab page
	gettabwinvar()		get a variable from specific window & tab page
	setwinvar()		set a variable in a specific window
	settabvar()		set a variable in a specific tab page
	settabwinvar()		set a variable in a specific window & tab page
	garbagecollect()	possibly free memory

Cursor and mark position:		*cursor-functions* *mark-functions*
	col()			column number of the cursor or a mark
	virtcol()		screen column of the cursor or a mark
	line()			line number of the cursor or mark
	wincol()		window column number of the cursor
	winline()		window line number of the cursor
	cursor()		position the cursor at a line/column
	screencol()		get screen column of the cursor
	screenrow()		get screen row of the cursor
	getcurpos()		get position of the cursor
	getpos()		get position of cursor, mark, etc.
	setpos()		set position of cursor, mark, etc.
	byte2line()		get line number at a specific byte count
	line2byte()		byte count at a specific line
	diff_filler()		get the number of filler lines above a line
	screenattr()		get attribute at a screen line/row
	screenchar()		get character code at a screen line/row

Working with text in the current buffer:		*text-functions*
	getline()		get a line or list of lines from the buffer
	setline()		replace a line in the buffer
	append()		append line or list of lines in the buffer
	indent()		indent of a specific line
	cindent()		indent according to C indenting
	lispindent()		indent according to Lisp indenting
	nextnonblank()		find next non-blank line
	prevnonblank()		find previous non-blank line
	search()		find a match for a pattern
	searchpos()		find a match for a pattern
	searchpair()		find the other end of a start/skip/end
	searchpairpos()		find the other end of a start/skip/end
	searchdecl()		search for the declaration of a name

					*system-functions* *file-functions*
System functions and manipulation of files:
	glob()			expand wildcards
	globpath()		expand wildcards in a number of directories
	findfile()		find a file in a list of directories
	finddir()		find a directory in a list of directories
	resolve()		find out where a shortcut points to
	fnamemodify()		modify a file name
	pathshorten()		shorten directory names in a path
	simplify()		simplify a path without changing its meaning
	executable()		check if an executable program exists
	exepath()		full path of an executable program
	filereadable()		check if a file can be read
	filewritable()		check if a file can be written to
	getfperm()		get the permissions of a file
	getftype()		get the kind of a file
	isdirectory()		check if a directory exists
	getfsize()		get the size of a file
	getcwd()		get the current working directory
	haslocaldir()		check if current window used |:lcd|
	tempname()		get the name of a temporary file
	mkdir()			create a new directory
	delete()		delete a file
	rename()		rename a file
	system()		get the result of a shell command as a string
	systemlist()		get the result of a shell command as a list
	hostname()		name of the system
	readfile()		read a file into a List of lines
	writefile()		write a List of lines into a file

Date and Time:				*date-functions* *time-functions*
	getftime()		get last modification time of a file
	localtime()		get current time in seconds
	strftime()		convert time to a string
	reltime()		get the current or elapsed time accurately
	reltimestr()		convert reltime() result to a string
	reltimefloat()		convert reltime() result to a Float

			*buffer-functions* *window-functions* *arg-functions*
Buffers, windows and the argument list:
	argc()			number of entries in the argument list
	argidx()		current position in the argument list
	arglistid()		get id of the argument list
	argv()			get one entry from the argument list
	bufexists()		check if a buffer exists
	buflisted()		check if a buffer exists and is listed
	bufloaded()		check if a buffer exists and is loaded
	bufname()		get the name of a specific buffer
	bufnr()			get the buffer number of a specific buffer
	tabpagebuflist()	return List of buffers in a tab page
	tabpagenr()		get the number of a tab page
	tabpagewinnr()		like winnr() for a specified tab page
	winnr()			get the window number for the current window
	bufwinnr()		get the window number of a specific buffer
	winbufnr()		get the buffer number of a specific window
	getbufline()		get a list of lines from the specified buffer

Command line:					*command-line-functions*
	getcmdline()		get the current command line
	getcmdpos()		get position of the cursor in the command line
	setcmdpos()		set position of the cursor in the command line
	getcmdtype()		return the current command-line type
	getcmdwintype()		return the current command-line window type

Quickfix and location lists:			*quickfix-functions*
	getqflist()		list of quickfix errors
	setqflist()		modify a quickfix list
	getloclist()		list of location list items
	setloclist()		modify a location list

Insert mode completion:				*completion-functions*
	complete()		set found matches
	complete_add()		add to found matches
	complete_check()	check if completion should be aborted
	pumvisible()		check if the popup menu is displayed

Folding:					*folding-functions*
	foldclosed()		check for a closed fold at a specific line
	foldclosedend()		like foldclosed() but return the last line
	foldlevel()		check for the fold level at a specific line
	foldtext()		generate the line displayed for a closed fold
	foldtextresult()	get the text displayed for a closed fold

Syntax and highlighting:	  *syntax-functions* *highlighting-functions*
	clearmatches()		clear all matches defined by |matchadd()| and
				the |:match| commands
	getmatches()		get all matches defined by |matchadd()| and
				the |:match| commands
	hlexists()		check if a highlight group exists
	hlID()			get ID of a highlight group
	synID()			get syntax ID at a specific position
	synIDattr()		get a specific attribute of a syntax ID
	synIDtrans()		get translated syntax ID
	synstack()		get list of syntax IDs at a specific position
	synconcealed()		get info about concealing
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		define a pattern to highlight (a "match")
	matchaddpos()		define a list of positions to highlight
	matcharg()		get info about |:match| arguments
	matchdelete()		delete a match defined by |matchadd()| or a
				|:match| command
	setmatches()		restore a list of matches saved by
				|getmatches()|

Spelling:					*spell-functions*
	spellbadword()		locate badly spelled word at or after cursor
	spellsuggest()		return suggested spelling corrections
	soundfold()		return the sound-a-like equivalent of a word

History:					*history-functions*
	histadd()		add an item to a history
	histdel()		delete an item from a history
	histget()		get an item from a history
	histnr()		get highest index of a history list

Interactive:					*interactive-functions*
	browse()		put up a file requester
	browsedir()		put up a directory requester
	confirm()		let the user make a choice
	getchar()		get a character from the user
	getcharmod()		get modifiers for the last typed character
	feedkeys()		put characters in the typeahead queue
	input()			get a line from the user
	inputlist()		let the user pick an entry from a list
	inputsecret()		get a line from the user without showing it
	inputdialog()		get a line from the user in a dialog
	inputsave()		save and clear typeahead
	inputrestore()		restore typeahead

GUI:						*gui-functions*
	getfontname()		get name of current font being used
	getwinposx()		X position of the GUI Vim window
	getwinposy()		Y position of the GUI Vim window

Vim server:					*server-functions*
	serverlist()		return the list of server names
	remote_send()		send command characters to a Vim server
	remote_expr()		evaluate an expression in a Vim server
	server2client()		send a reply to a client of a Vim server
	remote_peek()		check if there is a reply from a Vim server
	remote_read()		read a reply from a Vim server
	foreground()		move the Vim window to the foreground
	remote_foreground()	move the Vim server window to the foreground

Window size and position:			*window-size-functions*
	winheight()		get height of a specific window
	winwidth()		get width of a specific window
	winrestcmd()		return command to restore window sizes
	winsaveview()		get view of current window
	winrestview()		restore saved view of current window

Mappings:				    *mapping-functions*
	hasmapto()		check if a mapping exists
	mapcheck()		check if a matching mapping exists
	maparg()		get rhs of a mapping
	wildmenumode()		check if the wildmode is active

Testing:				    *test-functions*
	assert_equal()		assert that two expressions values are equal
	assert_notequal()	assert that two expressions values are not equal
	assert_match()		assert that a pattern matches the value
	assert_notmatch()	assert that a pattern does not match the value
	assert_false()		assert that an expression is false
	assert_true()		assert that an expression is true
	assert_exception()	assert that a command throws an exception
	assert_fails()		assert that a function call fails

Various:					*various-functions*
	mode()			get current editing mode
	visualmode()		last visual mode used
	exists()		check if a variable, function, etc. exists
	has()			check if a feature is supported in Vim
	changenr()		return number of most recent change
	cscope_connection()	check if a cscope connection exists
	did_filetype()		check if a FileType autocommand was used
	eventhandler()		check if invoked by an event handler
	getpid()		get process ID of Vim

	libcall()		call a function in an external library
	libcallnr()		idem, returning a number

	undofile()		get the name of the undo file
	undotree()		return the state of the undo tree

	getreg()		get contents of a register
	getregtype()		get type of a register
	setreg()		set contents and type of a register

	shiftwidth()		effective value of 'shiftwidth'

	taglist()		get list of matching tags
	tagfiles()		get a list of tags files

	py3eval()		evaluate Python expression (|+python3|)
	pyeval()		evaluate Python expression (|+python|)
	wordcount()		get byte/word/char count of buffer

==============================================================================
*41.7*	Defining a function

Vim enables you to define your own functions.  The basic function declaration
begins as follows: >

	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
<
	Note:
	Function names must begin with a capital letter.

Let's define a short function to return the smaller of two numbers.  It starts
with this line: >

	:function Min(num1, num2)

This tells Vim that the function is named "Min" and it takes two arguments:
"num1" and "num2".
   The first thing you need to do is to check to see which number is smaller:
   >
	:  if a:num1 < a:num2

The special prefix "a:" tells Vim that the variable is a function argument.
Let's assign the variable "smaller" the value of the smallest number: >

	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif

The variable "smaller" is a local variable.  Variables used inside a function
are local unless prefixed by something like "g:", "a:", or "s:".

	Note:
	To access a global variable from inside a function you must prepend
	"g:" to it.  Thus "g:today" inside a function is used for the global
	variable "today", and "today" is another variable, local to the
	function.

You now use the ":return" statement to return the smallest number to the user.
Finally, you end the function: >

	:  return smaller
	:endfunction

The complete function definition is as follows: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction

For people who like short functions, this does the same thing: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction

A user defined function is called in exactly the same way as a built-in
function.  Only the name is different.  The Min function can be used like
this: >

	:echo Min(5, 8)

Only now will the function be executed and the lines be interpreted by Vim.
If there are mistakes, like using an undefined variable or function, you will
now get an error message.  When defining the function these errors are not
detected.

When a function reaches ":endfunction" or ":return" is used without an
argument, the function returns zero.

To redefine a function that already exists, use the ! for the ":function"
command: >

	:function!  Min(num1, num2, num3)


USING A RANGE

The ":call" command can be given a line range.  This can have one of two
meanings.  When a function has been defined with the "range" keyword, it will
take care of the line range itself.
  The function will be passed the variables "a:firstline" and "a:lastline".
These will have the line numbers from the range the function was called with.
Example: >

	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum <= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " . n . " words"
	:endfunction

You can call this function with: >

	:10,30call Count_words()

It will be executed once and echo the number of words.
   The other way to use a line range is by defining a function without the
"range" keyword.  The function will be called once for every line in the
range, with the cursor in that line.  Example: >

	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction

If you call this function with: >

	:10,15call Number()

The function will be called six times.


VARIABLE NUMBER OF ARGUMENTS

Vim enables you to define functions that have a variable number of arguments.
The following command, for instance, defines a function that must have 1
argument (start) and can have up to 20 additional arguments: >

	:function Show(start, ...)

The variable "a:1" contains the first optional argument, "a:2" the second, and
so on.  The variable "a:0" contains the number of extra arguments.
   For example: >

	:function Show(start, ...)
	:  echohl Title
	:  echo "start is " . a:start
	:  echohl None
	:  let index = 1
	:  while index <= a:0
	:    echo "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction

This uses the ":echohl" command to specify the highlighting used for the
following ":echo" command.  ":echohl None" stops it again.  The ":echon"
command works like ":echo", but doesn't output a line break.

You can also use the a:000 variable, it is a List of all the "..." arguments.
See |a:000|.


LISTING FUNCTIONS

The ":function" command lists the names and arguments of all user-defined
functions: >

	:function
<	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~

To see what a function does, use its name as an argument for ":function": >

	:function SetSyn
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~


DEBUGGING

The line number is useful for when you get an error message or when debugging.
See |debug-scripts| about debugging mode.
   You can also set the 'verbose' option to 12 or higher to see all function
calls.  Set it to 15 or higher to see every executed line.


DELETING A FUNCTION

To delete the Show() function: >

	:delfunction Show

You get an error when the function doesn't exist.


FUNCTION REFERENCES

Sometimes it can be useful to have a variable point to one function or
another.  You can do it with the function() function.  It turns the name of a
function into a reference: >

	:let result = 0		" or 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
<	Wrong! ~

Note that the name of a variable that holds a function reference must start
with a capital.  Otherwise it could be confused with the name of a builtin
function.
   The way to invoke a function that a variable refers to is with the call()
function.  Its first argument is the function reference, the second argument
is a List with arguments.

Function references are most useful in combination with a Dictionary, as is
explained in the next section.

==============================================================================
*41.8*	Lists and Dictionaries

So far we have used the basic types String and Number.  Vim also supports two
composite types: List and Dictionary.

A List is an ordered sequence of things.  The things can be any kind of value,
thus you can make a List of numbers, a List of Lists and even a List of mixed
items.  To create a List with three strings: >

	:let alist = ['aap', 'mies', 'noot']

The List items are enclosed in square brackets and separated by commas.  To
create an empty List: >

	:let alist = []

You can add items to a List with the add() function: >

	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
<	['foo', 'bar'] ~

List concatenation is done with +: >

	:echo alist + ['foo', 'bar']
<	['foo', 'bar', 'foo', 'bar'] ~

Or, if you want to extend a List directly: >

	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
<	['one', 'two', 'three'] ~

Notice that using add() will have a different effect: >

	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
<	['one', ['two', 'three']] ~

The second argument of add() is added as a single item.


FOR LOOP

One of the nice things you can do with a List is iterate over it: >

	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
<	one ~
	two ~
	three ~

This will loop over each element in List "alist", assigning the value to
variable "n".  The generic form of a for loop is: >

	:for {varname} in {listexpression}
	:  {commands}
	:endfor

To loop a certain number of times you need a List of a specific length.  The
range() function creates one for you: >

	:for a in range(3)
	:  echo a
	:endfor
<	0 ~
	1 ~
	2 ~

Notice that the first item of the List that range() produces is zero, thus the
last item is one less than the length of the list.
   You can also specify the maximum value, the stride and even go backwards: >

	:for a in range(8, 4, -2)
	:  echo a
	:endfor
<	8 ~
	6 ~
	4 ~

A more useful example, looping over lines in the buffer: >

	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor

This looks into lines 1 to 20 (inclusive) and echoes any date found in there.


DICTIONARIES

A Dictionary stores key-value pairs.  You can quickly lookup a value if you
know the key.  A Dictionary is created with curly braces: >

	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}

Now you can lookup words by putting the key in square brackets: >

	:echo uk2nl['two']
<	twee ~

The generic form for defining a Dictionary is: >

	{<key> : <value>, ...}

An empty Dictionary is one without any keys: >

	{}

The possibilities with Dictionaries are numerous.  There are various functions
for them as well.  For example, you can obtain a list of the keys and loop
over them: >

	:for key in keys(uk2nl)
	:  echo key
	:endfor
<	three ~
	one ~
	two ~

You will notice the keys are not ordered.  You can sort the list to get a
specific order: >

	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
<	one ~
	three ~
	two ~

But you can never get back the order in which items are defined.  For that you
need to use a List, it stores items in an ordered sequence.


DICTIONARY FUNCTIONS

The items in a Dictionary can normally be obtained with an index in square
brackets: >

	:echo uk2nl['one']
<	een ~

A method that does the same, but without so many punctuation characters: >

	:echo uk2nl.one
<	een ~

This only works for a key that is made of ASCII letters, digits and the
underscore.  You can also assign a new value this way: >

	:let uk2nl.four = 'vier'
	:echo uk2nl
<	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~

And now for something special: you can directly define a function and store a
reference to it in the dictionary: >

	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction

Let's first try it out: >

	:echo uk2nl.translate('three two five one')
<	drie twee ??? een ~

The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.
   Now let's break up the complicated return command: >

	split(a:line)

The split() function takes a string, chops it into whitespace separated words
and returns a list with these words.  Thus in the example it returns: >

	:echo split('three two five one')
<	['three', 'two', 'five', 'one'] ~

This list is the first argument to the map() function.  This will go through
the list, evaluating its second argument with "v:val" set to the value of each
item.  This is a shortcut to using a for loop.  This command: >

	:let alist = map(split(a:line), 'get(self, v:val, "???")')

Is equivalent to: >

	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor

The get() function checks if a key is present in a Dictionary.  If it is, then
the value is retrieved.  If it isn't, then the default value is returned, in
the example it's '???'.  This is a convenient way to handle situations where a
key may not be present and you don't want an error message.

The join() function does the opposite of split(): it joins together a list of
words, putting a space in between.
  This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.


OBJECT ORIENTED PROGRAMMING

Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: >

	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction

It's slightly different from the function above, using 'self.words' to lookup
word translations.  But we don't have a self.words.  Thus you could call this
an abstract class.

Now we can instantiate a Dutch translation object: >

	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
<	drie een ~

And a German translator: >

	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
<	drei ein ~

You see that the copy() function is used to make a copy of the "transdict"
Dictionary and then the copy is changed to add the words.  The original
remains the same, of course.

Now you can go one step further, and use your preferred translator: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
<	een twee drie ~

Here "trans" refers to one of the two objects (Dictionaries).  No copy is
made.  More about List and Dictionary identity can be found at |list-identity|
and |dict-identity|.

Now you might use a language that isn't supported.  You can overrule the
translate() function to do nothing: >

	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
<	three one wladiwostok ~

Notice that a ! was used to overwrite the existing function reference.  Now
use "uk2uk" when no recognized language is found: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
<	one two three ~

For further reading see |Lists| and |Dictionaries|.

==============================================================================
*41.9*	Exceptions

Let's start with an example: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

The ":read" command will fail if the file does not exist.  Instead of
generating an error message, this code catches the error and gives the user a
nice message.

For the commands in between ":try" and ":endtry" errors are turned into
exceptions.  An exception is a string.  In the case of an error the string
contains the error message.  And every error message has a number.  In this
case, the error we catch contains "E484:".  This number is guaranteed to stay
the same (the text may change, e.g., it may be translated).

When the ":read" command causes another error, the pattern "E484:" will not
match in it.  Thus this exception will not be caught and result in the usual
error message.

You might be tempted to do this: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

This means all errors are caught.  But then you will not see errors that are
useful, such as "E21: Cannot make changes, 'modifiable' is off".

Another useful mechanism is the ":finally" command: >

	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry

This filters the lines from the cursor until the end of the file through the
"filter" command, which takes a file name argument.  No matter if the
filtering works, something goes wrong in between ":try" and ":finally" or the
user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is
always executed.  This makes sure you don't leave the temporary file behind.

More information about exception handling can be found in the reference
manual: |exception-handling|.

==============================================================================
*41.10*	Various remarks

Here is a summary of items that apply to Vim scripts.  They are also mentioned
elsewhere, but form a nice checklist.

The end-of-line character depends on the system.  For Unix a single <NL>
character is used.  For Windows <CR><LF> is used.  This is important when
using mappings that end in a <CR>.  See |:source_crnl|.


WHITE SPACE

Blank lines are allowed and ignored.

Leading whitespace characters (blanks and TABs) are always ignored.  The
whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in
the example below) are reduced to one blank character and plays the role of a
separator, the whitespaces after the last (visible) character may or may not
be ignored depending on the situation, see below.

For a ":set" command involving the "=" (equal) sign, such as in: >

	:set cpoptions    =aABceFst

the whitespace immediately before the "=" sign is ignored.  But there can be
no whitespace after the "=" sign!

To include a whitespace character in the value of an option, it must be
escaped by a "\" (backslash)  as in the following example: >

	:set tags=my\ nice\ file

The same example written as: >

	:set tags=my nice file

will issue an error, because it is interpreted as: >

	:set tags=my
	:set nice
	:set file


COMMENTS

The character " (the double quote mark) starts a comment.  Everything after
and including this character until the end-of-line is considered a comment and
is ignored, except for commands that don't consider comments, as shown in
examples below.  A comment can start on any character position on the line.

There is a little "catch" with comments for some commands.  Examples: >

	:abbrev dev development		" shorthand
	:map <F3> o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files

The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of <F3> will actually be the whole line after the 'o# ....' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick: >

	:abbrev dev development|" shorthand
	:map <F3> o#include|" insert include
	:execute cmd			|" do it

With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|': >
	:exe '!ls *.c'			|" list C files

Notice that there is no white space before the '|' in the abbreviation and
mapping.  For these commands, any character until the end-of-line or '|' is
included.  As a consequence of this behavior, you don't always see that
trailing whitespace is included: >

	:map <F4> o#include  

To spot these problems, you can set the 'list' option when editing vimrc
files.

For Unix there is one special way to comment a line, that allows making a Vim
script executable: >
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit

The "#" command by itself lists a line with the line number.  Adding an
exclamation mark changes it into doing nothing, so that you can add the shell
command to execute the rest of the file. |:#!| |-S|


PITFALLS

Even bigger problem arises in the following example: >

	:map ,ab o#include
	:unmap ,ab 

Here the unmap command will not work, because it tries to unmap ",ab ".  This
does not exist as a mapped sequence.  An error will be issued, which is very
hard to identify, because the ending whitespace character in ":unmap ,ab " is
not visible.

And this is the same as what happens when one uses a comment after an 'unmap'
command: >

	:unmap ,ab     " comment

Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as: >

	:unmap ,ab|    " comment


RESTORING THE VIEW

Sometimes you want to make a change and go back to where the cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view: >

	map ,p ma"aYHmbgg"aP`bzt`a

What this does: >
	ma"aYHmbgg"aP`bzt`a
<	ma			set mark a at cursor position
	  "aY			yank current line into register a
	     Hmb		go to top line in window and set mark b there
		gg		go to first line in file
		  "aP		put the yanked line above it
		     `b		go back to top line in display
		       zt	position the text in the window as before
			 `a	go back to saved cursor position


PACKAGING

To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example: >

	" This is the XXX package

	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif

	function XXX_one(a)
		... body of function ...
	endfun

	function XXX_two(b)
		... body of function ...
	endfun

	let XXX_loaded = 1

==============================================================================
*41.11*	Writing a plugin				*write-plugin*

You can write a Vim script in such a way that many people can use it.  This is
called a plugin.  Vim users can drop your script in their plugin directory and
use its features right away |add-plugin|.

There are actually two types of plugins:

  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.

In this section the first type is explained.  Most items are also relevant for
writing filetype plugins.  The specifics for filetype plugins are in the next
section |write-filetype-plugin|.


NAME

First of all you must choose a name for your plugin.  The features provided
by the plugin should be clear from its name.  And it should be unlikely that
someone else writes a plugin with the same name but which does something
different.  And please limit the name to 8 characters, to avoid problems on
old Windows systems.

A script that corrects typing mistakes could be called "typecorr.vim".  We
will use it here as an example.

For the plugin to work for everybody, it should follow a few guidelines.  This
will be explained step-by-step.  The complete example plugin is at the end.


BODY

Let's start with the body of the plugin, the lines that do the actual work: >

 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4

The actual list should be much longer, of course.

The line numbers have only been added to explain a few things, don't put them
in your plugin file!


HEADER

You will probably add new corrections to the plugin and soon have several
versions lying around.  And when distributing this file, people will want to
know who wrote this wonderful plugin and where they can send remarks.
Therefore, put a header at the top of your plugin: >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>

About copyright and licensing: Since plugins are very useful and it's hardly
worth restricting their distribution, please consider making your plugin
either public domain or use the Vim |license|.  A short note about this near
the top of the plugin should be sufficient.  Example: >

  4	" License:	This file is placed in the public domain.


LINE CONTINUATION, AVOIDING SIDE EFFECTS		*use-cpo-save*

In line 18 above, the line-continuation mechanism is used |line-continuation|.
Users with 'compatible' set will run into trouble here, they will get an error
message.  We can't just reset 'compatible', because that has a lot of side
effects.  To avoid this, we will set the 'cpoptions' option to its Vim default
value and restore it later.  That will allow the use of line-continuation and
make the script work for most people.  It is done like this: >

 11	let s:save_cpo = &cpo
 12	set cpo&vim
 ..
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo

We first store the old value of 'cpoptions' in the s:save_cpo variable.  At
the end of the plugin this value is restored.

Notice that a script-local variable is used |s:var|.  A global variable could
already be in use for something else.  Always use script-local variables for
things that are only used in the script.


NOT LOADING

It's possible that a user doesn't always want to load this plugin.  Or the
system administrator has dropped it in the system-wide plugin directory, but a
user has his own plugin he wants to use.  Then the user must have a chance to
disable loading this specific plugin.  This will make it possible: >

  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1

This also avoids that when the script is loaded twice it would cause error
messages for redefining functions and cause trouble for autocommands that are
added twice.

The name is recommended to start with "loaded_" and then the file name of the
plugin, literally.  The "g:" is prepended just to avoid mistakes when using
the variable in a function (without "g:" it would be a variable local to the
function).

Using "finish" stops Vim from reading the rest of the file, it's much quicker
than using if-endif around the whole file.


MAPPING

Now let's make the plugin more interesting: We will add a mapping that adds a
correction for the word under the cursor.  We could just pick a key sequence
for this mapping, but the user might already use it for something else.  To
allow the user to define which keys a mapping in a plugin uses, the <Leader>
item can be used: >

 22	  map <unique> <Leader>a  <Plug>TypecorrAdd

The "<Plug>TypecorrAdd" thing will do the work, more about that further on.

The user can set the "mapleader" variable to the key sequence that he wants
this mapping to start with.  Thus if the user has done: >

	let mapleader = "_"

the mapping will define "_a".  If the user didn't do this, the default value
will be used, which is a backslash.  Then a map for "\a" will be defined.

Note that <unique> is used, this will cause an error message if the mapping
already happened to exist. |:map-<unique>|

But what if the user wants to define his own key sequence?  We can allow that
with this mechanism: >

 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif

This checks if a mapping to "<Plug>TypecorrAdd" already exists, and only
defines the mapping from "<Leader>a" if it doesn't.  The user then has a
chance of putting this in his vimrc file: >

	map ,c  <Plug>TypecorrAdd

Then the mapped key sequence will be ",c" instead of "_a" or "\a".


PIECES

If a script gets longer, you often want to break up the work in pieces.  You
can use functions or mappings for this.  But you don't want these functions
and mappings to interfere with the ones from other scripts.  For example, you
could define a function Add(), but another script could try to define the same
function.  To avoid this, we define the function local to the script by
prepending it with "s:".

We will define a function that adds a new typing correction: >

 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 ..
 36	endfunction

Now we can call the function s:Add() from within this script.  If another
script also defines s:Add(), it will be local to that script and can only
be called from the script it was defined in.  There can also be a global Add()
function (without the "s:"), which is again another function.

<SID> can be used with mappings.  It generates a script ID, which identifies
the current script.  In our typing correction plugin we use it like this: >

 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 ..
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>

Thus when a user types "\a", this sequence is invoked: >

	\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()

If another script would also map <SID>Add, it would get another script ID and
thus define another mapping.

Note that instead of s:Add() we use <SID>Add() here.  That is because the
mapping is typed by the user, thus outside of the script.  The <SID> is
translated to the script ID, so that Vim knows in which script to look for
the Add() function.

This is a bit complicated, but it's required for the plugin to work together
with other plugins.  The basic rule is that you use <SID>Add() in mappings and
s:Add() in other places (the script itself, autocommands, user commands).

We can also add a menu entry to do the same as the mapping: >

 26	noremenu <script> Plugin.Add\ Correction      <SID>Add

The "Plugin" menu is recommended for adding menu items for plugins.  In this
case only one item is used.  When adding more items, creating a submenu is
recommended.  For example, "Plugin.CVS" could be used for a plugin that offers
CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.

Note that in line 28 ":noremap" is used to avoid that any other mappings cause
trouble.  Someone may have remapped ":call", for example.  In line 24 we also
use ":noremap", but we do want "<SID>Add" to be remapped.  This is why
"<script>" is used here.  This only allows mappings which are local to the
script. |:map-<script>|  The same is done in line 26 for ":noremenu".
|:menu-<script>|


<SID> AND <Plug>					*using-<Plug>*

Both <SID> and <Plug> are used to avoid that mappings of typed keys interfere
with mappings that are only to be used from other mappings.  Note the
difference between using <SID> and <Plug>:

<Plug>	is visible outside of the script.  It is used for mappings which the
	user might want to map a key sequence to.  <Plug> is a special code
	that a typed key will never produce.
	To make it very unlikely that other plugins use the same sequence of
	characters, use this structure: <Plug> scriptname mapname
	In our example the scriptname is "Typecorr" and the mapname is "Add".
	This results in "<Plug>TypecorrAdd".  Only the first character of
	scriptname and mapname is uppercase, so that we can see where mapname
	starts.

<SID>	is the script ID, a unique identifier for a script.
	Internally Vim translates <SID> to "<SNR>123_", where "123" can be any
	number.  Thus a function "<SID>Add()" will have a name "<SNR>11_Add()"
	in one script, and "<SNR>22_Add()" in another.  You can see this if
	you use the ":function" command to get a list of functions.  The
	translation of <SID> in mappings is exactly the same, that's how you
	can call a script-local function from a mapping.


USER COMMAND

Now let's add a user command to add a correction: >

 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif

The user command is defined only if no command with the same name already
exists.  Otherwise we would get an error here.  Overriding the existing user
command with ":command!" is not a good idea, this would probably make the user
wonder why the command he defined himself doesn't work.  |:command|


SCRIPT VARIABLES

When a variable starts with "s:" it is a script variable.  It can only be used
inside a script.  Outside the script it's not visible.  This avoids trouble
with using the same variable name in different scripts.  The variables will be
kept as long as Vim is running.  And the same variables are used when sourcing
the same script again. |s:var|

The fun is that these variables can also be used in functions, autocommands
and user commands that are defined in the script.  In our example we can add
a few lines to count the number of corrections: >

 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction

First s:count is initialized to 4 in the script itself.  When later the
s:Add() function is called, it increments s:count.  It doesn't matter from
where the function was called, since it has been defined in the script, it
will use the local variables from this script.


THE RESULT

Here is the resulting complete example: >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
 10
 11	let s:save_cpo = &cpo
 12	set cpo&vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif
 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 25
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 33	  if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif
 41
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo

Line 33 wasn't explained yet.  It applies the new correction to the word under
the cursor.  The |:normal| command is used to use the new abbreviation.  Note
that mappings and abbreviations are expanded here, even though the function
was called from a mapping defined with ":noremap".

Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will
then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on
Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before
writing the file: >

	:set fileformat=unix


DOCUMENTATION						*write-local-help*

It's a good idea to also write some documentation for your plugin.  Especially
when its behavior can be changed by the user.  See |add-local-help| for how
they are installed.

Here is a simple example for a plugin help file, called "typecorr.txt": >

  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.

The first line is actually the only one for which the format matters.  It will
be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of
help.txt |local-additions|.  The first "*" must be in the first column of the
first line.  After adding your help file do ":help" and check that the entries
line up nicely.

You can add more tags inside ** in your help file.  But be careful not to use
existing help tags.  You would probably use the name of your plugin in most of
them, like "typecorr-settings" in the example.

Using references to other parts of the help in || is recommended.  This makes
it easy for the user to find associated help.


FILETYPE DETECTION					*plugin-filetype*

If your filetype is not already detected by Vim, you should create a filetype
detection snippet in a separate file.  It is usually in the form of an
autocommand that sets the filetype when the file name matches a pattern.
Example: >

	au BufNewFile,BufRead *.foo			set filetype=foofoo

Write this single-line file as "ftdetect/foofoo.vim" in the first directory
that appears in 'runtimepath'.  For Unix that would be
"~/.config/nvim/ftdetect/foofoo.vim".  The convention is to use the name of 
the filetype for the script name.

You can make more complicated checks if you like, for example to inspect the
contents of the file to recognize the language.  Also see |new-filetype|.


SUMMARY							*plugin-special*

Summary of special things to use in a plugin:

s:name			Variables local to the script.

<SID>			Script-ID, used for mappings and functions local to
			the script.

hasmapto()		Function to test if the user already defined a mapping
			for functionality the script offers.

<Leader>		Value of "mapleader", which the user defines as the
			keys that plugin mappings start with.

:map <unique>		Give a warning if a mapping already exists.

:noremap <script>	Use only mappings local to the script, not global
			mappings.

exists(":Cmd")		Check if a user command already exists.

==============================================================================
*41.12*	Writing a filetype plugin	*write-filetype-plugin* *ftplugin*

A filetype plugin is like a global plugin, except that it sets options and
defines mappings for the current buffer only.  See |add-filetype-plugin| for
how this type of plugin is used.

First read the section on global plugins above |41.11|.  All that is said there
also applies to filetype plugins.  There are a few extras, which are explained
here.  The essential thing is that a filetype plugin should only have an
effect on the current buffer.


DISABLING

If you are writing a filetype plugin to be used by many people, they need a
chance to disable loading it.  Put this at the top of the plugin: >

	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1

This also needs to be used to avoid that the same plugin is executed twice for
the same buffer (happens when using an ":edit" command without arguments).

Now users can disable loading the default plugin completely by making a
filetype plugin with only this line: >

	let b:did_ftplugin = 1

This does require that the filetype plugin directory comes before $VIMRUNTIME
in 'runtimepath'!

If you do want to use the default plugin, but overrule one of the settings,
you can write the different setting in a script: >

	setlocal textwidth=70

Now write this in the "after" directory, so that it gets sourced after the
distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be
"~/.config/nvim/after/ftplugin/vim.vim".  Note that the default plugin will 
have set "b:did_ftplugin", but it is ignored here.


OPTIONS

To make sure the filetype plugin only affects the current buffer use the >

	:setlocal

command to set options.  And only set options which are local to a buffer (see
the help for the option to check that).  When using |:setlocal| for global
options or options local to a window, the value will change for many buffers,
and that is not what a filetype plugin should do.

When an option has a value that is a list of flags or items, consider using
"+=" and "-=" to keep the existing value.  Be aware that the user may have
changed an option value already.  First resetting to the default value and
then changing it is often a good idea.  Example: >

	:setlocal formatoptions& formatoptions+=ro


MAPPINGS

To make sure mappings will only work in the current buffer use the >

	:map <buffer>

command.  This needs to be combined with the two-step mapping explained above.
An example of how to define functionality in a filetype plugin: >

	if !hasmapto('<Plug>JavaImport')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
	endif
	noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>

|hasmapto()| is used to check if the user has already defined a map to
<Plug>JavaImport.  If not, then the filetype plugin defines the default
mapping.  This starts with |<LocalLeader>|, which allows the user to select
the key(s) he wants filetype plugin mappings to start with.  The default is a
backslash.
"<unique>" is used to give an error message if the mapping already exists or
overlaps with an existing mapping.
|:noremap| is used to avoid that any other mappings that the user has defined
interferes.  You might want to use ":noremap <script>" to allow remapping
mappings defined in this script that start with <SID>.

The user must have a chance to disable the mappings in a filetype plugin,
without disabling everything.  Here is an example of how this is done for a
plugin for the mail filetype: >

	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") && !exists("no_mail_maps")
	  " Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote
	  endif
	  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
	endif

Two global variables are used:
no_plugin_maps		disables mappings for all filetype plugins
no_mail_maps		disables mappings for a specific filetype


USER COMMANDS

To add a user command for a specific file type, so that it can only be used in
one buffer, use the "-buffer" argument to |:command|.  Example: >

	:command -buffer  Make  make %:r.s


VARIABLES

A filetype plugin will be sourced for each buffer of the type it's for.  Local
script variables |s:var| will be shared between all invocations.  Use local
buffer variables |b:var| if you want a variable specifically for one buffer.


FUNCTIONS

When defining a function, this only needs to be done once.  But the filetype
plugin will be sourced every time a file with this filetype will be opened.
This construct makes sure the function is only defined once: >

	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
<

UNDO						*undo_indent* *undo_ftplugin*

When the user does ":setfiletype xyz" the effect of the previous filetype
should be undone.  Set the b:undo_ftplugin variable to the commands that will
undo the settings in your filetype plugin.  Example: >

	let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"

Using ":setlocal" with "<" after the option name resets the option to its
global value.  That is mostly the best way to reset the option value.

This does require removing the "C" flag from 'cpoptions' to allow line
continuation, as mentioned above |use-cpo-save|.

For undoing the effect of an indent script, the b:undo_indent variable should
be set accordingly.


FILE NAME

The filetype must be included in the file name |ftplugin-name|.  Use one of
these three forms:

	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim

"stuff" is the filetype, "foo" and "bar" are arbitrary names.


SUMMARY							*ftplugin-special*

Summary of special things to use in a filetype plugin:

<LocalLeader>		Value of "maplocalleader", which the user defines as
			the keys that filetype plugin mappings start with.

:map <buffer>		Define a mapping local to the buffer.

:noremap <script>	Only remap mappings defined in this script that start
			with <SID>.

:setlocal		Set an option for the current buffer only.

:command -buffer	Define a user command local to the buffer.

exists("*s:Func")	Check if a function was already defined.

Also see |plugin-special|, the special things used for all plugins.

==============================================================================
*41.13*	Writing a compiler plugin		*write-compiler-plugin*

A compiler plugin sets options for use with a specific compiler.  The user can
load it with the |:compiler| command.  The main use is to set the
'errorformat' and 'makeprg' options.

Easiest is to have a look at examples.  This command will edit all the default
compiler plugins: >

	:next $VIMRUNTIME/compiler/*.vim

Use |:next| to go to the next plugin file.

There are two special items about these files.  First is a mechanism to allow
a user to overrule or add to the default file.  The default files start with: >

	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"

When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.config/nvim/compiler for Unix), you set the "current_compiler" 
variable to make the default file skip the settings.
							*:CompilerSet*
The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
older Vim versions don't, thus your plugin should define it then.  This is an
example: >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the default 'errorformat'
  CompilerSet makeprg=nmake

When you write a compiler plugin for the Vim distribution or for a system-wide
runtime directory, use the mechanism mentioned above.  When
"current_compiler" was already set by a user plugin nothing will be done.

When you write a compiler plugin to overrule settings from a default plugin,
don't check "current_compiler".  This plugin is supposed to be loaded
last, thus it should be in a directory at the end of 'runtimepath'.  For Unix
that could be ~/.config/nvim/after/compiler.

==============================================================================
*41.14*	Writing a plugin that loads quickly	*write-plugin-quickload*

A plugin may grow and become quite long.  The startup delay may become
noticeable, while you hardly ever use the plugin.  Then it's time for a
quickload plugin.

The basic idea is that the plugin is loaded twice.  The first time user
commands and mappings are defined that offer the functionality.  The second
time the functions that implement the functionality are defined.

It may sound surprising that quickload means loading a script twice.  What we
mean is that it loads quickly the first time, postponing the bulk of the
script to the second time, which only happens when you actually use it.  When
you always use the functionality it actually gets slower!

Note that since Vim 7 there is an alternative: use the |autoload|
functionality |41.15|.

The following example shows how it's done: >

	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" License:	This file is placed in the public domain.

	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(<f-args>)
		map <F19> :call BufNetWrite('something')<CR>

		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
		finish
	endif

	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" read functionality here
	endfunction

	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" write functionality here
	endfunction

When the script is first loaded "s:did_load" is not set.  The commands between
the "if" and "endif" will be executed.  This ends in a |:finish| command, thus
the rest of the script is not executed.

The second time the script is loaded "s:did_load" exists and the commands
after the "endif" are executed.  This defines the (possible long)
BufNetRead() and BufNetWrite() functions.

If you drop this script in your plugin directory Vim will execute it on
startup.  This is the sequence of events that happens:

1. The "BNRead" command is defined and the <F19> key is mapped when the script
   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
   ":finish" command causes the script to terminate early.

2. The user types the BNRead command or presses the <F19> key.  The
   BufNetRead() or BufNetWrite() function will be called.

3. Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.  Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.  "fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "<sfile>" (see |expand()|).

4. The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.

Notice that the functions that are loaded afterwards match the pattern in the
|FuncUndefined| autocommand.  You must make sure that no other plugin defines
functions that match this pattern.

==============================================================================
*41.15*	Writing library scripts			*write-library-script*

Some functionality will be required in several places.  When this becomes more
than a few lines you will want to put it in one script and use it from many
scripts.  We will call that one script a library script.

Manually loading a library script is possible, so long as you avoid loading it
when it's already done.  You can do this with the |exists()| function.
Example: >

	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)

Here you need to know that MyLibFunction() is defined in a script
"library/mylibscript.vim" in one of the directories in 'runtimepath'.

To make this a bit simpler Vim offers the autoload mechanism.  Then the
example looks like this: >

	call mylib#myfunction(arg)

That's a lot simpler, isn't it?  Vim will recognize the function name and when
it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
That script must define the "mylib#myfunction()" function.

You can put many other functions in the mylib.vim script, you are free to
organize your functions in library scripts.  But you must use function names
where the part before the '#' matches the script name.  Otherwise Vim would
not know what script to load.

If you get really enthusiastic and write lots of library scripts, you may
want to use subdirectories.  Example: >

	call netlib#ftp#read('somefile')

For Unix the library script used for this could be:

	~/.config/nvim/autoload/netlib/ftp.vim

Where the function is defined like this: >

	function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction

Notice that the name the function is defined with is exactly the same as the
name used for calling the function.  And the part before the last '#'
exactly matches the subdirectory and script name.

You can use the same mechanism for variables: >

	let weekdays = dutch#weekdays

This will load the script "autoload/dutch.vim", which should contain something
like: >

	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']

Further reading: |autoload|.

==============================================================================
*41.16*	Distributing Vim scripts			*distribute-script*

Vim users will look for scripts on the Vim website: http://www.vim.org.
If you made something that is useful for others, share it!

Vim scripts can be used on any system.  There might not be a tar or gzip
command.  If you want to pack files together and/or compress them the "zip"
utility is recommended.

For utmost portability use Vim itself to pack scripts together.  This can be
done with the Vimball utility.  See |vimball|.

==============================================================================

Next chapter: |usr_42.txt|  Add new menus

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *eval.txt*	For Vim version 7.4.  Last change: 2016 Jun 04


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


Expression evaluation			*expression* *expr* *E15* *eval*

Using expressions is introduced in chapter 41 of the user manual |usr_41.txt|.

Note: Expression evaluation can be disabled at compile time.  If this has been
done, the features in this document are not available.	See |+eval| and
|no-eval-feature|.

1.  Variables			|variables|
    1.1 Variable types
    1.2 Function references		|Funcref|
    1.3 Lists				|Lists|
    1.4 Dictionaries			|Dictionaries|
    1.5 More about variables		|more-variables|
2.  Expression syntax		|expression-syntax|
3.  Internal variable		|internal-variables|
4.  Builtin Functions		|functions|
5.  Defining functions		|user-functions|
6.  Curly braces names		|curly-braces-names|
7.  Commands			|expression-commands|
8.  Exception handling		|exception-handling|
9.  Examples			|eval-examples|
10. No +eval feature		|no-eval-feature|
11. The sandbox			|eval-sandbox|
12. Textlock			|textlock|

==============================================================================
1. Variables						*variables*

1.1 Variable types ~
							*E712*
There are six types of variables:

Number		A 32 or 64 bit signed number.  |expr-number| *Number*
		Examples:  -123  0x10  0177

Float		A floating point number. |floating-point-format| *Float*
		Examples: 123.456  1.15e-6  -1.1e3

							*E928*
String		A NUL terminated string of 8-bit unsigned characters (bytes).
		|expr-string| Examples: "ab\txx\"--"  'x-z''a,c'

Funcref		A reference to a function |Funcref|.
		Example: function("strlen")

List		An ordered sequence of items |List|.
		Example: [1, 2, ['a', 'b']]

Dictionary	An associative, unordered array: Each entry has a key and a
		value. |Dictionary|
		Example: {'blue': "#0000ff", 'red': "#ff0000"}

The Number and String types are converted automatically, depending on how they
are used.

Conversion from a Number to a String is by making the ASCII representation of
the Number.  Examples:
	Number 123	-->	String "123" ~
	Number 0	-->	String "0" ~
	Number -1	-->	String "-1" ~
							*octal*
Conversion from a String to a Number is done by converting the first digits to
a number.  Hexadecimal "0xf9", Octal "017", and Binary "0b10" numbers are
recognized.  If the String doesn't start with digits, the result is zero.
Examples:
	String "456"	-->	Number 456 ~
	String "6bar"	-->	Number 6 ~
	String "foo"	-->	Number 0 ~
	String "0xf1"	-->	Number 241 ~
	String "0100"	-->	Number 64 ~
	String "0b101"	-->	Number 5 ~
	String "-8"	-->	Number -8 ~
	String "+8"	-->	Number 0 ~

To force conversion from String to Number, add zero to it: >
	:echo "0100" + 0
<	64 ~

To avoid a leading zero to cause octal conversion, or for using a different
base, use |str2nr()|.

For boolean operators Numbers are used.  Zero is FALSE, non-zero is TRUE.

Note that in the command >
	:if "foo"
"foo" is converted to 0, which means FALSE.  To test for a non-empty string,
use empty(): >
	:if !empty("foo")
<				*E745* *E728* *E703* *E729* *E730* *E731*
List, Dictionary and Funcref types are not automatically converted.

							*E805* *E806* *E808*
When mixing Number and Float the Number is converted to Float.	Otherwise
there is no automatic conversion of Float.  You can use str2float() for String
to Float, printf() for Float to String and float2nr() for Float to Number.

						*E891* *E892* *E893* *E894*
When expecting a Float a Number can also be used, but nothing else.

					*no-type-checking*
You will not get an error if you try to change the type of a variable.
	
1.2 Function references ~
					*Funcref* *E695* *E718*
A Funcref variable is obtained with the |function()| function.	It can be used
in an expression in the place of a function name, before the parenthesis
around the arguments, to invoke the function it refers to.  Example: >

	:let Fn = function("MyFunc")
	:echo Fn()
<							*E704* *E705* *E707*
A Funcref variable must start with a capital, "s:", "w:", "t:" or "b:".  You
can use "g:" but the following name must still start with a capital.  You
cannot have both a Funcref variable and a function with the same name.

A special case is defining a function and directly assigning its Funcref to a
Dictionary entry.  Example: >
	:function dict.init() dict
	:   let self.val = 0
	:endfunction

The key of the Dictionary can start with a lower case letter.  The actual
function name is not used here.  Also see |numbered-function|.

A Funcref can also be used with the |:call| command: >
	:call Fn()
	:call dict.init()

The name of the referenced function can be obtained with |string()|. >
	:let func = string(Fn)

You can use |call()| to invoke a Funcref and use a list variable for the
arguments: >
	:let r = call(Fn, mylist)


1.3 Lists ~
						*list* *List* *Lists* *E686*
A List is an ordered sequence of items.  An item can be of any type.  Items
can be accessed by their index number.	Items can be added and removed at any
position in the sequence.


List creation ~
							*E696* *E697*
A List is created with a comma separated list of items in square brackets.
Examples: >
	:let mylist = [1, two, 3, "four"]
	:let emptylist = []

An item can be any expression.	Using a List for an item creates a
List of Lists: >
	:let nestlist = [[11, 12], [21, 22], [31, 32]]

An extra comma after the last item is ignored.


List index ~
							*list-index* *E684*
An item in the List can be accessed by putting the index in square brackets
after the List.  Indexes are zero-based, thus the first item has index zero. >
	:let item = mylist[0]		" get the first item: 1
	:let item = mylist[2]		" get the third item: 3

When the resulting item is a list this can be repeated: >
	:let item = nestlist[0][1]	" get the first list, second item: 12
<
A negative index is counted from the end.  Index -1 refers to the last item in
the List, -2 to the last but one item, etc. >
	:let last = mylist[-1]		" get the last item: "four"

To avoid an error for an invalid index use the |get()| function.  When an item
is not available it returns zero or the default value you specify: >
	:echo get(mylist, idx)
	:echo get(mylist, idx, "NONE")


List concatenation ~

Two lists can be concatenated with the "+" operator: >
	:let longlist = mylist + [5, 6]
	:let mylist += [7, 8]

To prepend or append an item turn the item into a list by putting [] around
it.  To change a list in-place see |list-modification| below.


Sublist ~

A part of the List can be obtained by specifying the first and last index,
separated by a colon in square brackets: >
	:let shortlist = mylist[2:-1]	" get List [3, "four"]

Omitting the first index is similar to zero.  Omitting the last index is
similar to -1. >
	:let endlist = mylist[2:]	" from item 2 to the end: [3, "four"]
	:let shortlist = mylist[2:2]	" List with one item: [3]
	:let otherlist = mylist[:]	" make a copy of the List

If the first index is beyond the last item of the List or the second item is
before the first item, the result is an empty list.  There is no error
message.

If the second index is equal to or greater than the length of the list the
length minus one is used: >
	:let mylist = [0, 1, 2, 3]
	:echo mylist[2:8]		" result: [2, 3]

NOTE: mylist[s:e] means using the variable "s:e" as index.  Watch out for
using a single letter variable before the ":".	Insert a space when needed:
mylist[s : e].


List identity ~
							*list-identity*
When variable "aa" is a list and you assign it to another variable "bb", both
variables refer to the same list.  Thus changing the list "aa" will also
change "bb": >
	:let aa = [1, 2, 3]
	:let bb = aa
	:call add(aa, 4)
	:echo bb
<	[1, 2, 3, 4]

Making a copy of a list is done with the |copy()| function.  Using [:] also
works, as explained above.  This creates a shallow copy of the list: Changing
a list item in the list will also change the item in the copied list: >
	:let aa = [[1, 'a'], 2, 3]
	:let bb = copy(aa)
	:call add(aa, 4)
	:let aa[0][1] = 'aaa'
	:echo aa
<	[[1, aaa], 2, 3, 4] >
	:echo bb
<	[[1, aaa], 2, 3]

To make a completely independent list use |deepcopy()|.  This also makes a
copy of the values in the list, recursively.  Up to a hundred levels deep.

The operator "is" can be used to check if two variables refer to the same
List.  "isnot" does the opposite.  In contrast "==" compares if two lists have
the same value. >
	:let alist = [1, 2, 3]
	:let blist = [1, 2, 3]
	:echo alist is blist
<	0 >
	:echo alist == blist
<	1

Note about comparing lists: Two lists are considered equal if they have the
same length and all items compare equal, as with using "==".  There is one
exception: When comparing a number with a string they are considered
different.  There is no automatic type conversion, as with using "==" on
variables.  Example: >
	echo 4 == "4"
<	1 >
	echo [4] == ["4"]
<	0

Thus comparing Lists is more strict than comparing numbers and strings.  You
can compare simple values this way too by putting them in a list: >

	:let a = 5
	:let b = "5"
	:echo a == b
<	1 >
	:echo [a] == [b]
<	0


List unpack ~

To unpack the items in a list to individual variables, put the variables in
square brackets, like list items: >
	:let [var1, var2] = mylist

When the number of variables does not match the number of items in the list
this produces an error.  To handle any extra items from the list append ";"
and a variable name: >
	:let [var1, var2; rest] = mylist

This works like: >
	:let var1 = mylist[0]
	:let var2 = mylist[1]
	:let rest = mylist[2:]

Except that there is no error if there are only two items.  "rest" will be an
empty list then.


List modification ~
							*list-modification*
To change a specific item of a list use |:let| this way: >
	:let list[4] = "four"
	:let listlist[0][3] = item

To change part of a list you can specify the first and last item to be
modified.  The value must at least have the number of items in the range: >
	:let list[3:5] = [3, 4, 5]

Adding and removing items from a list is done with functions.  Here are a few
examples: >
	:call insert(list, 'a')		" prepend item 'a'
	:call insert(list, 'a', 3)	" insert item 'a' before list[3]
	:call add(list, "new")		" append String item
	:call add(list, [1, 2])		" append a List as one new item
	:call extend(list, [1, 2])	" extend the list with two more items
	:let i = remove(list, 3)	" remove item 3
	:unlet list[3]			" idem
	:let l = remove(list, 3, -1)	" remove items 3 to last item
	:unlet list[3 : ]		" idem
	:call filter(list, 'v:val !~ "x"')  " remove items with an 'x'

Changing the order of items in a list: >
	:call sort(list)		" sort a list alphabetically
	:call reverse(list)		" reverse the order of items
	:call uniq(sort(list))		" sort and remove duplicates


For loop ~

The |:for| loop executes commands for each item in a list.  A variable is set
to each item in the list in sequence.  Example: >
	:for item in mylist
	:   call Doit(item)
	:endfor

This works like: >
	:let index = 0
	:while index < len(mylist)
	:   let item = mylist[index]
	:   :call Doit(item)
	:   let index = index + 1
	:endwhile

Note that all items in the list should be of the same type, otherwise this
results in error |E706|.  To avoid this |:unlet| the variable at the end of
the loop.

If all you want to do is modify each item in the list then the |map()|
function will be a simpler method than a for loop.

Just like the |:let| command, |:for| also accepts a list of variables.	This
requires the argument to be a list of lists. >
	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]
	:   call Doit(lnum, col)
	:endfor

This works like a |:let| command is done for each list item.  Again, the types
must remain the same to avoid an error.

It is also possible to put remaining items in a List variable: >
	:for [i, j; rest] in listlist
	:   call Doit(i, j)
	:   if !empty(rest)
	:      echo "remainder: " . string(rest)
	:   endif
	:endfor


List functions ~
						*E714*
Functions that are useful with a List: >
	:let r = call(funcname, list)	" call a function with an argument list
	:if empty(list)			" check if list is empty
	:let l = len(list)		" number of items in list
	:let big = max(list)		" maximum value in list
	:let small = min(list)		" minimum value in list
	:let xs = count(list, 'x')	" count nr of times 'x' appears in list
	:let i = index(list, 'x')	" index of first 'x' in list
	:let lines = getline(1, 10)	" get ten text lines from buffer
	:call append('$', lines)	" append text lines in buffer
	:let list = split("a b c")	" create list from items in a string
	:let string = join(list, ', ')	" create string from list items
	:let s = string(list)		" String representation of list
	:call map(list, '">> " . v:val')  " prepend ">> " to each item

Don't forget that a combination of features can make things simple.  For
example, to add up all the numbers in a list: >
	:exe 'let sum = ' . join(nrlist, '+')


1.4 Dictionaries ~
				 *Dict* *dict* *Dictionaries* *Dictionary*
A Dictionary is an associative array: Each entry has a key and a value.  The
entry can be located with the key.  The entries are stored without a specific
ordering.


Dictionary creation ~
						*E720* *E721* *E722* *E723*
A Dictionary is created with a comma separated list of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once.  Examples: >
	:let mydict = {1: 'one', 2: 'two', 3: 'three'}
	:let emptydict = {}
<							*E713* *E716* *E717*
A key is always a String.  You can use a Number, it will be converted to a
String automatically.  Thus the String '4' and the number 4 will find the same
entry.	Note that the String '04' and the Number 04 are different, since the
Number will be converted to the String '4'.  The empty string can be used as a
key.

A value can be any expression.	Using a Dictionary for a value creates a
nested Dictionary: >
	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}

An extra comma after the last entry is ignored.


Accessing entries ~

The normal way to access an entry is by putting the key in square brackets: >
	:let val = mydict["one"]
	:let mydict["four"] = 4

You can add new entries to an existing Dictionary this way, unlike Lists.

For keys that consist entirely of letters, digits and underscore the following
form can be used |expr-entry|: >
	:let val = mydict.one
	:let mydict.four = 4

Since an entry can be any type, also a List and a Dictionary, the indexing and
key lookup can be repeated: >
	:echo dict.key[idx].key


Dictionary to List conversion ~

You may want to loop over the entries in a dictionary.	For this you need to
turn the Dictionary into a List and pass it to |:for|.

Most often you want to loop over the keys, using the |keys()| function: >
	:for key in keys(mydict)
	:   echo key . ': ' . mydict[key]
	:endfor

The List of keys is unsorted.  You may want to sort them first: >
	:for key in sort(keys(mydict))

To loop over the values use the |values()| function:  >
	:for v in values(mydict)
	:   echo "value: " . v
	:endfor

If you want both the key and the value use the |items()| function.  It returns
a List in which each item is a	List with two items, the key and the value: >
	:for [key, value] in items(mydict)
	:   echo key . ': ' . value
	:endfor


Dictionary identity ~
							*dict-identity*
Just like Lists you need to use |copy()| and |deepcopy()| to make a copy of a
Dictionary.  Otherwise, assignment results in referring to the same
Dictionary: >
	:let onedict = {'a': 1, 'b': 2}
	:let adict = onedict
	:let adict['a'] = 11
	:echo onedict['a']
	11

Two Dictionaries compare equal if all the key-value pairs compare equal.  For
more info see |list-identity|.


Dictionary modification ~
							*dict-modification*
To change an already existing entry of a Dictionary, or to add a new entry,
use |:let| this way: >
	:let dict[4] = "four"
	:let dict['one'] = item

Removing an entry from a Dictionary is done with |remove()| or |:unlet|.
Three ways to remove the entry with key "aaa" from dict: >
	:let i = remove(dict, 'aaa')
	:unlet dict.aaa
	:unlet dict['aaa']

Merging a Dictionary with another is done with |extend()|: >
	:call extend(adict, bdict)
This extends adict with all entries from bdict.  Duplicate keys cause entries
in adict to be overwritten.  An optional third argument can change this.
Note that the order of entries in a Dictionary is irrelevant, thus don't
expect ":echo adict" to show the items from bdict after the older entries in
adict.

Weeding out entries from a Dictionary can be done with |filter()|: >
	:call filter(dict, 'v:val =~ "x"')
This removes all entries from "dict" with a value not matching 'x'.


Dictionary function ~
				*Dictionary-function* *self* *E725* *E862*
When a function is defined with the "dict" attribute it can be used in a
special way with a dictionary.	Example: >
	:function Mylen() dict
	:   return len(self.data)
	:endfunction
	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}
	:echo mydict.len()

This is like a method in object oriented programming.  The entry in the
Dictionary is a |Funcref|.  The local variable "self" refers to the dictionary
the function was invoked from.

It is also possible to add a function without the "dict" attribute as a
Funcref to a Dictionary, but the "self" variable is not available then.

				*numbered-function* *anonymous-function*
To avoid the extra name for the function it can be defined and directly
assigned to a Dictionary in this way: >
	:let mydict = {'data': [0, 1, 2, 3]}
	:function mydict.len()
	:   return len(self.data)
	:endfunction
	:echo mydict.len()

The function will then get a number and the value of dict.len is a |Funcref|
that references this function.	The function can only be used through a
|Funcref|.  It will automatically be deleted when there is no |Funcref|
remaining that refers to it.

It is not necessary to use the "dict" attribute for a numbered function.

If you get an error for a numbered function, you can find out what it is with
a trick.  Assuming the function is 42, the command is: >
	:function {42}


Functions for Dictionaries ~
							*E715*
Functions that can be used with a Dictionary: >
	:if has_key(dict, 'foo')	" TRUE if dict has entry with key "foo"
	:if empty(dict)			" TRUE if dict is empty
	:let l = len(dict)		" number of items in dict
	:let big = max(dict)		" maximum value in dict
	:let small = min(dict)		" minimum value in dict
	:let xs = count(dict, 'x')	" count nr of times 'x' appears in dict
	:let s = string(dict)		" String representation of dict
	:call map(dict, '">> " . v:val')  " prepend ">> " to each item


1.5 More about variables ~
							*more-variables*
If you need to know the type of a variable or expression, use the |type()|
function.

When the '!' flag is included in the 'shada' option, global variables that
start with an uppercase letter, and don't contain a lowercase letter, are
stored in the shada file |shada-file|.

When the 'sessionoptions' option contains "global", global variables that
start with an uppercase letter and contain at least one lowercase letter are
stored in the session file |session-file|.

variable name		can be stored where ~
my_var_6		not
My_Var_6		session file
MY_VAR_6		shada file


It's possible to form a variable name with curly braces, see
|curly-braces-names|.

==============================================================================
2. Expression syntax					*expression-syntax*

Expression syntax summary, from least to most significant:

|expr1| expr2 ? expr1 : expr1	if-then-else

|expr2|	expr3 || expr3 ..	logical OR

|expr3|	expr4 && expr4 ..	logical AND

|expr4|	expr5 == expr5		equal
	expr5 != expr5		not equal
	expr5 >	 expr5		greater than
	expr5 >= expr5		greater than or equal
	expr5 <	 expr5		smaller than
	expr5 <= expr5		smaller than or equal
	expr5 =~ expr5		regexp matches
	expr5 !~ expr5		regexp doesn't match

	expr5 ==? expr5		equal, ignoring case
	expr5 ==# expr5		equal, match case
	etc.			As above, append ? for ignoring case, # for
				matching case

	expr5 is expr5		same |List| instance
	expr5 isnot expr5	different |List| instance

|expr5|	expr6 +	 expr6 ..	number addition or list concatenation
	expr6 -	 expr6 ..	number subtraction
	expr6 .	 expr6 ..	string concatenation

|expr6|	expr7 *	 expr7 ..	number multiplication
	expr7 /	 expr7 ..	number division
	expr7 %	 expr7 ..	number modulo

|expr7|	! expr7			logical NOT
	- expr7			unary minus
	+ expr7			unary plus

|expr8|	expr8[expr1]		byte of a String or item of a |List|
	expr8[expr1 : expr1]	substring of a String or sublist of a |List|
	expr8.name		entry in a |Dictionary|
	expr8(expr1, ...)	function call with |Funcref| variable

|expr9| number			number constant
	"string"		string constant, backslash is special
	'string'		string constant, ' is doubled
	[expr1, ...]		|List|
	{expr1: expr1, ...}	|Dictionary|
	&option			option value
	(expr1)			nested expression
	variable		internal variable
	va{ria}ble		internal variable with curly braces
	$VAR			environment variable
	@r			contents of register 'r'
	function(expr1, ...)	function call
	func{ti}on(expr1, ...)	function call with curly braces


".." indicates that the operations in this level can be concatenated.
Example: >
	&nu || &list && &shell == "csh"

All expressions within one level are parsed from left to right.


expr1							*expr1* *E109*
-----

expr2 ? expr1 : expr1

The expression before the '?' is evaluated to a number.  If it evaluates to
non-zero, the result is the value of the expression between the '?' and ':',
otherwise the result is the value of the expression after the ':'.
Example: >
	:echo lnum == 1 ? "top" : lnum

Since the first expression is an "expr2", it cannot contain another ?:.  The
other two expressions can, thus allow for recursive use of ?:.
Example: >
	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum

To keep this readable, using |line-continuation| is suggested: >
	:echo lnum == 1
	:\	? "top"
	:\	: lnum == 1000
	:\		? "last"
	:\		: lnum

You should always put a space before the ':', otherwise it can be mistaken for
use in a variable such as "a:1".


expr2 and expr3						*expr2* *expr3*
---------------

					*expr-barbar* *expr-&&*
The "||" and "&&" operators take one argument on each side.  The arguments
are (converted to) Numbers.  The result is:

	 input				 output ~
n1		n2		n1 || n2	n1 && n2 ~
zero		zero		zero		zero
zero		non-zero	non-zero	zero
non-zero	zero		non-zero	zero
non-zero	non-zero	non-zero	non-zero

The operators can be concatenated, for example: >

	&nu || &list && &shell == "csh"

Note that "&&" takes precedence over "||", so this has the meaning of: >

	&nu || (&list && &shell == "csh")

Once the result is known, the expression "short-circuits", that is, further
arguments are not evaluated.  This is like what happens in C.  For example: >

	let a = 1
	echo a || b

This is valid even if there is no variable called "b" because "a" is non-zero,
so the result must be non-zero.  Similarly below: >

	echo exists("b") && b == "yes"

This is valid whether "b" has been defined or not.  The second clause will
only be evaluated if "b" has been defined.


expr4							*expr4*
-----

expr5 {cmp} expr5

Compare two expr5 expressions, resulting in a 0 if it evaluates to false, or 1
if it evaluates to true.

			*expr-==*  *expr-!=*  *expr->*	 *expr->=*
			*expr-<*   *expr-<=*  *expr-=~*  *expr-!~*
			*expr-==#* *expr-!=#* *expr->#*  *expr->=#*
			*expr-<#*  *expr-<=#* *expr-=~#* *expr-!~#*
			*expr-==?* *expr-!=?* *expr->?*  *expr->=?*
			*expr-<?*  *expr-<=?* *expr-=~?* *expr-!~?*
			*expr-is* *expr-isnot* *expr-is#* *expr-isnot#*
			*expr-is?* *expr-isnot?*
		use 'ignorecase'    match case	   ignore case ~
equal			==		==#		==?
not equal		!=		!=#		!=?
greater than		>		>#		>?
greater than or equal	>=		>=#		>=?
smaller than		<		<#		<?
smaller than or equal	<=		<=#		<=?
regexp matches		=~		=~#		=~?
regexp doesn't match	!~		!~#		!~?
same instance		is		is#		is?
different instance	isnot		isnot#		isnot?

Examples:
"abc" ==# "Abc"	  evaluates to 0
"abc" ==? "Abc"	  evaluates to 1
"abc" == "Abc"	  evaluates to 1 if 'ignorecase' is set, 0 otherwise

							*E691* *E692*
A |List| can only be compared with a |List| and only "equal", "not equal" and
"is" can be used.  This compares the values of the list, recursively.
Ignoring case means case is ignored when comparing item values.

							*E735* *E736*
A |Dictionary| can only be compared with a |Dictionary| and only "equal", "not
equal" and "is" can be used.  This compares the key/values of the |Dictionary|
recursively.  Ignoring case means case is ignored when comparing item values.

							*E693* *E694*
A |Funcref| can only be compared with a |Funcref| and only "equal" and "not
equal" can be used.  Case is never ignored.

When using "is" or "isnot" with a |List| or a |Dictionary| this checks if the
expressions are referring to the same |List| or |Dictionary| instance.  A copy
of a |List| is different from the original |List|.  When using "is" without
a |List| or a |Dictionary| it is equivalent to using "equal", using "isnot"
equivalent to using "not equal".  Except that a different type means the
values are different: >
	echo 4 == '4'
	1
	echo 4 is '4'
	0
	echo 0 is []
	0
"is#"/"isnot#" and "is?"/"isnot?" can be used to match and ignore case.

When comparing a String with a Number, the String is converted to a Number,
and the comparison is done on Numbers. This means that: >
	echo 0 == 'x'
	1
because 'x' converted to a Number is zero. However: >
	echo 0 == 'x'
	0
Inside a List or Dictionary this conversion is not used.

When comparing two Strings, this is done with strcmp() or stricmp().  This
results in the mathematical difference (comparing byte values), not
necessarily the alphabetical difference in the local language.

When using the operators with a trailing '#', or the short version and
'ignorecase' is off, the comparing is done with strcmp(): case matters.

When using the operators with a trailing '?', or the short version and
'ignorecase' is set, the comparing is done with stricmp(): case is ignored.

'smartcase' is not used.

The "=~" and "!~" operators match the lefthand argument with the righthand
argument, which is used as a pattern.  See |pattern| for what a pattern is.
This matching is always done like 'magic' was set and 'cpoptions' is empty, no
matter what the actual value of 'magic' or 'cpoptions' is.  This makes scripts
portable.  To avoid backslashes in the regexp pattern to be doubled, use a
single-quote string, see |literal-string|.
Since a string is considered to be a single line, a multi-line pattern
(containing \n, backslash-n) will not match.  However, a literal NL character
can be matched like an ordinary character.  Examples:
	"foo\nbar" =~ "\n"	evaluates to 1
	"foo\nbar" =~ "\\n"	evaluates to 0


expr5 and expr6						*expr5* *expr6*
---------------
expr6 +	 expr6 ..	Number addition or |List| concatenation	*expr-+*
expr6 -	 expr6 ..	Number subtraction			*expr--*
expr6 .	 expr6 ..	String concatenation			*expr-.*

For |Lists| only "+" is possible and then both expr6 must be a list.  The
result is a new list with the two lists Concatenated.

expr7 *	 expr7 ..	Number multiplication			*expr-star*
expr7 /	 expr7 ..	Number division				*expr-/*
expr7 %	 expr7 ..	Number modulo				*expr-%*

For all, except ".", Strings are converted to Numbers.
For bitwise operators see |and()|, |or()| and |xor()|.

Note the difference between "+" and ".":
	"123" + "456" = 579
	"123" . "456" = "123456"

Since '.' has the same precedence as '+' and '-', you need to read: >
	1 . 90 + 90.0
As: >
	(1 . 90) + 90.0
That works, since the String "190" is automatically converted to the Number
190, which can be added to the Float 90.0.  However: >
	1 . 90 * 90.0
Should be read as: >
	1 . (90 * 90.0)
Since '.' has lower precedence than '*'.  This does NOT work, since this
attempts to concatenate a Float and a String.

When dividing a Number by zero the result depends on the value:
	  0 / 0  = -0x80000000	(like NaN for Float)
	 >0 / 0  =  0x7fffffff	(like positive infinity)
	 <0 / 0  = -0x7fffffff	(like negative infinity)
	(before Vim 7.2 it was always 0x7fffffff)

When the righthand side of '%' is zero, the result is 0.

None of these work for |Funcref|s.

. and % do not work for Float. *E804*


expr7							*expr7*
-----
! expr7			logical NOT		*expr-!*
- expr7			unary minus		*expr-unary--*
+ expr7			unary plus		*expr-unary-+*

For '!' non-zero becomes zero, zero becomes one.
For '-' the sign of the number is changed.
For '+' the number is unchanged.

A String will be converted to a Number first.

These three can be repeated and mixed.	Examples:
	!-1	    == 0
	!!8	    == 1
	--9	    == 9


expr8							*expr8*
-----
expr8[expr1]		item of String or |List|	*expr-[]* *E111*
							*subscript*

If expr8 is a Number or String this results in a String that contains the
expr1'th single byte from expr8.  expr8 is used as a String, expr1 as a
Number.  This doesn't recognize multi-byte encodings, see |byteidx()| for
an alternative, or use `split()` to turn the string into a list of characters.

Index zero gives the first byte.  This is like it works in C.  Careful:
text column numbers start with one!  Example, to get the byte under the
cursor: >
	:let c = getline(".")[col(".") - 1]

If the length of the String is less than the index, the result is an empty
String.  A negative index always results in an empty string (reason: backward
compatibility).  Use [-1:] to get the last byte.

If expr8 is a |List| then it results the item at index expr1.  See |list-index|
for possible index values.  If the index is out of range this results in an
error.	Example: >
	:let item = mylist[-1]		" get last item

Generally, if a |List| index is equal to or higher than the length of the
|List|, or more negative than the length of the |List|, this results in an
error.


expr8[expr1a : expr1b]	substring or sublist		*expr-[:]*

If expr8 is a Number or String this results in the substring with the bytes
from expr1a to and including expr1b.  expr8 is used as a String, expr1a and
expr1b are used as a Number.  This doesn't recognize multi-byte encodings, see
|byteidx()| for computing the indexes.

If expr1a is omitted zero is used.  If expr1b is omitted the length of the
string minus one is used.

A negative number can be used to measure from the end of the string.  -1 is
the last character, -2 the last but one, etc.

If an index goes out of range for the string characters are omitted.  If
expr1b is smaller than expr1a the result is an empty string.

Examples: >
	:let c = name[-1:]		" last byte of a string
	:let c = name[-2:-2]		" last but one byte of a string
	:let s = line(".")[4:]		" from the fifth byte to the end
	:let s = s[:-3]			" remove last two bytes
<
							*sublist* *slice*
If expr8 is a |List| this results in a new |List| with the items indicated by
the indexes expr1a and expr1b.	This works like with a String, as explained
just above, except that indexes out of range cause an error.  Examples: >
	:let l = mylist[:3]		" first four items
	:let l = mylist[4:4]		" List with one item
	:let l = mylist[:]		" shallow copy of a List

Using expr8[expr1] or expr8[expr1a : expr1b] on a |Funcref| results in an
error.

Watch out for confusion between a namespace and a variable followed by a colon
for a sublist: >
	mylist[n:]     " uses variable n
	mylist[s:]     " uses namespace s:, error!


expr8.name		entry in a |Dictionary|		*expr-entry*

If expr8 is a |Dictionary| and it is followed by a dot, then the following
name will be used as a key in the |Dictionary|.  This is just like:
expr8[name].

The name must consist of alphanumeric characters, just like a variable name,
but it may start with a number.  Curly braces cannot be used.

There must not be white space before or after the dot.

Examples: >
	:let dict = {"one": 1, 2: "two"}
	:echo dict.one
	:echo dict .2

Note that the dot is also used for String concatenation.  To avoid confusion
always put spaces around the dot for String concatenation.


expr8(expr1, ...)	|Funcref| function call

When expr8 is a |Funcref| type variable, invoke the function it refers to.



							*expr9*
number
------
number			number constant			*expr-number* 
						*hex-number* *octal-number*

Decimal, Hexadecimal (starting with 0x or 0X), or Octal (starting with 0).

						*floating-point-format*
Floating point numbers can be written in two forms:

	[-+]{N}.{M}
	[-+]{N}.{M}[eE][-+]{exp}

{N} and {M} are numbers.  Both {N} and {M} must be present and can only
contain digits.
[-+] means there is an optional plus or minus sign.
{exp} is the exponent, power of 10.
Only a decimal point is accepted, not a comma.	No matter what the current
locale is.

Examples:
	123.456
	+0.0001
	55.0
	-0.123
	1.234e03
	1.0E-6
	-3.1416e+88

These are INVALID:
	3.		empty {M}
	1e40		missing .{M}

							*float-pi* *float-e*
A few useful values to copy&paste: >
	:let pi = 3.14159265359
	:let e  = 2.71828182846

Rationale:
Before floating point was introduced, the text "123.456" was interpreted as
the two numbers "123" and "456", both converted to a string and concatenated,
resulting in the string "123456".  Since this was considered pointless, and we
could not find it intentionally being used in Vim scripts, this backwards
incompatibility was accepted in favor of being able to use the normal notation
for floating point numbers.

						*floating-point-precision*
The precision and range of floating points numbers depends on what "double"
means in the library Vim was compiled with.  There is no way to change this at
runtime.

The default for displaying a |Float| is to use 6 decimal places, like using
printf("%g", f).  You can select something else when using the |printf()|
function.  Example: >
	:echo printf('%.15e', atan(1))
<	7.853981633974483e-01



string					*string* *String* *expr-string* *E114*
------
"string"		string constant		*expr-quote*

Note that double quotes are used.

A string constant accepts these special characters:
\...	three-digit octal number (e.g., "\316")
\..	two-digit octal number (must be followed by non-digit)
\.	one-digit octal number (must be followed by non-digit)
\x..	byte specified with two hex numbers (e.g., "\x1f")
\x.	byte specified with one hex number (must be followed by non-hex char)
\X..	same as \x..
\X.	same as \x.
\u....	character specified with up to 4 hex numbers, stored as UTF-8
	(e.g., "\u02a4")
\U....	same as \u but allows up to 8 hex numbers.
\b	backspace <BS>
\e	escape <Esc>
\f	formfeed <FF>
\n	newline <NL>
\r	return <CR>
\t	tab <Tab>
\\	backslash
\"	double quote
\<xxx>	Special key named "xxx".  e.g. "\<C-W>" for CTRL-W.  This is for use
	in mappings, the 0x80 byte is escaped.  Don't use <Char-xxxx> to get a
	utf-8 character, use \uxxxx as mentioned above.

Note that "\xff" is stored as the byte 255, which may be invalid in some
encodings.  Use "\u00ff" to store character 255 correctly as UTF-8.

Note that "\000" and "\x00" force the end of the string.


literal-string						*literal-string* *E115*
---------------
'string'		string constant			*expr-'*

Note that single quotes are used.

This string is taken as it is.	No backslashes are removed or have a special
meaning.  The only exception is that two quotes stand for one quote.

Single quoted strings are useful for patterns, so that backslashes do not need
to be doubled.	These two commands are equivalent: >
	if a =~ "\\s*"
	if a =~ '\s*'


option						*expr-option* *E112* *E113*
------
&option			option value, local value if possible
&g:option		global option value
&l:option		local option value

Examples: >
	echo "tabstop is " . &tabstop
	if &insertmode

Any option name can be used here.  See |options|.  When using the local value
and there is no buffer-local or window-local value, the global value is used
anyway.


register						*expr-register* *@r*
--------
@r			contents of register 'r'

The result is the contents of the named register, as a single string.
Newlines are inserted where required.  To get the contents of the unnamed
register use @" or @@.	See |registers| for an explanation of the available
registers.

When using the '=' register you get the expression itself, not what it
evaluates to.  Use |eval()| to evaluate it.


nesting							*expr-nesting* *E110*
-------
(expr1)			nested expression


environment variable					*expr-env*
--------------------
$VAR			environment variable

The String value of any environment variable.  When it is not defined, the
result is an empty string.
						*expr-env-expand*
Note that there is a difference between using $VAR directly and using
expand("$VAR").  Using it directly will only expand environment variables that
are known inside the current Vim session.  Using expand() will first try using
the environment variables known inside the current Vim session.  If that
fails, a shell will be used to expand the variable.  This can be slow, but it
does expand all variables that the shell knows about.  Example: >
	:echo $shell
	:echo expand("$shell")
The first one probably doesn't echo anything, the second echoes the $shell
variable (if your shell supports it).


internal variable					*expr-variable*
-----------------
variable		internal variable
See below |internal-variables|.


function call		*expr-function* *E116* *E118* *E119* *E120*
-------------
function(expr1, ...)	function call
See below |functions|.


==============================================================================
3. Internal variable				*internal-variables* *E461*

An internal variable name can be made up of letters, digits and '_'.  But it
cannot start with a digit.  It's also possible to use curly braces, see
|curly-braces-names|.

An internal variable is created with the ":let" command |:let|.
An internal variable is explicitly destroyed with the ":unlet" command
|:unlet|.
Using a name that is not an internal variable or refers to a variable that has
been destroyed results in an error.

There are several name spaces for variables.  Which one is to be used is
specified by what is prepended:

		(nothing) In a function: local to a function; otherwise: global
|buffer-variable|    b:	  Local to the current buffer.
|window-variable|    w:	  Local to the current window.
|tabpage-variable|   t:	  Local to the current tab page.
|global-variable|    g:	  Global.
|local-variable|     l:	  Local to a function.
|script-variable|    s:	  Local to a |:source|'ed Vim script.
|function-argument|  a:	  Function argument (only inside a function).
|vim-variable|       v:	  Global, predefined by Vim.

The scope name by itself can be used as a |Dictionary|.  For example, to
delete all script-local variables: >
	:for k in keys(s:)
	:    unlet s:[k]
	:endfor
<
						*buffer-variable* *b:var* *b:*
A variable name that is preceded with "b:" is local to the current buffer.
Thus you can have several "b:foo" variables, one for each buffer.
This kind of variable is deleted when the buffer is wiped out or deleted with
|:bdelete|.

One local buffer variable is predefined:
					*b:changedtick* *changetick*
b:changedtick	The total number of changes to the current buffer.  It is
		incremented for each change.  An undo command is also a change
		in this case.  This can be used to perform an action only when
		the buffer has changed.  Example: >
		    :if my_changedtick != b:changedtick
		    :	let my_changedtick = b:changedtick
		    :	call My_Update()
		    :endif
<
						*window-variable* *w:var* *w:*
A variable name that is preceded with "w:" is local to the current window.  It
is deleted when the window is closed.

						*tabpage-variable* *t:var* *t:*
A variable name that is preceded with "t:" is local to the current tab page,
It is deleted when the tab page is closed. {not available when compiled
without the |+windows| feature}

						*global-variable* *g:var* *g:*
Inside functions global variables are accessed with "g:".  Omitting this will
access a variable local to a function.	But "g:" can also be used in any other
place if you like.

						*local-variable* *l:var* *l:*
Inside functions local variables are accessed without prepending anything.
But you can also prepend "l:" if you like.  However, without prepending "l:"
you may run into reserved variable names.  For example "count".  By itself it
refers to "v:count".  Using "l:count" you can have a local variable with the
same name.

						*script-variable* *s:var*
In a Vim script variables starting with "s:" can be used.  They cannot be
accessed from outside of the scripts, thus are local to the script.

They can be used in:
- commands executed while the script is sourced
- functions defined in the script
- autocommands defined in the script
- functions and autocommands defined in functions and autocommands which were
  defined in the script (recursively)
- user defined commands defined in the script
Thus not in:
- other scripts sourced from this one
- mappings
- menus
- etc.

Script variables can be used to avoid conflicts with global variable names.
Take this example: >

	let s:counter = 0
	function MyCounter()
	  let s:counter = s:counter + 1
	  echo s:counter
	endfunction
	command Tick call MyCounter()

You can now invoke "Tick" from any script, and the "s:counter" variable in
that script will not be changed, only the "s:counter" in the script where
"Tick" was defined is used.

Another example that does the same: >

	let s:counter = 0
	command Tick let s:counter = s:counter + 1 | echo s:counter

When calling a function and invoking a user-defined command, the context for
script variables is set to the script where the function or command was
defined.

The script variables are also available when a function is defined inside a
function that is defined in a script.  Example: >

	let s:counter = 0
	function StartCounting(incr)
	  if a:incr
	    function MyCounter()
	      let s:counter = s:counter + 1
	    endfunction
	  else
	    function MyCounter()
	      let s:counter = s:counter - 1
	    endfunction
	  endif
	endfunction

This defines the MyCounter() function either for counting up or counting down
when calling StartCounting().  It doesn't matter from where StartCounting() is
called, the s:counter variable will be accessible in MyCounter().

When the same script is sourced again it will use the same script variables.
They will remain valid as long as Vim is running.  This can be used to
maintain a counter: >

	if !exists("s:counter")
	  let s:counter = 1
	  echo "script executed for the first time"
	else
	  let s:counter = s:counter + 1
	  echo "script executed " . s:counter . " times now"
	endif

Note that this means that filetype plugins don't get a different set of script
variables for each buffer.  Use local buffer variables instead |b:var|.


Predefined Vim variables:			*vim-variable* *v:var* *v:*

					*v:beval_col* *beval_col-variable*
v:beval_col	The number of the column, over which the mouse pointer is.
		This is the byte index in the |v:beval_lnum| line.
		Only valid while evaluating the 'balloonexpr' option.

					*v:beval_bufnr* *beval_bufnr-variable*
v:beval_bufnr	The number of the buffer, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.

					*v:beval_lnum* *beval_lnum-variable*
v:beval_lnum	The number of the line, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.

					*v:beval_text* *beval_text-variable*
v:beval_text	The text under or after the mouse pointer.  Usually a word as
		it is useful for debugging a C program.  'iskeyword' applies,
		but a dot and "->" before the position is included.  When on a
		']' the text before it is used, including the matching '[' and
		word before it.  When on a Visual area within one line the
		highlighted text is used.
		Only valid while evaluating the 'balloonexpr' option.

					*v:beval_winnr* *beval_winnr-variable*
v:beval_winnr	The number of the window, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.  The first
		window has number zero (unlike most other places where a
		window gets a number).

					*v:beval_winid* *beval_winid-variable*
v:beval_winid	The window ID of the window, over which the mouse pointer is.
		Otherwise like v:beval_winnr.

					*v:char* *char-variable*
v:char		Argument for evaluating 'formatexpr' and used for the typed
		character when using <expr> in an abbreviation |:map-<expr>|.
		It is also used by the |InsertCharPre| and |InsertEnter| events.

			*v:charconvert_from* *charconvert_from-variable*
v:charconvert_from
		The name of the character encoding of a file to be converted.
		Only valid while evaluating the 'charconvert' option.

			*v:charconvert_to* *charconvert_to-variable*
v:charconvert_to
		The name of the character encoding of a file after conversion.
		Only valid while evaluating the 'charconvert' option.

					*v:cmdarg* *cmdarg-variable*
v:cmdarg	This variable is used for two purposes:
		1. The extra arguments given to a file read/write command.
		   Currently these are "++enc=" and "++ff=".  This variable is
		   set before an autocommand event for a file read/write
		   command is triggered.  There is a leading space to make it
		   possible to append this variable directly after the
		   read/write command.	Note: The "+cmd" argument isn't
		   included here, because it will be executed anyway.
		2. When printing a PostScript file with ":hardcopy" this is
		   the argument for the ":hardcopy" command.  This can be used
		   in 'printexpr'.

					*v:cmdbang* *cmdbang-variable*
v:cmdbang	Set like v:cmdarg for a file read/write command.  When a "!"
		was used the value is 1, otherwise it is 0.  Note that this
		can only be used in autocommands.  For user commands |<bang>|
		can be used.

				*v:completed_item* *completed_item-variable*
v:completed_item
		Dictionary containing the most recent |complete-items| after
		|CompleteDone|.  Empty if the completion failed, or after
		leaving and re-entering insert mode.

					*v:count* *count-variable*
v:count		The count given for the last Normal mode command.  Can be used
		to get the count before a mapping.  Read-only.	Example: >
	:map _x :<C-U>echo "the count is " . v:count<CR>
<		Note: The <C-U> is required to remove the line range that you
		get when typing ':' after a count.
		When there are two counts, as in "3d2w", they are multiplied,
		just like what happens in the command, "d6w" for the example.
		Also used for evaluating the 'formatexpr' option.
		"count" also works, for backwards compatibility.

					*v:count1* *count1-variable*
v:count1	Just like "v:count", but defaults to one when no count is
		used.

						*v:ctype* *ctype-variable*
v:ctype		The current locale setting for characters of the runtime
		environment.  This allows Vim scripts to be aware of the
		current locale encoding.  Technical: it's the value of
		LC_CTYPE.  When not using a locale the value is "C".
		This variable can not be set directly, use the |:language|
		command.
		See |multi-lang|.

					*v:dying* *dying-variable*
v:dying		Normally zero.	When a deadly signal is caught it's set to
		one.  When multiple signals are caught the number increases.
		Can be used in an autocommand to check if Vim didn't
		terminate normally. {only works on Unix}
		Example: >
	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
<		Note: if another deadly signal is caught when v:dying is one,
		VimLeave autocommands will not be executed.

					*v:errmsg* *errmsg-variable*
v:errmsg	Last given error message.  It's allowed to set this variable.
		Example: >
	:let v:errmsg = ""
	:silent! next
	:if v:errmsg != ""
	:  ... handle error
<		"errmsg" also works, for backwards compatibility.

					*v:errors* *errors-variable*
v:errors	Errors found by assert functions, such as |assert_true()|.
		This is a list of strings.
		The assert functions append an item when an assert fails.
		To remove old results make it empty: >
	:let v:errors = []
<		If v:errors is set to anything but a list it is made an empty
		list by the assert function.

					*v:event* *event-variable*
v:event		Dictionary of event data for the current |autocommand|.  The
		available keys differ per event type and are specified at the
		documentation for each |event|.  The possible keys are:
			operator	The operation performed.  Unlike
					|v:operator|, it is set also for an Ex
					mode command.  For instance, |:yank| is
					translated to "|y|".
			regcontents	Text stored in the register as a
					|readfile()|-style list of lines.
			regname 	Requested register (e.g "x" for "xyy)
					or the empty string for an unnamed
					operation.
			regtype		Type of register as returned by
					|getregtype()|.

					*v:exception* *exception-variable*
v:exception	The value of the exception most recently caught and not
		finished.  See also |v:throwpoint| and |throw-variables|.
		Example: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "caught" v:exception
	:endtry
<		Output: "caught oops".

					*v:false* *false-variable*
v:false		Special value used to put "false" in JSON and msgpack.  See 
		|json_encode()|.  This value is converted to "false" when used 
		as a String (e.g. in |expr5| with string concatenation 
		operator) and to zero when used as a Number (e.g. in |expr5| 
		or |expr7| when used with numeric operators).

					*v:fcs_reason* *fcs_reason-variable*
v:fcs_reason	The reason why the |FileChangedShell| event was triggered.
		Can be used in an autocommand to decide what to do and/or what
		to set v:fcs_choice to.  Possible values:
			deleted		file no longer exists
			conflict	file contents, mode or timestamp was
					changed and buffer is modified
			changed		file contents has changed
			mode		mode of file changed
			time		only file timestamp changed

					*v:fcs_choice* *fcs_choice-variable*
v:fcs_choice	What should happen after a |FileChangedShell| event was
		triggered.  Can be used in an autocommand to tell Vim what to
		do with the affected buffer:
			reload		Reload the buffer (does not work if
					the file was deleted).
			ask		Ask the user what to do, as if there
					was no autocommand.  Except that when
					only the timestamp changed nothing
					will happen.
			<empty>		Nothing, the autocommand should do
					everything that needs to be done.
		The default is empty.  If another (invalid) value is used then
		Vim behaves like it is empty, there is no warning message.

					*v:fname_in* *fname_in-variable*
v:fname_in	The name of the input file.  Valid while evaluating:
			option		used for ~
			'charconvert'	file to be converted
			'diffexpr'	original file
			'patchexpr'	original file
			'printexpr'	file to be printed
		And set to the swap file name for |SwapExists|.

					*v:fname_out* *fname_out-variable*
v:fname_out	The name of the output file.  Only valid while
		evaluating:
			option		used for ~
			'charconvert'	resulting converted file (*)
			'diffexpr'	output of diff
			'patchexpr'	resulting patched file
		(*) When doing conversion for a write command (e.g., ":w
		file") it will be equal to v:fname_in.	When doing conversion
		for a read command (e.g., ":e file") it will be a temporary
		file and different from v:fname_in.

					*v:fname_new* *fname_new-variable*
v:fname_new	The name of the new version of the file.  Only valid while
		evaluating 'diffexpr'.

					*v:fname_diff* *fname_diff-variable*
v:fname_diff	The name of the diff (patch) file.  Only valid while
		evaluating 'patchexpr'.

					*v:folddashes* *folddashes-variable*
v:folddashes	Used for 'foldtext': dashes representing foldlevel of a closed
		fold.
		Read-only in the |sandbox|. |fold-foldtext|

					*v:foldlevel* *foldlevel-variable*
v:foldlevel	Used for 'foldtext': foldlevel of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|

					*v:foldend* *foldend-variable*
v:foldend	Used for 'foldtext': last line of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|

					*v:foldstart* *foldstart-variable*
v:foldstart	Used for 'foldtext': first line of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|

					*v:hlsearch* *hlsearch-variable*
v:hlsearch	Variable that indicates whether search highlighting is on.
		Setting it makes sense only if 'hlsearch' is enabled. Setting
		this variable to zero acts like the |:nohlsearch| command,
		setting it to one acts like >
			let &hlsearch = &hlsearch
<		Note that the value is restored when returning from a
		function. |function-search-undo|.

					*v:insertmode* *insertmode-variable*
v:insertmode	Used for the |InsertEnter| and |InsertChange| autocommand
		events.  Values:
			i	Insert mode
			r	Replace mode
			v	Virtual Replace mode

						*v:key* *key-variable*
v:key		Key of the current item of a |Dictionary|.  Only valid while
		evaluating the expression used with |map()| and |filter()|.
		Read-only.

						*v:lang* *lang-variable*
v:lang		The current locale setting for messages of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_MESSAGES.
		The value is system dependent.
		This variable can not be set directly, use the |:language|
		command.
		It can be different from |v:ctype| when messages are desired
		in a different language than what is used for character
		encoding.  See |multi-lang|.

						*v:lc_time* *lc_time-variable*
v:lc_time	The current locale setting for time messages of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_TIME.
		This variable can not be set directly, use the |:language|
		command.  See |multi-lang|.

						*v:lnum* *lnum-variable*
v:lnum		Line number for the 'foldexpr' |fold-expr|, 'formatexpr' and
		'indentexpr' expressions, tab page number for 'guitablabel'
		and 'guitabtooltip'.  Only valid while one of these
		expressions is being evaluated.  Read-only when in the
		|sandbox|.

					*v:mouse_win* *mouse_win-variable*
v:mouse_win	Window number for a mouse click obtained with |getchar()|.
		First window has number 1, like with |winnr()|.  The value is
		zero when there was no mouse button click.

					*v:mouse_winid* *mouse_winid-variable*
v:mouse_winid	Window ID for a mouse click obtained with |getchar()|.
		The value is zero when there was no mouse button click.

					*v:mouse_lnum* *mouse_lnum-variable*
v:mouse_lnum	Line number for a mouse click obtained with |getchar()|.
		This is the text line number, not the screen line number.  The
		value is zero when there was no mouse button click.

					*v:mouse_col* *mouse_col-variable*
v:mouse_col	Column number for a mouse click obtained with |getchar()|.
		This is the screen column number, like with |virtcol()|.  The
		value is zero when there was no mouse button click.

				*v:msgpack_types* *msgpack_types-variable*
v:msgpack_types	Dictionary containing msgpack types used by |msgpackparse()| 
		and |msgpackdump()|. All types inside dictionary are fixed 
		(not editable) empty lists. To check whether some list is one 
		of msgpack types, use |is| operator.

					*v:null* *null-variable*
v:null		Special value used to put "null" in JSON and NIL in msgpack.  
		See |json_encode()|.  This value is converted to "null" when 
		used as a String (e.g. in |expr5| with string concatenation 
		operator) and to zero when used as a Number (e.g. in |expr5| 
		or |expr7| when used with numeric operators).

					*v:oldfiles* *oldfiles-variable*
v:oldfiles	List of file names that is loaded from the |shada| file on
		startup.  These are the files that Vim remembers marks for.
		The length of the List is limited by the ' argument of the
		'shada' option (default is 100).
		When the |shada| file is not used the List is empty.
		Also see |:oldfiles| and |c_#<|.
		The List can be modified, but this has no effect on what is
		stored in the |shada| file later.  If you use values other
		than String this will cause trouble.
		{only when compiled with the |+shada| feature}

						    *v:option_new*
v:option_new    New value of the option. Valid while executing an |OptionSet|
		autocommand.
						    *v:option_old*
v:option_old    Old value of the option. Valid while executing an |OptionSet|
		autocommand.
						    *v:option_type*
v:option_type   Scope of the set command. Valid while executing an
		|OptionSet| autocommand. Can be either "global" or "local"
					*v:operator* *operator-variable*
v:operator	The last operator given in Normal mode.  This is a single
		character except for commands starting with <g> or <z>,
		in which case it is two characters.  Best used alongside
		|v:prevcount| and |v:register|.  Useful if you want to cancel
		Operator-pending mode and then use the operator, e.g.: >
			:omap O <Esc>:call MyMotion(v:operator)<CR>
<		The value remains set until another operator is entered, thus
		don't expect it to be empty.
		v:operator is not set for |:delete|, |:yank| or other Ex
		commands.
		Read-only.

					*v:prevcount* *prevcount-variable*
v:prevcount	The count given for the last but one Normal mode command.
		This is the v:count value of the previous command.  Useful if
		you want to cancel Visual or Operator-pending mode and then
		use the count, e.g.: >
			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
<		Read-only.

					*v:profiling* *profiling-variable*
v:profiling	Normally zero.	Set to one after using ":profile start".
		See |profiling|.

					*v:progname* *progname-variable*
v:progname	Contains the name (with path removed) with which Nvim was
		invoked.  Allows you to do special initialisations for any
		other name you might symlink to Nvim.
		Read-only.

					*v:progpath* *progpath-variable*
v:progpath	Contains the command with which Vim was invoked, including the
		path. To get the full path use: >
			echo exepath(v:progpath)
<		NOTE: This does not work when the command is a relative path
		and the current directory has changed.
		Read-only.

					*v:register* *register-variable*
v:register	The name of the register in effect for the current normal mode
		command (regardless of whether that command actually used a
		register).  Or for the currently executing normal mode mapping
		(use this in custom commands that take a register).
		If none is supplied it is the default register '"', unless
		'clipboard' contains "unnamed" or "unnamedplus", then it is
		'*' or '+'.
		Also see |getreg()| and |setreg()|

					*v:scrollstart* *scrollstart-variable*
v:scrollstart	String describing the script or function that caused the
		screen to scroll up.  It's only set when it is empty, thus the
		first reason is remembered.  It is set to "Unknown" for a
		typed command.
		This can be used to find out why your script causes the
		hit-enter prompt.

					*v:servername* *servername-variable*
					*$NVIM_LISTEN_ADDRESS*
v:servername	Default {Nvim} server address. Equivalent to
		|$NVIM_LISTEN_ADDRESS| on startup. |serverstop()|
		Read-only.

		
v:searchforward			*v:searchforward* *searchforward-variable*
		Search direction:  1 after a forward search, 0 after a
		backward search.  It is reset to forward when directly setting
		the last search pattern, see |quote/|.
		Note that the value is restored when returning from a
		function. |function-search-undo|.
		Read-write.

					*v:shell_error* *shell_error-variable*
v:shell_error	Result of the last shell command.  When non-zero, the last
		shell command had an error.  When zero, there was no problem.
		This only works when the shell returns the error code to Vim.
		The value -1 is often used when the command could not be
		executed.  Read-only.
		Example: >
	:!mv foo bar
	:if v:shell_error
	:  echo 'could not rename "foo" to "bar"!'
	:endif
<		"shell_error" also works, for backwards compatibility.

					*v:statusmsg* *statusmsg-variable*
v:statusmsg	Last given status message.  It's allowed to set this variable.

					*v:swapname* *swapname-variable*
v:swapname	Only valid when executing |SwapExists| autocommands: Name of
		the swap file found.  Read-only.

					*v:swapchoice* *swapchoice-variable*
v:swapchoice	|SwapExists| autocommands can set this to the selected choice
		for handling an existing swap file:
			'o'	Open read-only
			'e'	Edit anyway
			'r'	Recover
			'd'	Delete swapfile
			'q'	Quit
			'a'	Abort
		The value should be a single-character string.	An empty value
		results in the user being asked, as would happen when there is
		no SwapExists autocommand.  The default is empty.

					*v:swapcommand* *swapcommand-variable*
v:swapcommand	Normal mode command to be executed after a file has been
		opened.  Can be used for a |SwapExists| autocommand to have
		another Vim open the file and jump to the right place.	For
		example, when jumping to a tag the value is ":tag tagname\r".
		For ":edit +cmd file" the value is ":cmd\r".

				*v:termresponse* *termresponse-variable*
v:termresponse	The escape sequence returned by the terminal for the |t_RV|
		termcap entry.	It is set when Vim receives an escape sequence
		that starts with ESC [ or CSI and ends in a 'c', with only
		digits, ';' and '.' in between.
		When this option is set, the TermResponse autocommand event is
		fired, so that you can react to the response from the
		terminal.
		The response from a new xterm is: "<Esc>[ Pp ; Pv ; Pc c".  Pp
		is the terminal type: 0 for vt100 and 1 for vt220.  Pv is the
		patch level (since this was introduced in patch 95, it's
		always 95 or bigger).  Pc is always zero.
		{only when compiled with |+termresponse| feature}

				*v:this_session* *this_session-variable*
v:this_session	Full filename of the last loaded or saved session file.  See
		|:mksession|.  It is allowed to set this variable.  When no
		session file has been saved, this variable is empty.
		"this_session" also works, for backwards compatibility.

					*v:throwpoint* *throwpoint-variable*
v:throwpoint	The point where the exception most recently caught and not
		finished was thrown.  Not set when commands are typed.	See
		also |v:exception| and |throw-variables|.
		Example: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "Exception from" v:throwpoint
	:endtry
<		Output: "Exception from test.vim, line 2"

					*v:true* *true-variable*
v:true		Special value used to put "true" in JSON and msgpack.  See 
		|json_encode()|.  This value is converted to "true" when used 
		as a String (e.g. in |expr5| with string concatenation 
		operator) and to one when used as a Number (e.g. in |expr5| or 
		|expr7| when used with numeric operators).

						*v:val* *val-variable*
v:val		Value of the current item of a |List| or |Dictionary|.	Only
		valid while evaluating the expression used with |map()| and
		|filter()|.  Read-only.

					*v:version* *version-variable*
v:version	Version number of Vim: Major version number times 100 plus
		minor version number.  Version 5.0 is 500.  Version 5.1 (5.01)
		is 501.  Read-only.  "version" also works, for backwards
		compatibility.
		Use |has()| to check if a certain patch was included, e.g.: >
			if has("patch-7.4.123")
<		Note that patch numbers are specific to the version, thus both
		version 5.0 and 5.1 may have a patch 123, but these are
		completely different.

				*v:vim_did_enter* *vim_did_enter-variable*
v:vim_did_enter	Zero until most of startup is done.  It is set to one just
		before |VimEnter| autocommands are triggered.

					*v:warningmsg* *warningmsg-variable*
v:warningmsg	Last given warning message.  It's allowed to set this variable.

					*v:windowid* *windowid-variable* {Nvim}
v:windowid	Application-specific window ID ("window handle" in MS-Windows)
		which may be set by any attached UI. Defaults to zero.
		Note: for windows inside Vim use |winnr()| or |win_getid()|.

==============================================================================
4. Builtin Functions					*functions*

See |function-list| for a list grouped by what the function is used for.

(Use CTRL-] on the function name to jump to the full explanation.)

USAGE				RESULT	DESCRIPTION	~

abs({expr})			Float or Number  absolute value of {expr}
acos({expr})			Float	arc cosine of {expr}
add({list}, {item})		List	append {item} to |List| {list}
and({expr}, {expr})		Number  bitwise AND
api_info()			Dict	api metadata
append({lnum}, {string})	Number	append {string} below line {lnum}
append({lnum}, {list})		Number	append lines {list} below line {lnum}
argc()				Number	number of files in the argument list
argidx()			Number	current index in the argument list
arglistid([{winnr} [, {tabnr}]]) Number	argument list id
argv({nr})			String	{nr} entry of the argument list
argv()				List	the argument list
assert_equal({exp}, {act} [, {msg}]) none  assert {exp} is equal to {act}
assert_exception( {error} [, {msg}]) none  assert {error} is in v:exception
assert_fails( {cmd} [, {error}])     none  assert {cmd} fails
assert_false({actual} [, {msg}])     none  assert {actual} is false
assert_match( {pat}, {text} [, {msg}]) none  assert {pat} matches {text}
assert_notequal( {exp}, {act} [, {msg}]) none  assert {exp} is not equal {act}
assert_notmatch( {pat}, {text} [, {msg}]) none  assert {pat} not matches {text}
assert_true({actual} [, {msg}])      none  assert {actual} is true
asin({expr})			Float	arc sine of {expr}
atan({expr})			Float	arc tangent of {expr}
atan2({expr}, {expr})		Float   arc tangent of {expr1} / {expr2}
browse({save}, {title}, {initdir}, {default})
				String	put up a file requester
browsedir({title}, {initdir})	String	put up a directory requester
bufexists({expr})		Number	TRUE if buffer {expr} exists
buflisted({expr})		Number	TRUE if buffer {expr} is listed
bufloaded({expr})		Number	TRUE if buffer {expr} is loaded
bufname({expr})		String	Name of the buffer {expr}
bufnr({expr} [, {create}])	Number	Number of the buffer {expr}
bufwinid({expr})		Number	window ID of buffer {expr}
bufwinnr({expr})		Number	window number of buffer {expr}
byte2line({byte})		Number	line number at byte count {byte}
byteidx({expr}, {nr})		Number	byte index of {nr}'th char in {expr}
byteidxcomp({expr}, {nr})	Number	byte index of {nr}'th char in {expr}
call({func}, {arglist} [, {dict}])
				any	call {func} with arguments {arglist}
ceil({expr})			Float	round {expr} up
changenr()			Number	current change number
char2nr({expr}[, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
cindent({lnum})		Number	C indent for line {lnum}
clearmatches()			none	clear all matches
col({expr})			Number	column nr of cursor or mark
complete({startcol}, {matches}) none	set Insert mode completion
complete_add({expr})		Number	add completion match
complete_check()		Number	check for key typed during completion
confirm({msg} [, {choices} [, {default} [, {type}]]])
				Number	number of choice picked by user
copy({expr})			any	make a shallow copy of {expr}
cos({expr})			Float	cosine of {expr}
cosh({expr})			Float	hyperbolic cosine of {expr}
count({list}, {expr} [, {ic} [, {start}]])
				Number	 count how many {expr} are in {list}
cscope_connection([{num} , {dbpath} [, {prepend}]])
				Number	checks existence of cscope connection
cursor({lnum}, {col} [, {off}])
				Number	move cursor to {lnum}, {col}, {off}
cursor({list})			Number	move cursor to position in {list}
deepcopy({expr} [, {noref}])	any	make a full copy of {expr}
delete({fname} [, {flags}])	Number	delete the file or directory {fname}
dictwatcheradd({dict}, {pattern}, {callback})
				Start watching a dictionary
dictwatcherdel({dict}, {pattern}, {callback})
				Stop watching a dictionary
did_filetype()			Number	TRUE if FileType autocommand event used
diff_filler({lnum})		Number	diff filler lines about {lnum}
diff_hlID({lnum}, {col})	Number	diff highlighting at {lnum}/{col}
empty({expr})			Number	TRUE if {expr} is empty
escape({string}, {chars})	String	escape {chars} in {string} with '\'
eval({string})			any	evaluate {string} into its value
eventhandler()			Number	TRUE if inside an event handler
executable({expr})		Number	1 if executable {expr} exists
execute({command})		String	execute and capture output of {command}
exepath({expr})		String  full path of the command {expr}
exists({expr})			Number	TRUE if {expr} exists
extend({expr1}, {expr2} [, {expr3}])
				List/Dict insert items of {expr2} into {expr1}
exp({expr})			Float	exponential of {expr}
expand({expr} [, {nosuf} [, {list}]])
				any	expand special keywords in {expr}
feedkeys({string} [, {mode}])	Number	add key sequence to typeahead buffer
filereadable({file})		Number	TRUE if {file} is a readable file
filewritable({file})		Number	TRUE if {file} is a writable file
filter({expr}, {string})	List/Dict  remove items from {expr} where
				{string} is 0
finddir({name}[, {path}[, {count}]])
				String	find directory {name} in {path}
findfile({name}[, {path}[, {count}]])
				String	find file {name} in {path}
float2nr({expr})		Number	convert Float {expr} to a Number
floor({expr})			Float	round {expr} down
fmod({expr1}, {expr2})		Float	remainder of {expr1} / {expr2}
fnameescape({fname})		String	escape special characters in {fname}
fnamemodify({fname}, {mods})	String	modify file name
foldclosed({lnum})		Number	first line of fold at {lnum} if closed
foldclosedend({lnum})		Number	last line of fold at {lnum} if closed
foldlevel({lnum})		Number	fold level at {lnum}
foldtext()			String	line displayed for closed fold
foldtextresult({lnum})		String	text for closed fold at {lnum}
foreground()			Number	bring the Vim window to the foreground
function({name})		Funcref reference to function {name}
garbagecollect([{atexit}])	none	free memory, breaking cyclic references
get({list}, {idx} [, {def}])	any	get item {idx} from {list} or {def}
get({dict}, {key} [, {def}])	any	get item {key} from {dict} or {def}
getbufline({expr}, {lnum} [, {end}])
				List	lines {lnum} to {end} of buffer {expr}
getbufvar({expr}, {varname} [, {def}])
				any	variable {varname} in buffer {expr}
getchar([expr])		Number	get one character from the user
getcharmod()			Number	modifiers for the last typed character
getcharsearch()			Dict	last character search
getcmdline()			String	return the current command-line
getcmdpos()			Number	return cursor position in command-line
getcmdtype()			String	return current command-line type
getcmdwintype()			String	return current command-line window type
getcompletion({pat}, {type} [, {filtered}])
				List	list of cmdline completion matches
getcurpos()			List	position of the cursor
getcwd([{winnr} [, {tabnr}]])	String	the current working directory
getfontname([{name}])		String	name of font being used
getfperm({fname})		String	file permissions of file {fname}
getfsize({fname})		Number	size in bytes of file {fname}
getftime({fname})		Number	last modification time of file
getftype({fname})		String	description of type of file {fname}
getline({lnum})		String	line {lnum} of current buffer
getline({lnum}, {end})		List	lines {lnum} to {end} of current buffer
getloclist({nr})		List	list of location list items
getmatches()			List	list of current matches
getpid()			Number	process ID of Vim
getpos({expr})			List	position of cursor, mark, etc.
getqflist()			List	list of quickfix items
getreg([{regname} [, 1 [, {list}]]])
				String or List   contents of register
getregtype([{regname}])	String	type of register
gettabvar({nr}, {varname} [, {def}])
				any	variable {varname} in tab {nr} or {def}
gettabwinvar({tabnr}, {winnr}, {name} [, {def}])
				any	{name} in {winnr} in tab page {tabnr}
getwinposx()			Number	X coord in pixels of GUI Vim window
getwinposy()			Number	Y coord in pixels of GUI Vim window
getwinvar({nr}, {varname} [, {def}])
				any	variable {varname} in window {nr}
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])
				any	expand file wildcards in {expr}
glob2regpat({expr})		String  convert a glob pat into a search pat
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
				String	do glob({expr}) for all dirs in {path}
has({feature})			Number	TRUE if feature {feature} supported
has_key({dict}, {key})		Number	TRUE if {dict} has entry {key}
haslocaldir([{winnr} [, {tabnr}]])
				Number	TRUE if current window executed |:lcd|
hasmapto({what} [, {mode} [, {abbr}]])
				Number	TRUE if mapping to {what} exists
histadd({history}, {item})	String	add an item to a history
histdel({history} [, {item}])	String	remove an item from a history
histget({history} [, {index}])	String	get the item {index} from a history
histnr({history})		Number	highest index of a history
hlexists({name})		Number	TRUE if highlight group {name} exists
hlID({name})			Number	syntax ID of highlight group {name}
hostname()			String	name of the machine Vim is running on
iconv({expr}, {from}, {to})	String	convert encoding of {expr}
indent({lnum})			Number	indent of line {lnum}
index({list}, {expr} [, {start} [, {ic}]])
				Number	index in {list} where {expr} appears
input({prompt} [, {text} [, {completion}]])
				String	get input from the user
inputdialog({p} [, {t} [, {c}]]) String  like input() but in a GUI dialog
inputlist({textlist})		Number	let the user pick from a choice list
inputrestore()			Number	restore typeahead
inputsave()			Number	save and clear typeahead
inputsecret({prompt} [, {text}])
				String  like input() but hiding the text
insert({list}, {item} [, {idx}])
				List	insert {item} in {list} [before {idx}]
invert({expr})			Number  bitwise invert
isdirectory({directory})	Number	TRUE if {directory} is a directory
islocked({expr})		Number	TRUE if {expr} is locked
items({dict})			List	key-value pairs in {dict}
jobclose({job}[, {stream}])	Number	Closes a job stream(s)
jobpid({job})			Number	Returns pid of a job.
jobresize({job}, {width}, {height})
				Number	Resize {job}'s pseudo terminal window
jobsend({job}, {data})		Number	Writes {data} to {job}'s stdin
jobstart({cmd}[, {opts}])	Number	Spawns {cmd} as a job
jobstop({job})			Number	Stops a job
jobwait({ids}[, {timeout}])	Number	Wait for a set of jobs
join({list} [, {sep}])		String	join {list} items into one String
json_decode({expr})		any	Convert {expr} from JSON
json_encode({expr})		String	Convert {expr} to JSON
keys({dict})			List	keys in {dict}
len({expr})			Number	the length of {expr}
libcall({lib}, {func}, {arg})	String	call {func} in library {lib} with {arg}
libcallnr({lib}, {func}, {arg})  Number  idem, but return a Number
line({expr})			Number	line nr of cursor, last line or mark
line2byte({lnum})		Number	byte count of line {lnum}
lispindent({lnum})		Number	Lisp indent for line {lnum}
localtime()			Number	current time
log({expr})			Float	natural logarithm (base e) of {expr}
log10({expr})			Float	logarithm of Float {expr} to base 10
map({expr}, {string})		List/Dict  change each item in {expr} to {expr}
maparg({name}[, {mode} [, {abbr} [, {dict}]]])
				String or Dict
					rhs of mapping {name} in mode {mode}
mapcheck({name}[, {mode} [, {abbr}]])
				String	check for mappings matching {name}
match({expr}, {pat}[, {start}[, {count}]])
				Number	position where {pat} matches in {expr}
matchadd({group}, {pattern}[, {priority}[, {id}]])
				Number	highlight {pattern} with {group}
matchaddpos({group}, {list}[, {priority}[, {id}]])
				Number	highlight positions with {group}
matcharg({nr})			List	arguments of |:match|
matchdelete({id})		Number	delete match identified by {id}
matchend({expr}, {pat}[, {start}[, {count}]])
				Number	position where {pat} ends in {expr}
matchlist({expr}, {pat}[, {start}[, {count}]])
				List	match and submatches of {pat} in {expr}
matchstr({expr}, {pat}[, {start}[, {count}]])
				String	{count}'th match of {pat} in {expr}
max({list})			Number	maximum value of items in {list}
min({list})			Number	minimum value of items in {list}
mkdir({name} [, {path} [, {prot}]])
				Number	create directory {name}
mode([expr])			String	current editing mode
msgpackdump({list})		List	dump a list of objects to msgpack
msgpackparse({list})		List	parse msgpack to a list of objects
nextnonblank({lnum})		Number	line nr of non-blank line >= {lnum}
nr2char({expr}[, {utf8}])	String	single char with ASCII/UTF8 value {expr}
nvim_...({args}...)		any	call nvim |api| functions
or({expr}, {expr})		Number  bitwise OR
pathshorten({expr})		String	shorten directory names in a path
pow({x}, {y})			Float	{x} to the power of {y}
prevnonblank({lnum})		Number	line nr of non-blank line <= {lnum}
printf({fmt}, {expr1}...)	String	format text
pumvisible()			Number	whether popup menu is visible
pyeval({expr})			any	evaluate |Python| expression
py3eval({expr})		any	evaluate |python3| expression
range({expr} [, {max} [, {stride}]])
				List	items from {expr} to {max}
readfile({fname} [, {binary} [, {max}]])
				List	get list of lines from file {fname}
reltime([{start} [, {end}]])	List	get time value
reltimefloat({time})		Float	turn the time value into a Float
reltimestr({time})		String	turn time value into a String
remote_expr({server}, {string} [, {idvar}])
				String	send expression
remote_foreground({server})	Number	bring Vim server to the foreground
remote_peek({serverid} [, {retvar}])
				Number	check for reply string
remote_read({serverid})	String	read reply string
remote_send({server}, {string} [, {idvar}])
				String	send key sequence
remove({list}, {idx} [, {end}])  any	remove items {idx}-{end} from {list}
remove({dict}, {key})		any	remove entry {key} from {dict}
rename({from}, {to})		Number	rename (move) file from {from} to {to}
repeat({expr}, {count})	String	repeat {expr} {count} times
resolve({filename})		String	get filename a shortcut points to
reverse({list})		List	reverse {list} in-place
round({expr})			Float	round off {expr}
rpcnotify({channel}, {event}[, {args}...])
				Sends an |RPC| notification to {channel}
rpcrequest({channel}, {method}[, {args}...])
				Sends an |RPC| request to {channel}
rpcstop({channel})		Closes an |RPC| {channel}
screenattr({row}, {col})	Number	attribute at screen position
screenchar({row}, {col})	Number	character at screen position
screencol()			Number	current cursor column
screenrow()			Number	current cursor row
search({pattern} [, {flags} [, {stopline} [, {timeout}]]])
				Number	search for {pattern}
searchdecl({name} [, {global} [, {thisblock}]])
				Number	search for variable declaration
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				Number	search for other end of start/end pair
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				List	search for other end of start/end pair
searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])
				List	search for {pattern}
server2client({clientid}, {string})
				Number	send reply string
serverlist()			String	get a list of available servers
setbufvar({expr}, {varname}, {val})	set {varname} in buffer {expr} to {val}
setcharsearch({dict})		Dict	set character search from {dict}
setcmdpos({pos})		Number	set cursor position in command-line
setfperm({fname}, {mode}	Number	set {fname} file permissions to {mode}
setline({lnum}, {line})	Number	set line {lnum} to {line}
setloclist({nr}, {list}[, {action}[, {title}]])
				Number	modify location list using {list}
setmatches({list})		Number	restore a list of matches
setpos({expr}, {list})		Number	set the {expr} position to {list}
setqflist({list}[, {action}[, {title}]]
				Number	modify quickfix list using {list}
setreg({n}, {v}[, {opt}])	Number	set register to value and type
settabvar({nr}, {varname}, {val})	set {varname} in tab page {nr} to {val}
settabwinvar({tabnr}, {winnr}, {varname}, {val})    set {varname} in window
					{winnr} in tab page {tabnr} to {val}
setwinvar({nr}, {varname}, {val})	set {varname} in window {nr} to {val}
sha256({string})		String	SHA256 checksum of {string}
shellescape({string} [, {special}])
				String	escape {string} for use as shell
					command argument
shiftwidth()			Number	effective value of 'shiftwidth'
simplify({filename})		String	simplify filename as much as possible
sin({expr})			Float	sine of {expr}
sinh({expr})			Float	hyperbolic sine of {expr}
sort({list} [, {func} [, {dict}]])
				List	sort {list}, using {func} to compare
soundfold({word})		String	sound-fold {word}
spellbadword()			String	badly spelled word at cursor
spellsuggest({word} [, {max} [, {capital}]])
				List	spelling suggestions
split({expr} [, {pat} [, {keepempty}]])
				List	make |List| from {pat} separated {expr}
sqrt({expr})			Float	square root of {expr}
str2float({expr})		Float	convert String to Float
str2nr({expr} [, {base}])	Number	convert String to Number
strchars({expr} [, {skipcc}])	Number	character length of the String {expr}
strdisplaywidth({expr} [, {col}]) Number display length of the String {expr}
strftime({format}[, {time}])	String	time in specified format
stridx({haystack}, {needle}[, {start}])
				Number	index of {needle} in {haystack}
string({expr})			String	String representation of {expr} value
strlen({expr})			Number	length of the String {expr}
strpart({src}, {start}[, {len}])
				String	{len} characters of {src} at {start}
strridx({haystack}, {needle} [, {start}])
				Number	last index of {needle} in {haystack}
strtrans({expr})		String	translate string to make it printable
strwidth({expr})		Number	display cell length of the String {expr}
submatch({nr}[, {list}])	String or List
					specific match in ":s" or substitute()
substitute({expr}, {pat}, {sub}, {flags})
				String	all {pat} in {expr} replaced with {sub}
synID({lnum}, {col}, {trans})	Number	syntax ID at {lnum} and {col}
synIDattr({synID}, {what} [, {mode}])
				String	attribute {what} of syntax ID {synID}
synIDtrans({synID})		Number	translated syntax ID of {synID}
synconcealed({lnum}, {col})	List    info about concealing
synstack({lnum}, {col})	List	stack of syntax IDs at {lnum} and {col}
system({cmd} [, {input}])	String	output of shell command/filter {cmd}
systemlist({cmd} [, {input}])	List	output of shell command/filter {cmd}
tabpagebuflist([{arg}])	List	list of buffer numbers in tab page
tabpagenr([{arg}])		Number	number of current or last tab page
tabpagewinnr({tabarg}[, {arg}])
				Number	number of current window in tab page
taglist({expr})		List	list of tags matching {expr}
tagfiles()			List	tags files used
tan({expr})			Float	tangent of {expr}
tanh({expr})			Float	hyperbolic tangent of {expr}
tempname()			String	name for a temporary file
timer_start({time}, {callback} [, {options}])
				Number	create a timer
timer_stop({timer})		none	stop a timer
tolower({expr})		String	the String {expr} switched to lowercase
toupper({expr})		String	the String {expr} switched to uppercase
tr({src}, {fromstr}, {tostr})	String	translate chars of {src} in {fromstr}
					to chars in {tostr}
trunc({expr})			Float	truncate Float {expr}
type({name})			Number	type of variable {name}
undofile({name})		String	undo file name for {name}
undotree()			List	undo file tree
uniq({list} [, {func} [, {dict}]])
				List	remove adjacent duplicates from a list
values({dict})			List	values in {dict}
virtcol({expr})		Number	screen column of cursor or mark
visualmode([expr])		String	last visual mode used
wildmenumode()			Number	whether 'wildmenu' mode is active
win_findbuf( {bufnr}) 		List	find windows containing {bufnr}
win_getid( [{win} [, {tab}]])   Number  get window ID for {win} in {tab}
win_gotoid( {expr})             Number  go to window with ID {expr}
win_id2tabwin( {expr})          List    get tab window nr from window ID
win_id2win( {expr})             Number  get window nr from window ID
winbufnr({nr})			Number	buffer number of window {nr}
wincol()			Number	window column of the cursor
winheight({nr})		Number	height of window {nr}
winline()			Number	window line of the cursor
winnr([{expr}])		Number	number of current window
winrestcmd()			String	returns command to restore window sizes
winrestview({dict})		none	restore view of current window
winsaveview()			Dict	save view of current window
winwidth({nr})			Number	width of window {nr}
wordcount()			Dict	get byte/char/word statistics
writefile({list}, {fname} [, {flags}])
				Number	write list of lines to file {fname}
xor({expr}, {expr})		Number  bitwise XOR


abs({expr})							*abs()*
		Return the absolute value of {expr}.  When {expr} evaluates to
		a |Float| abs() returns a |Float|.  When {expr} can be
		converted to a |Number| abs() returns a |Number|.  Otherwise
		abs() gives an error message and returns -1.
		Examples: >
			echo abs(1.456)
<			1.456  >
			echo abs(-5.456)
<			5.456  >
			echo abs(-4)
<			4


acos({expr})							*acos()*
		Return the arc cosine of {expr} measured in radians, as a
		|Float| in the range of [0, pi].
		{expr} must evaluate to a |Float| or a |Number| in the range
		[-1, 1].
		Examples: >
			:echo acos(0)
<			1.570796 >
			:echo acos(-0.5)
<			2.094395


add({list}, {expr})					*add()*
		Append the item {expr} to |List| {list}.  Returns the
		resulting |List|.  Examples: >
			:let alist = add([1, 2, 3], item)
			:call add(mylist, "woodstock")
<		Note that when {expr} is a |List| it is appended as a single
		item.  Use |extend()| to concatenate |Lists|.
		Use |insert()| to add an item at another position.


and({expr}, {expr})					*and()*
		Bitwise AND on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Example: >
			:let flag = and(bits, 0x80)

api_info()						*api_info()*
		Returns Dictionary of |api-metadata|.

append({lnum}, {expr})					*append()*
		When {expr} is a |List|: Append each item of the |List| as a
		text line below line {lnum} in the current buffer.
		Otherwise append {expr} as one text line below line {lnum} in
		the current buffer.
		{lnum} can be zero to insert a line before the first one.
		Returns 1 for failure ({lnum} out of range or out of memory),
		0 for success.	Example: >
			:let failed = append(line('$'), "# THE END")
			:let failed = append(0, ["Chapter 1", "the beginning"])
<
							*argc()*
argc()		The result is the number of files in the argument list of the
		current window.  See |arglist|.

							*argidx()*
argidx()	The result is the current index in the argument list.  0 is
		the first file.  argc() - 1 is the last one.  See |arglist|.

							*arglistid()*
arglistid([{winnr} [, {tabnr}]])
		Return the argument list ID.  This is a number which
		identifies the argument list being used.  Zero is used for the
		global argument list.  See |arglist|.
		Return -1 if the arguments are invalid.

		Without arguments use the current window.
		With {winnr} only use this window in the current tab page.
		With {winnr} and {tabnr} use the window in the specified tab
		page.
		{winnr} can be the window number or the window ID.

							*argv()*
argv([{nr}])	The result is the {nr}th file in the argument list of the
		current window.  See |arglist|.  "argv(0)" is the first one.
		Example: >
	:let i = 0
	:while i < argc()
	:  let f = escape(fnameescape(argv(i)), '.')
	:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
	:  let i = i + 1
	:endwhile
<		Without the {nr} argument a |List| with the whole |arglist| is
		returned.

							*assert_equal()*
assert_equal({expected}, {actual}, [, {msg}])
		When {expected} and {actual} are not equal an error message is
		added to |v:errors|.
		There is no automatic conversion, the String "4" is different
		from the Number 4.  And the number 4 is different from the
		Float 4.0.  The value of 'ignorecase' is not used here, case
		always matters.
		When {msg} is omitted an error in the form "Expected
		{expected} but got {actual}" is produced.
		Example: >
	assert_equal('foo', 'bar')
<		Will result in a string to be added to |v:errors|:
	test.vim line 12: Expected 'foo' but got 'bar' ~

assert_exception({error} [, {msg}])			*assert_exception()*
		When v:exception does not contain the string {error} an error
		message is added to |v:errors|.
		This can be used to assert that a command throws an exception.
		Using the error number, followed by a colon, avoids problems
		with translations: >
			try
			  commandthatfails
			  call assert_false(1, 'command should have failed')
			catch
			  call assert_exception('E492:')
			endtry

assert_fails({cmd} [, {error}])					*assert_fails()*
		Run {cmd} and add an error message to |v:errors| if it does
		NOT produce an error.
		When {error} is given it must match |v:errmsg|.

assert_false({actual} [, {msg}])				*assert_false()*
		When {actual} is not false an error message is added to
		|v:errors|, like with |assert_equal()|.
		A value is false when it is zero or |v:false|. When "{actual}" 
		is not a number or |v:false| the assert fails.
		When {msg} is omitted an error in the form "Expected False but
		got {actual}" is produced.

								*assert_match()*
assert_match({pattern}, {actual} [, {msg}])
		When {pattern} does not match {actual} an error message is
		added to |v:errors|.

		{pattern} is used as with |=~|: The matching is always done
		like 'magic' was set and 'cpoptions' is empty, no matter what
		the actual value of 'magic' or 'cpoptions' is.

		{actual} is used as a string, automatic conversion applies.
		Use "^" and "$" to match with the start and end of the text.
		Use both to match the whole text.

		When {msg} is omitted an error in the form "Pattern {pattern}
		does not match {actual}" is produced.
		Example: >
	assert_match('^f.*o$', 'foobar')
<		Will result in a string to be added to |v:errors|:
	test.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~

							*assert_notequal()*
assert_notequal({expected}, {actual} [, {msg}])
		The opposite of `assert_equal()`: add an error message to
		|v:errors| when {expected} and {actual} are equal.

							*assert_notmatch()*
assert_notmatch({pattern}, {actual} [, {msg}])
		The opposite of `assert_match()`: add an error message to
		|v:errors| when {pattern} matches {actual}.

assert_true({actual} [, {msg}])					*assert_true()*
		When {actual} is not true an error message is added to
		|v:errors|, like with |assert_equal()|.
		A value is true when it is a non-zero number or |v:true|.  
		When {actual} is not a number or |v:true| the assert fails.
		When {msg} is omitted an error in the form "Expected True but
		got {actual}" is produced.

asin({expr})						*asin()*
		Return the arc sine of {expr} measured in radians, as a |Float|
		in the range of [-pi/2, pi/2].
		{expr} must evaluate to a |Float| or a |Number| in the range
		[-1, 1].
		Examples: >
			:echo asin(0.8)
<			0.927295 >
			:echo asin(-0.5)
<			-0.523599


atan({expr})						*atan()*
		Return the principal value of the arc tangent of {expr}, in
		the range [-pi/2, +pi/2] radians, as a |Float|.
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo atan(100)
<			1.560797 >
			:echo atan(-4.01)
<			-1.326405


atan2({expr1}, {expr2})					*atan2()*
		Return the arc tangent of {expr1} / {expr2}, measured in
		radians, as a |Float| in the range [-pi, pi].
		{expr1} and {expr2} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo atan2(-1, 1)
<			-0.785398 >
			:echo atan2(1, -1)
<			2.356194


							*browse()*
browse({save}, {title}, {initdir}, {default})
		Put up a file requester.  This only works when "has("browse")"
		returns non-zero (only in some GUI versions).
		The input fields are:
		    {save}	when non-zero, select file to write
		    {title}	title for the requester
		    {initdir}	directory to start browsing in
		    {default}	default file name
		When the "Cancel" button is hit, something went wrong, or
		browsing is not possible, an empty string is returned.

							*browsedir()*
browsedir({title}, {initdir})
		Put up a directory requester.  This only works when
		"has("browse")" returns non-zero (only in some GUI versions).
		On systems where a directory browser is not supported a file
		browser is used.  In that case: select a file in the directory
		to be used.
		The input fields are:
		    {title}	title for the requester
		    {initdir}	directory to start browsing in
		When the "Cancel" button is hit, something went wrong, or
		browsing is not possible, an empty string is returned.

bufexists({expr})					*bufexists()*
		The result is a Number, which is non-zero if a buffer called
		{expr} exists.
		If the {expr} argument is a number, buffer numbers are used.
		If the {expr} argument is a string it must match a buffer name
		exactly.  The name can be:
		- Relative to the current directory.
		- A full path.
		- The name of a buffer with 'buftype' set to "nofile".
		- A URL name.
		Unlisted buffers will be found.
		Note that help files are listed by their short name in the
		output of |:buffers|, but bufexists() requires using their
		long name to be able to find them.
		bufexists() may report a buffer exists, but to use the name
		with a |:buffer| command you may need to use |expand()|.  Esp
		for MS-Windows 8.3 names in the form "c:\DOCUME~1"
		Use "bufexists(0)" to test for the existence of an alternate
		file name.

buflisted({expr})					*buflisted()*
		The result is a Number, which is non-zero if a buffer called
		{expr} exists and is listed (has the 'buflisted' option set).
		The {expr} argument is used like with |bufexists()|.

bufloaded({expr})					*bufloaded()*
		The result is a Number, which is non-zero if a buffer called
		{expr} exists and is loaded (shown in a window or hidden).
		The {expr} argument is used like with |bufexists()|.

bufname({expr})						*bufname()*
		The result is the name of a buffer, as it is displayed by the
		":ls" command.
		If {expr} is a Number, that buffer number's name is given.
		Number zero is the alternate buffer for the current window.
		If {expr} is a String, it is used as a |file-pattern| to match
		with the buffer names.	This is always done like 'magic' is
		set and 'cpoptions' is empty.  When there is more than one
		match an empty string is returned.
		"" or "%" can be used for the current buffer, "#" for the
		alternate buffer.
		A full match is preferred, otherwise a match at the start, end
		or middle of the buffer name is accepted.  If you only want a
		full match then put "^" at the start and "$" at the end of the
		pattern.
		Listed buffers are found first.  If there is a single match
		with a listed buffer, that one is returned.  Next unlisted
		buffers are searched for.
		If the {expr} is a String, but you want to use it as a buffer
		number, force it to be a Number by adding zero to it: >
			:echo bufname("3" + 0)
<		If the buffer doesn't exist, or doesn't have a name, an empty
		string is returned. >
	bufname("#")		alternate buffer name
	bufname(3)		name of buffer 3
	bufname("%")		name of current buffer
	bufname("file2")	name of buffer where "file2" matches.

							*bufnr()*
bufnr({expr} [, {create}])
		The result is the number of a buffer, as it is displayed by
		the ":ls" command.  For the use of {expr}, see |bufname()|
		above.
		If the buffer doesn't exist, -1 is returned.  Or, if the
		{create} argument is present and not zero, a new, unlisted,
		buffer is created and its number is returned.
		bufnr("$") is the last buffer: >
	:let last_buffer = bufnr("$")
<		The result is a Number, which is the highest buffer number
		of existing buffers.  Note that not all buffers with a smaller
		number necessarily exist, because ":bwipeout" may have removed
		them.  Use bufexists() to test for the existence of a buffer.

bufwinid({expr})					*bufwinid()*
		The result is a Number, which is the window ID of the first
		window associated with buffer {expr}.  For the use of {expr},
		see |bufname()| above.  If buffer {expr} doesn't exist or
		there is no such window, -1 is returned.  Example: >

	echo "A window containing buffer 1 is " . (bufwinid(1))
<
		Only deals with the current tab page.

bufwinnr({expr})					*bufwinnr()*
		The result is a Number, which is the number of the first
		window associated with buffer {expr}.  For the use of {expr},
		see |bufname()| above.	If buffer {expr} doesn't exist or
		there is no such window, -1 is returned.  Example: >

	echo "A window containing buffer 1 is " . (bufwinnr(1))

<		The number can be used with |CTRL-W_w| and ":wincmd w"
		|:wincmd|.
		Only deals with the current tab page.


byte2line({byte})					*byte2line()*
		Return the line number that contains the character at byte
		count {byte} in the current buffer.  This includes the
		end-of-line character, depending on the 'fileformat' option
		for the current buffer.  The first character has byte count
		one.
		Also see |line2byte()|, |go| and |:goto|.

byteidx({expr}, {nr})					*byteidx()*
		Return byte index of the {nr}'th character in the string
		{expr}.  Use zero for the first character, it returns zero.
		This function is only useful when there are multibyte
		characters, otherwise the returned value is equal to {nr}.
		Composing characters are not counted separately, their byte
		length is added to the preceding base character.  See
		|byteidxcomp()| below for counting composing characters
		separately.
		Example : >
			echo matchstr(str, ".", byteidx(str, 3))
<		will display the fourth character.  Another way to do the
		same: >
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		If there are less than {nr} characters -1 is returned.
		If there are exactly {nr} characters the length of the string
		in bytes is returned.

byteidxcomp({expr}, {nr})					*byteidxcomp()*
		Like byteidx(), except that a composing character is counted
		as a separate character.  Example: >
			let s = 'e' . nr2char(0x301)
			echo byteidx(s, 1)
			echo byteidxcomp(s, 1)
			echo byteidxcomp(s, 2)
<		The first and third echo result in 3 ('e' plus composing
		character is 3 bytes), the second echo results in 1 ('e' is
		one byte).

call({func}, {arglist} [, {dict}])			*call()* *E699*
		Call function {func} with the items in |List| {arglist} as
		arguments.
		{func} can either be a |Funcref| or the name of a function.
		a:firstline and a:lastline are set to the cursor line.
		Returns the return value of the called function.
		{dict} is for functions with the "dict" attribute.  It will be
		used to set the local variable "self". |Dictionary-function|

ceil({expr})							*ceil()*
		Return the smallest integral value greater than or equal to
		{expr} as a |Float| (round up).
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			echo ceil(1.456)
<			2.0  >
			echo ceil(-5.456)
<			-5.0  >
			echo ceil(4.0)
<			4.0

changenr()						*changenr()*
		Return the number of the most recent change.  This is the same
		number as what is displayed with |:undolist| and can be used
		with the |:undo| command.
		When a change was made it is the number of that change.  After
		redo it is the number of the redone change.  After undo it is
		one less than the number of the undone change.

char2nr({expr}[, {utf8}])					*char2nr()*
		Return number value of the first char in {expr}.  Examples: >
			char2nr(" ")		returns 32
			char2nr("ABC")		returns 65
			char2nr("á")		returns 225
			char2nr("á"[0])		returns 195
<		Non-ASCII characters are always treated as UTF-8 characters.
		{utf8} has no effect, and exists only for
		backwards-compatibility.
		A combining character is a separate character.
		|nr2char()| does the opposite.

cindent({lnum})						*cindent()*
		Get the amount of indent for line {lnum} according the C
		indenting rules, as with 'cindent'.
		The indent is counted in spaces, the value of 'tabstop' is
		relevant.  {lnum} is used just like in |getline()|.
		When {lnum} is invalid -1 is returned.
		See |C-indenting|.

clearmatches()						*clearmatches()*
		Clears all matches previously defined by |matchadd()| and the
		|:match| commands.

							*col()*
col({expr})	The result is a Number, which is the byte index of the column
		position given with {expr}.  The accepted positions are:
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of bytes in the cursor line plus one)
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    v       In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |'<| in
			    that it's updated right away.
		Additionally {expr} can be [lnum, col]: a |List| with the line
		and column number. Most useful when the column is "$", to get
		the last column of a specific line.  When "lnum" or "col" is
		out of range then col() returns zero.
		To get the line number use |line()|.  To get both use
		|getpos()|.
		For the screen column position use |virtcol()|.
		Note that only marks in the current file can be used.
		Examples: >
			col(".")		column of cursor
			col("$")		length of cursor line plus one
			col("'t")		column of mark t
			col("'" . markname)	column of mark markname
<		The first column is 1.	0 is returned for an error.
		For an uppercase mark the column may actually be in another
		buffer.
		For the cursor position, when 'virtualedit' is active, the
		column is one higher if the cursor is after the end of the
		line.  This can be used to obtain the column in Insert mode: >
			:imap <F2> <C-O>:let save_ve = &ve<CR>
				\<C-O>:set ve=all<CR>
				\<C-O>:echo col(".") . "\n" <Bar>
				\let &ve = save_ve<CR>
<

complete({startcol}, {matches})			*complete()* *E785*
		Set the matches for Insert mode completion.
		Can only be used in Insert mode.  You need to use a mapping
		with CTRL-R = |i_CTRL-R|.  It does not work after CTRL-O or
		with an expression mapping.
		{startcol} is the byte offset in the line where the completed
		text start.  The text up to the cursor is the original text
		that will be replaced by the matches.  Use col('.') for an
		empty string.  "col('.') - 1" will replace one character by a
		match.
		{matches} must be a |List|.  Each |List| item is one match.
		See |complete-items| for the kind of items that are possible.
		Note that the after calling this function you need to avoid
		inserting anything that would cause completion to stop.
		The match can be selected with CTRL-N and CTRL-P as usual with
		Insert mode completion.  The popup menu will appear if
		specified, see |ins-completion-menu|.
		Example: >
	inoremap <F5> <C-R>=ListMonths()<CR>

	func! ListMonths()
	  call complete(col('.'), ['January', 'February', 'March',
		\ 'April', 'May', 'June', 'July', 'August', 'September',
		\ 'October', 'November', 'December'])
	  return ''
	endfunc
<		This isn't very useful, but it shows how it works.  Note that
		an empty string is returned to avoid a zero being inserted.

complete_add({expr})				*complete_add()*
		Add {expr} to the list of matches.  Only to be used by the
		function specified with the 'completefunc' option.
		Returns 0 for failure (empty string or out of memory),
		1 when the match was added, 2 when the match was already in
		the list.
		See |complete-functions| for an explanation of {expr}.	It is
		the same as one item in the list that 'omnifunc' would return.

complete_check()				*complete_check()*
		Check for a key typed while looking for completion matches.
		This is to be used when looking for matches takes some time.
		Returns non-zero when searching for matches is to be aborted,
		zero otherwise.
		Only to be used by the function specified with the
		'completefunc' option.

						*confirm()*
confirm({msg} [, {choices} [, {default} [, {type}]]])
		Confirm() offers the user a dialog, from which a choice can be
		made.  It returns the number of the choice.  For the first
		choice this is 1.
		Note: confirm() is only supported when compiled with dialog
		support, see |+dialog_con| and |+dialog_gui|.

		{msg} is displayed in a |dialog| with {choices} as the
		alternatives.  When {choices} is missing or empty, "&OK" is
		used (and translated).
		{msg} is a String, use '\n' to include a newline.  Only on
		some systems the string is wrapped when it doesn't fit.

		{choices} is a String, with the individual choices separated
		by '\n', e.g. >
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
<		The letter after the '&' is the shortcut key for that choice.
		Thus you can type 'c' to select "Cancel".  The shortcut does
		not need to be the first letter: >
			confirm("file has been modified", "&Save\nSave &All")
<		For the console, the first letter of each choice is used as
		the default shortcut key.

		The optional {default} argument is the number of the choice
		that is made if the user hits <CR>.  Use 1 to make the first
		choice the default one.  Use 0 to not set a default.  If
		{default} is omitted, 1 is used.

		The optional {type} argument gives the type of dialog.  This
		is only used for the icon of the Win32 GUI.  It can be one of
		these values: "Error", "Question", "Info", "Warning" or
		"Generic".  Only the first character is relevant.
		When {type} is omitted, "Generic" is used.

		If the user aborts the dialog by pressing <Esc>, CTRL-C,
		or another valid interrupt key, confirm() returns 0.

		An example: >
   :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
   :if choice == 0
   :	echo "make up your mind!"
   :elseif choice == 3
   :	echo "tasteful"
   :else
   :	echo "I prefer bananas myself."
   :endif
<		In a GUI dialog, buttons are used.  The layout of the buttons
		depends on the 'v' flag in 'guioptions'.  If it is included,
		the buttons are always put vertically.	Otherwise,  confirm()
		tries to put the buttons in one horizontal line.  If they
		don't fit, a vertical layout is used anyway.  For some systems
		the horizontal layout is always used.

							*copy()*
copy({expr})	Make a copy of {expr}.	For Numbers and Strings this isn't
		different from using {expr} directly.
		When {expr} is a |List| a shallow copy is created.  This means
		that the original |List| can be changed without changing the
		copy, and vice versa.  But the items are identical, thus
		changing an item changes the contents of both |Lists|.	Also
		see |deepcopy()|.

cos({expr})						*cos()*
		Return the cosine of {expr}, measured in radians, as a |Float|.
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo cos(100)
<			0.862319 >
			:echo cos(-4.01)
<			-0.646043


cosh({expr})						*cosh()*
		Return the hyperbolic cosine of {expr} as a |Float| in the range
		[1, inf].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo cosh(0.5)
<			1.127626 >
			:echo cosh(-0.5)
<			-1.127626


count({comp}, {expr} [, {ic} [, {start}]])			*count()*
		Return the number of times an item with value {expr} appears
		in |List| or |Dictionary| {comp}.
		If {start} is given then start with the item with this index.
		{start} can only be used with a |List|.
		When {ic} is given and it's non-zero then case is ignored.


							*cscope_connection()*
cscope_connection([{num} , {dbpath} [, {prepend}]])
		Checks for the existence of a |cscope| connection.  If no
		parameters are specified, then the function returns:
			0, if cscope was not available (not compiled in), or
			   if there are no cscope connections;
			1, if there is at least one cscope connection.

		If parameters are specified, then the value of {num}
		determines how existence of a cscope connection is checked:

		{num}	Description of existence check
		-----	------------------------------
		0	Same as no parameters (e.g., "cscope_connection()").
		1	Ignore {prepend}, and use partial string matches for
			{dbpath}.
		2	Ignore {prepend}, and use exact string matches for
			{dbpath}.
		3	Use {prepend}, use partial string matches for both
			{dbpath} and {prepend}.
		4	Use {prepend}, use exact string matches for both
			{dbpath} and {prepend}.

		Note: All string comparisons are case sensitive!

		Examples.  Suppose we had the following (from ":cs show"): >

  # pid    database name			prepend path
  0 27664  cscope.out				/usr/local
<
		Invocation					Return Val ~
		----------					---------- >
		cscope_connection()					1
		cscope_connection(1, "out")				1
		cscope_connection(2, "out")				0
		cscope_connection(3, "out")				0
		cscope_connection(3, "out", "local")			1
		cscope_connection(4, "out")				0
		cscope_connection(4, "out", "local")			0
		cscope_connection(4, "cscope.out", "/usr/local")	1
<
cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
		Positions the cursor at the column (byte count) {col} in the
		line {lnum}.  The first column is one.

		When there is one argument {list} this is used as a |List|
		with two, three or four item:
			[{lnum}, {col}]
			[{lnum}, {col}, {off}]
			[{lnum}, {col}, {off}, {curswant}]
		This is like the return value of |getpos()| or |getcurpos()|,
		but without the first item.

		Does not change the jumplist.
		If {lnum} is greater than the number of lines in the buffer,
		the cursor will be positioned at the last line in the buffer.
		If {lnum} is zero, the cursor will stay in the current line.
		If {col} is greater than the number of bytes in the line,
		the cursor will be positioned at the last character in the
		line.
		If {col} is zero, the cursor will stay in the current column.
		If {curswant} is given it is used to set the preferred column
		for vertical movement.  Otherwise {col} is used.

		When 'virtualedit' is used {off} specifies the offset in
		screen columns from the start of the character.  E.g., a
		position within a <Tab> or after the last character.
		Returns 0 when the position could be set, -1 otherwise.


deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
		Make a copy of {expr}.	For Numbers and Strings this isn't
		different from using {expr} directly.
		When {expr} is a |List| a full copy is created.  This means
		that the original |List| can be changed without changing the
		copy, and vice versa.  When an item is a |List|, a copy for it
		is made, recursively.  Thus changing an item in the copy does
		not change the contents of the original |List|.
		When {noref} is omitted or zero a contained |List| or
		|Dictionary| is only copied once.  All references point to
		this single copy.  With {noref} set to 1 every occurrence of a
		|List| or |Dictionary| results in a new copy.  This also means
		that a cyclic reference causes deepcopy() to fail.
								*E724*
		Nesting is possible up to 100 levels.  When there is an item
		that refers back to a higher level making a deep copy with
		{noref} set to 1 will fail.
		Also see |copy()|.

delete({fname} [, {flags}])					*delete()*
		Without {flags} or with {flags} empty: Deletes the file by the
		name {fname}.  This also works when {fname} is a symbolic link.
		A symbolic link itself is deleted, not what it points to.

		When {flags} is "d": Deletes the directory by the name
		{fname}.  This fails when directory {fname} is not empty.

		When {flags} is "rf": Deletes the directory by the name
		{fname} and everything in it, recursively.  BE CAREFUL!

		The result is a Number, which is 0 if the delete operation was
		successful and -1 when the deletion failed or partly failed.

dictwatcheradd({dict}, {pattern}, {callback})		      *dictwatcheradd()*
		Adds a watcher to a dictionary. A dictionary watcher is
		identified by three components:

		- A dictionary({dict});
		- A key pattern({pattern}).
		- A function({callback}).

		After this is called, every change on {dict} and on keys
		matching {pattern} will result in {callback} being invoked.

		For example, to watch all global variables: >
			silent! call dictwatcherdel(g:, '*', 'OnDictChanged')
			function! OnDictChanged(d,k,z)
			  echomsg string(a:k) string(a:z)
			endfunction
			call dictwatcheradd(g:, '*', 'OnDictChanged')
<
		For now {pattern} only accepts very simple patterns that can
		contain a '*' at the end of the string, in which case it will
		match every key that begins with the substring before the '*'.
		That means if '*' is not the last character of {pattern}, only
		keys that are exactly equal as {pattern} will be matched.

		The {callback} receives three arguments:

		- The dictionary being watched.
		- The key which changed.
		- A dictionary containing the new and old values for the key.

		The type of change can be determined by examining the keys
		present on the third argument:

		- If contains both `old` and `new`, the key was updated.
		- If it contains only `new`, the key was added.
		- If it contains only `old`, the key was deleted.

		This function can be used by plugins to implement options with
		validation and parsing logic.

dictwatcherdel({dict}, {pattern}, {callback})		      *dictwatcherdel()*
		Removes a watcher added  with |dictwatcheradd()|. All three
		arguments must match the ones passed to |dictwatcheradd()| in
		order for the watcher to be successfully deleted.

							*did_filetype()*
did_filetype()	Returns non-zero when autocommands are being executed and the
		FileType event has been triggered at least once.  Can be used
		to avoid triggering the FileType event again in the scripts
		that detect the file type. |FileType|
		When editing another file, the counter is reset, thus this
		really checks if the FileType event has been triggered for the
		current buffer.  This allows an autocommand that starts
		editing another buffer to set 'filetype' and load a syntax
		file.

diff_filler({lnum})					*diff_filler()*
		Returns the number of filler lines above line {lnum}.
		These are the lines that were inserted at this point in
		another diff'ed window.  These filler lines are shown in the
		display but don't exist in the buffer.
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		Returns 0 if the current window is not in diff mode.

diff_hlID({lnum}, {col})				*diff_hlID()*
		Returns the highlight ID for diff mode at line {lnum} column
		{col} (byte index).  When the current line does not have a
		diff change zero is returned.
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		{col} is 1 for the leftmost column, {lnum} is 1 for the first
		line.
		The highlight ID can be used with |synIDattr()| to obtain
		syntax information about the highlighting.

empty({expr})						*empty()*
		Return the Number 1 if {expr} is empty, zero otherwise.
		A |List| or |Dictionary| is empty when it does not have any
		items.  A Number is empty when its value is zero.  Special 
		variable is empty when it is |v:false| or |v:null|.

escape({string}, {chars})				*escape()*
		Escape the characters in {chars} that occur in {string} with a
		backslash.  Example: >
			:echo escape('c:\program files\vim', ' \')
<		results in: >
			c:\\program\ files\\vim
<		Also see |shellescape()|.

							*eval()*
eval({string})	Evaluate {string} and return the result.  Especially useful to
		turn the result of |string()| back into the original value.
		This works for Numbers, Floats, Strings and composites of
		them.  Also works for |Funcref|s that refer to existing
		functions.

eventhandler()						*eventhandler()*
		Returns 1 when inside an event handler.  That is that Vim got
		interrupted while waiting for the user to type a character,
		e.g., when dropping a file on Vim.  This means interactive
		commands cannot be used.  Otherwise zero is returned.

executable({expr})					*executable()*
		This function checks if an executable with the name {expr}
		exists.  {expr} must be the name of the program without any
		arguments.
		executable() uses the value of $PATH and/or the normal
		searchpath for programs.		*PATHEXT*
		On Windows the ".exe", ".bat", etc. can
		optionally be included.  Then the extensions in $PATHEXT are
		tried.	Thus if "foo.exe" does not exist, "foo.exe.bat" can be
		found.	If $PATHEXT is not set then ".exe;.com;.bat;.cmd" is
		used.  A dot by itself can be used in $PATHEXT to try using
		the name without an extension.	When 'shell' looks like a
		Unix shell, then the name is also tried without adding an
		extension.
		On Windows it only checks if the file exists and
		is not a directory, not if it's really executable.
		On Windows an executable in the same directory as Vim is
		always found.  Since this directory is added to $PATH it
		should also work to execute it |win32-PATH|.
		The result is a Number:
			1	exists
			0	does not exist
			-1	not implemented on this system

execute({command})					*execute()*
		Execute {command} and capture its output.
		If {command} is a |String|, returns {command} output.
		If {command} is a |List|, returns concatenated outputs.
		Examples: >
			echo execute('echon "foo"')
<			foo >
			echo execute(['echon "foo"', 'echon "bar"'])
<			foobar
		This function is not available in the |sandbox|.
		Note: {command} executes as if prepended with |:silent|
		(output is collected but not displayed).  If nested, an outer
		execute() will not observe output of the inner calls.
		Note: Text attributes (highlights) are not captured.

exepath({expr})						*exepath()*
		If {expr} is an executable and is either an absolute path, a
		relative path or found in $PATH, return the full path.
		Note that the current directory is used when {expr} starts
		with "./", which may be a problem for Vim: >
			echo exepath(v:progpath)
<		If {expr} cannot be found in $PATH or is not executable then
		an empty string is returned.

							*exists()*
exists({expr})	The result is a Number, which is non-zero if {expr} is
		defined, zero otherwise.  The {expr} argument is a string,
		which contains one of these:
			&option-name	Vim option (only checks if it exists,
					not if it really works)
			+option-name	Vim option that works.
			$ENVNAME	environment variable (could also be
					done by comparing with an empty
					string)
			*funcname	built-in function (see |functions|)
					or user defined function (see
					|user-functions|). Also works for a
					variable that is a Funcref.
			varname		internal variable (see
					|internal-variables|).	Also works
					for |curly-braces-names|, |Dictionary|
					entries, |List| items, etc.  Beware
					that evaluating an index may cause an
					error message for an invalid
					expression.  E.g.: >
					   :let l = [1, 2, 3]
					   :echo exists("l[5]")
<					   0 >
					   :echo exists("l[xx]")
<					   E121: Undefined variable: xx
					   0
			:cmdname	Ex command: built-in command, user
					command or command modifier |:command|.
					Returns:
					1  for match with start of a command
					2  full match with a command
					3  matches several user commands
					To check for a supported command
					always check the return value to be 2.
			:2match		The |:2match| command.
			:3match		The |:3match| command.
			#event		autocommand defined for this event
			#event#pattern	autocommand defined for this event and
					pattern (the pattern is taken
					literally and compared to the
					autocommand patterns character by
					character)
			#group		autocommand group exists
			#group#event	autocommand defined for this group and
					event.
			#group#event#pattern
					autocommand defined for this group,
					event and pattern.
			##event		autocommand for this event is
					supported.
		For checking for a supported feature use |has()|.

		Examples: >
			exists("&mouse")
			exists("$HOSTNAME")
			exists("*strftime")
			exists("*s:MyFunc")
			exists("bufcount")
			exists(":Make")
			exists("#CursorHold")
			exists("#BufReadPre#*.gz")
			exists("#filetypeindent")
			exists("#filetypeindent#FileType")
			exists("#filetypeindent#FileType#*")
			exists("##ColorScheme")
<		There must be no space between the symbol (&/$/*/#) and the
		name.
		There must be no extra characters after the name, although in
		a few cases this is ignored.  That may become more strict in
		the future, thus don't count on it!
		Working example: >
			exists(":make")
<		NOT working example: >
			exists(":make install")

<		Note that the argument must be a string, not the name of the
		variable itself.  For example: >
			exists(bufcount)
<		This doesn't check for existence of the "bufcount" variable,
		but gets the value of "bufcount", and checks if that exists.

exp({expr})						*exp()*
		Return the exponential of {expr} as a |Float| in the range
		[0, inf].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo exp(2)
<			7.389056 >
			:echo exp(-1)
<			0.367879


expand({expr} [, {nosuf} [, {list}]])				*expand()*
		Expand wildcards and the following special keywords in {expr}.
		'wildignorecase' applies.

		If {list} is given and it is non-zero, a List will be returned.
		Otherwise the result is a String and when there are several
		matches, they are separated by <NL> characters.  [Note: in
		version 5.0 a space was used, which caused problems when a
		file name contains a space]

		If the expansion fails, the result is an empty string.	A name
		for a non-existing file is not included, unless {expr} does
		not start with '%', '#' or '<', see below.

		When {expr} starts with '%', '#' or '<', the expansion is done
		like for the |cmdline-special| variables with their associated
		modifiers.  Here is a short overview:

			%		current file name
			#		alternate file name
			#n		alternate file name n
			<cfile>		file name under the cursor
			<afile>		autocmd file name
			<abuf>		autocmd buffer number (as a String!)
			<amatch>	autocmd matched name
			<sfile>		sourced script file or function name
			<slnum>		sourced script file line number
			<cword>		word under the cursor
			<cWORD>		WORD under the cursor
			<client>	the {clientid} of the last received
					message |server2client()|
		Modifiers:
			:p		expand to full path
			:h		head (last path component removed)
			:t		tail (last path component only)
			:r		root (one extension removed)
			:e		extension only

		Example: >
			:let &tags = expand("%:p:h") . "/tags"
<		Note that when expanding a string that starts with '%', '#' or
		'<', any following text is ignored.  This does NOT work: >
			:let doesntwork = expand("%:h.bak")
<		Use this: >
			:let doeswork = expand("%:h") . ".bak"
<		Also note that expanding "<cfile>" and others only returns the
		referenced file name without further expansion.  If "<cfile>"
		is "~/.cshrc", you need to do another expand() to have the
		"~/" expanded into the path of the home directory: >
			:echo expand(expand("<cfile>"))
<
		There cannot be white space between the variables and the
		following modifier.  The |fnamemodify()| function can be used
		to modify normal file names.

		When using '%' or '#', and the current or alternate file name
		is not defined, an empty string is used.  Using "%:p" in a
		buffer with no name, results in the current directory, with a
		'/' added.

		When {expr} does not start with '%', '#' or '<', it is
		expanded like a file name is expanded on the command line.
		'suffixes' and 'wildignore' are used, unless the optional
		{nosuf} argument is given and it is non-zero.
		Names for non-existing files are included.  The "**" item can
		be used to search in a directory tree.  For example, to find
		all "README" files in the current directory and below: >
			:echo expand("**/README")
<
		Expand() can also be used to expand variables and environment
		variables that are only known in a shell.  But this can be
		slow, because a shell may be used to do the expansion.  See
		|expr-env-expand|.
		The expanded variable is still handled like a list of file
		names.	When an environment variable cannot be expanded, it is
		left unchanged.  Thus ":echo expand('$FOOBAR')" results in
		"$FOOBAR".

		See |glob()| for finding existing files.  See |system()| for
		getting the raw output of an external command.

extend({expr1}, {expr2} [, {expr3}])			*extend()*
		{expr1} and {expr2} must be both |Lists| or both
		|Dictionaries|.

		If they are |Lists|: Append {expr2} to {expr1}.
		If {expr3} is given insert the items of {expr2} before item
		{expr3} in {expr1}.  When {expr3} is zero insert before the
		first item.  When {expr3} is equal to len({expr1}) then
		{expr2} is appended.
		Examples: >
			:echo sort(extend(mylist, [7, 5]))
			:call extend(mylist, [2, 3], 1)
<		When {expr1} is the same List as {expr2} then the number of
		items copied is equal to the original length of the List.
		E.g., when {expr3} is 1 you get N new copies of the first item
		(where N is the original length of the List).
		Use |add()| to concatenate one item to a list.	To concatenate
		two lists into a new list use the + operator: >
			:let newlist = [1, 2, 3] + [4, 5]
<
		If they are |Dictionaries|:
		Add all entries from {expr2} to {expr1}.
		If a key exists in both {expr1} and {expr2} then {expr3} is
		used to decide what to do:
		{expr3} = "keep": keep the value of {expr1}
		{expr3} = "force": use the value of {expr2}
		{expr3} = "error": give an error message		*E737*
		When {expr3} is omitted then "force" is assumed.

		{expr1} is changed when {expr2} is not empty.  If necessary
		make a copy of {expr1} first.
		{expr2} remains unchanged.
		When {expr1} is locked and {expr2} is not empty the operation
		fails.
		Returns {expr1}.


feedkeys({string} [, {mode}])				*feedkeys()*
		Characters in {string} are queued for processing as if they
		come from a mapping or were typed by the user.
		By default the string is added to the end of the typeahead
		buffer, thus if a mapping is still being executed the
		characters come after them.  Use the 'i' flag to insert before
		other characters, they will be executed next, before any
		characters from a mapping.
		The function does not wait for processing of keys contained in
		{string}.
		To include special keys into {string}, use double-quotes
		and "\..." notation |expr-quote|. For example,
		feedkeys("\<CR>") simulates pressing of the <Enter> key. But
		feedkeys('\<CR>') pushes 5 characters.
		If {mode} is absent, keys are remapped.
		{mode} is a String, which can contain these character flags:
		'm'	Remap keys. This is default.
		'n'	Do not remap keys.
		't'	Handle keys as if typed; otherwise they are handled as
			if coming from a mapping.  This matters for undo,
			opening folds, etc.
		'i'	Insert the string instead of appending (see above).
		'x'	Execute commands until typeahead is empty.  This is
			similar to using ":normal!".  You can call feedkeys()
			several times without 'x' and then one time with 'x'
			(possibly with an empty {string}) to execute all the
			typeahead.  Note that when Vim ends in Insert mode it
			will behave as if <Esc> is typed, to avoid getting
			stuck, waiting for a character to be typed before the
			script continues.
		Return value is always 0.

filereadable({file})					*filereadable()*
		The result is a Number, which is TRUE when a file with the
		name {file} exists, and can be read.  If {file} doesn't exist,
		or is a directory, the result is FALSE.  {file} is any
		expression, which is used as a String.
		If you don't care about the file being readable you can use
		|glob()|.


filewritable({file})					*filewritable()*
		The result is a Number, which is 1 when a file with the
		name {file} exists, and can be written.  If {file} doesn't
		exist, or is not writable, the result is 0.  If {file} is a
		directory, and we can write to it, the result is 2.


filter({expr}, {string})					*filter()*
		{expr} must be a |List| or a |Dictionary|.
		For each item in {expr} evaluate {string} and when the result
		is zero remove the item from the |List| or |Dictionary|.
		Inside {string} |v:val| has the value of the current item.
		For a |Dictionary| |v:key| has the key of the current item.
		Examples: >
			:call filter(mylist, 'v:val !~ "OLD"')
<		Removes the items where "OLD" appears. >
			:call filter(mydict, 'v:key >= 8')
<		Removes the items with a key below 8. >
			:call filter(var, 0)
<		Removes all the items, thus clears the |List| or |Dictionary|.

		Note that {string} is the result of expression and is then
		used as an expression again.  Often it is good to use a
		|literal-string| to avoid having to double backslashes.

		The operation is done in-place.  If you want a |List| or
		|Dictionary| to remain unmodified make a copy first: >
			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		Returns {expr}, the |List| or |Dictionary| that was filtered.
		When an error is encountered while evaluating {string} no
		further items in {expr} are processed.


finddir({name}[, {path}[, {count}]])				*finddir()*
		Find directory {name} in {path}.  Supports both downwards and
		upwards recursive directory searches.  See |file-searching|
		for the syntax of {path}.
		Returns the path of the first found match.  When the found
		directory is below the current directory a relative path is
		returned.  Otherwise a full path is returned.
		If {path} is omitted or empty then 'path' is used.
		If the optional {count} is given, find {count}'s occurrence of
		{name} in {path} instead of the first one.
		When {count} is negative return all the matches in a |List|.
		This is quite similar to the ex-command |:find|.
		{only available when compiled with the |+file_in_path|
		feature}

findfile({name}[, {path}[, {count}]])				*findfile()*
		Just like |finddir()|, but find a file instead of a directory.
		Uses 'suffixesadd'.
		Example: >
			:echo findfile("tags.vim", ".;")
<		Searches from the directory of the current file upwards until
		it finds the file "tags.vim".

float2nr({expr})					*float2nr()*
		Convert {expr} to a Number by omitting the part after the
		decimal point.
		{expr} must evaluate to a |Float| or a Number.
		When the value of {expr} is out of range for a |Number| the
		result is truncated to 0x7fffffff or -0x7fffffff.  NaN results
		in -0x80000000.
		Examples: >
			echo float2nr(3.95)
<			3  >
			echo float2nr(-23.45)
<			-23  >
			echo float2nr(1.0e100)
<			2147483647  >
			echo float2nr(-1.0e150)
<			-2147483647  >
			echo float2nr(1.0e-100)
<			0


floor({expr})							*floor()*
		Return the largest integral value less than or equal to
		{expr} as a |Float| (round down).
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			echo floor(1.856)
<			1.0  >
			echo floor(-5.456)
<			-6.0  >
			echo floor(4.0)
<			4.0


fmod({expr1}, {expr2})					*fmod()*
		Return the remainder of {expr1} / {expr2}, even if the
		division is not representable.  Returns {expr1} - i * {expr2}
		for some integer i such that if {expr2} is non-zero, the
		result has the same sign as {expr1} and magnitude less than
		the magnitude of {expr2}.  If {expr2} is zero, the value
		returned is zero.  The value returned is a |Float|.
		{expr1} and {expr2} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo fmod(12.33, 1.22)
<			0.13 >
			:echo fmod(-12.33, 1.22)
<			-0.13


fnameescape({string})					*fnameescape()*
		Escape {string} for use as file name command argument.	All
		characters that have a special meaning, such as '%' and '|'
		are escaped with a backslash.
		For most systems the characters escaped are
		" \t\n*?[{`$\\%#'\"|!<".  For systems where a backslash
		appears in a filename, it depends on the value of 'isfname'.
		A leading '+' and '>' is also escaped (special after |:edit|
		and |:write|).  And a "-" by itself (special after |:cd|).
		Example: >
			:let fname = '+some str%nge|name'
			:exe "edit " . fnameescape(fname)
<		results in executing: >
			edit \+some\ str\%nge\|name

fnamemodify({fname}, {mods})				*fnamemodify()*
		Modify file name {fname} according to {mods}.  {mods} is a
		string of characters like it is used for file names on the
		command line.  See |filename-modifiers|.
		Example: >
			:echo fnamemodify("main.c", ":p:h")
<		results in: >
			/home/mool/vim/vim/src
<		Note: Environment variables don't work in {fname}, use
		|expand()| first then.

foldclosed({lnum})					*foldclosed()*
		The result is a Number.  If the line {lnum} is in a closed
		fold, the result is the number of the first line in that fold.
		If the line {lnum} is not in a closed fold, -1 is returned.

foldclosedend({lnum})					*foldclosedend()*
		The result is a Number.  If the line {lnum} is in a closed
		fold, the result is the number of the last line in that fold.
		If the line {lnum} is not in a closed fold, -1 is returned.

foldlevel({lnum})					*foldlevel()*
		The result is a Number, which is the foldlevel of line {lnum}
		in the current buffer.	For nested folds the deepest level is
		returned.  If there is no fold at line {lnum}, zero is
		returned.  It doesn't matter if the folds are open or closed.
		When used while updating folds (from 'foldexpr') -1 is
		returned for lines where folds are still to be updated and the
		foldlevel is unknown.  As a special case the level of the
		previous line is usually available.

							*foldtext()*
foldtext()	Returns a String, to be displayed for a closed fold.  This is
		the default function used for the 'foldtext' option and should
		only be called from evaluating 'foldtext'.  It uses the
		|v:foldstart|, |v:foldend| and |v:folddashes| variables.
		The returned string looks like this: >
			+-- 45 lines: abcdef
<		The number of dashes depends on the foldlevel.	The "45" is
		the number of lines in the fold.  "abcdef" is the text in the
		first non-blank line of the fold.  Leading white space, "//"
		or "/*" and the text from the 'foldmarker' and 'commentstring'
		options is removed.
		{not available when compiled without the |+folding| feature}

foldtextresult({lnum})					*foldtextresult()*
		Returns the text that is displayed for the closed fold at line
		{lnum}.  Evaluates 'foldtext' in the appropriate context.
		When there is no closed fold at {lnum} an empty string is
		returned.
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		Useful when exporting folded text, e.g., to HTML.
		{not available when compiled without the |+folding| feature}

							*foreground()*
foreground()	Move the Vim window to the foreground.	Useful when sent from
		a client to a Vim server. |remote_send()|
		On Win32 systems this might not work, the OS does not always
		allow a window to bring itself to the foreground.  Use
		|remote_foreground()| instead.
		{only in the Win32 GUI and console version}


function({name})					*function()* *E700*
		Return a |Funcref| variable that refers to function {name}.
		{name} can be a user defined function or an internal function.


garbagecollect([{atexit}])				*garbagecollect()*
		Cleanup unused |Lists| and |Dictionaries| that have circular
		references.  There is hardly ever a need to invoke this
		function, as it is automatically done when Vim runs out of
		memory or is waiting for the user to press a key after
		'updatetime'.  Items without circular references are always
		freed when they become unused.
		This is useful if you have deleted a very big |List| and/or
		|Dictionary| with circular references in a script that runs
		for a long time.
		When the optional {atexit} argument is one, garbage
		collection will also be done when exiting Vim, if it wasn't
		done before.  This is useful when checking for memory leaks.

get({list}, {idx} [, {default}])			*get()*
		Get item {idx} from |List| {list}.  When this item is not
		available return {default}.  Return zero when {default} is
		omitted.
get({dict}, {key} [, {default}])
		Get item with key {key} from |Dictionary| {dict}.  When this
		item is not available return {default}.  Return zero when
		{default} is omitted.

							*getbufline()*
getbufline({expr}, {lnum} [, {end}])
		Return a |List| with the lines starting from {lnum} to {end}
		(inclusive) in the buffer {expr}.  If {end} is omitted, a
		|List| with only the line {lnum} is returned.

		For the use of {expr}, see |bufname()| above.

		For {lnum} and {end} "$" can be used for the last line of the
		buffer.  Otherwise a number must be used.

		When {lnum} is smaller than 1 or bigger than the number of
		lines in the buffer, an empty |List| is returned.

		When {end} is greater than the number of lines in the buffer,
		it is treated as {end} is set to the number of lines in the
		buffer.  When {end} is before {lnum} an empty |List| is
		returned.

		This function works only for loaded buffers.  For unloaded and
		non-existing buffers, an empty |List| is returned.

		Example: >
			:let lines = getbufline(bufnr("myfile"), 1, "$")

getbufvar({expr}, {varname} [, {def}])				*getbufvar()*
		The result is the value of option or local buffer variable
		{varname} in buffer {expr}.  Note that the name without "b:"
		must be used.
		When {varname} is empty returns a dictionary with all the
		buffer-local variables.
		This also works for a global or buffer-local option, but it
		doesn't work for a global variable, window-local variable or
		window-local option.
		For the use of {expr}, see |bufname()| above.
		When the buffer or variable doesn't exist {def} or an empty
		string is returned, there is no error message.
		Examples: >
			:let bufmodified = getbufvar(1, "&mod")
			:echo "todo myvar = " . getbufvar("todo", "myvar")
<
getchar([expr])						*getchar()*
		Get a single character from the user or input stream.
		If [expr] is omitted, wait until a character is available.
		If [expr] is 0, only get a character when one is available.
			Return zero otherwise.
		If [expr] is 1, only check if a character is available, it is
			not consumed.  Return zero if no character available.

		Without [expr] and when [expr] is 0 a whole character or
		special key is returned.  If it is an 8-bit character, the
		result is a number.  Use nr2char() to convert it to a String.
		Otherwise a String is returned with the encoded character.
		For a special key it's a sequence of bytes starting with 0x80
		(decimal: 128).  This is the same value as the string
		"\<Key>", e.g., "\<Left>".  The returned value is also a
		String when a modifier (shift, control, alt) was used that is
		not included in the character.

		When [expr] is 0 and Esc is typed, there will be a short delay
		while Vim waits to see if this is the start of an escape
		sequence.

		When [expr] is 1 only the first byte is returned.  For a
		one-byte character it is the character itself as a number.
		Use nr2char() to convert it to a String.

		Use getcharmod() to obtain any additional modifiers.

		When the user clicks a mouse button, the mouse event will be
		returned.  The position can then be found in |v:mouse_col|,
		|v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.  This
		example positions the mouse as it would normally happen: >
			let c = getchar()
			if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win . "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " . v:mouse_col . "|"
			endif
<
		There is no prompt, you will somehow have to make clear to the
		user that a character has to be typed.
		There is no mapping for the character.
		Key codes are replaced, thus when the user presses the <Del>
		key you get the code for the <Del> key, not the raw character
		sequence.  Examples: >
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		This example redefines "f" to ignore case: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction
<
		You may also receive synthetic characters, such as
		|<CursorHold>|. Often you will want to ignore this and get
		another character: >
			:function GetKey()
			:  let c = getchar()
			:  while c == "\<CursorHold>"
			:    let c = getchar()
			:  endwhile
			:  return c
			:endfunction

getcharmod()						*getcharmod()*
		The result is a Number which is the state of the modifiers for
		the last obtained character with getchar() or in another way.
		These values are added together:
			2	shift
			4	control
			8	alt (meta)
			16	meta (when it's different from ALT)
			32	mouse double click
			64	mouse triple click
			96	mouse quadruple click (== 32 + 64)
			128	command (Macintosh only)
		Only the modifiers that have not been included in the
		character itself are obtained.	Thus Shift-a results in "A"
		without a modifier.

getcharsearch()						*getcharsearch()*
		Return the current character search information as a {dict}
		with the following entries:

		    char	character previously used for a character
				search (|t|, |f|, |T|, or |F|); empty string
				if no character search has been performed
		    forward	direction of character search; 1 for forward,
				0 for backward
		    until	type of character search; 1 for a |t| or |T|
				character search, 0 for an |f| or |F|
				character search

		This can be useful to always have |;| and |,| search
		forward/backward regardless of the direction of the previous
		character search: >
			:nnoremap <expr> ; getcharsearch().forward ? ';' : ','
			:nnoremap <expr> , getcharsearch().forward ? ',' : ';'
<		Also see |setcharsearch()|.

getcmdline()						*getcmdline()*
		Return the current command-line.  Only works when the command
		line is being edited, thus requires use of |c_CTRL-\_e| or
		|c_CTRL-R_=|.
		Example: >
			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		Also see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.

getcmdpos()						*getcmdpos()*
		Return the position of the cursor in the command line as a
		byte count.  The first column is 1.
		Only works when editing the command line, thus requires use of
		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
		Returns 0 otherwise.
		Also see |getcmdtype()|, |setcmdpos()| and |getcmdline()|.

getcmdtype()						*getcmdtype()*
		Return the current command-line type. Possible return values
		are:
		    :	normal Ex command
		    >	debug mode command |debug-mode|
		    /	forward search command
		    ?	backward search command
		    @	|input()| command
		    -	|:insert| or |:append| command
		    =	|i_CTRL-R_=|
		Only works when editing the command line, thus requires use of
		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
		Returns an empty string otherwise.
		Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.

getcmdwintype()						*getcmdwintype()*
		Return the current |command-line-window| type. Possible return
		values are the same as |getcmdtype()|. Returns an empty string
		when not in the command-line window.

getcompletion({pat}, {type} [, {filtered}])		*getcompletion()*
		Return a list of command-line completion matches. {type}
		specifies what for.  The following completion types are
		supported:

		augroup		autocmd groups
		buffer		buffer names
		behave		:behave suboptions
		color		color schemes
		command		Ex command (and arguments)
		compiler	compilers
		cscope		|:cscope| suboptions
		dir		directory names
		environment	environment variable names
		event		autocommand events
		expression	Vim expression
		file		file and directory names
		file_in_path	file and directory names in |'path'|
		filetype	filetype names |'filetype'|
		function	function name
		help		help subjects
		highlight	highlight groups
		history		:history suboptions
		locale		locale names (as output of locale -a)
		mapping		mapping name
		menu		menus
		option		options
		shellcmd	Shell command
		sign		|:sign| suboptions
		syntax		syntax file names |'syntax'|
		syntime		|:syntime| suboptions
		tag		tags
		tag_listfiles	tags, file names
		user		user names
		var		user variables

		If {pat} is an empty string, then all the matches are returned.
		Otherwise only items matching {pat} are returned. See
		|wildcards| for the use of special characters in {pat}.

		If the optional {filtered} flag is set to 1, then 'wildignore'
		is applied to filter the results.  Otherwise all the matches
		are returned. The 'wildignorecase' option always applies.

		If there are no matches, an empty list is returned.  An
		invalid value for {type} produces an error.

							*getcurpos()*
getcurpos()	Get the position of the cursor.  This is like getpos('.'), but
		includes an extra item in the list:
		    [bufnum, lnum, col, off, curswant] ~
		The "curswant" number is the preferred column when moving the
		cursor vertically.
		This can be used to save and restore the cursor position: >
			let save_cursor = getcurpos()
			MoveTheCursorAround
			call setpos('.', save_cursor)
<
getcwd([{winnr}[, {tabnr}]])				*getcwd()*
		With no arguments the result is a String, which is the name of
		the current effective working directory. With {winnr} or
		{tabnr} the working directory of that scope is returned.
		Tabs and windows are identified by their respective numbers,
		0 means current tab or window. Missing argument implies 0.
		Thus the following are equivalent: >
			getcwd()
			getcwd(0)
			getcwd(0, 0)
<		If {winnr} is -1 it is ignored, only the tab is resolved.
		{winnr} can be the window number or the window ID.


getfsize({fname})					*getfsize()*
		The result is a Number, which is the size in bytes of the
		given file {fname}.
		If {fname} is a directory, 0 is returned.
		If the file {fname} can't be found, -1 is returned.
		If the size of {fname} is too big to fit in a Number then -2
		is returned.

getfontname([{name}])					*getfontname()*
		Without an argument returns the name of the normal font being
		used.  Like what is used for the Normal highlight group
		|hl-Normal|.
		With an argument a check is done whether {name} is a valid
		font name.  If not then an empty string is returned.
		Otherwise the actual font name is returned, or {name} if the
		GUI does not support obtaining the real name.
		Only works when the GUI is running, thus not in your vimrc or
		gvimrc file.  Use the |GUIEnter| autocommand to use this
		function just after the GUI has started.

getfperm({fname})					*getfperm()*
		The result is a String, which is the read, write, and execute
		permissions of the given file {fname}.
		If {fname} does not exist or its directory cannot be read, an
		empty string is returned.
		The result is of the form "rwxrwxrwx", where each group of
		"rwx" flags represent, in turn, the permissions of the owner
		of the file, the group the file belongs to, and other users.
		If a user does not have a given permission the flag for this
		is replaced with the string "-".  Examples: >
			:echo getfperm("/etc/passwd")
			:echo getfperm(expand("~/.config/nvim/init.vim"))
<		This will hopefully (from a security point of view) display
		the string "rw-r--r--" or even "rw-------".

		For setting permissions use |setfperm()|.

getftime({fname})					*getftime()*
		The result is a Number, which is the last modification time of
		the given file {fname}.  The value is measured as seconds
		since 1st Jan 1970, and may be passed to strftime().  See also
		|localtime()| and |strftime()|.
		If the file {fname} can't be found -1 is returned.

getftype({fname})					*getftype()*
		The result is a String, which is a description of the kind of
		file of the given file {fname}.
		If {fname} does not exist an empty string is returned.
		Here is a table over different kinds of files and their
		results:
			Normal file		"file"
			Directory		"dir"
			Symbolic link		"link"
			Block device		"bdev"
			Character device	"cdev"
			Socket			"socket"
			FIFO			"fifo"
			All other		"other"
		Example: >
			getftype("/home")
<		Note that a type such as "link" will only be returned on
		systems that support it.  On some systems only "dir" and
		"file" are returned.  On MS-Windows a symbolic link to a
		directory returns "dir" instead of "link".

							*getline()*
getline({lnum} [, {end}])
		Without {end} the result is a String, which is line {lnum}
		from the current buffer.  Example: >
			getline(1)
<		When {lnum} is a String that doesn't start with a
		digit, line() is called to translate the String into a Number.
		To get the line under the cursor: >
			getline(".")
<		When {lnum} is smaller than 1 or bigger than the number of
		lines in the buffer, an empty string is returned.

		When {end} is given the result is a |List| where each item is
		a line from the current buffer in the range {lnum} to {end},
		including line {end}.
		{end} is used in the same way as {lnum}.
		Non-existing lines are silently omitted.
		When {end} is before {lnum} an empty |List| is returned.
		Example: >
			:let start = line('.')
			:let end = search("^$") - 1
			:let lines = getline(start, end)

<		To get lines from another buffer see |getbufline()|

getloclist({nr})					*getloclist()*
		Returns a list with all the entries in the location list for
		window {nr}. {nr} can be the window number or the window ID.
		When {nr} is zero the current window is used.

		For a location list window, the displayed location list is
		returned.  For an invalid window number {nr}, an empty list is
		returned. Otherwise, same as |getqflist()|.

getmatches()						*getmatches()*
		Returns a |List| with all matches previously defined by
		|matchadd()| and the |:match| commands.  |getmatches()| is
		useful in combination with |setmatches()|, as |setmatches()|
		can restore a list of matches saved by |getmatches()|.
		Example: >
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:let m = getmatches()
			:call clearmatches()
			:echo getmatches()
<			[] >
			:call setmatches(m)
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:unlet m
<
							*getpid()*
getpid()	Return a Number which is the process ID of the Vim process.
		This is a unique number, until Vim exits.

							*getpos()*
getpos({expr})	Get the position for {expr}.  For possible values of {expr}
		see |line()|.  For getting the cursor position see
		|getcurpos()|.
		The result is a |List| with four numbers:
		    [bufnum, lnum, col, off]
		"bufnum" is zero, unless a mark like '0 or 'A is used, then it
		is the buffer number of the mark.
		"lnum" and "col" are the position in the buffer.  The first
		column is 1.
		The "off" number is zero, unless 'virtualedit' is used.  Then
		it is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.
		Note that for '< and '> Visual mode matters: when it is "V"
		(visual line mode) the column of '< is zero and the column of
		'> is a large number.
		This can be used to save and restore the position of a mark: >
			let save_a_mark = getpos("'a")
			...
			call setpos("'a", save_a_mark)
<		Also see |getcurpos()| and |setpos()|.


getqflist()						*getqflist()*
		Returns a list with all the current quickfix errors.  Each
		list item is a dictionary with these entries:
			bufnr	number of buffer that has the file name, use
				bufname() to get the name
			lnum	line number in the buffer (first line is 1)
			col	column number (first column is 1)
			vcol	non-zero: "col" is visual column
				zero: "col" is byte index
			nr	error number
			pattern	search pattern used to locate the error
			text	description of the error
			type	type of the error, 'E', '1', etc.
			valid	non-zero: recognized error message

		When there is no error list or it's empty an empty list is
		returned. Quickfix list entries with non-existing buffer
		number are returned with "bufnr" set to zero.

		Useful application: Find pattern matches in multiple files and
		do something with them: >
			:vimgrep /theword/jg *.c
			:for d in getqflist()
			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			:endfor


getreg([{regname} [, 1 [, {list}]]])			*getreg()*
		The result is a String, which is the contents of register
		{regname}.  Example: >
			:let cliptext = getreg('*')
<		getreg('=') returns the last evaluated value of the expression
		register.  (For use in maps.)
		getreg('=', 1) returns the expression itself, so that it can
		be restored with |setreg()|.  For other registers the extra
		argument is ignored, thus you can always give it.
		If {list} is present and non-zero result type is changed to 
		|List|. Each list item is one text line. Use it if you care
		about zero bytes possibly present inside register: without
		third argument both NLs and zero bytes are represented as NLs
		(see |NL-used-for-Nul|).
		If {regname} is not specified, |v:register| is used.


getregtype([{regname}])					*getregtype()*
		The result is a String, which is type of register {regname}.
		The value will be one of:
		    "v"			for |characterwise| text
		    "V"			for |linewise| text
		    "<CTRL-V>{width}"	for |blockwise-visual| text
		    ""			for an empty or unknown register
		<CTRL-V> is one character with value 0x16.
		If {regname} is not specified, |v:register| is used.

gettabvar({tabnr}, {varname} [, {def}])				*gettabvar()*
		Get the value of a tab-local variable {varname} in tab page
		{tabnr}. |t:var|
		Tabs are numbered starting with one.
		When {varname} is empty a dictionary with all tab-local
		variables is returned.
		Note that the name without "t:" must be used.
		When the tab or variable doesn't exist {def} or an empty
		string is returned, there is no error message.

gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])		*gettabwinvar()*
		Get the value of window-local variable {varname} in window
		{winnr} in tab page {tabnr}.
		When {varname} starts with "&" get the value of a window-local
		option.
		When {varname} is empty a dictionary with all window-local
		variables is returned.
		Note that {varname} must be the name without "w:".
		Tabs are numbered starting with one.  For the current tabpage
		use |getwinvar()|.
		{winnr} can be the window number or the window ID.
		When {winnr} is zero the current window is used.
		This also works for a global option, buffer-local option and
		window-local option, but it doesn't work for a global variable
		or buffer-local variable.
		When the tab, window or variable doesn't exist {def} or an
		empty string is returned, there is no error message.
		Examples: >
			:let list_is_on = gettabwinvar(1, 2, '&list')
			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')
<
							*getwinposx()*
getwinposx()	The result is a Number, which is the X coordinate in pixels of
		the left hand side of the GUI Vim window.  The result will be
		-1 if the information is not available.

							*getwinposy()*
getwinposy()	The result is a Number, which is the Y coordinate in pixels of
		the top of the GUI Vim window.	The result will be -1 if the
		information is not available.

getwinvar({winnr}, {varname} [, {def}])				*getwinvar()*
		Like |gettabwinvar()| for the current tabpage.
		Examples: >
			:let list_is_on = getwinvar(2, '&list')
			:echo "myvar = " . getwinvar(1, 'myvar')
<
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])		*glob()*
		Expand the file wildcards in {expr}.  See |wildcards| for the
		use of special characters.

		Unless the optional {nosuf} argument is given and is non-zero,
		the 'suffixes' and 'wildignore' options apply: Names matching
		one of the patterns in 'wildignore' will be skipped and
		'suffixes' affect the ordering of matches.
		'wildignorecase' always applies.

		When {list} is present and it is non-zero the result is a List
		with all matching files. The advantage of using a List is,
		you also get filenames containing newlines correctly.
		Otherwise the result is a String and when there are several
		matches, they are separated by <NL> characters.

		If the expansion fails, the result is an empty String or List.

		A name for a non-existing file is not included.  A symbolic
		link is only included if it points to an existing file.
		However, when the {alllinks} argument is present and it is
		non-zero then all symbolic links are included.

		For most systems backticks can be used to get files names from
		any external command.  Example: >
			:let tagfiles = glob("`find . -name tags -print`")
			:let &tags = substitute(tagfiles, "\n", ",", "g")
<		The result of the program inside the backticks should be one
		item per line.	Spaces inside an item are allowed.

		See |expand()| for expanding special Vim variables.  See
		|system()| for getting the raw output of an external command.

glob2regpat({expr})					 *glob2regpat()*
		Convert a file pattern, as used by glob(), into a search
		pattern.  The result can be used to match with a string that
		is a file name.  E.g. >
			if filename =~ glob2regpat('Make*.mak')
<		This is equivalent to: >
			if filename =~ '^Make.*\.mak$'
<		When {expr} is an empty string the result is "^$", match an
		empty string.

								*globpath()*
globpath({path}, {expr} [, {nosuf} [, {list} [, {allinks}]]])
		Perform glob() on all directories in {path} and concatenate
		the results.  Example: >
			:echo globpath(&rtp, "syntax/c.vim")
<
		{path} is a comma-separated list of directory names.  Each
		directory name is prepended to {expr} and expanded like with
		|glob()|.  A path separator is inserted when needed.
		To add a comma inside a directory name escape it with a
		backslash.  Note that on MS-Windows a directory may have a
		trailing backslash, remove it if you put a comma after it.
		If the expansion fails for one of the directories, there is no
		error message.

		Unless the optional {nosuf} argument is given and is non-zero,
		the 'suffixes' and 'wildignore' options apply: Names matching
		one of the patterns in 'wildignore' will be skipped and
		'suffixes' affect the ordering of matches.

		When {list} is present and it is non-zero the result is a List
		with all matching files. The advantage of using a List is, you
		also get filenames containing newlines correctly. Otherwise
		the result is a String and when there are several matches,
		they are separated by <NL> characters.  Example: >
			:echo globpath(&rtp, "syntax/c.vim", 0, 1)
<
		{allinks} is used as with |glob()|.

		The "**" item can be used to search in a directory tree.
		For example, to find all "README.txt" files in the directories
		in 'runtimepath' and below: >
			:echo globpath(&rtp, "**/README.txt")
<		Upwards search and limiting the depth of "**" is not
		supported, thus using 'path' will not always work properly.

							*has()*
has({feature})	The result is a Number, which is 1 if the feature {feature} is
		supported, zero otherwise.  The {feature} argument is a
		string.  See |feature-list| below.
		Also see |exists()|.


has_key({dict}, {key})					*has_key()*
		The result is a Number, which is 1 if |Dictionary| {dict} has
		an entry with key {key}.  Zero otherwise.

haslocaldir([{winnr}[, {tabnr}]])			*haslocaldir()*
		The result is a Number, which is 1 when the specified tabpage
		or window has a local path set via |:lcd| or |:tcd|, and
		0 otherwise.

		Tabs and windows are identified by their respective numbers,
		0 means current tab or window. Missing argument implies 0.
		Thus the following are equivalent: >
			haslocaldir()
			haslocaldir(0)
			haslocaldir(0, 0)
<		{winnr} can be the window number or the window ID.
		If {winnr} is -1 it is ignored, only the tab is resolved.

hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
		The result is a Number, which is 1 if there is a mapping that
		contains {what} in somewhere in the rhs (what it is mapped to)
		and this mapping exists in one of the modes indicated by
		{mode}.
		When {abbr} is there and it is non-zero use abbreviations
		instead of mappings.  Don't forget to specify Insert and/or
		Command-line mode.
		Both the global mappings and the mappings local to the current
		buffer are checked for a match.
		If no matching mapping is found 0 is returned.
		The following characters are recognized in {mode}:
			n	Normal mode
			v	Visual mode
			o	Operator-pending mode
			i	Insert mode
			l	Language-Argument ("r", "f", "t", etc.)
			c	Command-line mode
		When {mode} is omitted, "nvo" is used.

		This function is useful to check if a mapping already exists
		to a function in a Vim script.	Example: >
			:if !hasmapto('\ABCdoit')
			:   map <Leader>d \ABCdoit
			:endif
<		This installs the mapping to "\ABCdoit" only if there isn't
		already a mapping to "\ABCdoit".

histadd({history}, {item})				*histadd()*
		Add the String {item} to the history {history} which can be
		one of:					*hist-names*
			"cmd"	 or ":"	  command line history
			"search" or "/"   search pattern history
			"expr"	 or "="   typed expression history
			"input"  or "@"	  input line history
			"debug"  or ">"   debug command history
		The {history} string does not need to be the whole name, one
		character is sufficient.
		If {item} does already exist in the history, it will be
		shifted to become the newest entry.
		The result is a Number: 1 if the operation was successful,
		otherwise 0 is returned.

		Example: >
			:call histadd("input", strftime("%Y %b %d"))
			:let date=input("Enter date: ")
<		This function is not available in the |sandbox|.

histdel({history} [, {item}])				*histdel()*
		Clear {history}, i.e. delete all its entries.  See |hist-names|
		for the possible values of {history}.

		If the parameter {item} evaluates to a String, it is used as a
		regular expression.  All entries matching that expression will
		be removed from the history (if there are any).
		Upper/lowercase must match, unless "\c" is used |/\c|.
		If {item} evaluates to a Number, it will be interpreted as
		an index, see |:history-indexing|.  The respective entry will
		be removed if it exists.

		The result is a Number: 1 for a successful operation,
		otherwise 0 is returned.

		Examples:
		Clear expression register history: >
			:call histdel("expr")
<
		Remove all entries starting with "*" from the search history: >
			:call histdel("/", '^\*')
<
		The following three are equivalent: >
			:call histdel("search", histnr("search"))
			:call histdel("search", -1)
			:call histdel("search", '^'.histget("search", -1).'$')
<
		To delete the last search pattern and use the last-but-one for
		the "n" command and 'hlsearch': >
			:call histdel("search", -1)
			:let @/ = histget("search", -1)

histget({history} [, {index}])				*histget()*
		The result is a String, the entry with Number {index} from
		{history}.  See |hist-names| for the possible values of
		{history}, and |:history-indexing| for {index}.  If there is
		no such entry, an empty String is returned.  When {index} is
		omitted, the most recent item from the history is used.

		Examples:
		Redo the second last search from history. >
			:execute '/' . histget("search", -2)

<		Define an Ex command ":H {num}" that supports re-execution of
		the {num}th entry from the output of |:history|. >
			:command -nargs=1 H execute histget("cmd", 0+<args>)
<
histnr({history})					*histnr()*
		The result is the Number of the current entry in {history}.
		See |hist-names| for the possible values of {history}.
		If an error occurred, -1 is returned.

		Example: >
			:let inp_index = histnr("expr")
<
hlexists({name})					*hlexists()*
		The result is a Number, which is non-zero if a highlight group
		called {name} exists.  This is when the group has been
		defined in some way.  Not necessarily when highlighting has
		been defined for it, it may also have been used for a syntax
		item.

							*hlID()*
hlID({name})	The result is a Number, which is the ID of the highlight group
		with name {name}.  When the highlight group doesn't exist,
		zero is returned.
		This can be used to retrieve information about the highlight
		group.	For example, to get the background color of the
		"Comment" group: >
	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")

hostname()						*hostname()*
		The result is a String, which is the name of the machine on
		which Vim is currently running.  Machine names greater than
		256 characters long are truncated.

iconv({expr}, {from}, {to})				*iconv()*
		The result is a String, which is the text {expr} converted
		from encoding {from} to encoding {to}.
		When the conversion completely fails an empty string is
		returned.  When some characters could not be converted they
		are replaced with "?".
		The encoding names are whatever the iconv() library function
		can accept, see ":!man 3 iconv".
		Most conversions require Vim to be compiled with the |+iconv|
		feature.  Otherwise only UTF-8 to latin1 conversion and back
		can be done.
		Note that Vim uses UTF-8 for all Unicode encodings, conversion
		from/to UCS-2 is automatically changed to use UTF-8.  You
		cannot use UCS-2 in a string anyway, because of the NUL bytes.
		{only available when compiled with the |+multi_byte| feature}

							*indent()*
indent({lnum})	The result is a Number, which is indent of line {lnum} in the
		current buffer.  The indent is counted in spaces, the value
		of 'tabstop' is relevant.  {lnum} is used just like in
		|getline()|.
		When {lnum} is invalid -1 is returned.


index({list}, {expr} [, {start} [, {ic}]])			*index()*
		Return the lowest index in |List| {list} where the item has a
		value equal to {expr}.  There is no automatic conversion, so
		the String "4" is different from the Number 4.  And the number
		4 is different from the Float 4.0.  The value of 'ignorecase'
		is not used here, case always matters.
		If {start} is given then start looking at the item with index
		{start} (may be negative for an item relative to the end).
		When {ic} is given and it is non-zero, ignore case.  Otherwise
		case must match.
		-1 is returned when {expr} is not found in {list}.
		Example: >
			:let idx = index(words, "the")
			:if index(numbers, 123) >= 0


input({prompt} [, {text} [, {completion}]])		*input()*
		The result is a String, which is whatever the user typed on
		the command-line.  The {prompt} argument is either a prompt
		string, or a blank string (for no prompt).  A '\n' can be used
		in the prompt to start a new line.
		The highlighting set with |:echohl| is used for the prompt.
		The input is entered just like a command-line, with the same
		editing commands and mappings.	There is a separate history
		for lines typed for input().
		Example: >
			:if input("Coffee or beer? ") == "beer"
			:  echo "Cheers!"
			:endif
<
		If the optional {text} argument is present and not empty, this
		is used for the default reply, as if the user typed this.
		Example: >
			:let color = input("Color? ", "white")

<		The optional {completion} argument specifies the type of
		completion supported for the input.  Without it completion is
		not performed.	The supported completion types are the same as
		that can be supplied to a user-defined command using the
		"-complete=" argument.	Refer to |:command-completion| for
		more information.  Example: >
			let fname = input("File: ", "", "file")
<
		NOTE: This function must not be used in a startup file, for
		the versions that only run in GUI mode (e.g., the Win32 GUI).
		Note: When input() is called from within a mapping it will
		consume remaining characters from that mapping, because a
		mapping is handled like the characters were typed.
		Use |inputsave()| before input() and |inputrestore()|
		after input() to avoid that.  Another solution is to avoid
		that further characters follow in the mapping, e.g., by using
		|:execute| or |:normal|.

		Example with a mapping: >
			:nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR>
			:function GetFoo()
			:  call inputsave()
			:  let g:Foo = input("enter search pattern: ")
			:  call inputrestore()
			:endfunction

inputdialog({prompt} [, {text} [, {cancelreturn}]])		*inputdialog()*
		Like |input()|, but when the GUI is running and text dialogs
		are supported, a dialog window pops up to input the text.
		Example: >
		   :let n = inputdialog("value for shiftwidth", shiftwidth())
		   :if n != ""
		   :  let &sw = n
		   :endif
<		When the dialog is cancelled {cancelreturn} is returned.  When
		omitted an empty string is returned.
		Hitting <Enter> works like pressing the OK button.  Hitting
		<Esc> works like pressing the Cancel button.
		NOTE: Command-line completion is not supported.

inputlist({textlist})					*inputlist()*
		{textlist} must be a |List| of strings.  This |List| is
		displayed, one string per line.  The user will be prompted to
		enter a number, which is returned.
		The user can also select an item by clicking on it with the
		mouse.	For the first string 0 is returned.  When clicking
		above the first item a negative number is returned.  When
		clicking on the prompt one more than the length of {textlist}
		is returned.
		Make sure {textlist} has less than 'lines' entries, otherwise
		it won't work.	It's a good idea to put the entry number at
		the start of the string.  And put a prompt in the first item.
		Example: >
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])

inputrestore()						*inputrestore()*
		Restore typeahead that was saved with a previous |inputsave()|.
		Should be called the same number of times inputsave() is
		called.  Calling it more often is harmless though.
		Returns 1 when there is nothing to restore, 0 otherwise.

inputsave()						*inputsave()*
		Preserve typeahead (also from mappings) and clear it, so that
		a following prompt gets input from the user.  Should be
		followed by a matching inputrestore() after the prompt.  Can
		be used several times, in which case there must be just as
		many inputrestore() calls.
		Returns 1 when out of memory, 0 otherwise.

inputsecret({prompt} [, {text}])			*inputsecret()*
		This function acts much like the |input()| function with but
		two exceptions:
		a) the user's response will be displayed as a sequence of
		asterisks ("*") thereby keeping the entry secret, and
		b) the user's response will not be recorded on the input
		|history| stack.
		The result is a String, which is whatever the user actually
		typed on the command-line in response to the issued prompt.
		NOTE: Command-line completion is not supported.

insert({list}, {item} [, {idx}])			*insert()*
		Insert {item} at the start of |List| {list}.
		If {idx} is specified insert {item} before the item with index
		{idx}.	If {idx} is zero it goes before the first item, just
		like omitting {idx}.  A negative {idx} is also possible, see
		|list-index|.  -1 inserts just before the last item.
		Returns the resulting |List|.  Examples: >
			:let mylist = insert([2, 3, 5], 1)
			:call insert(mylist, 4, -1)
			:call insert(mylist, 6, len(mylist))
<		The last example can be done simpler with |add()|.
		Note that when {item} is a |List| it is inserted as a single
		item.  Use |extend()| to concatenate |Lists|.

invert({expr})						*invert()*
		Bitwise invert.  The argument is converted to a number.  A
		List, Dict or Float argument causes an error.  Example: >
			:let bits = invert(bits)

isdirectory({directory})				*isdirectory()*
		The result is a Number, which is non-zero when a directory
		with the name {directory} exists.  If {directory} doesn't
		exist, or isn't a directory, the result is FALSE.  {directory}
		is any expression, which is used as a String.

islocked({expr})					*islocked()* *E786*
		The result is a Number, which is non-zero when {expr} is the
		name of a locked variable.
		{expr} must be the name of a variable, |List| item or
		|Dictionary| entry, not the variable itself!  Example: >
			:let alist = [0, ['a', 'b'], 2, 3]
			:lockvar 1 alist
			:echo islocked('alist')		" 1
			:echo islocked('alist[1]')	" 0

<		When {expr} is a variable that does not exist you get an error
		message.  Use |exists()| to check for existence.

items({dict})						*items()*
		Return a |List| with all the key-value pairs of {dict}.  Each
		|List| item is a list with two items: the key of a {dict}
		entry and the value of this entry.  The |List| is in arbitrary
		order.

jobclose({job}[, {stream}])				{Nvim} *jobclose()*
		Close {job}'s {stream}, which can be one of "stdin", "stdout",
		"stderr" or "rpc" (closes the rpc channel for a job started
		with the "rpc" option.) If {stream} is omitted, all streams
		are closed. If the job is a pty job, this will then close the
		pty master, sending SIGHUP to the job process.

jobpid({job})						{Nvim} *jobpid()*
		Return the pid (process id) of {job}.

jobresize({job}, {width}, {height})			{Nvim} *jobresize()*
		Resize {job}'s pseudo terminal window to {width} and {height}.
		This function will fail if used on jobs started without the
		"pty" option.

jobsend({job}, {data})					{Nvim} *jobsend()*
		Send data to {job} by writing it to the stdin of the process.
		Returns 1 if the write succeeded, 0 otherwise.
		See |job-control| for more information.

		{data} may be a string, string convertible, or a list.  If
		{data} is a list, the items will be separated by newlines and
		any newlines in an item will be sent as a NUL. A final newline
		can be sent by adding a final empty string. For example: >
			:call jobsend(j, ["abc", "123\n456", ""])
< 		will send "abc<NL>123<NUL>456<NL>".

		If the job was started with the rpc option this function
		cannot be used, instead use |rpcnotify()| and |rpcrequest()|
		to communicate with the job.

jobstart({cmd}[, {opts}])				{Nvim} *jobstart()*
		Spawns {cmd} as a job.  If {cmd} is a |List| it is run
		directly.  If {cmd} is a |String| it is processed like this: >
		  :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])
<		NOTE: read |shell-unquoting| before constructing any lists 
		with 'shell' or 'shellcmdflag' options.  The above call is 
		only written to show the idea, one needs to perform unquoting 
		and do split taking quotes into account.

		{opts} is a dictionary with these keys:
		  on_stdout: stdout event handler (function name or |Funcref|)
		  on_stderr: stderr event handler (function name or |Funcref|)
		  on_exit  : exit event handler (function name or |Funcref|)
		  cwd      : Working directory of the job; defaults to
		             |current-directory|.
		  rpc      : If set, |msgpack-rpc| will be used to communicate
			     with the job over stdin and stdout. "on_stdout" is
			     then ignored, but "on_stderr" can still be used.
		  pty      : If set, the job will be connected to a new pseudo
			     terminal, and the job streams are connected to
			     the master file descriptor. "on_stderr" is ignored
			     as all output will be received on stdout.

		  width    : (pty only) Width of the terminal screen
		  height   : (pty only) Height of the terminal screen
		  TERM     : (pty only) $TERM environment variable
		  detach   : (non-pty only) Detach the job process from the
			     nvim process. The process will not get killed
			     when nvim exits. If the process dies before
			     nvim exits, on_exit will still be invoked.

		{opts} is passed as |self| to the callback; the caller may
		pass arbitrary data by setting other keys.
		Returns:
		  - The job ID on success, which is used by |jobsend()| (or
		    |rpcnotify()| and |rpcrequest()| if "rpc" option was used)
		    and |jobstop()|
		  - 0 on invalid arguments or if the job table is full
		  - -1 if {cmd}[0] is not executable.
		See |job-control| and |msgpack-rpc| for more information.

jobstop({job})						{Nvim} *jobstop()*
		Stop a job created with |jobstart()| by sending a `SIGTERM`
		to the corresponding process. If the process doesn't exit
		cleanly soon, a `SIGKILL` will be sent. When the job is
		finally closed, the exit handler provided to |jobstart()| or
		|termopen()| will be run.
		See |job-control| for more information.

jobwait({ids}[, {timeout}])				{Nvim} *jobwait()*
		Wait for a set of jobs to finish. The {ids} argument is a list
		of ids for jobs that will be waited for. If passed, {timeout}
		is the maximum number of milliseconds to wait. While this
		function is executing, callbacks for jobs not in the {ids}
		list can be executed. Also, the screen wont be updated unless
		|:redraw| is invoked by one of the callbacks.

		Returns a list of integers with the same length as {ids}, with
		each integer representing the wait result for the
		corresponding job id. The possible values for the resulting
		integers are:

		* the job return code if the job exited
		* -1 if the wait timed out for the job
		* -2 if the job was interrupted
		* -3 if the job id is invalid.

join({list} [, {sep}])					*join()*
		Join the items in {list} together into one String.
		When {sep} is specified it is put in between the items.  If
		{sep} is omitted a single space is used.
		Note that {sep} is not added at the end.  You might want to
		add it there too: >
			let lines = join(mylist, "\n") . "\n"
<		String items are used as-is.  |Lists| and |Dictionaries| are
		converted into a string like with |string()|.
		The opposite function is |split()|.

json_decode({expr})					*json_decode()*
		Convert {expr} from JSON object.  Accepts |readfile()|-style 
		list as the input, as well as regular string.  May output any 
		Vim value. In the following cases it will output
		|msgpack-special-dict|:
		1. Dictionary contains duplicate key.
		2. Dictionary contains empty key.
		3. String contains NUL byte.  Two special dictionaries: for 
		   dictionary and for string will be emitted in case string 
		   with NUL byte was a dictionary key.

		Note: function treats its input as UTF-8 always.  The JSON
		standard allows only a few encodings, of which UTF-8 is
		recommended and the only one required to be supported.
		Non-UTF-8 characters are an error.

json_encode({expr})					*json_encode()*
		Convert {expr} into a JSON string.  Accepts 
		|msgpack-special-dict| as the input.  Will not convert |Funcref|s, 
		mappings with non-string keys (can be created as 
		|msgpack-special-dict|), values with self-referencing 
		containers, strings which contain non-UTF-8 characters, 
		pseudo-UTF-8 strings which contain codepoints reserved for 
		surrogate pairs (such strings are not valid UTF-8 strings).  
		Non-printable characters are converted into "\u1234" escapes 
		or special escapes like "\t", other are dumped as-is.

keys({dict})						*keys()*
		Return a |List| with all the keys of {dict}.  The |List| is in
		arbitrary order.

							*len()* *E701*
len({expr})	The result is a Number, which is the length of the argument.
		When {expr} is a String or a Number the length in bytes is
		used, as with |strlen()|.
		When {expr} is a |List| the number of items in the |List| is
		returned.
		When {expr} is a |Dictionary| the number of entries in the
		|Dictionary| is returned.
		Otherwise an error is given.

						*libcall()* *E364* *E368*
libcall({libname}, {funcname}, {argument})
		Call function {funcname} in the run-time library {libname}
		with single argument {argument}.
		This is useful to call functions in a library that you
		especially made to be used with Vim.  Since only one argument
		is possible, calling standard library functions is rather
		limited.
		The result is the String returned by the function.  If the
		function returns NULL, this will appear as an empty string ""
		to Vim.
		If the function returns a number, use libcallnr()!
		If {argument} is a number, it is passed to the function as an
		int; if {argument} is a string, it is passed as a
		null-terminated string.
		This function will fail in |restricted-mode|.

		libcall() allows you to write your own 'plug-in' extensions to
		Vim without having to recompile the program.  It is NOT a
		means to call system functions!  If you try to do so Vim will
		very probably crash.

		For Win32, the functions you write must be placed in a DLL
		and use the normal C calling convention (NOT Pascal which is
		used in Windows System DLLs).  The function must take exactly
		one parameter, either a character pointer or a long integer,
		and must return a character pointer or NULL.  The character
		pointer returned must point to memory that will remain valid
		after the function has returned (e.g. in static data in the
		DLL).  If it points to allocated memory, that memory will
		leak away.  Using a static buffer in the function should work,
		it's then freed when the DLL is unloaded.

		WARNING: If the function returns a non-valid pointer, Vim may
		crash!	This also happens if the function returns a number,
		because Vim thinks it's a pointer.
		For Win32 systems, {libname} should be the filename of the DLL
		without the ".DLL" suffix.  A full path is only required if
		the DLL is not in the usual places.
		For Unix: When compiling your own plugins, remember that the
		object code must be compiled as position-independent ('PIC').
		{only in Win32 and some Unix versions, when the |+libcall|
		feature is present}
		Examples: >
			:echo libcall("libc.so", "getenv", "HOME")
<
							*libcallnr()*
libcallnr({libname}, {funcname}, {argument})
		Just like |libcall()|, but used for a function that returns an
		int instead of a string.
		{only in Win32 on some Unix versions, when the |+libcall|
		feature is present}
		Examples: >
			:echo libcallnr("/usr/lib/libc.so", "getpid", "")
			:call libcallnr("libc.so", "printf", "Hello World!\n")
			:call libcallnr("libc.so", "sleep", 10)
<
							*line()*
line({expr})	The result is a Number, which is the line number of the file
		position given with {expr}.  The accepted positions are:
		    .	    the cursor position
		    $	    the last line in the current buffer
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    w0	    first line visible in current window
		    w$	    last line visible in current window
		    v	    In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |'<| in
			    that it's updated right away.
		Note that a mark in another file can be used.  The line number
		then applies to another buffer.
		To get the column number use |col()|.  To get both use
		|getpos()|.
		Examples: >
			line(".")		line number of the cursor
			line("'t")		line number of mark t
			line("'" . marker)	line number of mark marker
<							*last-position-jump*
		This autocommand jumps to the last known position in a file
		just after opening it, if the '" mark is set: >
	:au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

line2byte({lnum})					*line2byte()*
		Return the byte count from the start of the buffer for line
		{lnum}.  This includes the end-of-line character, depending on
		the 'fileformat' option for the current buffer.  The first
		line returns 1. UTF-8 encoding is used, 'fileencoding' is
		ignored.  This can also be used to get the byte count for the
		line just below the last line: >
			line2byte(line("$") + 1)
<		This is the buffer size plus one.  If 'fileencoding' is empty
		it is the file size plus one.
		When {lnum} is invalid -1 is returned.
		Also see |byte2line()|, |go| and |:goto|.

lispindent({lnum})					*lispindent()*
		Get the amount of indent for line {lnum} according the lisp
		indenting rules, as with 'lisp'.
		The indent is counted in spaces, the value of 'tabstop' is
		relevant.  {lnum} is used just like in |getline()|.
		When {lnum} is invalid or Vim was not compiled the
		|+lispindent| feature, -1 is returned.

localtime()						*localtime()*
		Return the current time, measured as seconds since 1st Jan
		1970.  See also |strftime()| and |getftime()|.


log({expr})						*log()*
		Return the natural logarithm (base e) of {expr} as a |Float|.
		{expr} must evaluate to a |Float| or a |Number| in the range
		(0, inf].
		Examples: >
			:echo log(10)
<			2.302585 >
			:echo log(exp(5))
<			5.0


log10({expr})						*log10()*
		Return the logarithm of Float {expr} to base 10 as a |Float|.
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo log10(1000)
<			3.0 >
			:echo log10(0.01)
<			-2.0


map({expr}, {string})					*map()*
		{expr} must be a |List| or a |Dictionary|.
		Replace each item in {expr} with the result of evaluating
		{string}.
		Inside {string} |v:val| has the value of the current item.
		For a |Dictionary| |v:key| has the key of the current item
		and for a |List| |v:key| has the index of the current item.
		Example: >
			:call map(mylist, '"> " . v:val . " <"')
<		This puts "> " before and " <" after each item in "mylist".

		Note that {string} is the result of an expression and is then
		used as an expression again.  Often it is good to use a
		|literal-string| to avoid having to double backslashes.  You
		still have to double ' quotes

		The operation is done in-place.  If you want a |List| or
		|Dictionary| to remain unmodified make a copy first: >
			:let tlist = map(copy(mylist), ' v:val . "\t"')

<		Returns {expr}, the |List| or |Dictionary| that was filtered.
		When an error is encountered while evaluating {string} no
		further items in {expr} are processed.


maparg({name}[, {mode} [, {abbr} [, {dict}]]])			*maparg()*
		When {dict} is omitted or zero: Return the rhs of mapping
		{name} in mode {mode}.  The returned String has special
		characters translated like in the output of the ":map" command
		listing.
		
		When there is no mapping for {name}, an empty String is
		returned.

		The {name} can have special key names, like in the ":map"
		command.

		{mode} can be one of these strings:
			"n"	Normal
			"v"	Visual (including Select)
			"o"	Operator-pending
			"i"	Insert
			"c"	Cmd-line
			"s"	Select
			"x"	Visual
			"l"	langmap |language-mapping|
			""	Normal, Visual and Operator-pending
		When {mode} is omitted, the modes for "" are used.

		When {abbr} is there and it is non-zero use abbreviations
		instead of mappings.

		When {dict} is there and it is non-zero return a dictionary
		containing all the information of the mapping with the
		following items:
		  "lhs"	     The {lhs} of the mapping.
		  "rhs"	     The {rhs} of the mapping as typed.
		  "silent"   1 for a |:map-silent| mapping, else 0.
		  "noremap"  1 if the {rhs} of the mapping is not remappable.
		  "expr"     1 for an expression mapping (|:map-<expr>|).
		  "buffer"   1 for a buffer local mapping (|:map-local|).
		  "mode"     Modes for which the mapping is defined. In
			     addition to the modes mentioned above, these
			     characters will be used:
			     " "     Normal, Visual and Operator-pending
			     "!"     Insert and Commandline mode
				     (|mapmode-ic|)
		  "sid"	     The script local ID, used for <sid> mappings
			     (|<SID>|).
		  "nowait"   Do not wait for other, longer mappings.
			     (|:map-<nowait>|).

		The mappings local to the current buffer are checked first,
		then the global mappings.
		This function can be used to map a key even when it's already
		mapped, and have it do the original mapping too.  Sketch: >
			exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')


mapcheck({name}[, {mode} [, {abbr}]])			*mapcheck()*
		Check if there is a mapping that matches with {name} in mode
		{mode}.  See |maparg()| for {mode} and special names in
		{name}.
		When {abbr} is there and it is non-zero use abbreviations
		instead of mappings.
		A match happens with a mapping that starts with {name} and
		with a mapping which is equal to the start of {name}.

			matches mapping "a"	"ab"	"abc" ~
		   mapcheck("a")	yes	yes	 yes
		   mapcheck("abc")	yes	yes	 yes
		   mapcheck("ax")	yes	no	 no
		   mapcheck("b")	no	no	 no

		The difference with maparg() is that mapcheck() finds a
		mapping that matches with {name}, while maparg() only finds a
		mapping for {name} exactly.
		When there is no mapping that starts with {name}, an empty
		String is returned.  If there is one, the rhs of that mapping
		is returned.  If there are several mappings that start with
		{name}, the rhs of one of them is returned.
		The mappings local to the current buffer are checked first,
		then the global mappings.
		This function can be used to check if a mapping can be added
		without being ambiguous.  Example: >
	:if mapcheck("_vv") == ""
	:   map _vv :set guifont=7x13<CR>
	:endif
<		This avoids adding the "_vv" mapping when there already is a
		mapping for "_v" or for "_vvv".

match({expr}, {pat}[, {start}[, {count}]])			*match()*
		When {expr} is a |List| then this returns the index of the
		first item where {pat} matches.  Each item is used as a
		String, |Lists| and |Dictionaries| are used as echoed.
		Otherwise, {expr} is used as a String.	The result is a
		Number, which gives the index (byte offset) in {expr} where
		{pat} matches.
		A match at the first character or |List| item returns zero.
		If there is no match -1 is returned.
		For getting submatches see |matchlist()|.
		Example: >
			:echo match("testing", "ing")	" results in 4
			:echo match([1, 'x'], '\a')	" results in 1
<		See |string-match| for how {pat} is used.
								*strpbrk()*
		Vim doesn't have a strpbrk() function.	But you can do: >
			:let sepidx = match(line, '[.,;: \t]')
<								*strcasestr()*
		Vim doesn't have a strcasestr() function.  But you can add
		"\c" to the pattern to ignore case: >
			:let idx = match(haystack, '\cneedle')
<
		If {start} is given, the search starts from byte index
		{start} in a String or item {start} in a |List|.
		The result, however, is still the index counted from the
		first character/item.  Example: >
			:echo match("testing", "ing", 2)
<		result is again "4". >
			:echo match("testing", "ing", 4)
<		result is again "4". >
			:echo match("testing", "t", 2)
<		result is "3".
		For a String, if {start} > 0 then it is like the string starts
		{start} bytes later, thus "^" will match at {start}.  Except
		when {count} is given, then it's like matches before the
		{start} byte are ignored (this is a bit complicated to keep it
		backwards compatible).
		For a String, if {start} < 0, it will be set to 0.  For a list
		the index is counted from the end.
		If {start} is out of range ({start} > strlen({expr}) for a
		String or {start} > len({expr}) for a |List|) -1 is returned.

		When {count} is given use the {count}'th match.  When a match
		is found in a String the search for the next one starts one
		character further.  Thus this example results in 1: >
			echo match("testing", "..", 0, 2)
<		In a |List| the search continues in the next item.
		Note that when {count} is added the way {start} works changes,
		see above.

		See |pattern| for the patterns that are accepted.
		The 'ignorecase' option is used to set the ignore-caseness of
		the pattern.  'smartcase' is NOT used.	The matching is always
		done like 'magic' is set and 'cpoptions' is empty.

					*matchadd()* *E798* *E799* *E801*
matchadd({group}, {pattern}[, {priority}[, {id} [, {dict}]]])
		Defines a pattern to be highlighted in the current window (a
		"match").  It will be highlighted with {group}.  Returns an
		identification number (ID), which can be used to delete the
		match using |matchdelete()|.
		Matching is case sensitive and magic, unless case sensitivity
		or magicness are explicitly overridden in {pattern}.  The
		'magic', 'smartcase' and 'ignorecase' options are not used.
		The "Conceal" value is special, it causes the match to be
		concealed.

		The optional {priority} argument assigns a priority to the
		match.	A match with a high priority will have its
		highlighting overrule that of a match with a lower priority.
		A priority is specified as an integer (negative numbers are no
		exception).  If the {priority} argument is not specified, the
		default priority is 10.  The priority of 'hlsearch' is zero,
		hence all matches with a priority greater than zero will
		overrule it.  Syntax highlighting (see 'syntax') is a separate
		mechanism, and regardless of the chosen priority a match will
		always overrule syntax highlighting.

		The optional {id} argument allows the request for a specific
		match ID.  If a specified ID is already taken, an error
		message will appear and the match will not be added.  An ID
		is specified as a positive integer (zero excluded).  IDs 1, 2
		and 3 are reserved for |:match|, |:2match| and |:3match|,
		respectively.  If the {id} argument is not specified or -1,
		|matchadd()| automatically chooses a free ID.

		The optional {dict} argument allows for further custom
		values. Currently this is used to specify a match specific
		conceal character that will be shown for |hl-Conceal|
		highlighted matches. The dict can have the following members:

			conceal	    Special character to show instead of the
				    match (only for |hl-Conceal| highlighed
				    matches, see |:syn-cchar|)

		The number of matches is not limited, as it is the case with
		the |:match| commands.

		Example: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchadd("MyGroup", "TODO")
<		Deletion of the pattern: >
			:call matchdelete(m)

<		A list of matches defined by |matchadd()| and |:match| are
		available from |getmatches()|.	All matches can be deleted in
		one operation by |clearmatches()|.

matchaddpos({group}, {pos}[, {priority}[, {id}[, {dict}]]])		*matchaddpos()*
		Same as |matchadd()|, but requires a list of positions {pos}
		instead of a pattern. This command is faster than |matchadd()|
		because it does not require to handle regular expressions and
		sets buffer line boundaries to redraw screen. It is supposed
		to be used when fast match additions and deletions are
		required, for example to highlight matching parentheses.

		The list {pos} can contain one of these items:
		- A number.  This whole line will be highlighted.  The first
		  line has number 1.
		- A list with one number, e.g., [23]. The whole line with this
		  number will be highlighted.
		- A list with two numbers, e.g., [23, 11]. The first number is
		  the line number, the second one is the column number (first
		  column is 1, the value must correspond to the byte index as
		  |col()| would return).  The character at this position will
		  be highlighted.
		- A list with three numbers, e.g., [23, 11, 3]. As above, but
		  the third number gives the length of the highlight in bytes.
		
		The maximum number of positions is 8.

		Example: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchaddpos("MyGroup", [[23, 24], 34])
<		Deletion of the pattern: >
			:call matchdelete(m)

<		Matches added by |matchaddpos()| are returned by
		|getmatches()| with an entry "pos1", "pos2", etc., with the
		value a list like the {pos} item.
		These matches cannot be set via |setmatches()|, however they
		can still be deleted by |clearmatches()|.

matcharg({nr})							*matcharg()*
		Selects the {nr} match item, as set with a |:match|,
		|:2match| or |:3match| command.
		Return a |List| with two elements:
			The name of the highlight group used
			The pattern used.
		When {nr} is not 1, 2 or 3 returns an empty |List|.
		When there is no match item set returns ['', ''].
		This is useful to save and restore a |:match|.
		Highlighting matches using the |:match| commands are limited
		to three matches. |matchadd()| does not have this limitation.

matchdelete({id})			       *matchdelete()* *E802* *E803*
		Deletes a match with ID {id} previously defined by |matchadd()|
		or one of the |:match| commands.  Returns 0 if successful,
		otherwise -1.  See example for |matchadd()|.  All matches can
		be deleted in one operation by |clearmatches()|.

matchend({expr}, {pat}[, {start}[, {count}]])			*matchend()*
		Same as |match()|, but return the index of first character
		after the match.  Example: >
			:echo matchend("testing", "ing")
<		results in "7".
							*strspn()* *strcspn()*
		Vim doesn't have a strspn() or strcspn() function, but you can
		do it with matchend(): >
			:let span = matchend(line, '[a-zA-Z]')
			:let span = matchend(line, '[^a-zA-Z]')
<		Except that -1 is returned when there are no matches.

		The {start}, if given, has the same meaning as for |match()|. >
			:echo matchend("testing", "ing", 2)
<		results in "7". >
			:echo matchend("testing", "ing", 5)
<		result is "-1".
		When {expr} is a |List| the result is equal to |match()|.

matchlist({expr}, {pat}[, {start}[, {count}]])			*matchlist()*
		Same as |match()|, but return a |List|.  The first item in the
		list is the matched string, same as what matchstr() would
		return.  Following items are submatches, like "\1", "\2", etc.
		in |:substitute|.  When an optional submatch didn't match an
		empty string is used.  Example: >
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		Results in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		When there is no match an empty list is returned.

matchstr({expr}, {pat}[, {start}[, {count}]])			*matchstr()*
		Same as |match()|, but return the matched string.  Example: >
			:echo matchstr("testing", "ing")
<		results in "ing".
		When there is no match "" is returned.
		The {start}, if given, has the same meaning as for |match()|. >
			:echo matchstr("testing", "ing", 2)
<		results in "ing". >
			:echo matchstr("testing", "ing", 5)
<		result is "".
		When {expr} is a |List| then the matching item is returned.
		The type isn't changed, it's not necessarily a String.

							*max()*
max({list})	Return the maximum value of all items in {list}.
		If {list} is not a list or one of the items in {list} cannot
		be used as a Number this results in an error.
		An empty |List| results in zero.

							*min()*
min({list})	Return the minimum value of all items in {list}.
		If {list} is not a list or one of the items in {list} cannot
		be used as a Number this results in an error.
		An empty |List| results in zero.

							*mkdir()* *E739*
mkdir({name} [, {path} [, {prot}]])
		Create directory {name}.
		If {path} is "p" then intermediate directories are created as
		necessary.  Otherwise it must be "".
		If {prot} is given it is used to set the protection bits of
		the new directory.  The default is 0755 (rwxr-xr-x: r/w for
		the user readable for others).	Use 0700 to make it unreadable
		for others.
									{Nvim}
		{prot} is applied for all parts of {name}.  Thus if you create
		/tmp/foo/bar then /tmp/foo will be created with 0700. Example: >
			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
<		This function is not available in the |sandbox|.

		If you try to create an existing directory with {path} set to 
		"p" mkdir() will silently exit.

							*mode()*
mode([expr])	Return a string that indicates the current mode.
		If [expr] is supplied and it evaluates to a non-zero Number or
		a non-empty String (|non-zero-arg|), then the full mode is
		returned, otherwise only the first letter is returned.  Note
		that " " and "0" are also non-empty strings.

			n	Normal
			no	Operator-pending
			v	Visual by character
			V	Visual by line
			CTRL-V	Visual blockwise
			s	Select by character
			S	Select by line
			CTRL-S	Select blockwise
			i	Insert
			R	Replace |R|
			Rv	Virtual Replace |gR|
			t	Terminal {Nvim}
			c	Command-line
			cv	Vim Ex mode |gQ|
			ce	Normal Ex mode |Q|
			r	Hit-enter prompt
			rm	The -- more -- prompt
			r?	A |:confirm| query of some sort
			!	Shell or external command is executing
		This is useful in the 'statusline' option or when used
		with |remote_expr()| In most other places it always returns
		"c" or "n".
		Also see |visualmode()|.

msgpackdump({list})				   {Nvim} *msgpackdump()*
		Convert a list of VimL objects to msgpack. Returned value is
		|readfile()|-style list. Example: >
			call writefile(msgpackdump([{}]), 'fname.mpack', 'b')
<		This will write the single 0x80 byte to `fname.mpack` file
		(dictionary with zero items is represented by 0x80 byte in
		messagepack).

		Limitations:				*E5004* *E5005*
		1. |Funcref|s cannot be dumped.
		2. Containers that reference themselves cannot be dumped.
		3. Dictionary keys are always dumped as STR strings.
		4. Other strings are always dumped as BIN strings.
		5. Points 3. and 4. do not apply to |msgpack-special-dict|s.

msgpackparse({list})				   {Nvim} *msgpackparse()*
		Convert a |readfile()|-style list to a list of VimL objects. 
		Example: >
			let fname = expand('~/.config/nvim/shada/main.shada')
			let mpack = readfile(fname, 'b')
			let shada_objects = msgpackparse(mpack)
<		This will read ~/.config/nvim/shada/main.shada file to 
		`shada_objects` list.

		Limitations:
		1. Mapping ordering is not preserved unless messagepack 
		   mapping is dumped using generic  mapping 
		   (|msgpack-special-map|).
		2. Since the parser aims to preserve all data untouched 
		   (except for 1.) some strings are parsed to 
		   |msgpack-special-dict| format which is not convenient to 
		   use.
							*msgpack-special-dict*
		Some messagepack strings may be parsed to special 
		dictionaries. Special dictionaries are dictionaries which

		1. Contain exactly two keys: `_TYPE` and `_VAL`.
		2. `_TYPE` key is one of the types found in |v:msgpack_types| 
		   variable.
		3. Value for `_VAL` has the following format (Key column 
		   contains name of the key from |v:msgpack_types|):

		Key	Value ~
		nil	Zero, ignored when dumping.  This value cannot 
			possibly appear in |msgpackparse()| output in Neovim 
			versions which have |v:null|.
		boolean	One or zero.  When dumping it is only checked that 
			value is a |Number|.  This value cannot possibly 
			appear in |msgpackparse()| output in Neovim versions 
			which have |v:true| and |v:false|.
		integer	|List| with four numbers: sign (-1 or 1), highest two 
			bits, number with bits from 62nd to 31st, lowest 31 
			bits. I.e. to get actual number one will need to use 
			code like >
				_VAL[0] * ((_VAL[1] << 62)
				           & (_VAL[2] << 31)
				           & _VAL[3])
<			Special dictionary with this type will appear in 
			|msgpackparse()| output under one of the following 
			circumstances:
			1. |Number| is 32-bit and value is either above 
			   INT32_MAX or below INT32_MIN.
			2. |Number| is 64-bit and value is above INT64_MAX. It 
			   cannot possibly be below INT64_MIN because msgpack 
			   C parser does not support such values.
		float	|Float|. This value cannot possibly appear in 
			|msgpackparse()| output.
		string	|readfile()|-style list of strings. This value will 
			appear in |msgpackparse()| output if string contains 
			zero byte or if string is a mapping key and mapping is 
			being represented as special dictionary for other 
			reasons.
		binary	|readfile()|-style list of strings. This value will 
			appear in |msgpackparse()| output if binary string 
			contains zero byte.
		array	|List|. This value cannot appear in |msgpackparse()| 
			output.
							*msgpack-special-map*
		map	|List| of |List|s with two items (key and value) each. 
			This value will appear in |msgpackparse()| output if 
			parsed mapping contains one of the following keys:
			1. Any key that is not a string (including keys which 
			   are binary strings).
			2. String with NUL byte inside.
			3. Duplicate key.
			4. Empty key.
		ext	|List| with two values: first is a signed integer 
			representing extension type. Second is 
			|readfile()|-style list of strings.

nextnonblank({lnum})					*nextnonblank()*
		Return the line number of the first line at or below {lnum}
		that is not blank.  Example: >
			if getline(nextnonblank(1)) =~ "Java"
<		When {lnum} is invalid or there is no non-blank line at or
		below it, zero is returned.
		See also |prevnonblank()|.

nr2char({expr}[, {utf8}])				*nr2char()*
		Return a string with a single character, which has the number
		value {expr}.  Examples: >
			nr2char(64)		returns "@"
			nr2char(32)		returns " "
<		Example for "utf-8": >
			nr2char(300)		returns I with bow character
<		UTF-8 encoding is always used, {utf8} option has no effect,
		and exists only for backwards-compatibility.
		Note that a NUL character in the file is specified with
		nr2char(10), because NULs are represented with newline
		characters.  nr2char(0) is a real NUL and terminates the
		string, thus results in an empty string.

nvim_...({...})						*nvim_...()* *eval-api*
		Call nvim |api| functions. The type checking of arguments will
		be stricter than for most other builtins. For instance,
		if Integer is expected, a |Number| must be passed in, a
		|String| will not be autoconverted.
		Buffer numbers, as returned by |bufnr()| could be used as
		first argument to nvim_buf_... functions.  All functions
		expecting an object (buffer, window or tabpage) can
		also take the numerical value 0 to indicate the current
		(focused) object.

or({expr}, {expr})					*or()*
		Bitwise OR on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Example: >
			:let bits = or(bits, 0x80)


pathshorten({expr})					*pathshorten()*
		Shorten directory names in the path {expr} and return the
		result.  The tail, the file name, is kept as-is.  The other
		components in the path are reduced to single letters.  Leading
		'~' and '.' characters are kept.  Example: >
			:echo pathshorten('~/.config/nvim/autoload/file1.vim')
<			~/.v/a/file1.vim ~
		It doesn't matter if the path exists or not.

pow({x}, {y})						*pow()*
		Return the power of {x} to the exponent {y} as a |Float|.
		{x} and {y} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo pow(3, 3)
<			27.0 >
			:echo pow(2, 16)
<			65536.0 >
			:echo pow(32, 0.20)
<			2.0

prevnonblank({lnum})					*prevnonblank()*
		Return the line number of the first line at or above {lnum}
		that is not blank.  Example: >
			let ind = indent(prevnonblank(v:lnum - 1))
<		When {lnum} is invalid or there is no non-blank line at or
		above it, zero is returned.
		Also see |nextnonblank()|.


printf({fmt}, {expr1} ...)				*printf()*
		Return a String with {fmt}, where "%" items are replaced by
		the formatted form of their respective arguments.  Example: >
			printf("%4d: E%d %.30s", lnum, errno, msg)
<		May result in:
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		Often used items are:
		  %s	string
		  %6S	string right-aligned in 6 display cells
		  %6s	string right-aligned in 6 bytes
		  %.9s	string truncated to 9 bytes
		  %c	single byte
		  %d	decimal number
		  %5d	decimal number padded with spaces to 5 characters
		  %b	binary number
		  %08b	binary number padded with zeros to at least 8 characters
		  %B	binary number using upper case letters
		  %x	hex number
		  %04x	hex number padded with zeros to at least 4 characters
		  %X	hex number using upper case letters
		  %o	octal number
		  %f	floating point number in the form 123.456
		  %e	floating point number in the form 1.234e3
		  %E	floating point number in the form 1.234E3
		  %g	floating point number, as %f or %e depending on value
		  %G	floating point number, as %f or %E depending on value
		  %%	the % character itself

		Conversion specifications start with '%' and end with the
		conversion type.  All other characters are copied unchanged to
		the result.

		The "%" starts a conversion specification.  The following
		arguments appear in sequence:

			%  [flags]  [field-width]  [.precision]  type

		flags
			Zero or more of the following flags:

		    #	      The value should be converted to an "alternate
			      form".  For c, d, and s conversions, this option
			      has no effect.  For o conversions, the precision
			      of the number is increased to force the first
			      character of the output string to a zero (except
			      if a zero value is printed with an explicit
			      precision of zero).
			      For x and X conversions, a non-zero result has
			      the string "0x" (or "0X" for X conversions)
			      prepended to it.

		    0 (zero)  Zero padding.  For all conversions the converted
			      value is padded on the left with zeros rather
			      than blanks.  If a precision is given with a
			      numeric conversion (d, o, x, and X), the 0 flag
			      is ignored.

		    -	      A negative field width flag; the converted value
			      is to be left adjusted on the field boundary.
			      The converted value is padded on the right with
			      blanks, rather than on the left with blanks or
			      zeros.  A - overrides a 0 if both are given.

		    ' ' (space)  A blank should be left before a positive
			      number produced by a signed conversion (d).

		    +	      A sign must always be placed before a number
			      produced by a signed conversion.	A + overrides
			      a space if both are used.

		field-width
			An optional decimal digit string specifying a minimum
			field width.  If the converted value has fewer bytes
			than the field width, it will be padded with spaces on
			the left (or right, if the left-adjustment flag has
			been given) to fill out the field width.

		.precision
			An optional precision, in the form of a period '.'
			followed by an optional digit string.  If the digit
			string is omitted, the precision is taken as zero.
			This gives the minimum number of digits to appear for
			d, o, x, and X conversions, or the maximum number of
			bytes to be printed from a string for s conversions.
			For floating point it is the number of digits after
			the decimal point.

		type
			A character that specifies the type of conversion to
			be applied, see below.

		A field width or precision, or both, may be indicated by an
		asterisk '*' instead of a digit string.  In this case, a
		Number argument supplies the field width or precision.	A
		negative field width is treated as a left adjustment flag
		followed by a positive field width; a negative precision is
		treated as though it were missing.  Example: >
			:echo printf("%d: %.*s", nr, width, line)
<		This limits the length of the text used from "line" to
		"width" bytes.

		The conversion specifiers and their meanings are:

				*printf-d* *printf-b* *printf-B* *printf-o* *printf-x* *printf-X*
		dbBoxX	The Number argument is converted to signed decimal (d),
			unsigned binary (b and B), unsigned octal (o), or
			unsigned hexadecimal (x and X) notation.  The letters
			"abcdef" are used for x conversions; the letters
			"ABCDEF" are used for X conversions.  The precision, if
			any, gives the minimum number of digits that must
			appear; if the converted value requires fewer digits, it
			is padded on the left with zeros.  In no case does a
			non-existent or small field width cause truncation of a
			numeric field; if the result of a conversion is wider
			than the field width, the field is expanded to contain
			the conversion result.

							*printf-c*
		c	The Number argument is converted to a byte, and the
			resulting character is written.

							*printf-s*
		s	The text of the String argument is used.  If a
			precision is specified, no more bytes than the number
			specified are used.
							*printf-S*
		S	The text of the String argument is used.  If a
			precision is specified, no more display cells than the
			number specified are used.  Without the |+multi_byte|
			feature works just like 's'.

							*printf-f* *E807*
		f	The Float argument is converted into a string of the 
			form 123.456.  The precision specifies the number of
			digits after the decimal point.  When the precision is
			zero the decimal point is omitted.  When the precision
			is not specified 6 is used.  A really big number
			(out of range or dividing by zero) results in "inf".
			"0.0 / 0.0" results in "nan".
			Example: >
				echo printf("%.2f", 12.115)
<				12.12
			Note that roundoff depends on the system libraries.
			Use |round()| when in doubt.

							*printf-e* *printf-E*
		e E	The Float argument is converted into a string of the
			form 1.234e+03 or 1.234E+03 when using 'E'.  The
			precision specifies the number of digits after the
			decimal point, like with 'f'.

							*printf-g* *printf-G*
		g G	The Float argument is converted like with 'f' if the
			value is between 0.001 (inclusive) and 10000000.0
			(exclusive).  Otherwise 'e' is used for 'g' and 'E'
			for 'G'.  When no precision is specified superfluous
			zeroes and '+' signs are removed, except for the zero
			immediately after the decimal point.  Thus 10000000.0
			results in 1.0e7.

							*printf-%*
		%	A '%' is written.  No argument is converted.  The
			complete conversion specification is "%%".

		When a Number argument is expected a String argument is also
		accepted and automatically converted.
		When a Float or String argument is expected a Number argument
		is also accepted and automatically converted.
		Any other argument type results in an error message.

							*E766* *E767*
		The number of {exprN} arguments must exactly match the number
		of "%" items.  If there are not sufficient or too many
		arguments an error is given.  Up to 18 arguments can be used.


pumvisible()						*pumvisible()*
		Returns non-zero when the popup menu is visible, zero
		otherwise.  See |ins-completion-menu|.
		This can be used to avoid some things that would remove the
		popup menu.

							*E860*
py3eval({expr})						*py3eval()*
		Evaluate Python expression {expr} and return its result
		converted to Vim data structures.
		Numbers and strings are returned as they are (strings are 
		copied though, Unicode strings are additionally converted to 
		UTF-8).
		Lists are represented as Vim |List| type.
		Dictionaries are represented as Vim |Dictionary| type with 
		keys converted to strings.
		{only available when compiled with the |+python3| feature}

							*E858* *E859*
pyeval({expr})						*pyeval()*
		Evaluate Python expression {expr} and return its result
		converted to Vim data structures.
		Numbers and strings are returned as they are (strings are 
		copied though).
		Lists are represented as Vim |List| type.
		Dictionaries are represented as Vim |Dictionary| type, 
		non-string keys result in error.
		{only available when compiled with the |+python| feature}

							*E726* *E727*
range({expr} [, {max} [, {stride}]])				*range()*
		Returns a |List| with Numbers:
		- If only {expr} is specified: [0, 1, ..., {expr} - 1]
		- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]
		- If {stride} is specified: [{expr}, {expr} + {stride}, ...,
		  {max}] (increasing {expr} with {stride} each time, not
		  producing a value past {max}).
		When the maximum is one before the start the result is an
		empty list.  When the maximum is more than one before the
		start this is an error.
		Examples: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" error!
<
							*readfile()*
readfile({fname} [, {binary} [, {max}]])
		Read file {fname} and return a |List|, each line of the file
		as an item.  Lines broken at NL characters.  Macintosh files
		separated with CR will result in a single long line (unless a
		NL appears somewhere).
		All NUL characters are replaced with a NL character.
		When {binary} contains "b" binary mode is used:
		- When the last line ends in a NL an extra empty list item is
		  added.
		- No CR characters are removed.
		Otherwise:
		- CR characters that appear before a NL are removed.
		- Whether the last line ends in a NL or not does not matter.
		- Any UTF-8 byte order mark is removed from the text.
		When {max} is given this specifies the maximum number of lines
		to be read.  Useful if you only want to check the first ten
		lines of a file: >
			:for line in readfile(fname, '', 10)
			:  if line =~ 'Date' | echo line | endif
			:endfor
<		When {max} is negative -{max} lines from the end of the file
		are returned, or as many as there are.
		When {max} is zero the result is an empty list.
		Note that without {max} the whole file is read into memory.
		Also note that there is no recognition of encoding.  Read a
		file into a buffer if you need to.
		When the file can't be opened an error message is given and
		the result is an empty list.
		Also see |writefile()|.

reltime([{start} [, {end}]])				*reltime()*
		Return an item that represents a time value.  The format of
		the item depends on the system.  It can be passed to
		|reltimestr()| to convert it to a string or |reltimefloat()| 
		to convert to a float.

		Without an argument it returns the current "relative time", an
		implementation-defined value meaningful only when used as an
		argument to |reltime()|, |reltimestr()| and |reltimefloat()|.

		With one argument it returns the time passed since the time
		specified in the argument.
		With two arguments it returns the time passed between {start}
		and {end}.
		The {start} and {end} arguments must be values returned by
		reltime().

		Note: |localtime()| returns the current (non-relative) time.

reltimefloat({time})				*reltimefloat()*
		Return a Float that represents the time value of {time}.
		Unit of time is seconds.
		Example:
			let start = reltime()
			call MyFunction()
			let seconds = reltimefloat(reltime(start))
		See the note of reltimestr() about overhead.
 		Also see |profiling|.

reltimestr({time})				*reltimestr()*
		Return a String that represents the time value of {time}.
		This is the number of seconds, a dot and the number of
		microseconds.  Example: >
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
<		Note that overhead for the commands will be added to the time.
		Leading spaces are used to make the string align nicely.  You
		can use split() to remove it. >
			echo split(reltimestr(reltime(start)))[0]
<		Also see |profiling|.

							*remote_expr()* *E449*
remote_expr({server}, {string} [, {idvar}])
		Send the {string} to {server}.	The string is sent as an
		expression and the result is returned after evaluation.
		The result must be a String or a |List|.  A |List| is turned
		into a String by joining the items with a line break in
		between (not at the end), like with join(expr, "\n").
		If {idvar} is present, it is taken as the name of a
		variable and a {serverid} for later use with
		remote_read() is stored there.
		See also |clientserver| |RemoteReply|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Note: Any errors will cause a local error message to be issued
		and the result will be the empty string.
		Examples: >
			:echo remote_expr("gvim", "2+2")
			:echo remote_expr("gvim1", "b:current_syntax")
<

remote_foreground({server})				*remote_foreground()*
		Move the Vim server with the name {server} to the foreground.
		This works like: >
			remote_expr({server}, "foreground()")
<		Except that on Win32 systems the client does the work, to work
		around the problem that the OS doesn't always allow the server
		to bring itself to the foreground.
		Note: This does not restore the window if it was minimized,
		like foreground() does.
		This function is not available in the |sandbox|.
		{only in the Win32 GUI and the Win32 console version}


remote_peek({serverid} [, {retvar}])		*remote_peek()*
		Returns a positive number if there are available strings
		from {serverid}.  Copies any reply string into the variable
		{retvar} if specified.	{retvar} must be a string with the
		name of a variable.
		Returns zero if none are available.
		Returns -1 if something is wrong.
		See also |clientserver|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Examples: >
			:let repl = ""
			:echo "PEEK: ".remote_peek(id, "repl").": ".repl

remote_read({serverid})				*remote_read()*
		Return the oldest available reply from {serverid} and consume
		it.  It blocks until a reply is available.
		See also |clientserver|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Example: >
			:echo remote_read(id)
<
							*remote_send()* *E241*
remote_send({server}, {string} [, {idvar}])
		Send the {string} to {server}.	The string is sent as input
		keys and the function returns immediately.  At the Vim server
		the keys are not mapped |:map|.
		If {idvar} is present, it is taken as the name of a variable
		and a {serverid} for later use with remote_read() is stored
		there.
		See also |clientserver| |RemoteReply|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Note: Any errors will be reported in the server and may mess
		up the display.
		Examples: >
		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
		 \ remote_read(serverid)

		:autocmd NONE RemoteReply *
		 \ echo remote_read(expand("<amatch>"))
		:echo remote_send("gvim", ":sleep 10 | echo ".
		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
<
remove({list}, {idx} [, {end}])				*remove()*
		Without {end}: Remove the item at {idx} from |List| {list} and
		return the item.
		With {end}: Remove items from {idx} to {end} (inclusive) and
		return a List with these items.  When {idx} points to the same
		item as {end} a list with one item is returned.  When {end}
		points to an item before {idx} this is an error.
		See |list-index| for possible values of {idx} and {end}.
		Example: >
			:echo "last item: " . remove(mylist, -1)
			:call remove(mylist, 0, 9)
remove({dict}, {key})
		Remove the entry from {dict} with key {key}.  Example: >
			:echo "removed " . remove(dict, "one")
<		If there is no {key} in {dict} this is an error.

		Use |delete()| to remove a file.

rename({from}, {to})					*rename()*
		Rename the file by the name {from} to the name {to}.  This
		should also work to move files across file systems.  The
		result is a Number, which is 0 if the file was renamed
		successfully, and non-zero when the renaming failed.
		NOTE: If {to} exists it is overwritten without warning.
		This function is not available in the |sandbox|.

repeat({expr}, {count})					*repeat()*
		Repeat {expr} {count} times and return the concatenated
		result.  Example: >
			:let separator = repeat('-', 80)
<		When {count} is zero or negative the result is empty.
		When {expr} is a |List| the result is {expr} concatenated
		{count} times.	Example: >
			:let longlist = repeat(['a', 'b'], 3)
<		Results in ['a', 'b', 'a', 'b', 'a', 'b'].


resolve({filename})					*resolve()* *E655*
		On MS-Windows, when {filename} is a shortcut (a .lnk file),
		returns the path the shortcut points to in a simplified form.
		On Unix, repeat resolving symbolic links in all path
		components of {filename} and return the simplified result.
		To cope with link cycles, resolving of symbolic links is
		stopped after 100 iterations.
		On other systems, return the simplified {filename}.
		The simplification step is done as by |simplify()|.
		resolve() keeps a leading path component specifying the
		current directory (provided the result is still a relative
		path name) and also keeps a trailing path separator.

							*reverse()*
reverse({list})	Reverse the order of items in {list} in-place.	Returns
		{list}.
		If you want a list to remain unmodified make a copy first: >
			:let revlist = reverse(copy(mylist))

round({expr})							*round()*
		Round off {expr} to the nearest integral value and return it
		as a |Float|.  If {expr} lies halfway between two integral
		values, then use the larger one (away from zero).
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			echo round(0.456)
<			0.0  >
			echo round(4.5)
<			5.0 >
			echo round(-4.5)
<			-5.0

rpcnotify({channel}, {event}[, {args}...])		  {Nvim} *rpcnotify()*
		Sends {event} to {channel} via |RPC| and returns immediately.
		If {channel} is 0, the event is broadcast to all channels.
		Example: >
			:au VimLeave call rpcnotify(0, "leaving")

rpcrequest({channel}, {method}[, {args}...])		 {Nvim} *rpcrequest()*
		Sends a request to {channel} to invoke {method} via
		|RPC| and blocks until a response is received.
		Example: >
			:let result = rpcrequest(rpc_chan, "func", 1, 2, 3)

rpcstart({prog}[, {argv}])				   {Nvim} *rpcstart()*
		Deprecated. Replace  >
			:let id = rpcstart('prog', ['arg1', 'arg2'])
<		with >
			:let id = jobstart(['prog', 'arg1', 'arg2'], {'rpc': v:true})

rpcstop({channel})					    {Nvim} *rpcstop()*
		Closes an |RPC| {channel}.  If the channel is a job
		started with |jobstart()|  the job is killed.
		It is better to use |jobstop()| in this case, or use
		|jobclose|(id, "rpc") to only close the channel without
		killing the job.
		Closes the socket connection if the channel was opened by
		connecting to |v:servername|.

screenattr(row, col)						*screenattr()*
		Like screenchar(), but return the attribute.  This is a rather
		arbitrary number that can only be used to compare to the
		attribute at other positions.

screenchar(row, col)						*screenchar()*
		The result is a Number, which is the character at position
		[row, col] on the screen.  This works for every possible
		screen position, also status lines, window separators and the
		command line.  The top left position is row one, column one
		The character excludes composing characters.  For double-byte
		encodings it may only be the first byte.
		This is mainly to be used for testing.
		Returns -1 when row or col is out of range.

screencol()							*screencol()*
		The result is a Number, which is the current screen column of
		the cursor. The leftmost column has number 1.
		This function is mainly used for testing.

		Note: Always returns the current screen column, thus if used
		in a command (e.g. ":echo screencol()") it will return the
		column inside the command line, which is 1 when the command is
		executed. To get the cursor position in the file use one of
		the following mappings: >
			nnoremap <expr> GG ":echom ".screencol()."\n"
			nnoremap <silent> GG :echom screencol()<CR>
<
screenrow()							*screenrow()*
		The result is a Number, which is the current screen row of the
		cursor.  The top line has number one.
		This function is mainly used for testing.

		Note: Same restrictions as with |screencol()|.

search({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*search()*
		Search for regexp pattern {pattern}.  The search starts at the
		cursor position (you can use |cursor()| to set it).

		When a match has been found its line number is returned.
		If there is no match a 0 is returned and the cursor doesn't
		move.  No error message is given.

		{flags} is a String, which can contain these character flags:
		'b'	search Backward instead of forward
		'c'	accept a match at the Cursor position
		'e'	move to the End of the match
		'n'	do Not move the cursor
		'p'	return number of matching sub-Pattern (see below)
		's'	Set the ' mark at the previous location of the cursor
		'w'	Wrap around the end of the file
		'W'	don't Wrap around the end of the file
		'z'	start searching at the cursor column instead of Zero
		If neither 'w' or 'W' is given, the 'wrapscan' option applies.

		If the 's' flag is supplied, the ' mark is set, only if the
		cursor is moved. The 's' flag cannot be combined with the 'n'
		flag.

		'ignorecase', 'smartcase' and 'magic' are used.
		
		When the 'z' flag is not given, searching always starts in
		column zero and then matches before the cursor are skipped.
		When the 'c' flag is present in 'cpo' the next search starts
		after the match.  Without the 'c' flag the next search starts
		one column further.

		When the {stopline} argument is given then the search stops
		after searching this line.  This is useful to restrict the
		search to a range of lines.  Examples: >
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		When {stopline} is used and it is not zero this also implies
		that the search does not wrap around the end of the file.
		A zero value is equal to not giving the argument.

		When the {timeout} argument is given the search stops when
		more than this many milliseconds have passed.	Thus when
		{timeout} is 500 the search stops after half a second.
		The value must not be negative.  A zero value is like not
		giving the argument.
		{only available when compiled with the |+reltime| feature}

							*search()-sub-match*
		With the 'p' flag the returned value is one more than the
		first sub-match in \(\).  One if none of them matched but the
		whole pattern did match.
		To get the column number too use |searchpos()|.

		The cursor will be positioned at the match, unless the 'n'
		flag is used.

		Example (goes over all files in the argument list): >
		    :let n = 1
		    :while n <= argc()	    " loop over all files in arglist
		    :  exe "argument " . n
		    :  " start at the last char in the file and wrap for the
		    :  " first search to find match at start of file
		    :  normal G$
		    :  let flags = "w"
		    :  while search("foo", flags) > 0
		    :	 s/foo/bar/g
		    :	 let flags = "W"
		    :  endwhile
		    :  update		    " write the file if modified
		    :  let n = n + 1
		    :endwhile
<
		Example for using some flags: >
		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
<		This will search for the keywords "if", "else", and "endif"
		under or after the cursor.  Because of the 'p' flag, it
		returns 1, 2, or 3 depending on which keyword is found, or 0
		if the search fails.  With the cursor on the first word of the
		line:
		    if (foo == 0) | let foo = foo + 1 | endif ~
		the function returns 1.  Without the 'c' flag, the function
		finds the "endif" and returns 3.  The same thing happens
		without the 'e' flag if the cursor is on the "f" of "if".
		The 'n' flag tells the function not to move the cursor.


searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
		Search for the declaration of {name}.

		With a non-zero {global} argument it works like |gD|, find
		first match in the file.  Otherwise it works like |gd|, find
		first match in the function.

		With a non-zero {thisblock} argument matches in a {} block
		that ends before the cursor position are ignored.  Avoids
		finding variable declarations only valid in another scope.

		Moves the cursor to the found match.
		Returns zero for success, non-zero for failure.
		Example: >
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<
							*searchpair()*
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		Search for the match of a nested start-end pair.  This can be
		used to find the "endif" that matches an "if", while other
		if/endif pairs in between are ignored.
		The search starts at the cursor.  The default is to search
		forward, include 'b' in {flags} to search backward.
		If a match is found, the cursor is positioned at it and the
		line number is returned.  If no match is found 0 or -1 is
		returned and the cursor doesn't move.  No error message is
		given.

		{start}, {middle} and {end} are patterns, see |pattern|.  They
		must not contain \( \) pairs.  Use of \%( \) is allowed.  When
		{middle} is not empty, it is found when searching from either
		direction, but only when not in a nested start-end pair.  A
		typical use is: >
			searchpair('\<if\>', '\<else\>', '\<endif\>')
<		By leaving {middle} empty the "else" is skipped.

		{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with
		|search()|.  Additionally:
		'r'	Repeat until no more matches found; will find the
			outer pair.  Implies the 'W' flag.
		'm'	Return number of matches instead of line number with
			the match; will be > 1 when 'r' is used.
		Note: it's nearly always a good idea to use the 'W' flag, to
		avoid wrapping around the end of the file.

		When a match for {start}, {middle} or {end} is found, the
		{skip} expression is evaluated with the cursor positioned on
		the start of the match.  It should return non-zero if this
		match is to be skipped.  E.g., because it is inside a comment
		or a string.
		When {skip} is omitted or empty, every match is accepted.
		When evaluating {skip} causes an error the search is aborted
		and -1 returned.

		For {stopline} and {timeout} see |search()|.

		The value of 'ignorecase' is used.  'magic' is ignored, the
		patterns are used like it's on.

		The search starts exactly at the cursor.  A match with
		{start}, {middle} or {end} at the next character, in the
		direction of searching, is the first one found.  Example: >
			if 1
			  if 2
			  endif 2
			endif 1
<		When starting at the "if 2", with the cursor on the "i", and
		searching forwards, the "endif 2" is found.  When starting on
		the character just before the "if 2", the "endif 1" will be
		found.	That's because the "if 2" will be found first, and
		then this is considered to be a nested if/endif from "if 2" to
		"endif 2".
		When searching backwards and {end} is more than one character,
		it may be useful to put "\zs" at the end of the pattern, so
		that when the cursor is inside a match with the end it finds
		the matching start.

		Example, to find the "endif" command in a Vim script: >

	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

<		The cursor must be at or after the "if" for which a match is
		to be found.  Note that single-quote strings are used to avoid
		having to double the backslashes.  The skip expression only
		catches comments at the start of a line, not after a command.
		Also, a word "en" or "if" halfway through a line is considered
		a match.
		Another example, to search for the matching "{" of a "}": >

	:echo searchpair('{', '', '}', 'bW')

<		This works when the cursor is at or before the "}" for which a
		match is to be found.  To reject matches that syntax
		highlighting recognized as strings: >

	:echo searchpair('{', '', '}', 'bW',
	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<
							*searchpairpos()*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		Same as |searchpair()|, but returns a |List| with the line and
		column position of the match. The first element of the |List|
		is the line number and the second element is the byte index of
		the column position of the match.  If no match is found,
		returns [0, 0]. >

			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		See |match-parens| for a bigger and more useful example.

searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*searchpos()*
		Same as |search()|, but returns a |List| with the line and
		column position of the match. The first element of the |List|
		is the line number and the second element is the byte index of
		the column position of the match. If no match is found,
		returns [0, 0].
		Example: >
	:let [lnum, col] = searchpos('mypattern', 'n')

<		When the 'p' flag is given then there is an extra item with
		the sub-pattern match number |search()-sub-match|.  Example: >
	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		In this example "submatch" is 2 when a lowercase letter is
		found |/\l|, 3 when an uppercase letter is found |/\u|.

server2client({clientid}, {string})			*server2client()*
		Send a reply string to {clientid}.  The most recent {clientid}
		that sent a string can be retrieved with expand("<client>").
		{only available when compiled with the |+clientserver| feature}
		Note:
		This id has to be stored before the next command can be
		received.  I.e. before returning from the received command and
		before calling any commands that waits for input.
		See also |clientserver|.
		Example: >
			:echo server2client(expand("<client>"), "HELLO")
<
serverlist()						*serverlist()*
		Returns a list of available server names in a list.
		When there are no servers an empty string is returned.
		Example: >
			:echo serverlist()
<						{Nvim} *--serverlist*
		The Vim command-line option `--serverlist` was removed from
		Nvim, but it can be imitated: >
			nvim --cmd "echo serverlist()" --cmd "q"
<
serverstart([{address}])				*serverstart()*
		Opens a named pipe or TCP socket at {address} for clients to
		connect to and returns {address}. If no address is given, it
		is equivalent to: >
			:call serverstart(tempname())
< 		|$NVIM_LISTEN_ADDRESS| is set to {address} if not already set.
							*--servername*
		The Vim command-line option `--servername` can be imitated: >
			nvim --cmd "let g:server_addr = serverstart('foo')"
<
serverstop({address})					*serverstop()*
		Closes the pipe or socket at {address}. Does nothing if
		{address} is empty or invalid.
		If |$NVIM_LISTEN_ADDRESS| is stopped it is unset.
		If |v:servername| is stopped it is set to the next available
		address returned by |serverlist()|.

setbufvar({expr}, {varname}, {val})			*setbufvar()*
		Set option or local variable {varname} in buffer {expr} to
		{val}.
		This also works for a global or local window option, but it
		doesn't work for a global or local window variable.
		For a local window option the global value is unchanged.
		For the use of {expr}, see |bufname()| above.
		Note that the variable name without "b:" must be used.
		Examples: >
			:call setbufvar(1, "&mod", 1)
			:call setbufvar("todo", "myvar", "foobar")
<		This function is not available in the |sandbox|.

setcharsearch({dict})					*setcharsearch()*
		Set the current character search information to {dict},
		which contains one or more of the following entries:

		    char	character which will be used for a subsequent
				|,| or |;| command; an empty string clears the
				character search
		    forward	direction of character search; 1 for forward,
				0 for backward
		    until	type of character search; 1 for a |t| or |T|
				character search, 0 for an |f| or |F|
				character search

		This can be useful to save/restore a user's character search
		from a script: >
			:let prevsearch = getcharsearch()
			:" Perform a command which clobbers user's search
			:call setcharsearch(prevsearch)
<		Also see |getcharsearch()|.

setcmdpos({pos})					*setcmdpos()*
		Set the cursor position in the command line to byte position
		{pos}.	The first position is 1.
		Use |getcmdpos()| to obtain the current position.
		Only works while editing the command line, thus you must use
		|c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For
		|c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is
		set after the command line is set to the expression.  For
		|c_CTRL-R_=| it is set after evaluating the expression but
		before inserting the resulting text.
		When the number is too big the cursor is put at the end of the
		line.  A number smaller than one has undefined results.
		Returns 0 when successful, 1 when not editing the command
		line.

setfperm({fname}, {mode})				*setfperm()* *chmod*
		Set the file permissions for {fname} to {mode}.
		{mode} must be a string with 9 characters.  It is of the form
		"rwxrwxrwx", where each group of "rwx" flags represent, in
		turn, the permissions of the owner of the file, the group the
		file belongs to, and other users.  A '-' character means the
		permission is off, any other character means on.  Multi-byte
		characters are not supported.

		For example "rw-r-----" means read-write for the user,
		readable by the group, not accessible by others.  "xx-x-----"
		would do the same thing.

		Returns non-zero for success, zero for failure.

		To read permissions see |getfperm()|.

setline({lnum}, {text})					*setline()*
		Set line {lnum} of the current buffer to {text}.  To insert
		lines use |append()|.
		{lnum} is used like with |getline()|.
		When {lnum} is just below the last line the {text} will be
		added as a new line.
		If this succeeds, 0 is returned.  If this fails (most likely
		because {lnum} is invalid) 1 is returned.  Example: >
			:call setline(5, strftime("%c"))
<		When {text} is a |List| then line {lnum} and following lines
		will be set to the items in the list.  Example: >
			:call setline(5, ['aaa', 'bbb', 'ccc'])
<		This is equivalent to: >
			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
			:  call setline(n, l)
			:endfor
<		Note: The '[ and '] marks are not set.

setloclist({nr}, {list} [, {action}[, {title}]])	*setloclist()*
		Create or replace or add to the location list for window {nr}.
		{nr} can be the window number or the window ID.
		When {nr} is zero the current window is used.

		For a location list window, the displayed location list is
		modified.  For an invalid window number {nr}, -1 is returned. If
		{title} is given, it will be used to set |w:quickfix_title|
		after opening the location window.
		Otherwise, same as |setqflist()|.
		Also see |location-list|.

setmatches({list})					*setmatches()*
		Restores a list of matches saved by |getmatches()|.  Returns 0
		if successful, otherwise -1.  All current matches are cleared
		before the list is restored.  See example for |getmatches()|.

							*setpos()*
setpos({expr}, {list})
		Set the position for {expr}.  Possible values:
			.	the cursor
			'x	mark x

		{list} must be a |List| with four or five numbers:
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]

		"bufnum" is the buffer number.	Zero can be used for the
		current buffer.  Setting the cursor is only possible for
		the current buffer.  To set a mark in another buffer you can
		use the |bufnr()| function to turn a file name into a buffer
		number.
		Does not change the jumplist.

		"lnum" and "col" are the position in the buffer.  The first
		column is 1.  Use a zero "lnum" to delete a mark.  If "col" is
		smaller than 1 then 1 is used.

		The "off" number is only used when 'virtualedit' is set. Then
		it is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.

		The "curswant" number is only used when setting the cursor
		position.  It sets the preferred column for when moving the
		cursor vertically.  When the "curswant" number is missing the
		preferred column is not set.  When it is present and setting a
		mark position it is not used.

		Note that for '< and '> changing the line number may result in
		the marks to be effectively be swapped, so that '< is always
		before '>.

		Returns 0 when the position could be set, -1 otherwise.
		An error message is given if {expr} is invalid.

		Also see |getpos()| and |getcurpos()|.

		This does not restore the preferred column for moving
		vertically; if you set the cursor position with this, |j| and
		|k| motions will jump to previous columns!  Use |cursor()| to
		also set the preferred column.  Also see the "curswant" key in
		|winrestview()|.


setqflist({list} [, {action}[, {title}]])		*setqflist()*
		Create or replace or add to the quickfix list using the items
		in {list}.  Each item in {list} is a dictionary.
		Non-dictionary items in {list} are ignored.  Each dictionary
		item can contain the following entries:

		    bufnr	buffer number; must be the number of a valid
				buffer
		    filename	name of a file; only used when "bufnr" is not
				present or it is invalid.
		    lnum	line number in the file
		    pattern	search pattern used to locate the error
		    col		column number
		    vcol	when non-zero: "col" is visual column
				when zero: "col" is byte index
		    nr		error number
		    text	description of the error
		    type	single-character error type, 'E', 'W', etc.

		The "col", "vcol", "nr", "type" and "text" entries are
		optional.  Either "lnum" or "pattern" entry can be used to
		locate a matching error line.
		If the "filename" and "bufnr" entries are not present or
		neither the "lnum" or "pattern" entries are present, then the
		item will not be handled as an error line.
		If both "pattern" and "lnum" are present then "pattern" will
		be used.
		If you supply an empty {list}, the quickfix list will be
		cleared.
		Note that the list is not exactly the same as what
		|getqflist()| returns.

							*E927*
		If {action} is set to 'a', then the items from {list} are
		added to the existing quickfix list. If there is no existing
		list, then a new list is created.
		
		If {action} is set to 'r', then the items from the current
		quickfix list are replaced with the items from {list}.  This
		can also be used to clear the list: >
			:call setqflist([], 'r')
<	
		If {action} is not present or is set to ' ', then a new list
		is created.

		If {title} is given, it will be used to set |w:quickfix_title|
		after opening the quickfix window.

		Returns zero for success, -1 for failure.

		This function can be used to create a quickfix list
		independent of the 'errorformat' setting.  Use a command like
		":cc 1" to jump to the first position.


							*setreg()*
setreg({regname}, {value} [, {options}])
		Set the register {regname} to {value}.
		{value} may be any value returned by |getreg()|, including 
		a |List|.
		If {options} contains "a" or {regname} is upper case,
		then the value is appended.
		{options} can also contain a register type specification:
		    "c" or "v"	      |characterwise| mode
		    "l" or "V"	      |linewise| mode
		    "b" or "<CTRL-V>" |blockwise-visual| mode
		If a number immediately follows "b" or "<CTRL-V>" then this is
		used as the width of the selection - if it is not specified
		then the width of the block is set to the number of characters
		in the longest line (counting a <Tab> as 1 character).

		If {options} contains no register settings, then the default
		is to use character mode unless {value} ends in a <NL> for 
		string {value} and linewise mode for list {value}. Blockwise 
		mode is never selected automatically.
		Returns zero for success, non-zero for failure.

							*E883*
		Note: you may not use |List| containing more than one item to 
		      set search and expression registers. Lists containing no 
		      items act like empty strings.

		Examples: >
			:call setreg(v:register, @*)
			:call setreg('*', @%, 'ac')
			:call setreg('a', "1\n2\n3", 'b5')

<		This example shows using the functions to save and restore a
		register (note: you may not reliably restore register value 
		without using the third argument to |getreg()| as without it 
		newlines are represented as newlines AND Nul bytes are 
		represented as newlines as well, see |NL-used-for-Nul|). >
			:let var_a = getreg('a', 1, 1)
			:let var_amode = getregtype('a')
			    ....
			:call setreg('a', var_a, var_amode)

<		You can also change the type of a register by appending
		nothing: >
			:call setreg('a', '', 'al')

settabvar({tabnr}, {varname}, {val})			*settabvar()*
		Set tab-local variable {varname} to {val} in tab page {tabnr}.
		|t:var|
		Note that the variable name without "t:" must be used.
		Tabs are numbered starting with one.
		This function is not available in the |sandbox|.

settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
		Set option or local variable {varname} in window {winnr} to
		{val}.
		Tabs are numbered starting with one.  For the current tabpage
		use |setwinvar()|.
		{winnr} can be the window number or the window ID.
		When {winnr} is zero the current window is used.
		This also works for a global or local buffer option, but it
		doesn't work for a global or local buffer variable.
		For a local buffer option the global value is unchanged.
		Note that the variable name without "w:" must be used.
		Examples: >
			:call settabwinvar(1, 1, "&list", 0)
			:call settabwinvar(3, 2, "myvar", "foobar")
<		This function is not available in the |sandbox|.

setwinvar({nr}, {varname}, {val})			*setwinvar()*
		Like |settabwinvar()| for the current tab page.
		Examples: >
			:call setwinvar(1, "&list", 0)
			:call setwinvar(2, "myvar", "foobar")

sha256({string})						*sha256()*
		Returns a String with 64 hex characters, which is the SHA256
		checksum of {string}.

shellescape({string} [, {special}])			*shellescape()*
		Escape {string} for use as a shell command argument.
		On Windows when 'shellslash' is not set, it
		will enclose {string} in double quotes and double all double
		quotes within {string}.
		For other systems, it will enclose {string} in single quotes
		and replace all "'" with "'\''".
		When the {special} argument is present and it's a non-zero
		Number or a non-empty String (|non-zero-arg|), then special
		items such as "!", "%", "#" and "<cword>" will be preceded by
		a backslash.  This backslash will be removed again by the |:!|
		command.
		The "!" character will be escaped (again with a |non-zero-arg|
		{special}) when 'shell' contains "csh" in the tail.  That is
		because for csh and tcsh "!" is used for history replacement
		even when inside single quotes.
		The <NL> character is also escaped.  With a |non-zero-arg|
		{special} and 'shell' containing "csh" in the tail it's
		escaped a second time.
		Example of use with a |:!| command: >
		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
<		This results in a directory listing for the file under the
		cursor.  Example of use with |system()|: >
		    :call system("chmod +w -- " . shellescape(expand("%")))
<		See also |::S|.


shiftwidth()						*shiftwidth()*
		Returns the effective value of 'shiftwidth'. This is the
		'shiftwidth' value unless it is zero, in which case it is the
		'tabstop' value.  To be backwards compatible in indent
		plugins, use this: >
			if exists('*shiftwidth')
			  func s:sw()
			    return shiftwidth()
			  endfunc
			else
			  func s:sw()
			    return &sw
			  endfunc
			endif
<		And then use s:sw() instead of &sw.


simplify({filename})					*simplify()*
		Simplify the file name as much as possible without changing
		the meaning.  Shortcuts (on MS-Windows) or symbolic links (on
		Unix) are not resolved.  If the first path component in
		{filename} designates the current directory, this will be
		valid for the result as well.  A trailing path separator is
		not removed either.
		Example: >
			simplify("./dir/.././/file/") == "./file/"
<		Note: The combination "dir/.." is only removed if "dir" is
		a searchable directory or does not exist.  On Unix, it is also
		removed when "dir" is a symbolic link within the same
		directory.  In order to resolve all the involved symbolic
		links before simplifying the path name, use |resolve()|.


sin({expr})						*sin()*
		Return the sine of {expr}, measured in radians, as a |Float|.
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo sin(100)
<			-0.506366 >
			:echo sin(-4.01)
<			0.763301


sinh({expr})						*sinh()*
		Return the hyperbolic sine of {expr} as a |Float| in the range
		[-inf, inf].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo sinh(0.5)
<			0.521095 >
			:echo sinh(-0.9)
<			-1.026517


sort({list} [, {func} [, {dict}]])			*sort()* *E702*
		Sort the items in {list} in-place.  Returns {list}.
		
		If you want a list to remain unmodified make a copy first: >
			:let sortedlist = sort(copy(mylist))

<		When {func} is omitted, is empty or zero, then sort() uses the
		string representation of each item to sort on.  Numbers sort
		after Strings, |Lists| after Numbers.  For sorting text in the
		current buffer use |:sort|.

		When {func} is given and it is '1' or 'i' then case is
		ignored.
		
		When {func} is given and it is 'n' then all items will be
		sorted numerical (Implementation detail: This uses the
		strtod() function to parse numbers, Strings, Lists, Dicts and
		Funcrefs will be considered as being 0).

		When {func} is given and it is 'N' then all items will be
		sorted numerical. This is like 'n' but a string containing
		digits will be used as the number they represent.

		When {func} is given and it is 'f' then all items will be
		sorted numerical. All values must be a Number or a Float.

		When {func} is a |Funcref| or a function name, this function
		is called to compare items.  The function is invoked with two
		items as argument and must return zero if they are equal, 1 or
		bigger if the first one sorts after the second one, -1 or
		smaller if the first one sorts before the second one.

		{dict} is for functions with the "dict" attribute.  It will be
		used to set the local variable "self". |Dictionary-function|

		The sort is stable, items which compare equal (as number or as
		string) will keep their relative position. E.g., when sorting
		on numbers, text strings will sort next to each other, in the
		same order as they were originally.

		Also see |uniq()|.

		Example: >
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sortedlist = sort(mylist, "MyCompare")
<		A shorter compare version for this specific simple case, which
		ignores overflow: >
			func MyCompare(i1, i2)
			   return a:i1 - a:i2
			endfunc
<
							*soundfold()*
soundfold({word})
		Return the sound-folded equivalent of {word}.  Uses the first
		language in 'spelllang' for the current window that supports
		soundfolding.  'spell' must be set.  When no sound folding is
		possible the {word} is returned unmodified.
		This can be used for making spelling suggestions.  Note that
		the method can be quite slow.

							*spellbadword()*
spellbadword([{sentence}])
		Without argument: The result is the badly spelled word under
		or after the cursor.  The cursor is moved to the start of the
		bad word.  When no bad word is found in the cursor line the
		result is an empty string and the cursor doesn't move.

		With argument: The result is the first word in {sentence} that
		is badly spelled.  If there are no spelling mistakes the
		result is an empty string.

		The return value is a list with two items:
		- The badly spelled word or an empty string.
		- The type of the spelling error:
			"bad"		spelling mistake
			"rare"		rare word
			"local"		word only valid in another region
			"caps"		word should start with Capital
		Example: >
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~

		The spelling information for the current window is used.  The
		'spell' option must be set and the value of 'spelllang' is
		used.

							*spellsuggest()*
spellsuggest({word} [, {max} [, {capital}]])
		Return a |List| with spelling suggestions to replace {word}.
		When {max} is given up to this number of suggestions are
		returned.  Otherwise up to 25 suggestions are returned.

		When the {capital} argument is given and it's non-zero only
		suggestions with a leading capital will be given.  Use this
		after a match with 'spellcapcheck'.

		{word} can be a badly spelled word followed by other text.
		This allows for joining two words that were split.  The
		suggestions also include the following text, thus you can
		replace a line.

		{word} may also be a good word.  Similar words will then be
		returned.  {word} itself is not included in the suggestions,
		although it may appear capitalized.

		The spelling information for the current window is used.  The
		'spell' option must be set and the values of 'spelllang' and
		'spellsuggest' are used.


split({expr} [, {pattern} [, {keepempty}]])			*split()*
		Make a |List| out of {expr}.  When {pattern} is omitted or
		empty each white-separated sequence of characters becomes an
		item.
		Otherwise the string is split where {pattern} matches,
		removing the matched characters. 'ignorecase' is not used
		here, add \c to ignore case. |/\c|
		When the first or last item is empty it is omitted, unless the
		{keepempty} argument is given and it's non-zero.
		Other empty items are kept when {pattern} matches at least one
		character or when {keepempty} is non-zero.
		Example: >
			:let words = split(getline('.'), '\W\+')
<		To split a string in individual characters: >
			:for c in split(mystring, '\zs')
<		If you want to keep the separator you can also use '\zs' at
		the end of the pattern: >
			:echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi'] ~
		Splitting a table where the first element can be empty: >
			:let items = split(line, ':', 1)
<		The opposite function is |join()|.


sqrt({expr})						*sqrt()*
		Return the non-negative square root of Float {expr} as a
		|Float|.
		{expr} must evaluate to a |Float| or a |Number|.  When {expr}
		is negative the result is NaN (Not a Number).
		Examples: >
			:echo sqrt(100)
<			10.0 >
			:echo sqrt(-4.01)
<			nan
		"nan" may be different, it depends on system libraries.


str2float({expr})					*str2float()*
		Convert String {expr} to a Float.  This mostly works the same
		as when using a floating point number in an expression, see
		|floating-point-format|.  But it's a bit more permissive.
		E.g., "1e40" is accepted, while in an expression you need to
		write "1.0e40".
		Text after the number is silently ignored.
		The decimal point is always '.', no matter what the locale is
		set to.  A comma ends the number: "12,345.67" is converted to
		12.0.  You can strip out thousands separators with
		|substitute()|: >
			let f = str2float(substitute(text, ',', '', 'g'))


str2nr({expr} [, {base}])				*str2nr()*
		Convert string {expr} to a number.
		{base} is the conversion base, it can be 2, 8, 10 or 16.
		When {base} is omitted base 10 is used.  This also means that
		a leading zero doesn't cause octal conversion to be used, as
		with the default String to Number conversion.
		When {base} is 16 a leading "0x" or "0X" is ignored.  With a
		different base the result will be zero. Similarly, when {base}
		is 8 a leading "0" is ignored, and when {base} is 2 a leading
		"0b" or "0B" is ignored.
		Text after the number is silently ignored.


strchars({expr} [, {skipcc}])					*strchars()*
		The result is a Number, which is the number of characters
		in String {expr}.
		When {skipcc} is omitted or zero, composing characters are
		counted separately.
		When {skipcc} set to 1, Composing characters are ignored.
		Also see |strlen()|, |strdisplaywidth()| and |strwidth()|.

		
		{skipcc} is only available after 7.4.755.  For backward
		compatibility, you can define a wrapper function: >
		    if has("patch-7.4.755")
		      function s:strchars(str, skipcc)
			return strchars(a:str, a:skipcc)
		      endfunction
		    else
		      function s:strchars(str, skipcc)
			if a:skipcc
			  return strlen(substitute(a:str, ".", "x", "g"))
			else
			  return strchars(a:str)
			endif
		      endfunction
		    endif
<

strdisplaywidth({expr}[, {col}])			*strdisplaywidth()*
		The result is a Number, which is the number of display cells
		String {expr} occupies on the screen when it starts at {col}.
		When {col} is omitted zero is used.  Otherwise it is the
		screen column where to start.  This matters for Tab
		characters.
		The option settings of the current window are used.  This
		matters for anything that's displayed differently, such as
		'tabstop' and 'display'.
		When {expr} contains characters with East Asian Width Class
		Ambiguous, this function's return value depends on 'ambiwidth'.
		Also see |strlen()|, |strwidth()| and |strchars()|.

strftime({format} [, {time}])				*strftime()*
		The result is a String, which is a formatted date and time, as
		specified by the {format} string.  The given {time} is used,
		or the current time if no time is given.  The accepted
		{format} depends on your system, thus this is not portable!
		See the manual page of the C function strftime() for the
		format.  The maximum length of the result is 80 characters.
		See also |localtime()| and |getftime()|.
		The language can be changed with the |:language| command.
		Examples: >
		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
		  :echo strftime("%y%m%d %T")	   970427 11:53:55
		  :echo strftime("%H:%M")	   11:55
		  :echo strftime("%c", getftime("file.c"))
						   Show mod time of file.c.
<		Not available on all systems.  To check use: >
			:if exists("*strftime")

stridx({haystack}, {needle} [, {start}])		*stridx()*
		The result is a Number, which gives the byte index in
		{haystack} of the first occurrence of the String {needle}.
		If {start} is specified, the search starts at index {start}.
		This can be used to find a second match: >
			:let colon1 = stridx(line, ":")
			:let colon2 = stridx(line, ":", colon1 + 1)
<		The search is done case-sensitive.
		For pattern searches use |match()|.
		-1 is returned if the {needle} does not occur in {haystack}.
		See also |strridx()|.
		Examples: >
		  :echo stridx("An Example", "Example")	     3
		  :echo stridx("Starting point", "Start")    0
		  :echo stridx("Starting point", "start")   -1
<						*strstr()* *strchr()*
		stridx() works similar to the C function strstr().  When used
		with a single character it works similar to strchr().

							*string()*
string({expr})	Return {expr} converted to a String.  If {expr} is a Number,
		Float, String or a composition of them, then the result can be
		parsed back with |eval()|.
			{expr} type	result ~
			String		'string'
			Number		123
			Float		123.123456 or 1.123456e8 or 
					`str2float('inf')`
			Funcref		`function('name')`
			List		[item, item]
			Dictionary	{key: value, key: value}
		Note that in String values the ' character is doubled.
		Also see |strtrans()|.
		Note 2: Output format is mostly compatible with YAML, except 
		for infinite and NaN floating-point values representations 
		which use |str2float()|.  Strings are also dumped literally, 
		only single quote is escaped, which does not allow using YAML 
		for parsing back binary strings.  |eval()| should always work for 
		strings and floats though and this is the only official 
		method, use |msgpackdump()| or |json_encode()| if you need to 
		share data with other application.

							*strlen()*
strlen({expr})	The result is a Number, which is the length of the String
		{expr} in bytes.
		If the argument is a Number it is first converted to a String.
		For other types an error is given.
		If you want to count the number of multi-byte characters use
		|strchars()|.
		Also see |len()|, |strdisplaywidth()| and |strwidth()|.

strpart({src}, {start}[, {len}])			*strpart()*
		The result is a String, which is part of {src}, starting from
		byte {start}, with the byte length {len}.
		When non-existing bytes are included, this doesn't result in
		an error, the bytes are simply omitted.
		If {len} is missing, the copy continues from {start} till the
		end of the {src}. >
			strpart("abcdefg", 3, 2)    == "de"
			strpart("abcdefg", -2, 4)   == "ab"
			strpart("abcdefg", 5, 4)    == "fg"
			strpart("abcdefg", 3)	    == "defg"
<		Note: To get the first character, {start} must be 0.  For
		example, to get three bytes under and after the cursor: >
			strpart(getline("."), col(".") - 1, 3)
<
strridx({haystack}, {needle} [, {start}])			*strridx()*
		The result is a Number, which gives the byte index in
		{haystack} of the last occurrence of the String {needle}.
		When {start} is specified, matches beyond this index are
		ignored.  This can be used to find a match before a previous
		match: >
			:let lastcomma = strridx(line, ",")
			:let comma2 = strridx(line, ",", lastcomma - 1)
<		The search is done case-sensitive.
		For pattern searches use |match()|.
		-1 is returned if the {needle} does not occur in {haystack}.
		If the {needle} is empty the length of {haystack} is returned.
		See also |stridx()|.  Examples: >
		  :echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		When used with a single character it works similar to the C
		function strrchr().

strtrans({expr})					*strtrans()*
		The result is a String, which is {expr} with all unprintable
		characters translated into printable characters |'isprint'|.
		Like they are shown in a window.  Example: >
			echo strtrans(@a)
<		This displays a newline in register a as "^@" instead of
		starting a new line.

strwidth({expr})					*strwidth()*
		The result is a Number, which is the number of display cells
		String {expr} occupies.  A Tab character is counted as one
		cell, alternatively use |strdisplaywidth()|.
		When {expr} contains characters with East Asian Width Class
		Ambiguous, this function's return value depends on 'ambiwidth'.
		Also see |strlen()|, |strdisplaywidth()| and |strchars()|.

submatch({nr}[, {list}])				*submatch()*
		Only for an expression in a |:substitute| command or
		substitute() function.
		Returns the {nr}'th submatch of the matched text.  When {nr}
		is 0 the whole matched text is returned.
		Note that a NL in the string can stand for a line break of a
		multi-line match or a NUL character in the text.
		Also see |sub-replace-expression|.

		If {list} is present and non-zero then submatch() returns 
		a list of strings, similar to |getline()| with two arguments. 
		NL characters in the text represent NUL characters in the
		text.
		Only returns more than one item for |:substitute|, inside
		|substitute()| this list will always contain one or zero
		items, since there are no real line breaks.

		Example: >
			:s/\d\+/\=submatch(0) + 1/
<		This finds the first number in the line and adds one to it.
		A line break is included as a newline character.

substitute({expr}, {pat}, {sub}, {flags})		*substitute()*
		The result is a String, which is a copy of {expr}, in which
		the first match of {pat} is replaced with {sub}.
		When {flags} is "g", all matches of {pat} in {expr} are
		replaced.  Otherwise {flags} should be "".
		
		This works like the ":substitute" command (without any flags).
		But the matching with {pat} is always done like the 'magic'
		option is set and 'cpoptions' is empty (to make scripts
		portable).  'ignorecase' is still relevant, use |/\c| or |/\C|
		if you want to ignore or match case and ignore 'ignorecase'.
		'smartcase' is not used.  See |string-match| for how {pat} is
		used.

		A "~" in {sub} is not replaced with the previous {sub}.
		Note that some codes in {sub} have a special meaning
		|sub-replace-special|.	For example, to replace something with
		"\n" (two characters), use "\\\\n" or '\\n'.

		When {pat} does not match in {expr}, {expr} is returned
		unmodified.

		Example: >
			:let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		This removes the last component of the 'path' option. >
			:echo substitute("testing", ".*", "\\U\\0", "")
<		results in "TESTING".

		When {sub} starts with "\=", the remainder is interpreted as
		an expression. See |sub-replace-expression|.  Example: >
			:echo substitute(s, '%\(\x\x\)',
			   \ '\=nr2char("0x" . submatch(1))', 'g')

synID({lnum}, {col}, {trans})				*synID()*
		The result is a Number, which is the syntax ID at the position
		{lnum} and {col} in the current window.
		The syntax ID can be used with |synIDattr()| and
		|synIDtrans()| to obtain syntax information about text.

		{col} is 1 for the leftmost column, {lnum} is 1 for the first
		line.  'synmaxcol' applies, in a longer line zero is returned.
		Note that when the position is after the last character,
		that's where the cursor can be in Insert mode, synID() returns
		zero.

		When {trans} is non-zero, transparent items are reduced to the
		item that they reveal.	This is useful when wanting to know
		the effective color.  When {trans} is zero, the transparent
		item is returned.  This is useful when wanting to know which
		syntax item is effective (e.g. inside parens).
		Warning: This function can be very slow.  Best speed is
		obtained by going through the file in forward direction.

		Example (echoes the name of the syntax item under the cursor): >
			:echo synIDattr(synID(line("."), col("."), 1), "name")
<

synIDattr({synID}, {what} [, {mode}])			*synIDattr()*
		The result is a String, which is the {what} attribute of
		syntax ID {synID}.  This can be used to obtain information
		about a syntax item.
		{mode} can be "gui", "cterm" or "term", to get the attributes
		for that mode.	When {mode} is omitted, or an invalid value is
		used, the attributes for the currently active highlighting are
		used (GUI, cterm or term).
		Use synIDtrans() to follow linked highlight groups.
		{what}		result
		"name"		the name of the syntax item
		"fg"		foreground color (GUI: color name used to set
				the color, cterm: color number as a string,
				term: empty string)
		"bg"		background color (as with "fg")
		"font"		font name (only available in the GUI)
				|highlight-font|
		"sp"		special color (as with "fg") |highlight-guisp|
		"fg#"		like "fg", but for the GUI and the GUI is
				running the name in "#RRGGBB" form
		"bg#"		like "fg#" for "bg"
		"sp#"		like "fg#" for "sp"
		"bold"		"1" if bold
		"italic"	"1" if italic
		"reverse"	"1" if reverse
		"inverse"	"1" if inverse (= reverse)
		"standout"	"1" if standout
		"underline"	"1" if underlined
		"undercurl"	"1" if undercurled

		Example (echoes the color of the syntax item under the
		cursor): >
	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<
synIDtrans({synID})					*synIDtrans()*
		The result is a Number, which is the translated syntax ID of
		{synID}.  This is the syntax group ID of what is being used to
		highlight the character.  Highlight links given with
		":highlight link" are followed.

synconcealed({lnum}, {col})				*synconcealed()*
		The result is a List. The first item in the list is 0 if the
		character at the position {lnum} and {col} is not part of a
		concealable region, 1 if it is. The second item in the list is
		a string. If the first item is 1, the second item contains the
		text which will be displayed in place of the concealed text,
		depending on the current setting of 'conceallevel'. The third
		and final item in the list is a unique number representing the
		specific syntax region matched. This allows detection of the
		beginning of a new concealable region if there are two
		consecutive regions with the same replacement character.
		For an example use see $VIMRUNTIME/syntax/2html.vim .


synstack({lnum}, {col})					*synstack()*
		Return a |List|, which is the stack of syntax items at the
		position {lnum} and {col} in the current window.  Each item in
		the List is an ID like what |synID()| returns.
		The first item in the List is the outer region, following are
		items contained in that one.  The last one is what |synID()|
		returns, unless not the whole item is highlighted or it is a
		transparent item.
		This function is useful for debugging a syntax file.
		Example that shows the syntax stack under the cursor: >
			for id in synstack(line("."), col("."))
			   echo synIDattr(id, "name")
			endfor
<		When the position specified with {lnum} and {col} is invalid
		nothing is returned.  The position just after the last
		character in a line and the first column in an empty line are
		valid positions.

system({cmd} [, {input}])				*system()* *E677*
		Get the output of the shell command {cmd} as a |string|.  {cmd}
		will be run the same as in |jobstart()|.  See |systemlist()|
		to get the output as a |List|.
		Not to be used for interactive commands.

		If {input} is a string it is written to a pipe and passed as
		stdin to the command.  The string is written as-is, line
		separators are not changed.
		If {input} is a |List| it is written to the pipe as
		|writefile()| does with {binary} set to "b" (i.e. with
		a newline between each list item, and newlines inside list
		items converted to NULs).
								*E5677*
		Note: system() cannot write to or read from backgrounded ("&")
		shell commands, e.g.: >
		    :echo system("cat - &", "foo"))
<		which is equivalent to: >
		    $ echo foo | bash -c 'cat - &'
<		The pipes are disconnected (unless overridden by shell
		redirection syntax) before input can reach it. Use
		|jobstart()| instead.

		Note: Use |shellescape()| or |::S| with |expand()| or 
		|fnamemodify()| to escape special characters in a command 
		argument.  Newlines in {cmd} may cause the command to fail.  
		The characters in 'shellquote' and 'shellxquote' may also 
		cause trouble.

		The result is a String.  Example: >
		    :let files = system("ls " .  shellescape(expand('%:h')))
		    :let files = system('ls ' . expand('%:h:S'))

<		To make the result more system-independent, the shell output
		is filtered to replace <CR> with <NL> for Macintosh, and
		<CR><NL> with <NL> for DOS-like systems.
		To avoid the string being truncated at a NUL, all NUL
		characters are replaced with SOH (0x01).

		The command executed is constructed using several options when
		{cmd} is a string: 'shell' 'shellcmdflag' {cmd}

		The resulting error code can be found in |v:shell_error|.
		This function will fail in |restricted-mode|.

		Note that any wrong value in the options mentioned above may
		make the function fail.  It has also been reported to fail
		when using a security agent application.
		Unlike ":!cmd" there is no automatic check for changed files.
		Use |:checktime| to force a check.


systemlist({cmd} [, {input} [, {keepempty}]])		*systemlist()*
		Same as |system()|, but returns a |List| with lines (parts of 
		output separated by NL) with NULs transformed into NLs. Output 
		is the same as |readfile()| will output with {binary} argument 
		set to "b", except that a final newline is not preserved,
		unless {keepempty} is present and it's non-zero.

		Returns an empty string on error, so be careful not to run 
		into |E706|.


tabpagebuflist([{arg}])					*tabpagebuflist()*
		The result is a |List|, where each item is the number of the
		buffer associated with each window in the current tab page.
		{arg} specifies the number of tab page to be used.  When
		omitted the current tab page is used.
		When {arg} is invalid the number zero is returned.
		To get a list of all buffers in all tabs use this: >
			let buflist = []
			for i in range(tabpagenr('$'))
			   call extend(buflist, tabpagebuflist(i + 1))
			endfor
<		Note that a buffer may appear in more than one window.


tabpagenr([{arg}])					*tabpagenr()*
		The result is a Number, which is the number of the current
		tab page.  The first tab page has number 1.
		When the optional argument is "$", the number of the last tab
		page is returned (the tab page count).
		The number can be used with the |:tab| command.


tabpagewinnr({tabarg} [, {arg}])			*tabpagewinnr()*
		Like |winnr()| but for tab page {tabarg}.
		{tabarg} specifies the number of tab page to be used.
		{arg} is used like with |winnr()|:
		- When omitted the current window number is returned.  This is
		  the window which will be used when going to this tab page.
		- When "$" the number of windows is returned.
		- When "#" the previous window nr is returned.
		Useful examples: >
		    tabpagewinnr(1)	    " current window of tab page 1
		    tabpagewinnr(4, '$')    " number of windows in tab page 4
<		When {tabarg} is invalid zero is returned.

							*tagfiles()*
tagfiles()	Returns a |List| with the file names used to search for tags
		for the current buffer.  This is the 'tags' option expanded.


taglist({expr})							*taglist()*
		Returns a list of tags matching the regular expression {expr}.
		Each list item is a dictionary with at least the following
		entries:
			name		Name of the tag.
			filename	Name of the file where the tag is
					defined.  It is either relative to the
					current directory or a full path.
			cmd		Ex command used to locate the tag in
					the file.
			kind		Type of the tag.  The value for this
					entry depends on the language specific
					kind values.  Only available when
					using a tags file generated by
					Exuberant ctags or hdrtag.
			static		A file specific tag.  Refer to
					|static-tag| for more information.
		More entries may be present, depending on the content of the
		tags file: access, implementation, inherits and signature.
		Refer to the ctags documentation for information about these
		fields.  For C code the fields "struct", "class" and "enum"
		may appear, they give the name of the entity the tag is
		contained in.

		The ex-command 'cmd' can be either an ex search pattern, a
		line number or a line number followed by a byte number.

		If there are no matching tags, then an empty list is returned.

		To get an exact tag match, the anchors '^' and '$' should be
		used in {expr}.  This also make the function work faster.
		Refer to |tag-regexp| for more information about the tag
		search regular expression pattern.

		Refer to |'tags'| for information about how the tags file is
		located by Vim. Refer to |tags-file-format| for the format of
		the tags file generated by the different ctags tools.

tempname()					*tempname()* *temp-file-name*
		The result is a String, which is the name of a file that
		doesn't exist.	It can be used for a temporary file.  Example: >
			:let tmpfile = tempname()
			:exe "redir > " . tmpfile
<		For Unix, the file will be in a private directory |tempfile|.
		For MS-Windows forward slashes are used when the 'shellslash'
		option is set or when 'shellcmdflag' starts with '-'.

termopen({cmd}[, {opts}])			{Nvim} *termopen()*
		Spawns {cmd} in a new pseudo-terminal session connected
		to the current buffer.  {cmd} is the same as the one passed to
		|jobstart()|.  This function fails if the current buffer is
		modified (all buffer contents are destroyed).

		The {opts} dict is similar to the one passed to |jobstart()|,
		but the `pty`, `width`, `height`, and `TERM` fields are
		ignored: `height`/`width` are taken from the current window
		and `$TERM` is set to "xterm-256color".
		Returns the same values as |jobstart()|.

		See |terminal-emulator| for more information.

tan({expr})						*tan()*
		Return the tangent of {expr}, measured in radians, as a |Float|
		in the range [-inf, inf].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo tan(10)
<			0.648361 >
			:echo tan(-4.01)
<			-1.181502


tanh({expr})						*tanh()*
		Return the hyperbolic tangent of {expr} as a |Float| in the
		range [-1, 1].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo tanh(0.5)
<			0.462117 >
			:echo tanh(-1)
<			-0.761594


							*timer_start()*
timer_start({time}, {callback} [, {options}])
		Create a timer and return the timer ID.

		{time} is the waiting time in milliseconds. This is the
		minimum time before invoking the callback.  When the system is
		busy or Vim is not waiting for input the time will be longer.

		{callback} is the function to call.  It can be the name of a
		function or a Funcref.  It is called with one argument, which
		is the timer ID.  The callback is only invoked when Vim is
		waiting for input.

		{options} is a dictionary.  Supported entries:
		   "repeat"	Number of times to repeat calling the
		   		callback.  -1 means forever.

		Example: >
			func MyHandler(timer)
			  echo 'Handler called'
			endfunc
			let timer = timer_start(500, 'MyHandler',
				\ {'repeat': 3})
<		This will invoke MyHandler() three times at 500 msec
		intervals.
		{only available when compiled with the |+timers| feature}

timer_stop({timer})					*timer_stop()*
		Stop a timer.  The timer callback will no longer be invoked.
		{timer} is an ID returned by timer_start(), thus it must be a
		Number.

tolower({expr})						*tolower()*
		The result is a copy of the String given, with all uppercase
		characters turned into lowercase (just like applying |gu| to
		the string).

toupper({expr})						*toupper()*
		The result is a copy of the String given, with all lowercase
		characters turned into uppercase (just like applying |gU| to
		the string).

tr({src}, {fromstr}, {tostr})				*tr()*
		The result is a copy of the {src} string with all characters
		which appear in {fromstr} replaced by the character in that
		position in the {tostr} string.  Thus the first character in
		{fromstr} is translated into the first character in {tostr}
		and so on.  Exactly like the unix "tr" command.
		This code also deals with multibyte characters properly.

		Examples: >
			echo tr("hello there", "ht", "HT")
<		returns "Hello THere" >
			echo tr("<blob>", "<>", "{}")
<		returns "{blob}"

trunc({expr})							*trunc()*
		Return the largest integral value with magnitude less than or
		equal to {expr} as a |Float| (truncate towards zero).
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			echo trunc(1.456)
<			1.0  >
			echo trunc(-5.456)
<			-5.0  >
			echo trunc(4.0)
<			4.0

type({expr})							*type()*
		The result is a Number, depending on the type of {expr}:
			Number:     0
			String:     1
			Funcref:    2
			List:       3
			Dictionary: 4
			Float:      5
			Boolean:    6 (|v:true| and |v:false|)
			Null:       7 (|v:null|)
		To avoid the magic numbers it should be used this way: >
			:if type(myvar) == type(0)
			:if type(myvar) == type("")
			:if type(myvar) == type(function("tr"))
			:if type(myvar) == type([])
			:if type(myvar) == type({})
			:if type(myvar) == type(0.0)
			:if type(myvar) == type(v:true)
<		In place of checking for |v:null| type it is better to check 
		for |v:null| directly as it is the only value of this type: >
			:if myvar is v:null

undofile({name})					*undofile()*
		Return the name of the undo file that would be used for a file
		with name {name} when writing.  This uses the 'undodir'
		option, finding directories that exist.  It does not check if
		the undo file exists.
		{name} is always expanded to the full path, since that is what
		is used internally.
		If {name} is empty undofile() returns an empty string, since a
		buffer without a file name will not write an undo file.
		Useful in combination with |:wundo| and |:rundo|.
		When compiled without the +persistent_undo option this always
		returns an empty string.

undotree()						*undotree()*
		Return the current state of the undo tree in a dictionary with
		the following items:
		  "seq_last"	The highest undo sequence number used.
		  "seq_cur"	The sequence number of the current position in
				the undo tree.  This differs from "seq_last"
				when some changes were undone.
		  "time_cur"	Time last used for |:earlier| and related
				commands.  Use |strftime()| to convert to
				something readable.
		  "save_last"	Number of the last file write.  Zero when no
				write yet.
		  "save_cur"	Number of the current position in the undo
				tree.  
		  "synced"	Non-zero when the last undo block was synced.
				This happens when waiting from input from the
				user.  See |undo-blocks|.
		  "entries"	A list of dictionaries with information about
				undo blocks.

		The first item in the "entries" list is the oldest undo item.
		Each List item is a Dictionary with these items:
		  "seq"		Undo sequence number.  Same as what appears in
				|:undolist|.
		  "time"	Timestamp when the change happened.  Use
				|strftime()| to convert to something readable.
		  "newhead"	Only appears in the item that is the last one
				that was added.  This marks the last change
				and where further changes will be added.
		  "curhead"	Only appears in the item that is the last one
				that was undone.  This marks the current
				position in the undo tree, the block that will
				be used by a redo command.  When nothing was
				undone after the last change this item will
				not appear anywhere.
		  "save"	Only appears on the last block before a file
				write.  The number is the write count.  The
				first write has number 1, the last one the
				"save_last" mentioned above.
		  "alt"		Alternate entry.  This is again a List of undo
				blocks.  Each item may again have an "alt"
				item.

uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
		Remove second and succeeding copies of repeated adjacent
		{list} items in-place.  Returns {list}.  If you want a list
		to remain unmodified make a copy first: >
			:let newlist = uniq(copy(mylist))
<		The default compare function uses the string representation of
		each item.  For the use of {func} and {dict} see |sort()|.

values({dict})						*values()*
		Return a |List| with all the values of {dict}.	The |List| is
		in arbitrary order.


virtcol({expr})						*virtcol()*
		The result is a Number, which is the screen column of the file
		position given with {expr}.  That is, the last screen position
		occupied by the character at that position, when the screen
		would be of unlimited width.  When there is a <Tab> at the
		position, the returned Number will be the column at the end of
		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
		set to 8, it returns 8. |conceal| is ignored.
		For the byte position use |col()|.
		For the use of {expr} see |col()|.
		When 'virtualedit' is used {expr} can be [lnum, col, off], where
		"off" is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.  When "off" is omitted zero is used.
		When Virtual editing is active in the current mode, a position
		beyond the end of the line can be returned. |'virtualedit'|
		The accepted positions are:
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of displayed characters in the cursor line
			    plus one)
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    v       In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |'<| in
			    that it's updated right away.
		Note that only marks in the current file can be used.
		Examples: >
  virtcol(".")	   with text "foo^Lbar", with cursor on the "^L", returns 5
  virtcol("$")	   with text "foo^Lbar", returns 9
  virtcol("'t")    with text "	  there", with 't at 'h', returns 6
<		The first column is 1.	0 is returned for an error.
		A more advanced example that echoes the maximum length of
		all lines: >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))


visualmode([expr])						*visualmode()*
		The result is a String, which describes the last Visual mode
		used in the current buffer.  Initially it returns an empty
		string, but once Visual mode has been used, it returns "v",
		"V", or "<CTRL-V>" (a single CTRL-V character) for
		character-wise, line-wise, or block-wise Visual mode
		respectively.
		Example: >
			:exe "normal " . visualmode()
<		This enters the same Visual mode as before.  It is also useful
		in scripts if you wish to act differently depending on the
		Visual mode that was used.
		If Visual mode is active, use |mode()| to get the Visual mode
		(e.g., in a |:vmap|).
							*non-zero-arg*
		If [expr] is supplied and it evaluates to a non-zero Number or
		a non-empty String, then the Visual mode will be cleared and
		the old value is returned.  Note that " " and "0" are also
		non-empty strings, thus cause the mode to be cleared.  A List,
		Dictionary or Float is not a Number or String, thus does not
		cause the mode to be cleared.

wildmenumode()					*wildmenumode()*
		Returns non-zero when the wildmenu is active and zero
		otherwise.  See 'wildmenu' and 'wildmode'.
		This can be used in mappings to handle the 'wildcharm' option
		gracefully. (Makes only sense with |mapmode-c| mappings).

		For example to make <c-j> work like <down> in wildmode, use: >
    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
<
		(Note, this needs the 'wildcharm' option set appropriately).


win_findbuf({bufnr})					*win_findbuf()*
		Returns a list with window IDs for windows that contain buffer
		{bufnr}.  When there is none the list is empty.

win_getid([{win} [, {tab}]])				*win_getid()*
		Get the window ID for the specified window.
		When {win} is missing use the current window.
		With {win} this is the window number.  The top window has
		number 1.
		Without {tab} use the current tab, otherwise the tab with
		number {tab}.  The first tab has number one.
		Return zero if the window cannot be found.

win_gotoid({expr})					*win_gotoid()*
		Go to window with ID {expr}.  This may also change the current
		tabpage.
		Return 1 if successful, 0 if the window cannot be found.

win_id2tabwin({expr}					*win_id2tabwin()*
		Return a list with the tab number and window number of window
		with ID {expr}: [tabnr, winnr].
		Return [0, 0] if the window cannot be found.

win_id2win({expr})					*win_id2win()*
		Return the window number of window with ID {expr}.
		Return 0 if the window cannot be found in the current tabpage.

							*winbufnr()*
winbufnr({nr})	The result is a Number, which is the number of the buffer
		associated with window {nr}.  {nr} can be the window number or
		the window ID.
		When {nr} is zero, the number of the buffer in the current
		window is returned.
		When window {nr} doesn't exist, -1 is returned.
		Example: >
  :echo "The file in the current window is " . bufname(winbufnr(0))
<
							*wincol()*
wincol()	The result is a Number, which is the virtual column of the
		cursor in the window.  This is counting screen cells from the
		left side of the window.  The leftmost column is one.

winheight({nr})						*winheight()*
		The result is a Number, which is the height of window {nr}.
		{nr} can be the window number or the window ID.
		When {nr} is zero, the height of the current window is
		returned.  When window {nr} doesn't exist, -1 is returned.
		An existing window always has a height of zero or more.
		Examples: >
  :echo "The current window has " . winheight(0) . " lines."
<
							*winline()*
winline()	The result is a Number, which is the screen line of the cursor
		in the window.	This is counting screen lines from the top of
		the window.  The first line is one.
		If the cursor was moved the view on the file will be updated
		first, this may cause a scroll.

							*winnr()*
winnr([{arg}])	The result is a Number, which is the number of the current
		window.  The top window has number 1.
		When the optional argument is "$", the number of the
		last window is returned (the window count). >
			let window_count = winnr('$')
<		When the optional argument is "#", the number of the last
		accessed window is returned (where |CTRL-W_p| goes to).
		If there is no previous window or it is in another tab page 0
		is returned.
		The number can be used with |CTRL-W_w| and ":wincmd w"
		|:wincmd|.
		Also see |tabpagewinnr()|.

							*winrestcmd()*
winrestcmd()	Returns a sequence of |:resize| commands that should restore
		the current window sizes.  Only works properly when no windows
		are opened or closed and the current window and tab page is
		unchanged.
		Example: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
							*winrestview()*
winrestview({dict})
		Uses the |Dictionary| returned by |winsaveview()| to restore
		the view of the current window.
		Note: The {dict} does not have to contain all values, that are
		returned by |winsaveview()|. If values are missing, those
		settings won't be restored. So you can use: >
		    :call winrestview({'curswant': 4})
<
		This will only set the curswant value (the column the cursor
		wants to move on vertical movements) of the cursor to column 5
		(yes, that is 5), while all other settings will remain the
		same. This is useful, if you set the cursor position manually.

		If you have changed the values the result is unpredictable.
		If the window size changed the result won't be the same.

							*winsaveview()*
winsaveview()	Returns a |Dictionary| that contains information to restore
		the view of the current window.  Use |winrestview()| to
		restore the view.
		This is useful if you have a mapping that jumps around in the
		buffer and you want to go back to the original view.
		This does not save fold information.  Use the 'foldenable'
		option to temporarily switch off folding, so that folds are
		not opened when moving around. This may have side effects.
		The return value includes:
			lnum		cursor line number
			col		cursor column (Note: the first column
					zero, as opposed to what getpos()
					returns)
			coladd		cursor column offset for 'virtualedit'
			curswant	column for vertical movement
			topline		first line in the window
			topfill		filler lines, only in diff mode
			leftcol		first column displayed
			skipcol		columns skipped
		Note that no option values are saved.


winwidth({nr})						*winwidth()*
		The result is a Number, which is the width of window {nr}.
		{nr} can be the window number or the window ID.
		When {nr} is zero, the width of the current window is
		returned.  When window {nr} doesn't exist, -1 i